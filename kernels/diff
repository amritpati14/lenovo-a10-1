



diff -r linux-3.0.36/arch/alpha/include/asm/atomic.h linux-3.0.36-lenovo/arch/alpha/include/asm/atomic.h
17,18c17,18
< #define ATOMIC_INIT(i)		( (atomic_t) { (i) } )
< #define ATOMIC64_INIT(i)	( (atomic64_t) { (i) } )
---
> #define ATOMIC_INIT(i)		{ (i) }
> #define ATOMIC64_INIT(i)	{ (i) }




diff -r linux-3.0.36/arch/alpha/include/asm/socket.h linux-3.0.36-lenovo/arch/alpha/include/asm/socket.h
71a72
> #ifdef __KERNEL__
75a77
> #endif /* __KERNEL__ */




diff -r linux-3.0.36/arch/arm/boot/compressed/head.S linux-3.0.36-lenovo/arch/arm/boot/compressed/head.S
179a180,183
> #ifdef CONFIG_ARCH_RK29
> 		bl	cache_off
> 		bl	cache_on
> #endif
541a546
> 		bic	r0, r0, #1 << 28	@ clear SCTLR.TRE
658a664,665
> #if !defined(CONFIG_CPU_V7)
> 		/* This collides with some V7 IDs, preventing correct detection */
666a674
> #endif




diff -r linux-3.0.36/arch/arm/boot/Makefile linux-3.0.36-lenovo/arch/arm/boot/Makefile
65c65,66
< 		   -n 'Linux-$(KERNELRELEASE)' -d $< $@
---
> 		   -n 'Linux-$(KERNELRELEASE)' -d $< $@ \
> 		   && dd if=$@ of=$@.pad bs=4096 conv=sync 2>/dev/null && mv $@.pad $@
75c76,80
< $(obj)/uImage:	$(obj)/zImage FORCE
---
> $(obj)/Image.gz: $(obj)/Image FORCE
> 	$(call if_changed,gzip)
> 	@echo '  Image:  $@ is ready'
> 
> $(obj)/uImage: $(obj)/Image FORCE
77c82
< 	@echo '  Image $@ is ready'
---
> 	@echo '  Image:  $@ is ready'
Only in linux-3.0.36-lenovo/arch/arm/common: fiq_debugger.c
Only in linux-3.0.36-lenovo/arch/arm/common: fiq_debugger_ringbuf.h
Only in linux-3.0.36-lenovo/arch/arm/common: fiq_glue.S
Only in linux-3.0.36-lenovo/arch/arm/common: fiq_glue_setup.c




diff -r linux-3.0.36/arch/arm/common/gic.c linux-3.0.36-lenovo/arch/arm/common/gic.c
94a95,97
> #if defined(CONFIG_PLAT_RK) && !defined(CONFIG_SMP)
> 	dsb();
> #endif
105a109,111
> #if defined(CONFIG_PLAT_RK) && !defined(CONFIG_SMP)
> 	dsb();
> #endif
117a124,126
> #ifdef CONFIG_PLAT_RK
> 	dsb();
> #endif
194c203,204
< 	writel_relaxed(val | bit, reg);
---
> 	if(gic_irq(d)!=49)
> 		writel_relaxed(val | bit, reg);
205a216,218
> #ifdef CONFIG_PLAT_RK
> 	return 0;
> #endif
280a294,297
> #ifdef CONFIG_ARCH_RK29
> 	/* rk29 read GIC_DIST_CTR is 2, why? */
> 	gic_irqs = NR_AIC_IRQS;
> #else
282a300
> #endif
302a321,325
> 	
>     // Set  usb host IRQ 49 for N cpu
>     writel_relaxed(0x01010f01, base + GIC_DIST_TARGET + 0x30);
>     writel_relaxed(0xa0a090a0, base + GIC_DIST_PRI + 0x30);
> 




diff -r linux-3.0.36/arch/arm/common/Kconfig linux-3.0.36-lenovo/arch/arm/common/Kconfig
41a42,91
> 
> config FIQ_GLUE
> 	bool
> 	select FIQ
> 
> config FIQ_DEBUGGER
> 	bool "FIQ Mode Serial Debugger"
> 	select FIQ
> 	select FIQ_GLUE
> 	default n
> 	help
> 	  The FIQ serial debugger can accept commands even when the
> 	  kernel is unresponsive due to being stuck with interrupts
> 	  disabled.
> 
> 
> config FIQ_DEBUGGER_NO_SLEEP
> 	bool "Keep serial debugger active"
> 	depends on FIQ_DEBUGGER
> 	default n
> 	help
> 	  Enables the serial debugger at boot. Passing
> 	  fiq_debugger.no_sleep on the kernel commandline will
> 	  override this config option.
> 
> config FIQ_DEBUGGER_WAKEUP_IRQ_ALWAYS_ON
> 	bool "Don't disable wakeup IRQ when debugger is active"
> 	depends on FIQ_DEBUGGER
> 	default n
> 	help
> 	  Don't disable the wakeup irq when enabling the uart clock.  This will
> 	  cause extra interrupts, but it makes the serial debugger usable with
> 	  on some MSM radio builds that ignore the uart clock request in power
> 	  collapse.
> 
> config FIQ_DEBUGGER_CONSOLE
> 	bool "Console on FIQ Serial Debugger port"
> 	depends on FIQ_DEBUGGER
> 	default n
> 	help
> 	  Enables a console so that printk messages are displayed on
> 	  the debugger serial port as the occur.
> 
> config FIQ_DEBUGGER_CONSOLE_DEFAULT_ENABLE
> 	bool "Put the FIQ debugger into console mode by default"
> 	depends on FIQ_DEBUGGER_CONSOLE
> 	default n
> 	help
> 	  If enabled, this puts the fiq debugger into console mode by default.
> 	  Otherwise, the fiq debugger will start out in debug mode.




diff -r linux-3.0.36/arch/arm/common/Makefile linux-3.0.36-lenovo/arch/arm/common/Makefile
19a20,21
> obj-$(CONFIG_FIQ_GLUE)		+= fiq_glue.o fiq_glue_setup.o
> obj-$(CONFIG_FIQ_DEBUGGER)	+= fiq_debugger.o




diff -r linux-3.0.36/arch/arm/common/pl330.c linux-3.0.36-lenovo/arch/arm/common/pl330.c
30a31
> #include <asm/unaligned.h>
31a33
> #include <mach/sram.h>
222c224
< #define MCODE_BUFF_PER_REQ	256
---
> #define MCODE_BUFF_PER_REQ	128
379a382,387
> #ifdef CONFIG_PLAT_RK
> 	id |= ((readl(regs + off + 0x0) & 0xff) << 0);
> 	id |= ((readl(regs + off + 0x4) & 0xff) << 8);
> 	id |= ((readl(regs + off + 0x8) & 0xff) << 16);
> 	id |= ((readl(regs + off + 0xc) & 0xff) << 24);
> #else
383a392
> #endif
396c405
< 	*((u16 *)&buf[1]) = val;
---
> 	put_unaligned(val, (u16 *)&buf[1]);	//*((u16 *)&buf[1]) = val;
550c559
< 	*((u32 *)&buf[2]) = val;
---
> 	put_unaligned(val, (u32 *)&buf[2]);	//*((u32 *)&buf[2]) = val;
728c737
< 	*((u32 *)&buf[2]) = addr;
---
> 	put_unaligned(addr, (u32 *)&buf[2]);	//*((u32 *)&buf[2]) = addr;
993,994c1002,1003
< 		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->r->peri);
< 		off += _emit_LDP(dry_run, &buf[off], SINGLE, pxs->r->peri);
---
> 		off += _emit_WFP(dry_run, &buf[off], BURST, pxs->r->peri);
> 		off += _emit_LDP(dry_run, &buf[off], BURST, pxs->r->peri);
996c1005
< 		off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);
---
> 		//off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);    //for sdmmc sdio
1008c1017
< 		off += _emit_WFP(dry_run, &buf[off], SINGLE, pxs->r->peri);
---
> 		off += _emit_WFP(dry_run, &buf[off], BURST, pxs->r->peri);
1010,1011c1019,1020
< 		off += _emit_STP(dry_run, &buf[off], SINGLE, pxs->r->peri);
< 		off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);
---
> 		off += _emit_STP(dry_run, &buf[off], BURST, pxs->r->peri);
> 		//off += _emit_FLUSHP(dry_run, &buf[off], pxs->r->peri);     //for sdmmc sdio
1118a1128,1183
> /* Returns bytes consumed and updates bursts */
> static inline int _loop_infiniteloop(unsigned dry_run, u8 buf[],
> 		unsigned long bursts, const struct _xfer_spec *pxs, int ev)
> {
> 	int cyc, off;
> 	unsigned lcnt0, lcnt1, ljmp0, ljmp1, ljmpfe;
> 	struct _arg_LPEND lpend;
> 
> 	off = 0;
> 	ljmpfe = off;
> 	lcnt0 = pxs->r->infiniteloop;
> 	//hhb
> 	/* Max iterations possible in DMALP is 256 */
> 	if (bursts > 256) {
> 		lcnt1 = 256;
> 		cyc = bursts/256;    //cyc shuold be less than 8
> 	} else {
> 		lcnt1 = bursts;
> 		cyc = 1;
> 	}
> 
> 	/* forever loop */
> 	off += _emit_MOV(dry_run, &buf[off], SAR, pxs->x->src_addr);
> 	off += _emit_MOV(dry_run, &buf[off], DAR, pxs->x->dst_addr);
> 
> 	/* loop0 */
> 	off += _emit_LP(dry_run, &buf[off], 0,  lcnt0);
> 	ljmp0 = off;
> 
> 	/* loop1 */
> 	off += _emit_LP(dry_run, &buf[off], 1, lcnt1);
> 	ljmp1 = off;
> 	off += _bursts(dry_run, &buf[off], pxs, cyc);
> 	lpend.cond = ALWAYS;
> 	lpend.forever = false;
> 	lpend.loop = 1;
> 	lpend.bjump = off - ljmp1;
> 	off += _emit_LPEND(dry_run, &buf[off], &lpend);
> 	if(pxs->r->infiniteloop_sev)   //may be we don't need interrupt when dma transfer
> 		off += _emit_SEV(dry_run, &buf[off], ev);
> 	/* end loop1 */
> 	lpend.cond = ALWAYS;
> 	lpend.forever = false;
> 	lpend.loop = 0;
> 	lpend.bjump = off - ljmp0;
> 	off += _emit_LPEND(dry_run, &buf[off], &lpend);
> 	/* end loop0 */
> 	lpend.cond = ALWAYS;
> 	lpend.forever = true;
> 	lpend.loop = 1;
> 	lpend.bjump = off - ljmpfe;
> 	off +=  _emit_LPEND(dry_run, &buf[off], &lpend);
> 
> 	return off;
> }
> 
1152a1218,1231
> static inline int _setup_xfer_infiniteloop(unsigned dry_run, u8 buf[],
> 		const struct _xfer_spec *pxs, int ev)
> {
> 	struct pl330_xfer *x = pxs->x;
> 	u32 ccr = pxs->ccr;
> 	unsigned long bursts = BYTE_TO_BURST(x->bytes, ccr);
> 	int off = 0;
> 
> 	/* Setup Loop(s) */
> 	off += _loop_infiniteloop(dry_run, &buf[off], bursts, pxs, ev);
> 
> 	return off;
> }
> 
1171c1250,1268
< 	do {
---
> 
> 	if (!pxs->r->infiniteloop) {
> 		do {
> 			/* Error if xfer length is not aligned at burst size */
> 			if (x->bytes % (BRST_SIZE(pxs->ccr)
> 						* BRST_LEN(pxs->ccr)))
> 				return -EINVAL;
> 
> 			pxs->x = x;
> 			off += _setup_xfer(dry_run, &buf[off], pxs);
> 
> 			x = x->next;
> 		} while (x);
> 
> 		/* DMASEV peripheral/event */
> 		off += _emit_SEV(dry_run, &buf[off], thrd->ev);
> 		/* DMAEND */
> 		off += _emit_END(dry_run, &buf[off]);
> 	} else {
1177,1186c1274,1276
< 		off += _setup_xfer(dry_run, &buf[off], pxs);
< 
< 		x = x->next;
< 	} while (x);
< 
< 	/* DMASEV peripheral/event */
< 	off += _emit_SEV(dry_run, &buf[off], thrd->ev);
< 	/* DMAEND */
< 	off += _emit_END(dry_run, &buf[off]);
< 
---
> 		off += _setup_xfer_infiniteloop
> 				(dry_run, &buf[off], pxs, thrd->ev);
> 	}
1284,1289d1373
< 	/* Prefer Secure Channel */
< 	if (!_manager_ns(thrd))
< 		r->cfg->nonsecure = 0;
< 	else
< 		r->cfg->nonsecure = 1;
< 
1291c1375,1380
< 	if (r->cfg)
---
> 	if (r->cfg) {
> 		/* Prefer Secure Channel */
> 		if (!_manager_ns(thrd))
> 			r->cfg->nonsecure = 0;
> 		else
> 			r->cfg->nonsecure = 1;
1293c1382
< 	else
---
> 	} else {
1294a1384
> 	}
1471d1560
< 			MARK_FREE(rqdone);
1473,1474c1562,1567
< 			/* Get going again ASAP */
< 			_start(thrd);
---
> 			if (!rqdone->r->infiniteloop) {
> 				MARK_FREE(rqdone);
> 
> 				/* Get going again ASAP */
> 				_start(thrd);
> 			}
1624a1718,1721
> //hhb@rock-chips.com
> #ifdef CONFIG_RK_SRAM_DMA
> static __attribute__((aligned(4))) __sramdata char i2s_mcode_buff[2][MCODE_BUFF_PER_REQ*2];
> #endif
1629c1726
< void *pl330_request_channel(const struct pl330_info *pi)
---
> void *pl330_request_channel(int id, const struct pl330_info *pi)
1663a1761,1780
> #ifdef CONFIG_RK_SRAM_DMA
> 	switch(id) {
> 		case 4:   	//DMACH_I2S0_8CH_TX
> 		case 6:		//DMACH_I2S1_2CH_TX
> 		case 9:		//DMACH_I2S2_2CH_TX
> 			thrd->req[0].mc_bus = (u32)(RK30_IMEM_PHYS + ((void *)i2s_mcode_buff[0] - RK30_IMEM_BASE));
> 			thrd->req[0].mc_cpu = (RK30_IMEM_NONCACHED + ((void *)i2s_mcode_buff[0] - RK30_IMEM_BASE));
> 			thrd->req[1].mc_bus = thrd->req[0].mc_bus + MCODE_BUFF_PER_REQ;
> 			thrd->req[1].mc_cpu = thrd->req[0].mc_cpu + MCODE_BUFF_PER_REQ;
> 			break;
> 		case 5:   	//DMACH_I2S0_8CH_RX
> 		case 7:		//DMACH_I2S1_2CH_RX
> 		case 10:	//DMACH_I2S2_2CH_RX
> 			thrd->req[0].mc_bus = (u32)(RK30_IMEM_PHYS + ((void *)i2s_mcode_buff[1] - RK30_IMEM_BASE));
> 			thrd->req[0].mc_cpu = (RK30_IMEM_NONCACHED + ((void *)i2s_mcode_buff[1] - RK30_IMEM_BASE));
> 			thrd->req[1].mc_bus = thrd->req[0].mc_bus + MCODE_BUFF_PER_REQ;
> 			thrd->req[1].mc_cpu = thrd->req[0].mc_cpu + MCODE_BUFF_PER_REQ;
> 			break;
> 		default:
> 			break;
1664a1782,1783
> 	}
> #endif




diff -r linux-3.0.36/arch/arm/configs/mxs_defconfig linux-3.0.36-lenovo/arch/arm/configs/mxs_defconfig
32d31
< CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2926_sdk_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2926_tb_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2926_v86_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2928_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2928_phonepad_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2928_sdk_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk2928_tb_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3066b_m701_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3066b_sdk_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3066_sdk_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk30_ds1001b_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk30_ds975_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk30_sdk_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3108_tb_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_86v_codec_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_86v_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_86v_old_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_ds1006h_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_ds803f_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_LR097_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3168_tb_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_a10_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_ds1006h_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_ds1006h_v1_0_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_ds1006h_v1_1_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_flex10_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_LR097_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_s115a_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_tb_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_v80_defconfig
Only in linux-3.0.36-lenovo/arch/arm/configs: rk3188_v80_v10_defconfig




diff -r linux-3.0.36/arch/arm/include/asm/cacheflush.h linux-3.0.36-lenovo/arch/arm/include/asm/cacheflush.h
218c218,220
< 	if (cpumask_test_cpu(smp_processor_id(), mm_cpumask(vma->vm_mm)))
---
> 	struct mm_struct *mm = vma->vm_mm;
> 
> 	if (!mm || cpumask_test_cpu(smp_processor_id(), mm_cpumask(mm)))
226c228,230
< 	if (cpumask_test_cpu(smp_processor_id(), mm_cpumask(vma->vm_mm))) {
---
> 	struct mm_struct *mm = vma->vm_mm;
> 
> 	if (!mm || cpumask_test_cpu(smp_processor_id(), mm_cpumask(mm))) {
Only in linux-3.0.36-lenovo/arch/arm/include/asm: fiq_debugger.h
Only in linux-3.0.36-lenovo/arch/arm/include/asm: fiq_glue.h




diff -r linux-3.0.36/arch/arm/include/asm/hardirq.h linux-3.0.36-lenovo/arch/arm/include/asm/hardirq.h
8c8
< #define NR_IPI	5
---
> #define NR_IPI	6




diff -r linux-3.0.36/arch/arm/include/asm/hardware/cache-l2x0.h linux-3.0.36-lenovo/arch/arm/include/asm/hardware/cache-l2x0.h
59a60
> #define L2X0_CACHE_ID_REV_MASK		(0x3f)
73a75,76
> 
> #define REV_PL310_R2P0				4




diff -r linux-3.0.36/arch/arm/include/asm/hardware/coresight.h linux-3.0.36-lenovo/arch/arm/include/asm/hardware/coresight.h
19a20
> #define TRACER_TRACE_DATA_BIT	3
22a24
> #define TRACER_TRACE_DATA	BIT(TRACER_TRACE_DATA_BIT)
26,28c28,30
< #define etm_writel(t, v, x) \
< 	(__raw_writel((v), (t)->etm_regs + (x)))
< #define etm_readl(t, x) (__raw_readl((t)->etm_regs + (x)))
---
> #define etm_writel(t, id, v, x) \
> 	(__raw_writel((v), (t)->etm_regs[(id)] + (x)))
> #define etm_readl(t, id, x) (__raw_readl((t)->etm_regs[(id)] + (x)))
115a118,124
> 
> #define ETMR_VIEWDATAEVT	0x30
> #define ETMR_VIEWDATACTRL1	0x34
> #define ETMR_VIEWDATACTRL2	0x38
> #define ETMR_VIEWDATACTRL3	0x3c
> #define ETMVDC3_EXCLONLY	BIT(16)
> 
117d125
< 				ETMCTRL_DATA_DO_ADDR | \
120a129,130
> #define ETMR_TRACEIDR		0x200
> 
142a153
> #define ETBFF_STOPFL		BIT(12)
148,150c159,162
< #define etm_lock(t) do { etm_writel((t), 0, CSMR_LOCKACCESS); } while (0)
< #define etm_unlock(t) \
< 	do { etm_writel((t), UNLOCK_MAGIC, CSMR_LOCKACCESS); } while (0)
---
> #define etm_lock(t, id) \
> 	do { etm_writel((t), (id), 0, CSMR_LOCKACCESS); } while (0)
> #define etm_unlock(t, id) \
> 	do { etm_writel((t), (id), UNLOCK_MAGIC, CSMR_LOCKACCESS); } while (0)




diff -r linux-3.0.36/arch/arm/include/asm/hardware/pl330.h linux-3.0.36-lenovo/arch/arm/include/asm/hardware/pl330.h
167a168,169
> 	unsigned int infiniteloop;
> 	unsigned int infiniteloop_sev;
212c214
< extern void *pl330_request_channel(const struct pl330_info *pi);
---
> extern void *pl330_request_channel(int id, const struct pl330_info *pi);




diff -r linux-3.0.36/arch/arm/include/asm/hwcap.h linux-3.0.36-lenovo/arch/arm/include/asm/hwcap.h
21c21
< #define HWCAP_VFPv3D16	16384
---
> #define HWCAP_VFPv3D16	(1 << 14)	/* also set for VFPv4-D16 */
22a23
> #define HWCAP_VFPD32	(1 << 19)	/* set if VFP has 32 regs (not 16) */




diff -r linux-3.0.36/arch/arm/include/asm/irq.h linux-3.0.36-lenovo/arch/arm/include/asm/irq.h
27a28,30
> void arch_trigger_all_cpu_backtrace(void);
> #define arch_trigger_all_cpu_backtrace arch_trigger_all_cpu_backtrace
> 




diff -r linux-3.0.36/arch/arm/include/asm/mach/map.h linux-3.0.36-lenovo/arch/arm/include/asm/mach/map.h
31a32
> #define MT_DEVICE_STRONGLY_ORDERED	14
Only in linux-3.0.36-lenovo/arch/arm/include/asm/mach: mmc.h




diff -r linux-3.0.36/arch/arm/include/asm/mutex.h linux-3.0.36-lenovo/arch/arm/include/asm/mutex.h
10,15d9
< 
< #if __LINUX_ARM_ARCH__ < 6
< /* On pre-ARMv6 hardware the swp based implementation is the most efficient. */
< # include <asm-generic/mutex-xchg.h>
< #else
< 
17,24c11,13
<  * Attempting to lock a mutex on ARMv6+ can be done with a bastardized
<  * atomic decrement (it is not a reliable atomic decrement but it satisfies
<  * the defined semantics for our purpose, while being smaller and faster
<  * than a real atomic decrement or atomic swap.  The idea is to attempt
<  * decrementing the lock value only once.  If once decremented it isn't zero,
<  * or if its store-back fails due to a dispute on the exclusive store, we
<  * simply bail out immediately through the slow path where the lock will be
<  * reattempted until it succeeds.
---
>  * On pre-ARMv6 hardware this results in a swp-based implementation,
>  * which is the most efficient. For ARMv6+, we emit a pair of exclusive
>  * accesses instead.
26,126c15
< static inline void
< __mutex_fastpath_lock(atomic_t *count, void (*fail_fn)(atomic_t *))
< {
< 	int __ex_flag, __res;
< 
< 	__asm__ (
< 
< 		"ldrex	%0, [%2]	\n\t"
< 		"sub	%0, %0, #1	\n\t"
< 		"strex	%1, %0, [%2]	"
< 
< 		: "=&r" (__res), "=&r" (__ex_flag)
< 		: "r" (&(count)->counter)
< 		: "cc","memory" );
< 
< 	__res |= __ex_flag;
< 	if (unlikely(__res != 0))
< 		fail_fn(count);
< }
< 
< static inline int
< __mutex_fastpath_lock_retval(atomic_t *count, int (*fail_fn)(atomic_t *))
< {
< 	int __ex_flag, __res;
< 
< 	__asm__ (
< 
< 		"ldrex	%0, [%2]	\n\t"
< 		"sub	%0, %0, #1	\n\t"
< 		"strex	%1, %0, [%2]	"
< 
< 		: "=&r" (__res), "=&r" (__ex_flag)
< 		: "r" (&(count)->counter)
< 		: "cc","memory" );
< 
< 	__res |= __ex_flag;
< 	if (unlikely(__res != 0))
< 		__res = fail_fn(count);
< 	return __res;
< }
< 
< /*
<  * Same trick is used for the unlock fast path. However the original value,
<  * rather than the result, is used to test for success in order to have
<  * better generated assembly.
<  */
< static inline void
< __mutex_fastpath_unlock(atomic_t *count, void (*fail_fn)(atomic_t *))
< {
< 	int __ex_flag, __res, __orig;
< 
< 	__asm__ (
< 
< 		"ldrex	%0, [%3]	\n\t"
< 		"add	%1, %0, #1	\n\t"
< 		"strex	%2, %1, [%3]	"
< 
< 		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
< 		: "r" (&(count)->counter)
< 		: "cc","memory" );
< 
< 	__orig |= __ex_flag;
< 	if (unlikely(__orig != 0))
< 		fail_fn(count);
< }
< 
< /*
<  * If the unlock was done on a contended lock, or if the unlock simply fails
<  * then the mutex remains locked.
<  */
< #define __mutex_slowpath_needs_to_unlock()	1
< 
< /*
<  * For __mutex_fastpath_trylock we use another construct which could be
<  * described as a "single value cmpxchg".
<  *
<  * This provides the needed trylock semantics like cmpxchg would, but it is
<  * lighter and less generic than a true cmpxchg implementation.
<  */
< static inline int
< __mutex_fastpath_trylock(atomic_t *count, int (*fail_fn)(atomic_t *))
< {
< 	int __ex_flag, __res, __orig;
< 
< 	__asm__ (
< 
< 		"1: ldrex	%0, [%3]	\n\t"
< 		"subs		%1, %0, #1	\n\t"
< 		"strexeq	%2, %1, [%3]	\n\t"
< 		"movlt		%0, #0		\n\t"
< 		"cmpeq		%2, #0		\n\t"
< 		"bgt		1b		"
< 
< 		: "=&r" (__orig), "=&r" (__res), "=&r" (__ex_flag)
< 		: "r" (&count->counter)
< 		: "cc", "memory" );
< 
< 	return __orig;
< }
< 
< #endif
---
> #include <asm-generic/mutex-xchg.h>




diff -r linux-3.0.36/arch/arm/include/asm/pgtable.h linux-3.0.36-lenovo/arch/arm/include/asm/pgtable.h
362a363,374
> #define pte_none(pte)		(!pte_val(pte))
> #define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
> #define pte_write(pte)		(!(pte_val(pte) & L_PTE_RDONLY))
> #define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
> #define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
> #define pte_exec(pte)		(!(pte_val(pte) & L_PTE_XN))
> #define pte_special(pte)	(0)
> 
> #define pte_present_user(pte) \
> 	((pte_val(pte) & (L_PTE_PRESENT | L_PTE_USER)) == \
> 	 (L_PTE_PRESENT | L_PTE_USER))
> 
374,376c386,388
< 	if (addr >= TASK_SIZE)
< 		set_pte_ext(ptep, pteval, 0);
< 	else {
---
> 	unsigned long ext = 0;
> 
> 	if (addr < TASK_SIZE && pte_present_user(pteval)) {
378c390
< 		set_pte_ext(ptep, pteval, PTE_EXT_NG);
---
> 		ext |= PTE_EXT_NG;
380d391
< }
382,392c393,394
< #define pte_none(pte)		(!pte_val(pte))
< #define pte_present(pte)	(pte_val(pte) & L_PTE_PRESENT)
< #define pte_write(pte)		(!(pte_val(pte) & L_PTE_RDONLY))
< #define pte_dirty(pte)		(pte_val(pte) & L_PTE_DIRTY)
< #define pte_young(pte)		(pte_val(pte) & L_PTE_YOUNG)
< #define pte_exec(pte)		(!(pte_val(pte) & L_PTE_XN))
< #define pte_special(pte)	(0)
< 
< #define pte_present_user(pte) \
< 	((pte_val(pte) & (L_PTE_PRESENT | L_PTE_USER)) == \
< 	 (L_PTE_PRESENT | L_PTE_USER))
---
> 	set_pte_ext(ptep, pteval, ext);
> }
419c421
<  *   <--------------- offset --------------------> <- type --> 0 0 0
---
>  *   <--------------- offset ----------------------> < type -> 0 0 0
421c423
<  * This gives us up to 63 swap files and 32GB per swap file.  Note that
---
>  * This gives us up to 31 swap files and 64GB per swap file.  Note that
425c427
< #define __SWP_TYPE_BITS		6
---
> #define __SWP_TYPE_BITS		5




diff -r linux-3.0.36/arch/arm/include/asm/proc-fns.h linux-3.0.36-lenovo/arch/arm/include/asm/proc-fns.h
99a100,111
> #ifdef CONFIG_SMP
> 
> #define cpu_switch_mm(pgd, mm)	\
> 	({							\
> 		unsigned long flags;				\
> 		local_irq_save(flags);				\
> 		cpu_do_switch_mm(virt_to_phys(pgd), mm);	\
> 		local_irq_restore(flags);			\
> 	})
> 
> #else /* SMP */
> 
100a113,114
> 
> #endif




diff -r linux-3.0.36/arch/arm/include/asm/setup.h linux-3.0.36-lenovo/arch/arm/include/asm/setup.h
18a19,21
> #ifdef CONFIG_RK_CONFIG
> #define COMMAND_LINE_SIZE 65536
> #else
19a23
> #endif




diff -r linux-3.0.36/arch/arm/include/asm/smp.h linux-3.0.36-lenovo/arch/arm/include/asm/smp.h
95a96,97
> extern void smp_send_all_cpu_backtrace(void);
> 




diff -r linux-3.0.36/arch/arm/include/asm/vfpmacros.h linux-3.0.36-lenovo/arch/arm/include/asm/vfpmacros.h
30,32c30,32
< 	tst	\tmp, #HWCAP_VFPv3D16
< 	ldceq	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d16-d31}
< 	addne	\base, \base, #32*4		    @ step over unused register space
---
> 	tst	\tmp, #HWCAP_VFPD32
> 	ldcnel	p11, cr0, [\base],#32*4		    @ FLDMIAD \base!, {d16-d31}
> 	addeq	\base, \base, #32*4		    @ step over unused register space
54,56c54,56
< 	tst	\tmp, #HWCAP_VFPv3D16
< 	stceq	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d16-d31}
< 	addne	\base, \base, #32*4		    @ step over unused register space
---
> 	tst	\tmp, #HWCAP_VFPD32
> 	stcnel	p11, cr0, [\base],#32*4		    @ FSTMIAD \base!, {d16-d31}
> 	addeq	\base, \base, #32*4		    @ step over unused register space




diff -r linux-3.0.36/arch/arm/Kconfig linux-3.0.36-lenovo/arch/arm/Kconfig
31a32
> 	select CPU_PM if (SUSPEND || CPU_IDLE)
860a862,915
> config ARCH_RK29
> 	bool "Rockchip RK29xx"
> 	select PLAT_RK
> 	select CPU_V7
> 	select ARM_GIC
> 	select PL330
> 	select HIGHMEM
> 	select ZONE_DMA
> 	select ARM_L1_CACHE_SHIFT_6
> 	help
> 	  Support for Rockchip's RK29xx SoCs.
> 
> config ARCH_RK2928
> 	bool "Rockchip RK2928"
> 	select PLAT_RK
> 	select CPU_V7
> 	select ARM_GIC
> 	select RK_PL330_DMA
> 	select MIGHT_HAVE_CACHE_L2X0
> 	select ARM_ERRATA_754322
> 	select ARM_ERRATA_775420
> 	help
> 	  Support for Rockchip's RK2928 SoCs.
> 
> config ARCH_RK30
> 	bool "Rockchip RK30xx/RK3108/RK3168"
> 	select PLAT_RK
> 	select CPU_V7
> 	select ARM_GIC
> 	select RK_PL330_DMA
> 	select HAVE_SMP
> 	select MIGHT_HAVE_CACHE_L2X0
> 	select ARM_ERRATA_764369
> 	select ARM_ERRATA_754322
> 	select ARM_ERRATA_775420
> 	help
> 	  Support for Rockchip's RK30xx/RK3108/RK3168 SoCs.
> 
> config ARCH_RK3188
> 	bool "Rockchip RK3188"
> 	select PLAT_RK
> 	select CPU_V7
> 	select ARM_GIC
> 	select RK_PL330_DMA
> 	select RK_TIMER
> 	select HAVE_SMP
> 	select MIGHT_HAVE_CACHE_L2X0
> 	select ARM_ERRATA_761320
> 	select ARM_ERRATA_764369
> 	select ARM_ERRATA_754322
> 	select ARM_ERRATA_775420
> 	help
> 	  Support for Rockchip's RK3188 SoCs.
> 
960a1016,1021
> source "arch/arm/plat-rk/Kconfig"
> source "arch/arm/mach-rk29/Kconfig"
> source "arch/arm/mach-rk2928/Kconfig"
> source "arch/arm/mach-rk30/Kconfig"
> source "arch/arm/mach-rk3188/Kconfig"
> 
1026a1088,1098
> config PLAT_RK
> 	bool
> 	select CLKDEV_LOOKUP
> 	select HAVE_SCHED_CLOCK
> 	select ARCH_HAS_CPUFREQ
> 	select GENERIC_CLOCKEVENTS
> 	select ARCH_REQUIRE_GPIOLIB
> 	select SYNC
> 	select SW_SYNC
> 	select SW_SYNC_USER
> 
1236a1309,1350
> config ARM_ERRATA_761320
> 	bool "ARM errata: no direct eviction"
> 	depends on CPU_V7 && SMP
> 	help
> 	  This option enables the workaround for the 761320 Cortex-A9 erratum.
> 
> config ARM_ERRATA_764369
> 	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
> 	depends on CPU_V7 && SMP
> 	help
> 	  This option enables the workaround for erratum 764369
> 	  affecting Cortex-A9 MPCore with two or more processors (all
> 	  current revisions). Under certain timing circumstances, a data
> 	  cache line maintenance operation by MVA targeting an Inner
> 	  Shareable memory region may fail to proceed up to either the
> 	  Point of Coherency or to the Point of Unification of the
> 	  system. This workaround adds a DSB instruction before the
> 	  relevant cache maintenance functions and sets a specific bit
> 	  in the diagnostic control register of the SCU.
> 
> config PL310_ERRATA_769419
> 	bool "PL310 errata: no automatic Store Buffer drain"
> 	depends on CACHE_L2X0
> 	help
> 	  On revisions of the PL310 prior to r3p2, the Store Buffer does
> 	  not automatically drain. This can cause normal, non-cacheable
> 	  writes to be retained when the memory system is idle, leading
> 	  to suboptimal I/O performance for drivers using coherent DMA.
> 	  This option adds a write barrier to the cpu_idle loop so that,
> 	  on systems with an outer cache, the store buffer is drained
> 	  explicitly.
> 
> config ARM_ERRATA_775420
>        bool "ARM errata: A data cache maintenance operation which aborts, might lead to deadlock"
>        depends on CPU_V7
>        help
> 	 This option enables the workaround for the 775420 Cortex-A9 (r2p2,
> 	 r2p6,r2p8,r2p10,r3p0) erratum. In case a date cache maintenance
> 	 operation aborts with MMU exception, it might cause the processor
> 	 to deadlock. This workaround puts DSB before executing ISB if
> 	 an abort may occur on cache maintenance.
> 
1301,1326d1414
< config ARM_ERRATA_764369
< 	bool "ARM errata: Data cache line maintenance operation by MVA may not succeed"
< 	depends on CPU_V7 && SMP
< 	help
< 	  This option enables the workaround for erratum 764369
< 	  affecting Cortex-A9 MPCore with two or more processors (all
< 	  current revisions). Under certain timing circumstances, a data
< 	  cache line maintenance operation by MVA targeting an Inner
< 	  Shareable memory region may fail to proceed up to either the
< 	  Point of Coherency or to the Point of Unification of the
< 	  system. This workaround adds a DSB instruction before the
< 	  relevant cache maintenance functions and sets a specific bit
< 	  in the diagnostic control register of the SCU.
< 
< config PL310_ERRATA_769419
< 	bool "PL310 errata: no automatic Store Buffer drain"
< 	depends on CACHE_L2X0
< 	help
< 	  On revisions of the PL310 prior to r3p2, the Store Buffer does
< 	  not automatically drain. This can cause normal, non-cacheable
< 	  writes to be retained when the memory system is idle, leading
< 	  to suboptimal I/O performance for drivers using coherent DMA.
< 	  This option adds a write barrier to the cpu_idle loop so that,
< 	  on systems with an outer cache, the store buffer is drained
< 	  explicitly.
< 
1332a1421,1429
> config HAVE_SMP
> 	bool
> 	help
> 	  This option should be selected by machines which have an SMP-
> 	  capable CPU.
> 
> 	  The only effect of this option is to make the SMP-related
> 	  options available to the user for configuration.
> 
1337,1340c1434,1435
< 	depends on REALVIEW_EB_ARM11MP || REALVIEW_EB_A9MP || \
< 		 MACH_REALVIEW_PB11MP || MACH_REALVIEW_PBX || ARCH_OMAP4 || \
< 		 ARCH_EXYNOS4 || ARCH_TEGRA || ARCH_U8500 || ARCH_VEXPRESS_CA9X4 || \
< 		 ARCH_MSM_SCORPIONMP || ARCH_SHMOBILE
---
> 	depends on HAVE_SMP
> 	depends on MMU
1426c1521
< 	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT)
---
> 	select HAVE_ARM_TWD if (!ARCH_MSM_SCORPIONMP && !EXYNOS4_MCT && !RK_TIMER)
1699a1795,1803
> config ARM_FLUSH_CONSOLE_ON_RESTART
> 	bool "Force flush the console on restart"
> 	help
> 	  If the console is locked while the system is rebooted, the messages
> 	  in the temporary logbuffer would not have propogated to all the
> 	  console drivers. This option forces the console lock to be
> 	  released if it failed to be acquired, which will cause all the
> 	  pending messages to be flushed.
> 
1877a1982
> 	select CPU_FREQ_TABLE




diff -r linux-3.0.36/arch/arm/kernel/entry-armv.S linux-3.0.36-lenovo/arch/arm/kernel/entry-armv.S
499c499
< 	orr	r0, r0, r5, lsl #16
---
> 	orr    	r0, r0, r5, lsl #16




diff -r linux-3.0.36/arch/arm/kernel/entry-common.S linux-3.0.36-lenovo/arch/arm/kernel/entry-common.S
25c25,26
< ret_fast_syscall:
---
> /* ret_fast_syscall: */
> ENTRY(ret_fast_syscall)




diff -r linux-3.0.36/arch/arm/kernel/etm.c linux-3.0.36-lenovo/arch/arm/kernel/etm.c
17a18
> #include <linux/slab.h>
39c40,41
< 	void __iomem	*etm_regs;
---
> 	void __iomem	**etm_regs;
> 	int		etm_regs_count;
42a45,50
> 	u32		etb_fc;
> 	unsigned long	range_start;
> 	unsigned long	range_end;
> 	unsigned long	data_range_start;
> 	unsigned long	data_range_end;
> 	bool		dump_initial_etb;
48c56,59
< static struct tracectx tracer;
---
> static struct tracectx tracer = {
> 	.range_start = (unsigned long)_stext,
> 	.range_end = (unsigned long)_etext,
> };
55c66
< static int etm_setup_address_range(struct tracectx *t, int n,
---
> static int etm_setup_address_range(struct tracectx *t, int id, int n,
58c69
< 	u32 flags = ETMAAT_ARM | ETMAAT_IGNCONTEXTID | ETMAAT_NSONLY | \
---
> 	u32 flags = ETMAAT_ARM | ETMAAT_IGNCONTEXTID | ETMAAT_IGNSECURITY |
74,75c85,86
< 	etm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2));
< 	etm_writel(t, start, ETMR_COMP_VAL(n * 2));
---
> 	etm_writel(t, id, flags, ETMR_COMP_ACC_TYPE(n * 2));
> 	etm_writel(t, id, start, ETMR_COMP_VAL(n * 2));
78,79c89,90
< 	etm_writel(t, flags, ETMR_COMP_ACC_TYPE(n * 2 + 1));
< 	etm_writel(t, end, ETMR_COMP_VAL(n * 2 + 1));
---
> 	etm_writel(t, id, flags, ETMR_COMP_ACC_TYPE(n * 2 + 1));
> 	etm_writel(t, id, end, ETMR_COMP_VAL(n * 2 + 1));
81,82c92,100
< 	flags = exclude ? ETMTE_INCLEXCL : 0;
< 	etm_writel(t, flags | (1 << n), ETMR_TRACEENCTRL);
---
> 	if (data) {
> 		flags = exclude ? ETMVDC3_EXCLONLY : 0;
> 		if (exclude)
> 			n += 8;
> 		etm_writel(t, id, flags | BIT(n), ETMR_VIEWDATACTRL3);
> 	} else {
> 		flags = exclude ? ETMTE_INCLEXCL : 0;
> 		etm_writel(t, id, flags | (1 << n), ETMR_TRACEENCTRL);
> 	}
87c105
< static int trace_start(struct tracectx *t)
---
> static int trace_start_etm(struct tracectx *t, int id)
92,99d109
< 	etb_unlock(t);
< 
< 	etb_writel(t, 0, ETBR_FORMATTERCTRL);
< 	etb_writel(t, 1, ETBR_CTRL);
< 
< 	etb_lock(t);
< 
< 	/* configure etm */
105c115,116
< 	etm_unlock(t);
---
> 	if (t->flags & TRACER_TRACE_DATA)
> 		v |= ETMCTRL_DATA_DO_ADDR;
107c118
< 	etm_writel(t, v, ETMR_CTRL);
---
> 	etm_unlock(t, id);
109c120,122
< 	while (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
---
> 	etm_writel(t, id, v, ETMR_CTRL);
> 
> 	while (!(etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
113c126
< 		etm_lock(t);
---
> 		etm_lock(t, id);
117,121c130,149
< 	etm_setup_address_range(t, 1, (unsigned long)_stext,
< 			(unsigned long)_etext, 0, 0);
< 	etm_writel(t, 0, ETMR_TRACEENCTRL2);
< 	etm_writel(t, 0, ETMR_TRACESSCTRL);
< 	etm_writel(t, 0x6f, ETMR_TRACEENEVT);
---
> 	if (t->range_start || t->range_end)
> 		etm_setup_address_range(t, id, 1,
> 					t->range_start, t->range_end, 0, 0);
> 	else
> 		etm_writel(t, id, ETMTE_INCLEXCL, ETMR_TRACEENCTRL);
> 
> 	etm_writel(t, id, 0, ETMR_TRACEENCTRL2);
> 	etm_writel(t, id, 0, ETMR_TRACESSCTRL);
> 	etm_writel(t, id, 0x6f, ETMR_TRACEENEVT);
> 
> 	etm_writel(t, id, 0, ETMR_VIEWDATACTRL1);
> 	etm_writel(t, id, 0, ETMR_VIEWDATACTRL2);
> 
> 	if (t->data_range_start || t->data_range_end)
> 		etm_setup_address_range(t, id, 2, t->data_range_start,
> 					t->data_range_end, 0, 1);
> 	else
> 		etm_writel(t, id, ETMVDC3_EXCLONLY, ETMR_VIEWDATACTRL3);
> 
> 	etm_writel(t, id, 0x6f, ETMR_VIEWDATAEVT);
126c154
< 	etm_writel(t, v, ETMR_CTRL);
---
> 	etm_writel(t, id, v, ETMR_CTRL);
129c157
< 	while (etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM && --timeout)
---
> 	while (etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM && --timeout)
133c161
< 		etm_lock(t);
---
> 		etm_lock(t, id);
137c165,189
< 	etm_lock(t);
---
> 	etm_lock(t, id);
> 	return 0;
> }
> 
> static int trace_start(struct tracectx *t)
> {
> 	int ret;
> 	int id;
> 	u32 etb_fc = t->etb_fc;
> 
> 	etb_unlock(t);
> 
> 	t->dump_initial_etb = false;
> 	etb_writel(t, 0, ETBR_WRITEADDR);
> 	etb_writel(t, etb_fc, ETBR_FORMATTERCTRL);
> 	etb_writel(t, 1, ETBR_CTRL);
> 
> 	etb_lock(t);
> 
> 	/* configure etm(s) */
> 	for (id = 0; id < t->etm_regs_count; id++) {
> 		ret = trace_start_etm(t, id);
> 		if (ret)
> 			return ret;
> 	}
144c196
< static int trace_stop(struct tracectx *t)
---
> static int trace_stop_etm(struct tracectx *t, int id)
148c200
< 	etm_unlock(t);
---
> 	etm_unlock(t, id);
150,151c202,203
< 	etm_writel(t, 0x440, ETMR_CTRL);
< 	while (!(etm_readl(t, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
---
> 	etm_writel(t, id, 0x441, ETMR_CTRL);
> 	while (!(etm_readl(t, id, ETMR_CTRL) & ETMCTRL_PROGRAM) && --timeout)
155c207
< 		etm_lock(t);
---
> 		etm_lock(t, id);
159c211,226
< 	etm_lock(t);
---
> 	etm_lock(t, id);
> 	return 0;
> }
> 
> static int trace_stop(struct tracectx *t)
> {
> 	int id;
> 	int ret;
> 	unsigned long timeout = TRACER_TIMEOUT;
> 	u32 etb_fc = t->etb_fc;
> 
> 	for (id = 0; id < t->etm_regs_count; id++) {
> 		ret = trace_stop_etm(t, id);
> 		if (ret)
> 			return ret;
> 	}
162c229,233
< 	etb_writel(t, ETBFF_MANUAL_FLUSH, ETBR_FORMATTERCTRL);
---
> 	if (etb_fc) {
> 		etb_fc |= ETBFF_STOPFL;
> 		etb_writel(t, t->etb_fc, ETBR_FORMATTERCTRL);
> 	}
> 	etb_writel(t, etb_fc | ETBFF_MANUAL_FLUSH, ETBR_FORMATTERCTRL);
187c258
< 	int rp, wp;
---
> 	int wp;
194d264
< 	rp = etb_readl(t, ETBR_READADDR);
196,204c266
< 
< 	if (rp > wp) {
< 		etb_writel(t, 0, ETBR_READADDR);
< 		etb_writel(t, 0, ETBR_WRITEADDR);
< 
< 		return 0;
< 	}
< 
< 	return wp - rp;
---
> 	return wp;
237,244d298
< 	/* deassert the overflow bit */
< 	etb_writel(t, 1, ETBR_CTRL);
< 	etb_writel(t, 0, ETBR_CTRL);
< 
< 	etb_writel(t, 0, ETBR_TRIGGERCOUNT);
< 	etb_writel(t, 0, ETBR_READADDR);
< 	etb_writel(t, 0, ETBR_WRITEADDR);
< 
249a304,307
> 	if (!mutex_trylock(&tracer.mutex)) {
> 		printk(KERN_INFO "Tracing hardware busy\n");
> 		return;
> 	}
251a310
> 	mutex_unlock(&tracer.mutex);
277a337,340
> 	int wpos;
> 	int skip;
> 	long wlength;
> 	loff_t pos = *ppos;
288a352,353
> 	if (total == 0 && t->dump_initial_etb)
> 		total = t->etb_bufsz;
292c357,365
< 	etb_writel(t, first, ETBR_READADDR);
---
> 	if (pos > total * 4) {
> 		skip = 0;
> 		wpos = total;
> 	} else {
> 		skip = (int)pos % 4;
> 		wpos = (int)pos / 4;
> 	}
> 	total -= wpos;
> 	first = (first + wpos) % t->etb_bufsz;
294,295c367
< 	length = min(total * 4, (int)len);
< 	buf = vmalloc(length);
---
> 	etb_writel(t, first, ETBR_READADDR);
297c369,375
< 	dev_dbg(t->dev, "ETB buffer length: %d\n", total);
---
> 	wlength = min(total, DIV_ROUND_UP(skip + (int)len, 4));
> 	length = min(total * 4 - skip, (int)len);
> 	buf = vmalloc(wlength * 4);
> 
> 	dev_dbg(t->dev, "ETB read %ld bytes to %lld from %ld words at %d\n",
> 		length, pos, wlength, first);
> 	dev_dbg(t->dev, "ETB buffer length: %d\n", total + wpos);
299c377
< 	for (i = 0; i < length / 4; i++)
---
> 	for (i = 0; i < wlength; i++)
302,309d379
< 	/* the only way to deassert overflow bit in ETB status is this */
< 	etb_writel(t, 1, ETBR_CTRL);
< 	etb_writel(t, 0, ETBR_CTRL);
< 
< 	etb_writel(t, 0, ETBR_WRITEADDR);
< 	etb_writel(t, 0, ETBR_READADDR);
< 	etb_writel(t, 0, ETBR_TRIGGERCOUNT);
< 
312c382
< 	length -= copy_to_user(data, buf, length);
---
> 	length -= copy_to_user(data, (u8 *)buf + skip, length);
313a384
> 	*ppos = pos + length;
349a421
> 	mutex_lock(&t->mutex);
355a428,429
> 	t->dev = &dev->dev;
> 	t->dump_initial_etb = true;
358,371d431
< 	etb_miscdev.parent = &dev->dev;
< 
< 	ret = misc_register(&etb_miscdev);
< 	if (ret)
< 		goto out_unmap;
< 
< 	t->emu_clk = clk_get(&dev->dev, "emu_src_ck");
< 	if (IS_ERR(t->emu_clk)) {
< 		dev_dbg(&dev->dev, "Failed to obtain emu_src_ck.\n");
< 		return -EFAULT;
< 	}
< 
< 	clk_enable(t->emu_clk);
< 
379a440,453
> 	mutex_unlock(&t->mutex);
> 
> 	etb_miscdev.parent = &dev->dev;
> 
> 	ret = misc_register(&etb_miscdev);
> 	if (ret)
> 		goto out_unmap;
> 
> 	/* Get optional clock. Currently used to select clock source on omap3 */
> 	t->emu_clk = clk_get(&dev->dev, "emu_src_ck");
> 	if (IS_ERR(t->emu_clk))
> 		dev_dbg(&dev->dev, "Failed to obtain emu_src_ck.\n");
> 	else
> 		clk_enable(t->emu_clk);
386a461
> 	mutex_lock(&t->mutex);
388a464
> 	t->etb_regs = NULL;
390a467
> 	mutex_unlock(&t->mutex);
405,406c482,485
< 	clk_disable(t->emu_clk);
< 	clk_put(t->emu_clk);
---
> 	if (!IS_ERR(t->emu_clk)) {
> 		clk_disable(t->emu_clk);
> 		clk_put(t->emu_clk);
> 	}
450c529,532
< 	ret = value ? trace_start(&tracer) : trace_stop(&tracer);
---
> 	if (!tracer.etb_regs)
> 		ret = -ENODEV;
> 	else
> 		ret = value ? trace_start(&tracer) : trace_stop(&tracer);
464a547,548
> 	int id;
> 	int ret;
466,477c550,562
< 	etb_unlock(&tracer);
< 	datalen = etb_getdatalen(&tracer);
< 	etb_wa = etb_readl(&tracer, ETBR_WRITEADDR);
< 	etb_ra = etb_readl(&tracer, ETBR_READADDR);
< 	etb_st = etb_readl(&tracer, ETBR_STATUS);
< 	etb_fc = etb_readl(&tracer, ETBR_FORMATTERCTRL);
< 	etb_lock(&tracer);
< 
< 	etm_unlock(&tracer);
< 	etm_ctrl = etm_readl(&tracer, ETMR_CTRL);
< 	etm_st = etm_readl(&tracer, ETMR_STATUS);
< 	etm_lock(&tracer);
---
> 	mutex_lock(&tracer.mutex);
> 	if (tracer.etb_regs) {
> 		etb_unlock(&tracer);
> 		datalen = etb_getdatalen(&tracer);
> 		etb_wa = etb_readl(&tracer, ETBR_WRITEADDR);
> 		etb_ra = etb_readl(&tracer, ETBR_READADDR);
> 		etb_st = etb_readl(&tracer, ETBR_STATUS);
> 		etb_fc = etb_readl(&tracer, ETBR_FORMATTERCTRL);
> 		etb_lock(&tracer);
> 	} else {
> 		etb_wa = etb_ra = etb_st = etb_fc = ~0;
> 		datalen = -1;
> 	}
479c564
< 	return sprintf(buf, "Trace buffer len: %d\nComparator pairs: %d\n"
---
> 	ret = sprintf(buf, "Trace buffer len: %d\nComparator pairs: %d\n"
483,485c568
< 			"ETBR_FORMATTERCTRL:\t%08x\n"
< 			"ETMR_CTRL:\t%08x\n"
< 			"ETMR_STATUS:\t%08x\n",
---
> 			"ETBR_FORMATTERCTRL:\t%08x\n",
491c574,583
< 			etb_fc,
---
> 			etb_fc
> 			);
> 
> 	for (id = 0; id < tracer.etm_regs_count; id++) {
> 		etm_unlock(&tracer, id);
> 		etm_ctrl = etm_readl(&tracer, id, ETMR_CTRL);
> 		etm_st = etm_readl(&tracer, id, ETMR_STATUS);
> 		etm_lock(&tracer, id);
> 		ret += sprintf(buf + ret, "ETMR_CTRL:\t%08x\n"
> 			"ETMR_STATUS:\t%08x\n",
494a587,590
> 	}
> 	mutex_unlock(&tracer.mutex);
> 
> 	return ret;
532a629,699
> static ssize_t trace_range_show(struct kobject *kobj,
> 				  struct kobj_attribute *attr,
> 				  char *buf)
> {
> 	return sprintf(buf, "%08lx %08lx\n",
> 			tracer.range_start, tracer.range_end);
> }
> 
> static ssize_t trace_range_store(struct kobject *kobj,
> 				   struct kobj_attribute *attr,
> 				   const char *buf, size_t n)
> {
> 	unsigned long range_start, range_end;
> 
> 	if (sscanf(buf, "%lx %lx", &range_start, &range_end) != 2)
> 		return -EINVAL;
> 
> 	mutex_lock(&tracer.mutex);
> 	tracer.range_start = range_start;
> 	tracer.range_end = range_end;
> 	mutex_unlock(&tracer.mutex);
> 
> 	return n;
> }
> 
> 
> static struct kobj_attribute trace_range_attr =
> 	__ATTR(trace_range, 0644, trace_range_show, trace_range_store);
> 
> static ssize_t trace_data_range_show(struct kobject *kobj,
> 				  struct kobj_attribute *attr,
> 				  char *buf)
> {
> 	unsigned long range_start;
> 	u64 range_end;
> 	mutex_lock(&tracer.mutex);
> 	range_start = tracer.data_range_start;
> 	range_end = tracer.data_range_end;
> 	if (!range_end && (tracer.flags & TRACER_TRACE_DATA))
> 		range_end = 0x100000000ULL;
> 	mutex_unlock(&tracer.mutex);
> 	return sprintf(buf, "%08lx %08llx\n", range_start, range_end);
> }
> 
> static ssize_t trace_data_range_store(struct kobject *kobj,
> 				   struct kobj_attribute *attr,
> 				   const char *buf, size_t n)
> {
> 	unsigned long range_start;
> 	u64 range_end;
> 
> 	if (sscanf(buf, "%lx %llx", &range_start, &range_end) != 2)
> 		return -EINVAL;
> 
> 	mutex_lock(&tracer.mutex);
> 	tracer.data_range_start = range_start;
> 	tracer.data_range_end = (unsigned long)range_end;
> 	if (range_end)
> 		tracer.flags |= TRACER_TRACE_DATA;
> 	else
> 		tracer.flags &= ~TRACER_TRACE_DATA;
> 	mutex_unlock(&tracer.mutex);
> 
> 	return n;
> }
> 
> 
> static struct kobj_attribute trace_data_range_attr =
> 	__ATTR(trace_data_range, 0644,
> 		trace_data_range_show, trace_data_range_store);
> 
536a704,710
> 	void __iomem **new_regs;
> 	int new_count;
> 
> 	mutex_lock(&t->mutex);
> 	new_count = t->etm_regs_count + 1;
> 	new_regs = krealloc(t->etm_regs,
> 				sizeof(t->etm_regs[0]) * new_count, GFP_KERNEL);
538,540c712,714
< 	if (t->etm_regs) {
< 		dev_dbg(&dev->dev, "ETM already initialized\n");
< 		ret = -EBUSY;
---
> 	if (!new_regs) {
> 		dev_dbg(&dev->dev, "Failed to allocate ETM register array\n");
> 		ret = -ENOMEM;
542a717
> 	t->etm_regs = new_regs;
548,549c723,725
< 	t->etm_regs = ioremap_nocache(dev->res.start, resource_size(&dev->res));
< 	if (!t->etm_regs) {
---
> 	t->etm_regs[t->etm_regs_count] =
> 		ioremap_nocache(dev->res.start, resource_size(&dev->res));
> 	if (!t->etm_regs[t->etm_regs_count]) {
554c730
< 	amba_set_drvdata(dev, t);
---
> 	amba_set_drvdata(dev, t->etm_regs[t->etm_regs_count]);
556,558c732
< 	mutex_init(&t->mutex);
< 	t->dev = &dev->dev;
< 	t->flags = TRACER_CYCLE_ACC;
---
> 	t->flags = TRACER_CYCLE_ACC | TRACER_TRACE_DATA;
561,562c735,736
< 	etm_unlock(t);
< 	(void)etm_readl(t, ETMMR_PDSR);
---
> 	etm_unlock(t, t->etm_regs_count);
> 	(void)etm_readl(t, t->etm_regs_count, ETMMR_PDSR);
564c738
< 	(void)etm_readl(&tracer, ETMMR_OSSRR);
---
> 	(void)etm_readl(&tracer, t->etm_regs_count, ETMMR_OSSRR);
566,568c740,743
< 	t->ncmppairs = etm_readl(t, ETMR_CONFCODE) & 0xf;
< 	etm_writel(t, 0x440, ETMR_CTRL);
< 	etm_lock(t);
---
> 	t->ncmppairs = etm_readl(t, t->etm_regs_count, ETMR_CONFCODE) & 0xf;
> 	etm_writel(t, t->etm_regs_count, 0x441, ETMR_CTRL);
> 	etm_writel(t, t->etm_regs_count, new_count, ETMR_TRACEIDR);
> 	etm_lock(t, t->etm_regs_count);
584c759,774
< 	dev_dbg(t->dev, "ETM AMBA driver initialized.\n");
---
> 	ret = sysfs_create_file(&dev->dev.kobj, &trace_range_attr.attr);
> 	if (ret)
> 		dev_dbg(&dev->dev, "Failed to create trace_range in sysfs\n");
> 
> 	ret = sysfs_create_file(&dev->dev.kobj, &trace_data_range_attr.attr);
> 	if (ret)
> 		dev_dbg(&dev->dev,
> 			"Failed to create trace_data_range in sysfs\n");
> 
> 	dev_dbg(&dev->dev, "ETM AMBA driver initialized.\n");
> 
> 	/* Enable formatter if there are multiple trace sources */
> 	if (new_count > 1)
> 		t->etb_fc = ETBFF_ENFCONT | ETBFF_ENFTC;
> 
> 	t->etm_regs_count = new_count;
586a777
> 	mutex_unlock(&t->mutex);
591c782
< 	iounmap(t->etm_regs);
---
> 	iounmap(t->etm_regs[t->etm_regs_count]);
595a787
> 	mutex_unlock(&t->mutex);
601c793,801
< 	struct tracectx *t = amba_get_drvdata(dev);
---
> 	int i;
> 	struct tracectx *t = &tracer;
> 	void __iomem	*etm_regs = amba_get_drvdata(dev);
> 
> 	sysfs_remove_file(&dev->dev.kobj, &trace_running_attr.attr);
> 	sysfs_remove_file(&dev->dev.kobj, &trace_info_attr.attr);
> 	sysfs_remove_file(&dev->dev.kobj, &trace_mode_attr.attr);
> 	sysfs_remove_file(&dev->dev.kobj, &trace_range_attr.attr);
> 	sysfs_remove_file(&dev->dev.kobj, &trace_data_range_attr.attr);
605,606c805,816
< 	iounmap(t->etm_regs);
< 	t->etm_regs = NULL;
---
> 	mutex_lock(&t->mutex);
> 	for (i = 0; i < t->etm_regs_count; i++)
> 		if (t->etm_regs[i] == etm_regs)
> 			break;
> 	for (; i < t->etm_regs_count - 1; i++)
> 		t->etm_regs[i] = t->etm_regs[i + 1];
> 	t->etm_regs_count--;
> 	if (!t->etm_regs_count) {
> 		kfree(t->etm_regs);
> 		t->etm_regs = NULL;
> 	}
> 	mutex_unlock(&t->mutex);
607a818
> 	iounmap(etm_regs);
610,613d820
< 	sysfs_remove_file(&dev->dev.kobj, &trace_running_attr.attr);
< 	sysfs_remove_file(&dev->dev.kobj, &trace_info_attr.attr);
< 	sysfs_remove_file(&dev->dev.kobj, &trace_mode_attr.attr);
< 
621a829,832
> 	{
> 		.id	= 0x0003b950,
> 		.mask	= 0x0007ffff,
> 	},
637a849,850
> 
> 	mutex_init(&tracer.mutex);




diff -r linux-3.0.36/arch/arm/kernel/head.S linux-3.0.36-lenovo/arch/arm/kernel/head.S
44a45,48
> #ifdef CONFIG_PLAT_RK
> 	add	\rd, \phys, #((TEXT_OFFSET - 0x4000) & 0xffff0000)
> 	add	\rd, \rd,   #((TEXT_OFFSET - 0x4000) & 0x0000ffff)
> #else
45a50
> #endif




diff -r linux-3.0.36/arch/arm/kernel/leds.c linux-3.0.36-lenovo/arch/arm/kernel/leds.c
11a12,13
> #include <linux/notifier.h>
> #include <linux/cpu.h>
103a106,124
> static int leds_idle_notifier(struct notifier_block *nb, unsigned long val,
>                                 void *data)
> {
> 	switch (val) {
> 	case IDLE_START:
> 		leds_event(led_idle_start);
> 		break;
> 	case IDLE_END:
> 		leds_event(led_idle_end);
> 		break;
> 	}
> 
> 	return 0;
> }
> 
> static struct notifier_block leds_idle_nb = {
> 	.notifier_call = leds_idle_notifier,
> };
> 
112c133,134
< 	if (ret == 0)
---
> 
> 	if (ret == 0) {
113a136,138
> 		idle_notifier_register(&leds_idle_nb);
> 	}
> 




diff -r linux-3.0.36/arch/arm/kernel/process.c linux-3.0.36-lenovo/arch/arm/kernel/process.c
32a33
> #include <linux/console.h>
35d35
< #include <asm/leds.h>
64a65,76
> #ifdef CONFIG_SMP
> void arch_trigger_all_cpu_backtrace(void)
> {
> 	smp_send_all_cpu_backtrace();
> }
> #else
> void arch_trigger_all_cpu_backtrace(void)
> {
> 	dump_stack();
> }
> #endif
> 
93a106,130
> #ifdef CONFIG_ARM_FLUSH_CONSOLE_ON_RESTART
> void arm_machine_flush_console(void)
> {
> 	printk("\n");
> 	pr_emerg("Restarting %s\n", linux_banner);
> 	if (console_trylock()) {
> 		console_unlock();
> 		return;
> 	}
> 
> 	mdelay(50);
> 
> 	local_irq_disable();
> 	if (!console_trylock())
> 		pr_emerg("arm_restart: Console was locked! Busting\n");
> 	else
> 		pr_emerg("arm_restart: Console was locked!\n");
> 	console_unlock();
> }
> #else
> void arm_machine_flush_console(void)
> {
> }
> #endif
> 
95a133,136
> 	/* Flush the console to make sure all the relevant messages make it
> 	 * out to the console drivers */
> 	arm_machine_flush_console();
> 
184a226
> 		idle_notifier_call_chain(IDLE_START);
186d227
< 		leds_event(led_idle_start);
213d253
< 		leds_event(led_idle_end);
214a255
> 		idle_notifier_call_chain(IDLE_END);
233a275,285
> 	/*
> 	 * Disable preemption so we're guaranteed to
> 	 * run to power off or reboot and prevent
> 	 * the possibility of switching to another
> 	 * thread that might wind up blocking on
> 	 * one of the stopped CPUs.
> 	 */
> #ifndef CONFIG_PLAT_RK
> 	preempt_disable();
> #endif
> 
256a309,379
> /*
>  * dump a block of kernel memory from around the given address
>  */
> static void show_data(unsigned long addr, int nbytes, const char *name)
> {
> 	int	i, j;
> 	int	nlines;
> 	u32	*p;
> 
> 	/*
> 	 * don't attempt to dump non-kernel addresses or
> 	 * values that are probably just small negative numbers
> 	 */
> 	if (addr < PAGE_OFFSET || addr > -256UL)
> 		return;
> 
> 	printk("\n%s: %#lx:\n", name, addr);
> 
> 	/*
> 	 * round address down to a 32 bit boundary
> 	 * and always dump a multiple of 32 bytes
> 	 */
> 	p = (u32 *)(addr & ~(sizeof(u32) - 1));
> 	nbytes += (addr & (sizeof(u32) - 1));
> 	nlines = (nbytes + 31) / 32;
> 
> 
> 	for (i = 0; i < nlines; i++) {
> 		/*
> 		 * just display low 16 bits of address to keep
> 		 * each line of the dump < 80 characters
> 		 */
> 		printk("%04lx ", (unsigned long)p & 0xffff);
> 		for (j = 0; j < 8; j++) {
> 			u32	data;
> 			if (probe_kernel_address(p, data)) {
> 				printk(" ********");
> 			} else {
> 				printk(" %08x", data);
> 			}
> 			++p;
> 		}
> 		printk("\n");
> 	}
> }
> 
> static void show_extra_register_data(struct pt_regs *regs, int nbytes)
> {
> 	mm_segment_t fs;
> 
> 	fs = get_fs();
> 	set_fs(KERNEL_DS);
> 	show_data(regs->ARM_pc - nbytes, nbytes * 2, "PC");
> 	show_data(regs->ARM_lr - nbytes, nbytes * 2, "LR");
> 	show_data(regs->ARM_sp - nbytes, nbytes * 2, "SP");
> 	show_data(regs->ARM_ip - nbytes, nbytes * 2, "IP");
> 	show_data(regs->ARM_fp - nbytes, nbytes * 2, "FP");
> 	show_data(regs->ARM_r0 - nbytes, nbytes * 2, "R0");
> 	show_data(regs->ARM_r1 - nbytes, nbytes * 2, "R1");
> 	show_data(regs->ARM_r2 - nbytes, nbytes * 2, "R2");
> 	show_data(regs->ARM_r3 - nbytes, nbytes * 2, "R3");
> 	show_data(regs->ARM_r4 - nbytes, nbytes * 2, "R4");
> 	show_data(regs->ARM_r5 - nbytes, nbytes * 2, "R5");
> 	show_data(regs->ARM_r6 - nbytes, nbytes * 2, "R6");
> 	show_data(regs->ARM_r7 - nbytes, nbytes * 2, "R7");
> 	show_data(regs->ARM_r8 - nbytes, nbytes * 2, "R8");
> 	show_data(regs->ARM_r9 - nbytes, nbytes * 2, "R9");
> 	show_data(regs->ARM_r10 - nbytes, nbytes * 2, "R10");
> 	set_fs(fs);
> }
> 
315a439,440
> 
> 	show_extra_register_data(regs, 128);




diff -r linux-3.0.36/arch/arm/kernel/smp.c linux-3.0.36-lenovo/arch/arm/kernel/smp.c
55a56
> 	IPI_CPU_BACKTRACE,
280c281,289
< 	unsigned int cpu = smp_processor_id();
---
> 	unsigned int cpu;
> 
> 	/*
> 	 * The identity mapping is uncached (strongly ordered), so
> 	 * switch away from it before attempting any exclusive accesses.
> 	 */
> 	cpu_switch_mm(mm->pgd, mm);
> 	enter_lazy_tlb(mm, current);
> 	local_flush_tlb_all();
285a295
> 	cpu = smp_processor_id();
289,291d298
< 	cpu_switch_mm(mm->pgd, mm);
< 	enter_lazy_tlb(mm, current);
< 	local_flush_tlb_all();
304,306d310
< 	/*
< 	 * Enable local interrupts.
< 	 */
308,314d311
< 	local_irq_enable();
< 	local_fiq_enable();
< 
< 	/*
< 	 * Setup the percpu timer for this CPU.
< 	 */
< 	percpu_timer_setup();
315a313
> #ifndef CONFIG_PLAT_RK
316a315
> #endif
326,327c325,332
< 	while (!cpu_active(cpu))
< 		cpu_relax();
---
> 
> 	/*
> 	 * Setup the percpu timer for this CPU.
> 	 */
> 	percpu_timer_setup();
> 
> 	local_irq_enable();
> 	local_fiq_enable();
407a413
> 	S(IPI_CPU_BACKTRACE, "CPU backtrace"),
448d453
< 	irq_enter();
450d454
< 	irq_exit();
460a465
> 		irq_enter();
461a467
> 		irq_exit();
557a564,615
> static cpumask_t backtrace_mask;
> static DEFINE_RAW_SPINLOCK(backtrace_lock);
> 
> /* "in progress" flag of arch_trigger_all_cpu_backtrace */
> static unsigned long backtrace_flag;
> 
> void smp_send_all_cpu_backtrace(void)
> {
> 	unsigned int this_cpu = smp_processor_id();
> 	int i;
> 
> 	if (test_and_set_bit(0, &backtrace_flag))
> 		/*
> 		 * If there is already a trigger_all_cpu_backtrace() in progress
> 		 * (backtrace_flag == 1), don't output double cpu dump infos.
> 		 */
> 		return;
> 
> 	cpumask_copy(&backtrace_mask, cpu_online_mask);
> 	cpu_clear(this_cpu, backtrace_mask);
> 
> 	pr_info("Backtrace for cpu %d (current):\n", this_cpu);
> 	dump_stack();
> 
> 	pr_info("\nsending IPI to all other CPUs:\n");
> 	smp_cross_call(&backtrace_mask, IPI_CPU_BACKTRACE);
> 
> 	/* Wait for up to 10 seconds for all other CPUs to do the backtrace */
> 	for (i = 0; i < 10 * 1000; i++) {
> 		if (cpumask_empty(&backtrace_mask))
> 			break;
> 		mdelay(1);
> 	}
> 
> 	clear_bit(0, &backtrace_flag);
> 	smp_mb__after_clear_bit();
> }
> 
> /*
>  * ipi_cpu_backtrace - handle IPI from smp_send_all_cpu_backtrace()
>  */
> static void ipi_cpu_backtrace(unsigned int cpu, struct pt_regs *regs)
> {
> 	if (cpu_isset(cpu, backtrace_mask)) {
> 		raw_spin_lock(&backtrace_lock);
> 		pr_warning("IPI backtrace for cpu %d\n", cpu);
> 		show_regs(regs);
> 		raw_spin_unlock(&backtrace_lock);
> 		cpu_clear(cpu, backtrace_mask);
> 	}
> }
> 
570a629
> 		irq_enter();
571a631
> 		irq_exit();
578a639
> 		irq_enter();
579a641
> 		irq_exit();
582a645
> 		irq_enter();
583a647
> 		irq_exit();
586a651
> 		irq_enter();
587a653,657
> 		irq_exit();
> 		break;
> 
> 	case IPI_CPU_BACKTRACE:
> 		ipi_cpu_backtrace(cpu, regs);




diff -r linux-3.0.36/arch/arm/kernel/smp_twd.c linux-3.0.36-lenovo/arch/arm/kernel/smp_twd.c
12a13,14
> #include <linux/clk.h>
> #include <linux/cpufreq.h>
14a17
> #include <linux/err.h>
19a23
> #include <linux/percpu.h>
26a31
> static struct clk *twd_clk;
27a33
> static DEFINE_PER_CPU(struct clock_event_device *, twd_ce);
82a89,134
> /*
>  * Updates clockevent frequency when the cpu frequency changes.
>  * Called on the cpu that is changing frequency with interrupts disabled.
>  */
> static void twd_update_frequency(void *data)
> {
> 	twd_timer_rate = clk_get_rate(twd_clk);
> 
> 	clockevents_update_freq(__get_cpu_var(twd_ce), twd_timer_rate);
> }
> 
> static int twd_cpufreq_transition(struct notifier_block *nb,
> 	unsigned long state, void *data)
> {
> 	struct cpufreq_freqs *freqs = data;
> 
> 	/*
> 	 * The twd clock events must be reprogrammed to account for the new
> 	 * frequency.  The timer is local to a cpu, so cross-call to the
> 	 * changing cpu.
> 	 *
> 	 * Only wait for it to finish, if the cpu is active to avoid
> 	 * deadlock when cpu1 is spinning on while(!cpu_active(cpu1)) during
> 	 * booting of that cpu.
> 	 */
> 	if (state == CPUFREQ_POSTCHANGE || state == CPUFREQ_RESUMECHANGE)
> 		smp_call_function_single(freqs->cpu, twd_update_frequency,
> 					 NULL, cpu_active(freqs->cpu));
> 
> 	return NOTIFY_OK;
> }
> 
> static struct notifier_block twd_cpufreq_nb = {
> 	.notifier_call = twd_cpufreq_transition,
> };
> 
> static int twd_cpufreq_init(void)
> {
> 	if (!IS_ERR_OR_NULL(twd_clk))
> 		return cpufreq_register_notifier(&twd_cpufreq_nb,
> 			CPUFREQ_TRANSITION_NOTIFIER);
> 
> 	return 0;
> }
> core_initcall(twd_cpufreq_init);
> 
127c179,190
< 	twd_calibrate_rate();
---
> 	if (twd_clk == NULL) {
> 		twd_clk = clk_get_sys("smp_twd", NULL);
> 		if (IS_ERR_OR_NULL(twd_clk))
> 			pr_warn("%s: no clock found\n", __func__);
> 	}
> 
> 	if (!IS_ERR_OR_NULL(twd_clk))
> 		twd_timer_rate = clk_get_rate(twd_clk);
> 	else
> 		twd_calibrate_rate();
> 
> 	__raw_writel(0, twd_base + TWD_TIMER_CONTROL);
135,138c198,201
< 	clk->shift = 20;
< 	clk->mult = div_sc(twd_timer_rate, NSEC_PER_SEC, clk->shift);
< 	clk->max_delta_ns = clockevent_delta2ns(0xffffffff, clk);
< 	clk->min_delta_ns = clockevent_delta2ns(0xf, clk);
---
> 
> 	__get_cpu_var(twd_ce) = clk;
> 
> 	clockevents_config_and_register(clk, twd_timer_rate, 0xf, 0xffffffff);
142,143d204
< 
< 	clockevents_register_device(clk);




diff -r linux-3.0.36/arch/arm/kernel/swp_emulate.c linux-3.0.36-lenovo/arch/arm/kernel/swp_emulate.c
110a111
> 	down_read(&current->mm->mmap_sem);
114a116
> 	up_read(&current->mm->mmap_sem);




diff -r linux-3.0.36/arch/arm/kernel/vmlinux.lds.S linux-3.0.36-lenovo/arch/arm/kernel/vmlinux.lds.S
261a262,312
> #ifdef CONFIG_PLAT_RK
>         /*
> 	 * We align everything to a page boundary so we can
> 	 * free it after init has commenced and SRAM contents have
> 	 * been copied to its destination.
> 	 */
> 	.sram_start : {
> 		. = ALIGN(PAGE_SIZE);
> 		__sram_start = .;
> 		__sram_code_start = .;
> 	}
> 
> 	.text_sram_code SRAM_CODE_OFFSET : AT(__sram_code_start)
> 	{
> 		__ssram_code_text = .;
> 		*(.sram.text)
> 		*(.sram.rodata)
> 		. = ALIGN(4);
> 		__esram_code_text = .;
> 	}
> 
> 	/*
> 	 * Reset the dot pointer, this is needed to create the
> 	 * relative __sram_data_start below (to be used as extern in code).
> 	 */
> 	. = ADDR(.sram_start) + SIZEOF(.sram_start) + SIZEOF(.text_sram_code);
> 
> 	.sram_data_start : {
> 		__sram_data_start = .;
> 	}
> 
> 	/* TODO: add remainder of ITCM as well, that can be used for data! */
> 	.data_sram SRAM_CODE_OFFSET + SIZEOF(.text_sram_code) : AT(__sram_data_start)
> 	{
> 		. = ALIGN(4);
> 		__ssram_data = .;
> 		*(.sram.data)
> 		. = ALIGN(4);
> 		__esram_data = .;
> 	}
> 
> 	/* Reset the dot pointer or the linker gets confused */
> 	. = ADDR(.sram_data_start) + SIZEOF(.data_sram);
> 
> 	/* End marker for freeing TCM copy in linked object */
> 	.sram_end : AT(ADDR(.sram_data_start) + SIZEOF(.data_sram)){
> 		__sram_end = .;
> 	}
> 
> 	. = ALIGN(PAGE_SIZE);
> #endif




diff -r linux-3.0.36/arch/arm/mach-at91/at91rm9200_devices.c linux-3.0.36-lenovo/arch/arm/mach-at91/at91rm9200_devices.c
457c457
< 	.id			= -1,
---
> 	.id			= 0,




diff -r linux-3.0.36/arch/arm/mach-at91/at91sam9260_devices.c linux-3.0.36-lenovo/arch/arm/mach-at91/at91sam9260_devices.c
462c462
< 	.id			= -1,
---
> 	.id			= 0,




diff -r linux-3.0.36/arch/arm/mach-at91/at91sam9261_devices.c linux-3.0.36-lenovo/arch/arm/mach-at91/at91sam9261_devices.c
279c279
< 	.id			= -1,
---
> 	.id			= 0,




diff -r linux-3.0.36/arch/arm/mach-at91/at91sam9263_devices.c linux-3.0.36-lenovo/arch/arm/mach-at91/at91sam9263_devices.c
537c537
< 	.id			= -1,
---
> 	.id			= 0,




diff -r linux-3.0.36/arch/arm/mach-at91/at91sam9rl_devices.c linux-3.0.36-lenovo/arch/arm/mach-at91/at91sam9rl_devices.c
322c322
< 	.id			= -1,
---
> 	.id			= 0,




diff -r linux-3.0.36/arch/arm/mach-dove/include/mach/pm.h linux-3.0.36-lenovo/arch/arm/mach-dove/include/mach/pm.h
48c48
< 	if (IRQ_DOVE_PMU_START < irq && irq < NR_IRQS)
---
> 	if (IRQ_DOVE_PMU_START <= irq && irq < NR_IRQS)




diff -r linux-3.0.36/arch/arm/mach-dove/irq.c linux-3.0.36-lenovo/arch/arm/mach-dove/irq.c
63a64,74
> 	/*
> 	 * The PMU mask register is not RW0C: it is RW.  This means that
> 	 * the bits take whatever value is written to them; if you write
> 	 * a '1', you will set the interrupt.
> 	 *
> 	 * Unfortunately this means there is NO race free way to clear
> 	 * these interrupts.
> 	 *
> 	 * So, let's structure the code so that the window is as small as
> 	 * possible.
> 	 */
65c76,77
< 	writel(u, PMU_INTERRUPT_CAUSE);
---
> 	u &= readl_relaxed(PMU_INTERRUPT_CAUSE);
> 	writel_relaxed(u, PMU_INTERRUPT_CAUSE);




diff -r linux-3.0.36/arch/arm/mach-omap2/opp.c linux-3.0.36-lenovo/arch/arm/mach-omap2/opp.c
56c56
< 	for (i = 0; i < opp_def_size; i++) {
---
> 	for (i = 0; i < opp_def_size; i++, opp_def++) {
89d88
< 		opp_def++;
Only in linux-3.0.36-lenovo/arch/arm: mach-rk29
Only in linux-3.0.36-lenovo/arch/arm: mach-rk2928
Only in linux-3.0.36-lenovo/arch/arm: mach-rk30
Only in linux-3.0.36-lenovo/arch/arm: mach-rk3188




diff -r linux-3.0.36/arch/arm/Makefile linux-3.0.36-lenovo/arch/arm/Makefile
123c123
< textofs-y	:= 0x00008000
---
> textofs-y	:= 0x00408000
173a174,177
> machine-$(CONFIG_ARCH_RK29)   		:= rk29
> machine-$(CONFIG_ARCH_RK2928)		:= rk2928
> machine-$(CONFIG_ARCH_RK30)		:= rk30
> machine-$(CONFIG_ARCH_RK3188)		:= rk3188
209a214
> plat-$(CONFIG_PLAT_RK)		:= rk
291a297,326
> PHONY += kernel.img zkernel.img
> 
> ifdef CONFIG_MACH_RK29_2906
> kernel.img: Image FORCE
> 	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/Image $(obj)/kernel.img RK2906
> 	@echo '  RK2906 Image:  $@ is ready'
> else
> kernel.img: Image FORCE
> 	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/Image $(obj)/kernel.img
> 	@echo '  Image:  $@ is ready'
> endif
> 
> zkernel.img: zImage FORCE
> 	$(Q)$(srctree)/mkkrnlimg $(obj)/arch/arm/boot/zImage $(obj)/kernel.img
> 	@echo '  Image:  kernel.img is ready'
> 
> ANDROID_RAMDISK_IMG := $(shell echo $(OUT) | sed -e 's/^.*\/out\/target\/product\//out\/target\/product\//')/ramdisk.img
> ANDROID_DIR := $(shell cd $(OUT)/../../../../ && pwd)
> ANDROID_PROCESSORS := $(shell grep 'processor' /proc/cpuinfo | wc -l)
> checkandroid: FORCE
> 	$(Q)test -n "$(OUT)" || (echo "Run 'cd .. && . build/envsetup.sh && setpaths && cd -' first to build boot.img"; /bin/false)
> 	$(Q)test -n "`which mkbootimg`" || (echo "No mkbootimg, try build..." && sudo -u `whoami` $(MAKE) -j$(ANDROID_PROCESSORS) -C $(ANDROID_DIR) mkbootimg $(ANDROID_RAMDISK_IMG))
> 	$(Q)test -e $(OUT)/ramdisk.img || (echo "No $(OUT)/ramdisk.img, try build..." && sudo -u `whoami` $(MAKE) -j$(ANDROID_PROCESSORS) -C $(ANDROID_DIR) $(ANDROID_RAMDISK_IMG))
> 
> PHONY += bootimg boot.img
> bootimg boot.img: zImage checkandroid FORCE
> 	$(Q)cp -a $(obj)/arch/arm/boot/zImage $(OUT)/kernel
> 	$(Q)mkbootimg --kernel $(OUT)/kernel --ramdisk $(OUT)/ramdisk.img --output $(OUT)/boot.img
> 	@echo '  Image:  $(OUT)/boot.img is ready'
> 	$Q[ -d $(ANDROID_DIR)/rockdev/Image/ ] && cp -a $(OUT)/boot.img $(ANDROID_DIR)/rockdev/Image/ && echo '  Image:  $(ANDROID_DIR)/rockdev/Image/boot.img is ready' || /bin/true
293a329,332
>   echo  '  kernel.img    - Rockchip kernel image'
>   echo  '  zkernel.img   - Compressed Rockchip kernel image'
>   echo  '  boot.img'
>   echo  '  bootimg       - Android boot image'




diff -r linux-3.0.36/arch/arm/mm/cache-l2x0.c linux-3.0.36-lenovo/arch/arm/mm/cache-l2x0.c
31a32,41
> static u32 l2x0_cache_id;
> static unsigned int l2x0_sets;
> static unsigned int l2x0_ways;
> 
> static inline bool is_pl310_rev(int rev)
> {
> 	return (l2x0_cache_id &
> 		(L2X0_CACHE_ID_PART_MASK | L2X0_CACHE_ID_REV_MASK)) ==
> 			(L2X0_CACHE_ID_PART_L310 | rev);
> }
122a133,149
> #ifdef CONFIG_PL310_ERRATA_727915
> static void l2x0_for_each_set_way(void __iomem *reg)
> {
> 	int set;
> 	int way;
> 	unsigned long flags;
> 
> 	for (way = 0; way < l2x0_ways; way++) {
> 		spin_lock_irqsave(&l2x0_lock, flags);
> 		for (set = 0; set < l2x0_sets; set++)
> 			writel_relaxed((way << 28) | (set << 5), reg);
> 		cache_sync();
> 		spin_unlock_irqrestore(&l2x0_lock, flags);
> 	}
> }
> #endif
> 
135a163,169
> #ifdef CONFIG_PL310_ERRATA_727915
> 	if (is_pl310_rev(REV_PL310_R2P0)) {
> 		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_INV_LINE_IDX);
> 		return;
> 	}
> #endif
> 
145a180,186
> #ifdef CONFIG_PL310_ERRATA_727915
> 	if (is_pl310_rev(REV_PL310_R2P0)) {
> 		l2x0_for_each_set_way(l2x0_base + L2X0_CLEAN_LINE_IDX);
> 		return;
> 	}
> #endif
> 
147a189
> 	debug_writel(0x03);
150a193
> 	debug_writel(0x00);
283d325
< 	__u32 cache_id;
285d326
< 	int ways;
290c331
< 	cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
---
> 	l2x0_cache_id = readl_relaxed(l2x0_base + L2X0_CACHE_ID);
297c338
< 	switch (cache_id & L2X0_CACHE_ID_PART_MASK) {
---
> 	switch (l2x0_cache_id & L2X0_CACHE_ID_PART_MASK) {
300c341
< 			ways = 16;
---
> 			l2x0_ways = 16;
302c343
< 			ways = 8;
---
> 			l2x0_ways = 8;
306c347
< 		ways = (aux >> 13) & 0xf;
---
> 		l2x0_ways = (aux >> 13) & 0xf;
311c352
< 		ways = 8;
---
> 		l2x0_ways = 8;
316c357
< 	l2x0_way_mask = (1 << ways) - 1;
---
> 	l2x0_way_mask = (1 << l2x0_ways) - 1;
322,323c363,365
< 	way_size = 1 << (way_size + 3);
< 	l2x0_size = ways * way_size * SZ_1K;
---
> 	way_size = SZ_1K << (way_size + 3);
> 	l2x0_size = l2x0_ways * way_size;
> 	l2x0_sets = way_size / CACHE_LINE_SIZE;
352c394
< 			ways, cache_id, aux, l2x0_size);
---
> 			l2x0_ways, l2x0_cache_id, aux, l2x0_size);




diff -r linux-3.0.36/arch/arm/mm/cache-v6.S linux-3.0.36-lenovo/arch/arm/mm/cache-v6.S
274a275,279
> #ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
> 	sub	r2, r1, r0
> 	cmp	r2, #CONFIG_CACHE_FLUSH_RANGE_LIMIT
> 	bhi	v6_dma_flush_dcache_all
> #endif
295a301,312
> 
> #ifdef CONFIG_CACHE_FLUSH_RANGE_LIMIT
> v6_dma_flush_dcache_all:
> 	mov	r0, #0
> #ifdef HARVARD_CACHE
> 	mcr	p15, 0, r0, c7, c14, 0		@ D cache clean+invalidate
> #else
> 	mcr	p15, 0, r0, c7, c15, 0		@ Cache clean+invalidate
> #endif
> 	mcr	p15, 0, r0, c7, c10, 4		@ drain write buffer
> 	mov	pc, lr
> #endif




diff -r linux-3.0.36/arch/arm/mm/cache-v7.S linux-3.0.36-lenovo/arch/arm/mm/cache-v7.S
213a214,216
> #ifdef CONFIG_ARM_ERRATA_775420
> 	dsb
> #endif




diff -r linux-3.0.36/arch/arm/mm/context.c linux-3.0.36-lenovo/arch/arm/mm/context.c
102,103c102
< 	asm("mcr	p15, 0, %0, c13, c0, 1\n" : : "r" (mm->context.id));
< 	isb();
---
> 	cpu_switch_mm(mm->pgd, mm);




diff -r linux-3.0.36/arch/arm/mm/dma-mapping.c linux-3.0.36-lenovo/arch/arm/mm/dma-mapping.c
469a470,475
> 	unsigned long pfn;
> 	size_t left = size;
> 
> 	pfn = page_to_pfn(page) + offset / PAGE_SIZE;
> 	offset %= PAGE_SIZE;
> 
476d481
< 	size_t left = size;
480a486,487
> 		page = pfn_to_page(pfn);
> 
482,486c489
< 			if (len + offset > PAGE_SIZE) {
< 				if (offset >= PAGE_SIZE) {
< 					page += offset / PAGE_SIZE;
< 					offset %= PAGE_SIZE;
< 				}
---
> 			if (len + offset > PAGE_SIZE)
488d490
< 			}
505c507
< 		page++;
---
> 		pfn++;




diff -r linux-3.0.36/arch/arm/mm/flush.c linux-3.0.36-lenovo/arch/arm/mm/flush.c
239,240d238
< 	if (!pte_present_user(pteval))
< 		return;




diff -r linux-3.0.36/arch/arm/mm/Kconfig linux-3.0.36-lenovo/arch/arm/mm/Kconfig
818a819,832
> config MIGHT_HAVE_CACHE_L2X0
> 	bool
> 	help
> 	  This option should be selected by machines which have a L2x0
> 	  or PL310 cache controller, but where its use is optional.
> 
> 	  The only effect of this option is to make CACHE_L2X0 and
> 	  related options available to the user for configuration.
> 
> 	  Boards or SoCs which always require the cache controller
> 	  support to be present should select CACHE_L2X0 directly
> 	  instead of this option, thus preventing the user from
> 	  inadvertently configuring a broken kernel.
> 
820,825c834,835
< 	bool "Enable the L2x0 outer cache controller"
< 	depends on REALVIEW_EB_ARM11MP || MACH_REALVIEW_PB11MP || MACH_REALVIEW_PB1176 || \
< 		   REALVIEW_EB_A9MP || SOC_IMX35 || SOC_IMX31 || MACH_REALVIEW_PBX || \
< 		   ARCH_NOMADIK || ARCH_OMAP4 || ARCH_EXYNOS4 || ARCH_TEGRA || \
< 		   ARCH_U8500 || ARCH_VEXPRESS_CA9X4 || ARCH_SHMOBILE
< 	default y
---
> 	bool "Enable the L2x0 outer cache controller" if MIGHT_HAVE_CACHE_L2X0
> 	default MIGHT_HAVE_CACHE_L2X0




diff -r linux-3.0.36/arch/arm/mm/mmu.c linux-3.0.36-lenovo/arch/arm/mm/mmu.c
213a214,219
> 	},
> 	[MT_DEVICE_STRONGLY_ORDERED] = {  /* Guaranteed strongly ordered */
> 		.prot_pte       = PROT_PTE_DEVICE,
> 		.prot_l1        = PMD_TYPE_TABLE,
> 		.prot_sect      = PROT_SECT_DEVICE | PMD_SECT_UNCACHED,
> 		.domain         = DOMAIN_IO,
308a315
> #ifndef CONFIG_PLAT_RK
310a318
> #endif
355a364
> 			mem_types[MT_DEVICE_STRONGLY_ORDERED].prot_sect |= PMD_SECT_XN;
470c479
< 		unsigned long v = pgprot_val(protection_map[i]);
---
> 		pteval_t v = pgprot_val(protection_map[i]);
729a739,741
> #if defined(CONFIG_RK29_MEM_SIZE_M) && CONFIG_RK29_MEM_SIZE_M >= 1024
> static void * __initdata vmalloc_min = (void *)(VMALLOC_END - SZ_512M);
> #else
730a743
> #endif




diff -r linux-3.0.36/arch/arm/mm/proc-v7.S linux-3.0.36-lenovo/arch/arm/mm/proc-v7.S
357a358,362
> #ifdef CONFIG_ARM_ERRATA_761320
> 	mrc	p15, 0, r10, c15, c0, 1		@ read diagnostic register
> 	orr	r10, r10, #1 << 21		@ set bit #21
> 	mcr	p15, 0, r10, c15, c0, 1		@ write diagnostic register
> #endif
369a375,384
> #ifdef CONFIG_ARCH_RK29
> 	/* Setup L2 cache */
> 	mrc	p15, 1, r5, c9, c0, 2
> 	bic	r5, r5, #1 << 29		@ L2 data RAM read multiplexer select: 0 = two cycles
> 	bic	r5, r5, #7 << 6
> 	bic	r5, r5, #15
> 	orr	r5, r5, #2 << 6			@ Tag RAM latency: b010 = 3 cycles
> 	orr	r5, r5, #3			@ Data RAM latency: b0011 = 4 cycles
> 	mcr	p15, 1, r5, c9, c0, 2
> #endif




diff -r linux-3.0.36/arch/arm/mm/tlb-v7.S linux-3.0.36-lenovo/arch/arm/mm/tlb-v7.S
41a42,45
> #ifdef CONFIG_ARM_ERRATA_720789
> 	ALT_SMP(W(mov)	r3, #0	)
> 	ALT_UP(W(nop)		)
> #endif
44a49,51
> #ifdef CONFIG_ARM_ERRATA_720789
> 	ALT_SMP(mcr	p15, 0, r0, c8, c3, 3)	@ TLB invalidate U MVA all ASID (shareable)
> #else
45a53
> #endif
72a81,83
> #ifdef CONFIG_ARM_ERRATA_720789
> 	ALT_SMP(mcr	p15, 0, r0, c8, c3, 3)	@ TLB invalidate U MVA all ASID (shareable)
> #else
73a85
> #endif
Only in linux-3.0.36-lenovo/arch/arm: plat-rk




diff -r linux-3.0.36/arch/arm/plat-s3c24xx/dma.c linux-3.0.36-lenovo/arch/arm/plat-s3c24xx/dma.c
434c434
< int s3c2410_dma_enqueue(unsigned int channel, void *id,
---
> int s3c2410_dma_enqueue(enum dma_ch channel, void *id,




diff -r linux-3.0.36/arch/arm/plat-samsung/adc.c linux-3.0.36-lenovo/arch/arm/plat-samsung/adc.c
146,148d145
< 	if (client->is_ts && adc->ts_pend)
< 		return -EAGAIN;
< 
149a147,151
> 
> 	if (client->is_ts && adc->ts_pend) {
> 		spin_unlock_irqrestore(&adc->lock, flags);
> 		return -EAGAIN;
> 	}




diff -r linux-3.0.36/arch/arm/tools/mach-types linux-3.0.36-lenovo/arch/arm/tools/mach-types
571,572c571,575
< wm8505_7in_netbook	MACH_WM8505_7IN_NETBOOK	WM8505_7IN_NETBOOK	2928
< ec4350sdb		MACH_EC4350SDB		EC4350SDB		2929
---
> #wm8505_7in_netbook	MACH_WM8505_7IN_NETBOOK	WM8505_7IN_NETBOOK	2928
> rk29			MACH_RK29		RK29			2929
> rk2928			ARCH_RK2928		RK2928			2928
> rk30			ARCH_RK30		RK30			3066
> #ec4350sdb		MACH_EC4350SDB		EC4350SDB		2929




diff -r linux-3.0.36/arch/arm/vfp/entry.S linux-3.0.36-lenovo/arch/arm/vfp/entry.S
13c13
<  *  r5  = faulted PC+4
---
>  *  r2  = faulted PC+4
28a29
> 	str	r2, [sp, #S_PC]		@ update regs->ARM_pc for Thumb 2 case




diff -r linux-3.0.36/arch/arm/vfp/vfphw.S linux-3.0.36-lenovo/arch/arm/vfp/vfphw.S
80c80
< 	ldr	r3, last_VFP_context_address
---
> 	ldr	r3, vfp_current_hw_state_address
82c82
< 	ldr	r4, [r3, r11, lsl #2]	@ last_VFP_context pointer
---
> 	ldr	r4, [r3, r11, lsl #2]	@ vfp_current_hw_state pointer
84,88c84,85
< 	cmp	r4, r10
< 	beq	check_for_exception	@ we are returning to the same
< 					@ process, so the registers are
< 					@ still there.  In this case, we do
< 					@ not want to drop a pending exception.
---
> 	cmp	r4, r10			@ this thread owns the hw context?
> 	beq	vfp_hw_state_valid
119c116
< 	str	r10, [r3, r11, lsl #2]	@ update the last_VFP_context pointer
---
> 	str	r10, [r3, r11, lsl #2]	@ update the vfp_current_hw_state pointer
135c132,133
< check_for_exception:
---
> @ The context stored in the VFP hardware is up to date with this thread
> vfp_hw_state_valid:
208a207,225
> #ifdef CONFIG_ARCH_RK29
> ENTRY(vfp_load_state)
> 	@ Save the current VFP state
> 	@ r0 - save location
> 	@ r1 - FPEXC
> 	DBGSTR1	"save VFP state %p", r0
> 	VFPFLDMIA r0, r2		@ save the working registers
> 	ldmia   r0, {r1,r2,r3,r12}
> 	tst	r1, #FPEXC_EX		@ is there additional state to save?
> 	beq	1f
> 	tst	r1, #FPEXC_FP2V		@ is there an FPINST2 to read?
> 	beq	1f
> 1:
> 	VFPFMXR FPSCR, r2
> 	VFPFMXR	FPEXC, r1
> 	mov	pc, lr
> ENDPROC(vfp_load_state)
> #endif
> 
210,211c227,228
< last_VFP_context_address:
< 	.word	last_VFP_context
---
> vfp_current_hw_state_address:
> 	.word	vfp_current_hw_state




diff -r linux-3.0.36/arch/arm/vfp/vfpmodule.c linux-3.0.36-lenovo/arch/arm/vfp/vfpmodule.c
13a14,15
> #include <linux/cpu_pm.h>
> #include <linux/hardirq.h>
36c38,44
< union vfp_state *last_VFP_context[NR_CPUS];
---
> 
> /*
>  * The pointer to the vfpstate structure of the thread which currently
>  * owns the context held in the VFP hardware, or NULL if the hardware
>  * context is invalid.
>  */
> union vfp_state *vfp_current_hw_state[NR_CPUS];
60c68
< 	 * that the modification of last_VFP_context[] and hardware disable
---
> 	 * that the modification of vfp_current_hw_state[] and hardware disable
64,65c72,73
< 	if (last_VFP_context[cpu] == vfp)
< 		last_VFP_context[cpu] = NULL;
---
> 	if (vfp_current_hw_state[cpu] == vfp)
> 		vfp_current_hw_state[cpu] = NULL;
76,77c84,85
< 	if (last_VFP_context[cpu] == vfp)
< 		last_VFP_context[cpu] = NULL;
---
> 	if (vfp_current_hw_state[cpu] == vfp)
> 		vfp_current_hw_state[cpu] = NULL;
132,134c140,142
< 		if ((fpexc & FPEXC_EN) && last_VFP_context[cpu]) {
< 			vfp_save_state(last_VFP_context[cpu], fpexc);
< 			last_VFP_context[cpu]->hard.cpu = cpu;
---
> 		if ((fpexc & FPEXC_EN) && vfp_current_hw_state[cpu]) {
> 			vfp_save_state(vfp_current_hw_state[cpu], fpexc);
> 			vfp_current_hw_state[cpu]->hard.cpu = cpu;
142c150
< 			last_VFP_context[cpu] = NULL;
---
> 			vfp_current_hw_state[cpu] = NULL;
392c400,403
< 	u32 access = get_copro_access();
---
> 	u32 access;
> 
> 	BUG_ON(preemptible());
> 	access = get_copro_access();
400,402c411
< #ifdef CONFIG_PM
< #include <linux/syscore_ops.h>
< 
---
> #ifdef CONFIG_CPU_PM
414a424,429
> 	} else if (vfp_current_hw_state[ti->cpu]) {
> #ifndef CONFIG_SMP
> 		fmxr(FPEXC, fpexc | FPEXC_EN);
> 		vfp_save_state(vfp_current_hw_state[ti->cpu], fpexc);
> 		fmxr(FPEXC, fpexc);
> #endif
418c433
< 	memset(last_VFP_context, 0, sizeof(last_VFP_context));
---
> 	vfp_current_hw_state[ti->cpu] = NULL;
432,434c447,463
< static struct syscore_ops vfp_pm_syscore_ops = {
< 	.suspend	= vfp_pm_suspend,
< 	.resume		= vfp_pm_resume,
---
> static int vfp_cpu_pm_notifier(struct notifier_block *self, unsigned long cmd,
> 	void *v)
> {
> 	switch (cmd) {
> 	case CPU_PM_ENTER:
> 		vfp_pm_suspend();
> 		break;
> 	case CPU_PM_ENTER_FAILED:
> 	case CPU_PM_EXIT:
> 		vfp_pm_resume();
> 		break;
> 	}
> 	return NOTIFY_OK;
> }
> 
> static struct notifier_block vfp_cpu_pm_notifier_block = {
> 	.notifier_call = vfp_cpu_pm_notifier,
439c468
< 	register_syscore_ops(&vfp_pm_syscore_ops);
---
> 	cpu_pm_register_notifier(&vfp_cpu_pm_notifier_block);
444c473
< #endif /* CONFIG_PM */
---
> #endif /* CONFIG_CPU_PM */
454c483
< 	if (last_VFP_context[cpu] == &thread->vfpstate) {
---
> 	if (vfp_current_hw_state[cpu] == &thread->vfpstate) {
476c505
< 	if (last_VFP_context[cpu] == &thread->vfpstate) {
---
> 	if (vfp_current_hw_state[cpu] == &thread->vfpstate) {
485c514
< 		last_VFP_context[cpu] = NULL;
---
> 		vfp_current_hw_state[cpu] = NULL;
517c546
< 		last_VFP_context[cpu] = NULL;
---
> 		vfp_current_hw_state[cpu] = NULL;
532c561
< 		vfp_enable(NULL);
---
> 		on_each_cpu(vfp_enable, NULL, 1);
553,554d581
< 		smp_call_function(vfp_enable, NULL, 1);
< 
578,579c605,607
< 			 * Check for VFPv3 D16. CPUs in this configuration
< 			 * only have 16 x 64bit registers.
---
> 			 * Check for VFPv3 D16 and VFPv4 D16.  CPUs in
> 			 * this configuration only have 16 x 64bit
> 			 * registers.
582c610,612
< 				elf_hwcap |= HWCAP_VFPv3D16;
---
> 				elf_hwcap |= HWCAP_VFPv3D16; /* also v4-D16 */
> 			else
> 				elf_hwcap |= HWCAP_VFPD32;




diff -r linux-3.0.36/arch/cris/include/asm/io.h linux-3.0.36-lenovo/arch/cris/include/asm/io.h
136,141c136,168
< #define outb(data,port) if (cris_iops) cris_iops->write_io(port,(void*)(unsigned)data,1,1)
< #define outw(data,port) if (cris_iops) cris_iops->write_io(port,(void*)(unsigned)data,2,1)
< #define outl(data,port) if (cris_iops) cris_iops->write_io(port,(void*)(unsigned)data,4,1)
< #define outsb(port,addr,count) if(cris_iops) cris_iops->write_io(port,(void*)addr,1,count)
< #define outsw(port,addr,count) if(cris_iops) cris_iops->write_io(port,(void*)addr,2,count)
< #define outsl(port,addr,count) if(cris_iops) cris_iops->write_io(port,(void*)addr,3,count)
---
> static inline void outb(unsigned char data, unsigned int port)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *) &data, 1, 1);
> }
> static inline void outw(unsigned short data, unsigned int port)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *) &data, 2, 1);
> }
> static inline void outl(unsigned int data, unsigned int port)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *) &data, 4, 1);
> }
> static inline void outsb(unsigned int port, const void *addr,
> 			 unsigned long count)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *)addr, 1, count);
> }
> static inline void outsw(unsigned int port, const void *addr,
> 			 unsigned long count)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *)addr, 2, count);
> }
> static inline void outsl(unsigned int port, const void *addr,
> 			 unsigned long count)
> {
> 	if (cris_iops)
> 		cris_iops->write_io(port, (void *)addr, 4, count);
> }
Only in linux-3.0.36/arch: .gitignore




diff -r linux-3.0.36/arch/ia64/include/asm/atomic.h linux-3.0.36-lenovo/arch/ia64/include/asm/atomic.h
21,22c21,22
< #define ATOMIC_INIT(i)		((atomic_t) { (i) })
< #define ATOMIC64_INIT(i)	((atomic64_t) { (i) })
---
> #define ATOMIC_INIT(i)		{ (i) }
> #define ATOMIC64_INIT(i)	{ (i) }




diff -r linux-3.0.36/arch/ia64/kernel/irq_ia64.c linux-3.0.36-lenovo/arch/ia64/kernel/irq_ia64.c
26d25
< #include <linux/random.h>	/* for rand_initialize_irq() */




diff -r linux-3.0.36/arch/m68k/include/asm/entry_mm.h linux-3.0.36-lenovo/arch/m68k/include/asm/entry_mm.h
38,39c38,39
< 	/* block out HSYNC on the atari */
< #define ALLOWINT	(~0x400)
---
> 	/* block out HSYNC = ipl 2 on the atari */
> #define ALLOWINT	(~0x500)




diff -r linux-3.0.36/arch/m68k/include/asm/signal.h linux-3.0.36-lenovo/arch/m68k/include/asm/signal.h
159c159
< 		: "+od" (*set)
---
> 		: "+o" (*set)
167c167
< 		: "+od" (*set)
---
> 		: "+o" (*set)
183c183
< 		: "od" (*set), "id" ((_sig-1) ^ 31)
---
> 		: "o" (*set), "id" ((_sig-1) ^ 31)




diff -r linux-3.0.36/arch/m68k/kernel/sys_m68k.c linux-3.0.36-lenovo/arch/m68k/kernel/sys_m68k.c
482c482,486
< 		mem_value = *mem;
---
> 		/*
> 		 * No need to check for EFAULT; we know that the page is
> 		 * present and writable.
> 		 */
> 		__get_user(mem_value, mem);
484c488
< 			*mem = newval;
---
> 			__put_user(newval, mem);




diff -r linux-3.0.36/arch/mips/include/asm/thread_info.h linux-3.0.36-lenovo/arch/mips/include/asm/thread_info.h
62a63,64
> #endif /* !__ASSEMBLY__ */
> 
99,100d100
< 
< #endif /* !__ASSEMBLY__ */




diff -r linux-3.0.36/arch/mips/kernel/kgdb.c linux-3.0.36-lenovo/arch/mips/kernel/kgdb.c
285a286,294
> #ifdef CONFIG_KPROBES
> 	/*
> 	 * Return immediately if the kprobes fault notifier has set
> 	 * DIE_PAGE_FAULT.
> 	 */
> 	if (cmd == DIE_PAGE_FAULT)
> 		return NOTIFY_DONE;
> #endif /* CONFIG_KPROBES */
> 




diff -r linux-3.0.36/arch/mips/kernel/Makefile linux-3.0.36-lenovo/arch/mips/kernel/Makefile
103c103
< CFLAGS_cpu-bugs64.o	= $(shell if $(CC) $(KBUILD_CFLAGS) -Wa,-mdaddi -c -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-DHAVE_AS_SET_DADDI"; fi)
---
> CFLAGS_cpu-bugs64.o	= $(shell if $(CC) $(KBUILD_CFLAGS) -Wa,-mdaddi -c -o /dev/null -x c /dev/null >/dev/null 2>&1; then echo "-DHAVE_AS_SET_DADDI"; fi)




diff -r linux-3.0.36/arch/mips/kernel/vmlinux.lds.S linux-3.0.36-lenovo/arch/mips/kernel/vmlinux.lds.S
2a3
> #include <asm/thread_info.h>
76c77
< 		INIT_TASK_DATA(PAGE_SIZE)
---
> 		INIT_TASK_DATA(THREAD_SIZE)




diff -r linux-3.0.36/arch/mips/Makefile linux-3.0.36-lenovo/arch/mips/Makefile
239c239
< CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -xc /dev/null | \
---
> CHECKFLAGS += $(shell $(CC) $(KBUILD_CFLAGS) -dM -E -x c /dev/null | \




diff -r linux-3.0.36/arch/mn10300/Makefile linux-3.0.36-lenovo/arch/mn10300/Makefile
29c29
< KBUILD_CFLAGS	+= -mam33 -mmem-funcs -DCPU=AM33
---
> KBUILD_CFLAGS	+= -mam33 -DCPU=AM33 $(call cc-option,-mmem-funcs,)




diff -r linux-3.0.36/arch/parisc/include/asm/atomic.h linux-3.0.36-lenovo/arch/parisc/include/asm/atomic.h
251c251
< #define ATOMIC_INIT(i)	((atomic_t) { (i) })
---
> #define ATOMIC_INIT(i)	{ (i) }
260c260
< #define ATOMIC64_INIT(i) ((atomic64_t) { (i) })
---
> #define ATOMIC64_INIT(i) { (i) }




diff -r linux-3.0.36/arch/parisc/kernel/signal32.c linux-3.0.36-lenovo/arch/parisc/kernel/signal32.c
70c70,71
< 	if (sz != sizeof *set) panic("put_sigset32()");
---
> 	if (sz != sizeof *set)
> 		return -EINVAL;
82c83,84
< 	if (sz != sizeof *set) panic("put_sigset32()");
---
> 	if (sz != sizeof *set)
> 		return -EINVAL;




diff -r linux-3.0.36/arch/parisc/kernel/sys_parisc.c linux-3.0.36-lenovo/arch/parisc/kernel/sys_parisc.c
75a76,77
> 	offset = (offset + (pgoff << PAGE_SHIFT)) & 0x3FF000;
> 




diff -r linux-3.0.36/arch/powerpc/include/asm/cputime.h linux-3.0.36-lenovo/arch/powerpc/include/asm/cputime.h
129c129
< extern u64 __cputime_msec_factor;
---
> extern u64 __cputime_usec_factor;
133c133
< 	return mulhdu(ct, __cputime_msec_factor) * USEC_PER_MSEC;
---
> 	return mulhdu(ct, __cputime_usec_factor);
146c146
< 		do_div(ct, 1000);
---
> 		do_div(ct, 1000000);




diff -r linux-3.0.36/arch/powerpc/include/asm/reg.h linux-3.0.36-lenovo/arch/powerpc/include/asm/reg.h
1003c1003,1004
< 			asm volatile("mfmsr %0" : "=r" (rval)); rval;})
---
> 			asm volatile("mfmsr %0" : "=r" (rval) : \
> 						: "memory"); rval;})




diff -r linux-3.0.36/arch/powerpc/kernel/asm-offsets.c linux-3.0.36-lenovo/arch/powerpc/kernel/asm-offsets.c
77a78
> 	DEFINE(THREAD_DSCR_INHERIT, offsetof(struct thread_struct, dscr_inherit));




diff -r linux-3.0.36/arch/powerpc/kernel/entry_64.S linux-3.0.36-lenovo/arch/powerpc/kernel/entry_64.S
382a383,388
> 	.section	".toc","aw"
> DSCR_DEFAULT:
> 	.tc dscr_default[TC],dscr_default
> 
> 	.section	".text"
> 
522,524d527
< 	ld	r6,_CCR(r1)
< 	mtcrf	0xFF,r6
< 
532a536,537
> 	lwz	r6,THREAD_DSCR_INHERIT(r4)
> 	ld	r7,DSCR_DEFAULT@toc(2)
534,535c539,543
< 	cmpd	r0,r25
< 	beq	1f
---
> 	cmpwi	r6,0
> 	bne	1f
> 	ld	r0,0(r7)
> 1:	cmpd	r0,r25
> 	beq	2f
537c545
< 1:	
---
> 2:
539a548,550
> 
> 	ld	r6,_CCR(r1)
> 	mtcrf	0xFF,r6




diff -r linux-3.0.36/arch/powerpc/kernel/ftrace.c linux-3.0.36-lenovo/arch/powerpc/kernel/ftrace.c
248,250c248,250
< 	 *  0x3d, 0x60, 0x00, 0x00  lis r11,sym@ha
< 	 *  0x39, 0x6b, 0x00, 0x00  addi r11,r11,sym@l
< 	 *  0x7d, 0x69, 0x03, 0xa6  mtctr r11
---
> 	 *  0x3d, 0x80, 0x00, 0x00  lis r12,sym@ha
> 	 *  0x39, 0x8c, 0x00, 0x00  addi r12,r12,sym@l
> 	 *  0x7d, 0x89, 0x03, 0xa6  mtctr r12
265,267c265,267
< 	if (((jmp[0] & 0xffff0000) != 0x3d600000) ||
< 	    ((jmp[1] & 0xffff0000) != 0x396b0000) ||
< 	    (jmp[2] != 0x7d6903a6) ||
---
> 	if (((jmp[0] & 0xffff0000) != 0x3d800000) ||
> 	    ((jmp[1] & 0xffff0000) != 0x398c0000) ||
> 	    (jmp[2] != 0x7d8903a6) ||




diff -r linux-3.0.36/arch/powerpc/kernel/head_64.S linux-3.0.36-lenovo/arch/powerpc/kernel/head_64.S
428c428
< #ifdef CONFIG_CRASH_DUMP
---
> #ifdef CONFIG_RELOCATABLE




diff -r linux-3.0.36/arch/powerpc/kernel/process.c linux-3.0.36-lenovo/arch/powerpc/kernel/process.c
797,806c797,798
< 		if (current->thread.dscr_inherit) {
< 			p->thread.dscr_inherit = 1;
< 			p->thread.dscr = current->thread.dscr;
< 		} else if (0 != dscr_default) {
< 			p->thread.dscr_inherit = 1;
< 			p->thread.dscr = dscr_default;
< 		} else {
< 			p->thread.dscr_inherit = 0;
< 			p->thread.dscr = 0;
< 		}
---
> 		p->thread.dscr_inherit = current->thread.dscr_inherit;
> 		p->thread.dscr = current->thread.dscr;




diff -r linux-3.0.36/arch/powerpc/kernel/ptrace.c linux-3.0.36-lenovo/arch/powerpc/kernel/ptrace.c
1499a1500,1501
> 			unsigned int fpidx = index - PT_FPR0;
> 
1501,1502c1503,1507
< 			tmp = ((unsigned long *)child->thread.fpr)
< 				[TS_FPRWIDTH * (index - PT_FPR0)];
---
> 			if (fpidx < (PT_FPSCR - PT_FPR0))
> 				tmp = ((unsigned long *)child->thread.fpr)
> 					[fpidx * TS_FPRWIDTH];
> 			else
> 				tmp = child->thread.fpscr.val;
1527a1533,1534
> 			unsigned int fpidx = index - PT_FPR0;
> 
1529,1530c1536,1540
< 			((unsigned long *)child->thread.fpr)
< 				[TS_FPRWIDTH * (index - PT_FPR0)] = data;
---
> 			if (fpidx < (PT_FPSCR - PT_FPR0))
> 				((unsigned long *)child->thread.fpr)
> 					[fpidx * TS_FPRWIDTH] = data;
> 			else
> 				child->thread.fpscr.val = data;




diff -r linux-3.0.36/arch/powerpc/kernel/sysfs.c linux-3.0.36-lenovo/arch/powerpc/kernel/sysfs.c
194a195,202
> static void update_dscr(void *dummy)
> {
> 	if (!current->thread.dscr_inherit) {
> 		current->thread.dscr = dscr_default;
> 		mtspr(SPRN_DSCR, dscr_default);
> 	}
> }
> 
205a214,215
> 
> 	on_each_cpu(update_dscr, NULL, 1);




diff -r linux-3.0.36/arch/powerpc/kernel/time.c linux-3.0.36-lenovo/arch/powerpc/kernel/time.c
171c171
<  * jiffies, milliseconds, seconds, and clock_t (1/USER_HZ seconds).
---
>  * jiffies, microseconds, seconds, and clock_t (1/USER_HZ seconds).
176,177c176,177
< u64 __cputime_msec_factor;
< EXPORT_SYMBOL(__cputime_msec_factor);
---
> u64 __cputime_usec_factor;
> EXPORT_SYMBOL(__cputime_usec_factor);
195,196c195,196
< 	div128_by_32(1000, 0, tb_ticks_per_sec, &res);
< 	__cputime_msec_factor = res.result_low;
---
> 	div128_by_32(1000000, 0, tb_ticks_per_sec, &res);
> 	__cputime_usec_factor = res.result_low;
862,864d861
< 	/* Make userspace gettimeofday spin until we're done. */
< 	++vdso_data->tb_update_count;
< 	smp_mb();
867,868d863
< 	smp_mb();
< 	++vdso_data->tb_update_count;




diff -r linux-3.0.36/arch/powerpc/kernel/traps.c linux-3.0.36-lenovo/arch/powerpc/kernel/traps.c
938c938
< 		mtspr(SPRN_DSCR, regs->gpr[rd]);
---
> 		current->thread.dscr = regs->gpr[rd];
939a940
> 		mtspr(SPRN_DSCR, current->thread.dscr);




diff -r linux-3.0.36/arch/powerpc/kvm/44x_emulate.c linux-3.0.36-lenovo/arch/powerpc/kvm/44x_emulate.c
81a82
> 				vcpu->arch.dcr_is_write = 0;
102a104
> 				vcpu->arch.dcr_is_write = 1;




diff -r linux-3.0.36/arch/powerpc/platforms/embedded6xx/wii.c linux-3.0.36-lenovo/arch/powerpc/platforms/embedded6xx/wii.c
88c88,89
< 	pr_info("MEM1: <%08llx %08llx>\n", p[0].base, p[0].size);
---
> 	pr_info("MEM1: <%08llx %08llx>\n",
> 		(unsigned long long) p[0].base, (unsigned long long) p[0].size);
90c91,92
< 	pr_info("MEM2: <%08llx %08llx>\n", p[1].base, p[1].size);
---
> 	pr_info("MEM2: <%08llx %08llx>\n",
> 		(unsigned long long) p[1].base, (unsigned long long) p[1].size);




diff -r linux-3.0.36/arch/powerpc/xmon/xmon.c linux-3.0.36-lenovo/arch/powerpc/xmon/xmon.c
978c978
< 		for (cpu = 0; cpu < NR_CPUS; ++cpu) {
---
> 		for_each_possible_cpu(cpu) {




diff -r linux-3.0.36/arch/s390/include/asm/timex.h linux-3.0.36-lenovo/arch/s390/include/asm/timex.h
128a129,156
> /**
>  * tod_to_ns - convert a TOD format value to nanoseconds
>  * @todval: to be converted TOD format value
>  * Returns: number of nanoseconds that correspond to the TOD format value
>  *
>  * Converting a 64 Bit TOD format value to nanoseconds means that the value
>  * must be divided by 4.096. In order to achieve that we multiply with 125
>  * and divide by 512:
>  *
>  *    ns = (todval * 125) >> 9;
>  *
>  * In order to avoid an overflow with the multiplication we can rewrite this.
>  * With a split todval == 2^32 * th + tl (th upper 32 bits, tl lower 32 bits)
>  * we end up with
>  *
>  *    ns = ((2^32 * th + tl) * 125 ) >> 9;
>  * -> ns = (2^23 * th * 125) + ((tl * 125) >> 9);
>  *
>  */
> static inline unsigned long long tod_to_ns(unsigned long long todval)
> {
> 	unsigned long long ns;
> 
> 	ns = ((todval >> 32) << 23) * 125;
> 	ns += ((todval & 0xffffffff) * 125) >> 9;
> 	return ns;
> }
> 




diff -r linux-3.0.36/arch/s390/kernel/compat_linux.c linux-3.0.36-lenovo/arch/s390/kernel/compat_linux.c
634d633
< 	a.addr = (unsigned long) compat_ptr(a.addr);
645d643
< 	a.addr = (unsigned long) compat_ptr(a.addr);




diff -r linux-3.0.36/arch/s390/kernel/time.c linux-3.0.36-lenovo/arch/s390/kernel/time.c
66c66
< 	return (get_clock_monotonic() * 125) >> 9;
---
> 	return tod_to_ns(get_clock_monotonic());




diff -r linux-3.0.36/arch/s390/kvm/interrupt.c linux-3.0.36-lenovo/arch/s390/kvm/interrupt.c
361c361
< 	sltime = ((vcpu->arch.sie_block->ckc - now)*125)>>9;
---
> 	sltime = tod_to_ns(vcpu->arch.sie_block->ckc - now);




diff -r linux-3.0.36/arch/s390/mm/gup.c linux-3.0.36-lenovo/arch/s390/mm/gup.c
186c186
< 	if (end < start)
---
> 	if ((end < start) || (end > TASK_SIZE))
Only in linux-3.0.36/arch/sh/boot/compressed: vmlinux.scr
Only in linux-3.0.36/arch/sh/boot/romimage: vmlinux.scr




diff -r linux-3.0.36/arch/sh/include/asm/elf.h linux-3.0.36-lenovo/arch/sh/include/asm/elf.h
205c205
< 		NEW_AUX_ENT(AT_IGNORE, 0);
---
> 		NEW_AUX_ENT(AT_IGNORE, 0)
207c207
< #define VSYSCALL_AUX_ENT
---
> #define VSYSCALL_AUX_ENT	NEW_AUX_ENT(AT_IGNORE, 0)




diff -r linux-3.0.36/arch/sparc/include/asm/hugetlb.h linux-3.0.36-lenovo/arch/sparc/include/asm/hugetlb.h
61c61,62
< 	ptep_set_wrprotect(mm, addr, ptep);
---
> 	pte_t old_pte = *ptep;
> 	set_huge_pte_at(mm, addr, ptep, pte_wrprotect(old_pte));
68c69,74
< 	return ptep_set_access_flags(vma, addr, ptep, pte, dirty);
---
> 	int changed = !pte_same(*ptep, pte);
> 	if (changed) {
> 		set_huge_pte_at(vma->vm_mm, addr, ptep, pte);
> 		flush_tlb_page(vma, addr);
> 	}
> 	return changed;




diff -r linux-3.0.36/arch/sparc/kernel/perf_event.c linux-3.0.36-lenovo/arch/sparc/kernel/perf_event.c
516c516,518
< 	u64 val, mask = mask_for_index(idx);
---
> 	u64 enc, val, mask = mask_for_index(idx);
> 
> 	enc = perf_event_get_enc(cpuc->events[idx]);
520c522
< 	val |= hwc->config;
---
> 	val |= event_encoding(enc, idx);
1383,1384d1384
< 	perf_callchain_store(entry, regs->tpc);
< 
1405,1406d1404
< 	perf_callchain_store(entry, regs->tpc);
< 
1424a1423,1427
> 	perf_callchain_store(entry, regs->tpc);
> 
> 	if (!current->mm)
> 		return;
> 




diff -r linux-3.0.36/arch/sparc/kernel/signal_64.c linux-3.0.36-lenovo/arch/sparc/kernel/signal_64.c
312,314c312
< 	err |= do_sigaltstack(&sf->stack, NULL, (unsigned long)sf);
< 
< 	if (err)
---
> 	if (err || do_sigaltstack(&sf->stack, NULL, (unsigned long)sf) == -EFAULT)




diff -r linux-3.0.36/arch/sparc/kernel/syscalls.S linux-3.0.36-lenovo/arch/sparc/kernel/syscalls.S
215d214
< 	ldx	[%sp + PTREGS_OFF + PT_V9_TNPC], %l1 ! pc = npc
220,226d218
< 	/* Check if force_successful_syscall_return()
< 	 * was invoked.
< 	 */
< 	ldub	[%g6 + TI_SYS_NOERROR], %l2
< 	brnz,a,pn %l2, 80f
< 	 stb	%g0, [%g6 + TI_SYS_NOERROR]
< 
229,230c221,225
< 	 andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT|_TIF_SYSCALL_TRACEPOINT), %l6
< 80:
---
> 	 andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT|_TIF_SYSCALL_TRACEPOINT), %g0
> 	ldx	[%sp + PTREGS_OFF + PT_V9_TNPC], %l1 ! pc = npc
> 
> 2:
> 	stb	%g0, [%g6 + TI_SYS_NOERROR]
232a228
> 3:
240a237,242
> 	/* Check if force_successful_syscall_return()
> 	 * was invoked.
> 	 */
> 	ldub	[%g6 + TI_SYS_NOERROR], %l2
> 	brnz,pn %l2, 2b
> 	 ldx	[%sp + PTREGS_OFF + PT_V9_TNPC], %l1 ! pc = npc
244d245
< 	andcc	%l0, (_TIF_SYSCALL_TRACE|_TIF_SECCOMP|_TIF_SYSCALL_AUDIT|_TIF_SYSCALL_TRACEPOINT), %l6	
246d246
< 	or	%g3, %g2, %g3
248,251c248,249
< 	stx	%g3, [%sp + PTREGS_OFF + PT_V9_TSTATE]
< 	bne,pn	%icc, linux_syscall_trace2
< 	 add	%l1, 0x4, %l2			! npc = npc+4
< 	stx	%l1, [%sp + PTREGS_OFF + PT_V9_TPC]
---
> 	ba,pt	%xcc, 3b
> 	 or	%g3, %g2, %g3
253,254d250
< 	b,pt	%xcc, rtrap
< 	 stx	%l2, [%sp + PTREGS_OFF + PT_V9_TNPC]




diff -r linux-3.0.36/arch/sparc/kernel/sys_sparc_64.c linux-3.0.36-lenovo/arch/sparc/kernel/sys_sparc_64.c
522,524c522,524
< 	if (current->personality == PER_LINUX32 &&
< 	    personality == PER_LINUX)
< 		personality = PER_LINUX32;
---
> 	if (personality(current->personality) == PER_LINUX32 &&
> 	    personality(personality) == PER_LINUX)
> 		personality |= PER_LINUX32;
526,527c526,527
< 	if (ret == PER_LINUX32)
< 		ret = PER_LINUX;
---
> 	if (personality(ret) == PER_LINUX32)
> 		ret &= ~PER_LINUX32;




diff -r linux-3.0.36/arch/sparc/mm/init_64.c linux-3.0.36-lenovo/arch/sparc/mm/init_64.c
2120a2121,2123
> static long __meminitdata addr_start, addr_end;
> static int __meminitdata node_start;
> 
2151,2155c2154,2162
< 			printk(KERN_INFO "[%p-%p] page_structs=%lu "
< 			       "node=%d entry=%lu/%lu\n", start, block, nr,
< 			       node,
< 			       addr >> VMEMMAP_CHUNK_SHIFT,
< 			       VMEMMAP_SIZE);
---
> 			/* check to see if we have contiguous blocks */
> 			if (addr_end != addr || node_start != node) {
> 				if (addr_start)
> 					printk(KERN_DEBUG " [%lx-%lx] on node %d\n",
> 					       addr_start, addr_end-1, node_start);
> 				addr_start = addr;
> 				node_start = node;
> 			}
> 			addr_end = addr + VMEMMAP_CHUNK;
2158a2166,2176
> }
> 
> void __meminit vmemmap_populate_print_last(void)
> {
> 	if (addr_start) {
> 		printk(KERN_DEBUG " [%lx-%lx] on node %d\n",
> 		       addr_start, addr_end-1, node_start);
> 		addr_start = 0;
> 		addr_end = 0;
> 		node_start = 0;
> 	}




diff -r linux-3.0.36/arch/tile/Makefile linux-3.0.36-lenovo/arch/tile/Makefile
28a29,32
> # The tile compiler may emit .eh_frame information for backtracing.
> # In kernel modules, this causes load failures due to unsupported relocations.
> KBUILD_CFLAGS   += -fno-asynchronous-unwind-tables
> 




diff -r linux-3.0.36/arch/x86/ia32/ia32entry.S linux-3.0.36-lenovo/arch/x86/ia32/ia32entry.S
211c211
< 	sti
---
> 	ENABLE_INTERRUPTS(CLBR_NONE)
221c221
< 	cli
---
> 	DISABLE_INTERRUPTS(CLBR_NONE)
Only in linux-3.0.36-lenovo/arch/x86/include/asm: archrandom.h




diff -r linux-3.0.36/arch/x86/include/asm/cpufeature.h linux-3.0.36-lenovo/arch/x86/include/asm/cpufeature.h
176c176
< #define X86_FEATURE_DTS		(7*32+ 7) /* Digital Thermal Sensor */
---
> #define X86_FEATURE_DTHERM	(7*32+ 7) /* Digital Thermal Sensor */




diff -r linux-3.0.36/arch/x86/include/asm/idle.h linux-3.0.36-lenovo/arch/x86/include/asm/idle.h
4,10d3
< #define IDLE_START 1
< #define IDLE_END 2
< 
< struct notifier_block;
< void idle_notifier_register(struct notifier_block *n);
< void idle_notifier_unregister(struct notifier_block *n);
< 




diff -r linux-3.0.36/arch/x86/include/asm/pgtable.h linux-3.0.36-lenovo/arch/x86/include/asm/pgtable.h
144a145,149
> static inline unsigned long pud_pfn(pud_t pud)
> {
> 	return (pud_val(pud) & PTE_PFN_MASK) >> PAGE_SHIFT;
> }
> 
149,150c154
< 	return (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==
< 		(_PAGE_PSE | _PAGE_PRESENT);
---
> 	return pmd_flags(pte) & _PAGE_PSE;
418c422,428
< 	return pmd_flags(pmd) & _PAGE_PRESENT;
---
> 	/*
> 	 * Checking for _PAGE_PSE is needed too because
> 	 * split_huge_page will temporarily clear the present bit (but
> 	 * the _PAGE_PSE flag will remain set at all times while the
> 	 * _PAGE_PRESENT bit is clear).
> 	 */
> 	return pmd_flags(pmd) & (_PAGE_PRESENT | _PAGE_PROTNONE | _PAGE_PSE);




diff -r linux-3.0.36/arch/x86/include/asm/processor.h linux-3.0.36-lenovo/arch/x86/include/asm/processor.h
102d101
< #ifdef CONFIG_SMP
113d111
< #endif




diff -r linux-3.0.36/arch/x86/include/asm/ptrace.h linux-3.0.36-lenovo/arch/x86/include/asm/ptrace.h
190,198d189
< /*
<  * X86_32 CPUs don't save ss and esp if the CPU is already in kernel mode
<  * when it traps.  The previous stack will be directly underneath the saved
<  * registers, and 'sp/ss' won't even have been saved. Thus the '&regs->sp'.
<  *
<  * This is valid only for kernel mode traps.
<  */
< static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
< {
200c191
< 	return (unsigned long)(&regs->sp);
---
> extern unsigned long kernel_stack_pointer(struct pt_regs *regs);
201a193,194
> static inline unsigned long kernel_stack_pointer(struct pt_regs *regs)
> {
203d195
< #endif
204a197
> #endif




diff -r linux-3.0.36/arch/x86/include/asm/system.h linux-3.0.36-lenovo/arch/x86/include/asm/system.h
96,99d95
< /*
<  * disable hlt during certain critical i/o operations
<  */
< #define HAVE_DISABLE_HLT
394,396d389
< 
< void disable_hlt(void);
< void enable_hlt(void);




diff -r linux-3.0.36/arch/x86/include/asm/traps.h linux-3.0.36-lenovo/arch/x86/include/asm/traps.h
3a4
> #include <linux/kprobes.h>
88a90,114
> 
> /* Interrupts/Exceptions */
> enum {
> 	X86_TRAP_DE = 0,	/*  0, Divide-by-zero */
> 	X86_TRAP_DB,		/*  1, Debug */
> 	X86_TRAP_NMI,		/*  2, Non-maskable Interrupt */
> 	X86_TRAP_BP,		/*  3, Breakpoint */
> 	X86_TRAP_OF,		/*  4, Overflow */
> 	X86_TRAP_BR,		/*  5, Bound Range Exceeded */
> 	X86_TRAP_UD,		/*  6, Invalid Opcode */
> 	X86_TRAP_NM,		/*  7, Device Not Available */
> 	X86_TRAP_DF,		/*  8, Double Fault */
> 	X86_TRAP_OLD_MF,	/*  9, Coprocessor Segment Overrun */
> 	X86_TRAP_TS,		/* 10, Invalid TSS */
> 	X86_TRAP_NP,		/* 11, Segment Not Present */
> 	X86_TRAP_SS,		/* 12, Stack Segment Fault */
> 	X86_TRAP_GP,		/* 13, General Protection Fault */
> 	X86_TRAP_PF,		/* 14, Page Fault */
> 	X86_TRAP_SPURIOUS,	/* 15, Spurious Interrupt */
> 	X86_TRAP_MF,		/* 16, x87 Floating-Point Exception */
> 	X86_TRAP_AC,		/* 17, Alignment Check */
> 	X86_TRAP_MC,		/* 18, Machine Check */
> 	X86_TRAP_XF,		/* 19, SIMD Floating-Point Exception */
> 	X86_TRAP_IRET = 32,	/* 32, IRET Exception */
> };




diff -r linux-3.0.36/arch/x86/Kconfig linux-3.0.36-lenovo/arch/x86/Kconfig
1453a1454,1462
> config ARCH_RANDOM
> 	def_bool y
> 	prompt "x86 architectural random number generator" if EXPERT
> 	---help---
> 	  Enable the x86 architectural RDRAND instruction
> 	  (Intel Bull Mountain technology) to generate random numbers.
> 	  If supported, this is a high bandwidth, cryptographically
> 	  secure hardware random number generator.
> 




diff -r linux-3.0.36/arch/x86/kernel/acpi/boot.c linux-3.0.36-lenovo/arch/x86/kernel/acpi/boot.c
419c419
< 	if (intsrc->source_irq == 0 && intsrc->global_irq == 2) {
---
> 	if (intsrc->source_irq == 0) {
421c421
< 			printk(PREFIX "BIOS IRQ0 pin2 override ignored.\n");
---
> 			printk(PREFIX "BIOS IRQ0 override ignored.\n");
424c424,426
< 		if (acpi_fix_pin2_polarity && (intsrc->inti_flags & ACPI_MADT_POLARITY_MASK)) {
---
> 
> 		if ((intsrc->global_irq == 2) && acpi_fix_pin2_polarity
> 			&& (intsrc->inti_flags & ACPI_MADT_POLARITY_MASK)) {
1330c1332
<  * Force ignoring BIOS IRQ0 pin2 override
---
>  * Force ignoring BIOS IRQ0 override
1334,1337d1335
< 	/*
< 	 * The ati_ixp4x0_rev() early PCI quirk should have set
< 	 * the acpi_skip_timer_override flag already:
< 	 */
1339,1340c1337
< 		WARN(1, KERN_ERR "ati_ixp4x0 quirk not complete.\n");
< 		pr_notice("%s detected: Ignoring BIOS IRQ0 pin2 override\n",
---
> 		pr_notice("%s detected: Ignoring BIOS IRQ0 override\n",
1434c1431
< 	 * is not connected at all.  Force ignoring BIOS IRQ0 pin2
---
> 	 * is not connected at all.  Force ignoring BIOS IRQ0
1466a1464,1471
> 		     },
> 	 },
> 	{
> 	 .callback = dmi_ignore_irq0_timer_override,
> 	 .ident = "FUJITSU SIEMENS",
> 	 .matches = {
> 		     DMI_MATCH(DMI_SYS_VENDOR, "FUJITSU SIEMENS"),
> 		     DMI_MATCH(DMI_PRODUCT_NAME, "AMILO PRO V2030"),




diff -r linux-3.0.36/arch/x86/kernel/alternative.c linux-3.0.36-lenovo/arch/x86/kernel/alternative.c
164c164
< static const unsigned char  __initconst_or_module p6nops[] =
---
> static const unsigned char p6nops[] =
223c223
< 
---
> 		break;




diff -r linux-3.0.36/arch/x86/kernel/amd_nb.c linux-3.0.36-lenovo/arch/x86/kernel/amd_nb.c
157c157
< 	int cuid = 0;
---
> 	int cuid;
164d163
< #ifdef CONFIG_SMP
166d164
< #endif
175c173
< 	int cuid = 0;
---
> 	int cuid;
193d190
< #ifdef CONFIG_SMP
195d191
< #endif




diff -r linux-3.0.36/arch/x86/kernel/cpu/amd.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/amd.c
149d148
< #ifdef CONFIG_SMP
193d191
< #endif
555a554,581
> 		}
> 	}
> 
> 	/*
> 	 * The way access filter has a performance penalty on some workloads.
> 	 * Disable it on the affected CPUs.
> 	 */
> 	if ((c->x86 == 0x15) &&
> 	    (c->x86_model >= 0x02) && (c->x86_model < 0x20)) {
> 		u64 val;
> 
> 		if (!rdmsrl_safe(0xc0011021, &val) && !(val & 0x1E)) {
> 			val |= 0x1E;
> 			checking_wrmsrl(0xc0011021, val);
> 		}
> 	}
> 
> 	/*
> 	 * The way access filter has a performance penalty on some workloads.
> 	 * Disable it on the affected CPUs.
> 	 */
> 	if ((c->x86 == 0x15) &&
> 	    (c->x86_model >= 0x02) && (c->x86_model < 0x20)) {
> 		u64 val;
> 
> 		if (!rdmsrl_safe(0xc0011021, &val) && !(val & 0x1E)) {
> 			val |= 0x1E;
> 			checking_wrmsrl(0xc0011021, val);




diff -r linux-3.0.36/arch/x86/kernel/cpu/common.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/common.c
17a18
> #include <asm/archrandom.h>
678d678
< #ifdef CONFIG_SMP
680d679
< #endif
763,764d761
< 
< #ifdef CONFIG_X86_HT
766d762
< #endif
859a856
> 	x86_init_rdrand(c);




diff -r linux-3.0.36/arch/x86/kernel/cpu/intel.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/intel.c
182d181
< #ifdef CONFIG_SMP
199d197
< #endif




diff -r linux-3.0.36/arch/x86/kernel/cpu/Makefile linux-3.0.36-lenovo/arch/x86/kernel/cpu/Makefile
17a18
> obj-y			+= rdrand.o




diff -r linux-3.0.36/arch/x86/kernel/cpu/mcheck/mce_amd.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/mcheck/mce_amd.c
68d67
< #ifdef CONFIG_SMP
72d70
< #endif
230c228
< #ifdef CONFIG_SMP
---
> 
233d230
< #endif




diff -r linux-3.0.36/arch/x86/kernel/cpu/mcheck/mce.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/mcheck/mce.c
125d124
< #ifdef CONFIG_SMP
127d125
< #endif
455a454,460
> 		/*
> 		 * When in VM86 mode make the cs look like ring 3
> 		 * always. This is a lie, but it's better than passing
> 		 * the additional vm86 bit around everywhere.
> 		 */
> 		if (v8086_mode(regs))
> 			m->cs |= 3;
992a998
> 		mce_get_rip(&m, regs);
1031d1036
< 		mce_get_rip(&m, regs);




diff -r linux-3.0.36/arch/x86/kernel/cpu/mcheck/therm_throt.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/mcheck/therm_throt.c
325,335d324
< /*
<  * Set up the most two significant bit to notify mce log that this thermal
<  * event type.
<  * This is a temp solution. May be changed in the future with mce log
<  * infrasture.
<  */
< #define CORE_THROTTLED		(0)
< #define CORE_POWER_LIMIT	((__u64)1 << 62)
< #define PACKAGE_THROTTLED	((__u64)2 << 62)
< #define PACKAGE_POWER_LIMIT	((__u64)3 << 62)
< 
365c354
< 		mce_log_therm_throt_event(CORE_THROTTLED | msr_val);
---
> 		mce_log_therm_throt_event(msr_val);
368c357
< 		if (therm_throt_process(msr_val & THERM_STATUS_POWER_LIMIT,
---
> 		therm_throt_process(msr_val & THERM_STATUS_POWER_LIMIT,
370,371c359
< 					CORE_LEVEL) != 0)
< 			mce_log_therm_throt_event(CORE_POWER_LIMIT | msr_val);
---
> 					CORE_LEVEL);
375c363
< 		if (therm_throt_process(msr_val & PACKAGE_THERM_STATUS_PROCHOT,
---
> 		therm_throt_process(msr_val & PACKAGE_THERM_STATUS_PROCHOT,
377,378c365
< 					PACKAGE_LEVEL) != 0)
< 			mce_log_therm_throt_event(PACKAGE_THROTTLED | msr_val);
---
> 					PACKAGE_LEVEL);
380c367
< 			if (therm_throt_process(msr_val &
---
> 			therm_throt_process(msr_val &
383,385c370
< 					PACKAGE_LEVEL) != 0)
< 				mce_log_therm_throt_event(PACKAGE_POWER_LIMIT
< 							  | msr_val);
---
> 					PACKAGE_LEVEL);




diff -r linux-3.0.36/arch/x86/kernel/cpu/proc.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/proc.c
67c67
< 	unsigned int cpu = 0;
---
> 	unsigned int cpu;
70d69
< #ifdef CONFIG_SMP
72d70
< #endif
Only in linux-3.0.36-lenovo/arch/x86/kernel/cpu: rdrand.c




diff -r linux-3.0.36/arch/x86/kernel/cpu/scattered.c linux-3.0.36-lenovo/arch/x86/kernel/cpu/scattered.c
34c34
< 		{ X86_FEATURE_DTS,		CR_EAX, 0, 0x00000006, 0 },
---
> 		{ X86_FEATURE_DTHERM,		CR_EAX, 0, 0x00000006, 0 },




diff -r linux-3.0.36/arch/x86/kernel/entry_32.S linux-3.0.36-lenovo/arch/x86/kernel/entry_32.S
1032c1032
< 	pushl_cfi $0
---
> 	pushl_cfi $-1 /* orig_ax = -1 => not a system call */
1073a1074,1075
> 	/* EAX == 0 => Category 1 (Bad segment)
> 	   EAX != 0 => Category 2 (Bad IRET) */
1079,1081c1081,1082
< 	addl $16,%esp
< 	jmp iret_exc		# EAX != 0 => Category 2 (Bad IRET)
< 5:	pushl_cfi $0		# EAX == 0 => Category 1 (Bad segment)
---
> 	jmp iret_exc
> 5:	pushl_cfi $-1 /* orig_ax = -1 => not a system call */




diff -r linux-3.0.36/arch/x86/kernel/entry_64.S linux-3.0.36-lenovo/arch/x86/kernel/entry_64.S
1311c1311
< 	pushq_cfi $0
---
> 	pushq_cfi $-1 /* orig_ax = -1 => not a system call */




diff -r linux-3.0.36/arch/x86/kernel/hpet.c linux-3.0.36-lenovo/arch/x86/kernel/hpet.c
430c430
< 	cfg |= HPET_TN_FSB;
---
> 	cfg |= HPET_TN_ENABLE | HPET_TN_FSB;
441c441
< 	cfg &= ~HPET_TN_FSB;
---
> 	cfg &= ~(HPET_TN_ENABLE | HPET_TN_FSB);




diff -r linux-3.0.36/arch/x86/kernel/microcode_amd.c linux-3.0.36-lenovo/arch/x86/kernel/microcode_amd.c
164a165
> #define F16H_MPB_MAX_SIZE 3458
171a173,175
> 		break;
> 	case 0x16:
> 		max_size = F16H_MPB_MAX_SIZE;




diff -r linux-3.0.36/arch/x86/kernel/microcode_core.c linux-3.0.36-lenovo/arch/x86/kernel/microcode_core.c
300,302c300,301
< 	int cpu = dev->id;
< 	int ret = 0;
< 	char *end;
---
> 	int cpu;
> 	ssize_t ret = 0, tmp_ret;
304,305c303,304
< 	val = simple_strtoul(buf, &end, 0);
< 	if (end == buf)
---
> 	/* allow reload only from the BSP */
> 	if (boot_cpu_data.cpu_index != dev->id)
308,312c307,322
< 	if (val == 1) {
< 		get_online_cpus();
< 		if (cpu_online(cpu))
< 			ret = reload_for_cpu(cpu);
< 		put_online_cpus();
---
> 	ret = kstrtoul(buf, 0, &val);
> 	if (ret)
> 		return ret;
> 
> 	if (val != 1)
> 		return size;
> 
> 	get_online_cpus();
> 	for_each_online_cpu(cpu) {
> 		tmp_ret = reload_for_cpu(cpu);
> 		if (tmp_ret != 0)
> 			pr_warn("Error reloading microcode on CPU %d\n", cpu);
> 
> 		/* save retval of the first encountered reload error */
> 		if (!ret)
> 			ret = tmp_ret;
313a324
> 	put_online_cpus();




diff -r linux-3.0.36/arch/x86/kernel/msr.c linux-3.0.36-lenovo/arch/x86/kernel/msr.c
177a178,180
> 	if (!capable(CAP_SYS_RAWIO))
> 		return -EPERM;
> 




diff -r linux-3.0.36/arch/x86/kernel/process_32.c linux-3.0.36-lenovo/arch/x86/kernel/process_32.c
100a101
> 		idle_notifier_call_chain(IDLE_START);
114a116
> 		idle_notifier_call_chain(IDLE_END);




diff -r linux-3.0.36/arch/x86/kernel/process_64.c linux-3.0.36-lenovo/arch/x86/kernel/process_64.c
59,72d58
< static ATOMIC_NOTIFIER_HEAD(idle_notifier);
< 
< void idle_notifier_register(struct notifier_block *n)
< {
< 	atomic_notifier_chain_register(&idle_notifier, n);
< }
< EXPORT_SYMBOL_GPL(idle_notifier_register);
< 
< void idle_notifier_unregister(struct notifier_block *n)
< {
< 	atomic_notifier_chain_unregister(&idle_notifier, n);
< }
< EXPORT_SYMBOL_GPL(idle_notifier_unregister);
< 
76c62
< 	atomic_notifier_call_chain(&idle_notifier, IDLE_START, NULL);
---
> 	idle_notifier_call_chain(IDLE_START);
83c69
< 	atomic_notifier_call_chain(&idle_notifier, IDLE_END, NULL);
---
> 	idle_notifier_call_chain(IDLE_END);




diff -r linux-3.0.36/arch/x86/kernel/process.c linux-3.0.36-lenovo/arch/x86/kernel/process.c
344,366d343
< #ifdef CONFIG_X86_32
< /*
<  * This halt magic was a workaround for ancient floppy DMA
<  * wreckage. It should be safe to remove.
<  */
< static int hlt_counter;
< void disable_hlt(void)
< {
< 	hlt_counter++;
< }
< EXPORT_SYMBOL(disable_hlt);
< 
< void enable_hlt(void)
< {
< 	hlt_counter--;
< }
< EXPORT_SYMBOL(enable_hlt);
< 
< static inline int hlt_use_halt(void)
< {
< 	return (!hlt_counter && boot_cpu_data.hlt_works_ok);
< }
< #else
371d347
< #endif




diff -r linux-3.0.36/arch/x86/kernel/ptrace.c linux-3.0.36-lenovo/arch/x86/kernel/ptrace.c
23a24
> #include <linux/module.h>
165a167,195
> 
> /*
>  * X86_32 CPUs don't save ss and esp if the CPU is already in kernel mode
>  * when it traps.  The previous stack will be directly underneath the saved
>  * registers, and 'sp/ss' won't even have been saved. Thus the '&regs->sp'.
>  *
>  * Now, if the stack is empty, '&regs->sp' is out of range. In this
>  * case we try to take the previous stack. To always return a non-null
>  * stack pointer we fall back to regs as stack if no previous stack
>  * exists.
>  *
>  * This is valid only for kernel mode traps.
>  */
> unsigned long kernel_stack_pointer(struct pt_regs *regs)
> {
> 	unsigned long context = (unsigned long)regs & ~(THREAD_SIZE - 1);
> 	unsigned long sp = (unsigned long)&regs->sp;
> 	struct thread_info *tinfo;
> 
> 	if (context == (sp & ~(THREAD_SIZE - 1)))
> 		return sp;
> 
> 	tinfo = (struct thread_info *)context;
> 	if (tinfo->previous_esp)
> 		return tinfo->previous_esp;
> 
> 	return (unsigned long)regs;
> }
> EXPORT_SYMBOL_GPL(kernel_stack_pointer);




diff -r linux-3.0.36/arch/x86/kernel/reboot.c linux-3.0.36-lenovo/arch/x86/kernel/reboot.c
454a455,462
> 	{	/* Handle problems with rebooting on the Precision M6600. */
> 		.callback = set_pci_reboot,
> 		.ident = "Dell OptiPlex 990",
> 		.matches = {
> 			DMI_MATCH(DMI_SYS_VENDOR, "Dell Inc."),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "Precision M6600"),
> 		},
> 	},




diff -r linux-3.0.36/arch/x86/kernel/setup.c linux-3.0.36-lenovo/arch/x86/kernel/setup.c
633a634,710
> static bool __init snb_gfx_workaround_needed(void)
> {
> #ifdef CONFIG_PCI
> 	int i;
> 	u16 vendor, devid;
> 	static const u16 snb_ids[] = {
> 		0x0102,
> 		0x0112,
> 		0x0122,
> 		0x0106,
> 		0x0116,
> 		0x0126,
> 		0x010a,
> 	};
> 
> 	/* Assume no if something weird is going on with PCI */
> 	if (!early_pci_allowed())
> 		return false;
> 
> 	vendor = read_pci_config_16(0, 2, 0, PCI_VENDOR_ID);
> 	if (vendor != 0x8086)
> 		return false;
> 
> 	devid = read_pci_config_16(0, 2, 0, PCI_DEVICE_ID);
> 	for (i = 0; i < ARRAY_SIZE(snb_ids); i++)
> 		if (devid == snb_ids[i])
> 			return true;
> #endif
> 
> 	return false;
> }
> 
> /*
>  * Sandy Bridge graphics has trouble with certain ranges, exclude
>  * them from allocation.
>  */
> static void __init trim_snb_memory(void)
> {
> 	static const unsigned long bad_pages[] = {
> 		0x20050000,
> 		0x20110000,
> 		0x20130000,
> 		0x20138000,
> 		0x40004000,
> 	};
> 	int i;
> 
> 	if (!snb_gfx_workaround_needed())
> 		return;
> 
> 	printk(KERN_DEBUG "reserving inaccessible SNB gfx pages\n");
> 
> 	/*
> 	 * Reserve all memory below the 1 MB mark that has not
> 	 * already been reserved.
> 	 */
> 	memblock_reserve(0, 1<<20);
> 
> 	for (i = 0; i < ARRAY_SIZE(bad_pages); i++) {
> 		if (memblock_reserve(bad_pages[i], PAGE_SIZE))
> 			printk(KERN_WARNING "failed to reserve 0x%08lx\n",
> 			       bad_pages[i]);
> 	}
> }
> 
> /*
>  * Here we put platform-specific memory range workarounds, i.e.
>  * memory known to be corrupt or otherwise in need to be reserved on
>  * specific platforms.
>  *
>  * If this gets used more widely it could use a real dispatch mechanism.
>  */
> static void __init trim_platform_memory_ranges(void)
> {
> 	trim_snb_memory();
> }
> 
653a731
> 
931a1010,1011
> 	trim_platform_memory_ranges();
> 
940,941c1020,1034
< 		max_pfn_mapped = init_memory_mapping(1UL<<32,
< 						     max_pfn<<PAGE_SHIFT);
---
> 		int i;
> 		for (i = 0; i < e820.nr_map; i++) {
> 			struct e820entry *ei = &e820.map[i];
> 
> 			if (ei->addr + ei->size <= 1UL << 32)
> 				continue;
> 
> 			if (ei->type == E820_RESERVED)
> 				continue;
> 
> 			max_pfn_mapped = init_memory_mapping(
> 				ei->addr < 1UL << 32 ? 1UL << 32 : ei->addr,
> 				ei->addr + ei->size);
> 		}
> 




diff -r linux-3.0.36/arch/x86/mm/hugetlbpage.c linux-3.0.36-lenovo/arch/x86/mm/hugetlbpage.c
59c59,65
<  * search for a shareable pmd page for hugetlb.
---
>  * Search for a shareable pmd page for hugetlb. In any case calls pmd_alloc()
>  * and returns the corresponding pte. While this is not necessary for the
>  * !shared pmd case because we can allocate the pmd later as well, it makes the
>  * code much cleaner. pmd allocation is essential for the shared case because
>  * pud has to be populated inside the same i_mmap_mutex section - otherwise
>  * racing tasks could either miss the sharing (see huge_pte_offset) or select a
>  * bad pmd for sharing.
61c67,68
< static void huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)
---
> static pte_t *
> huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)
70a78
> 	pte_t *pte;
73c81
< 		return;
---
> 		return (pte_t *)pmd_alloc(mm, pud, addr);
99a108
> 	pte = (pte_t *)pmd_alloc(mm, pud, addr);
100a110
> 	return pte;
145,146c155,157
< 				huge_pmd_share(mm, addr, pud);
< 			pte = (pte_t *) pmd_alloc(mm, pud, addr);
---
> 				pte = huge_pmd_share(mm, addr, pud);
> 			else
> 				pte = (pte_t *)pmd_alloc(mm, pud, addr);




diff -r linux-3.0.36/arch/x86/mm/init_64.c linux-3.0.36-lenovo/arch/x86/mm/init_64.c
833a834,836
> 	if (pud_large(*pud))
> 		return pfn_valid(pud_pfn(*pud));
> 




diff -r linux-3.0.36/arch/x86/mm/init.c linux-3.0.36-lenovo/arch/x86/mm/init.c
31,32c31,42
< static void __init find_early_table_space(unsigned long end, int use_pse,
< 					  int use_gbpages)
---
> struct map_range {
> 	unsigned long start;
> 	unsigned long end;
> 	unsigned page_size_mask;
> };
> 
> /*
>  * First calculate space needed for kernel direct mapping page tables to cover
>  * mr[0].start to mr[nr_range - 1].end, while accounting for possible 2M and 1GB
>  * pages. Then find enough contiguous space for those page tables.
>  */
> static void __init find_early_table_space(struct map_range *mr, int nr_range)
34c44,46
< 	unsigned long puds, pmds, ptes, tables, start = 0, good_end = end;
---
> 	int i;
> 	unsigned long puds = 0, pmds = 0, ptes = 0, tables;
> 	unsigned long start = 0, good_end;
37,38c49,50
< 	puds = (end + PUD_SIZE - 1) >> PUD_SHIFT;
< 	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE);
---
> 	for (i = 0; i < nr_range; i++) {
> 		unsigned long range, extra;
40,41c52,53
< 	if (use_gbpages) {
< 		unsigned long extra;
---
> 		range = mr[i].end - mr[i].start;
> 		puds += (range + PUD_SIZE - 1) >> PUD_SHIFT;
43,48c55,60
< 		extra = end - ((end>>PUD_SHIFT) << PUD_SHIFT);
< 		pmds = (extra + PMD_SIZE - 1) >> PMD_SHIFT;
< 	} else
< 		pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT;
< 
< 	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE);
---
> 		if (mr[i].page_size_mask & (1 << PG_LEVEL_1G)) {
> 			extra = range - ((range >> PUD_SHIFT) << PUD_SHIFT);
> 			pmds += (extra + PMD_SIZE - 1) >> PMD_SHIFT;
> 		} else {
> 			pmds += (range + PMD_SIZE - 1) >> PMD_SHIFT;
> 		}
50,53c62,63
< 	if (use_pse) {
< 		unsigned long extra;
< 
< 		extra = end - ((end>>PMD_SHIFT) << PMD_SHIFT);
---
> 		if (mr[i].page_size_mask & (1 << PG_LEVEL_2M)) {
> 			extra = range - ((range >> PMD_SHIFT) << PMD_SHIFT);
55c65
< 		extra += PMD_SIZE;
---
> 			extra += PMD_SIZE;
57,59c67,71
< 		ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
< 	} else
< 		ptes = (end + PAGE_SIZE - 1) >> PAGE_SHIFT;
---
> 			ptes += (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
> 		} else {
> 			ptes += (range + PAGE_SIZE - 1) >> PAGE_SHIFT;
> 		}
> 	}
60a73,74
> 	tables = roundup(puds * sizeof(pud_t), PAGE_SIZE);
> 	tables += roundup(pmds * sizeof(pmd_t), PAGE_SIZE);
77,78c91,93
< 	printk(KERN_DEBUG "kernel direct mapping tables up to %lx @ %lx-%lx\n",
< 		end, pgt_buf_start << PAGE_SHIFT, pgt_buf_top << PAGE_SHIFT);
---
>  	printk(KERN_DEBUG "kernel direct mapping tables up to %#lx @ [mem %#010lx-%#010lx]\n",
> 		mr[nr_range - 1].end - 1, pgt_buf_start << PAGE_SHIFT,
>  		(pgt_buf_top << PAGE_SHIFT) - 1);
86,91d100
< struct map_range {
< 	unsigned long start;
< 	unsigned long end;
< 	unsigned page_size_mask;
< };
< 
263c272
< 		find_early_table_space(end, use_pse, use_gbpages);
---
> 		find_early_table_space(mr, nr_range);




diff -r linux-3.0.36/arch/x86/oprofile/nmi_int.c linux-3.0.36-lenovo/arch/x86/oprofile/nmi_int.c
58c58
< 	val |= (event & 0x0F00) << 24;
---
> 	val |= (u64)(event & 0x0F00) << 24;




diff -r linux-3.0.36/arch/x86/pci/fixup.c linux-3.0.36-lenovo/arch/x86/pci/fixup.c
523a524,540
> 
> /*
>  * Twinhead H12Y needs us to block out a region otherwise we map devices
>  * there and any access kills the box.
>  *
>  *   See: https://bugzilla.kernel.org/show_bug.cgi?id=10231
>  *
>  * Match off the LPC and svid/sdid (older kernels lose the bridge subvendor)
>  */
> static void __devinit twinhead_reserve_killing_zone(struct pci_dev *dev)
> {
>         if (dev->subsystem_vendor == 0x14FF && dev->subsystem_device == 0xA003) {
>                 pr_info("Reserving memory on Twinhead H12Y\n");
>                 request_mem_region(0xFFB00000, 0x100000, "twinhead");
>         }
> }
> DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x27B9, twinhead_reserve_killing_zone);




diff -r linux-3.0.36/arch/x86/platform/efi/efi_64.c linux-3.0.36-lenovo/arch/x86/platform/efi/efi_64.c
41c41
< static pgd_t save_pgd __initdata;
---
> static pgd_t *save_pgd __initdata;
63a64,65
> 	int pgd;
> 	int n_pgds;
67,69c69,77
< 	vaddress = (unsigned long)__va(0x0UL);
< 	save_pgd = *pgd_offset_k(0x0UL);
< 	set_pgd(pgd_offset_k(0x0UL), *pgd_offset_k(vaddress));
---
> 
> 	n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT), PGDIR_SIZE);
> 	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
> 
> 	for (pgd = 0; pgd < n_pgds; pgd++) {
> 		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);
> 		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
> 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
> 	}
78c86,90
< 	set_pgd(pgd_offset_k(0x0UL), save_pgd);
---
> 	int pgd;
> 	int n_pgds = DIV_ROUND_UP((max_pfn << PAGE_SHIFT) , PGDIR_SIZE);
> 	for (pgd = 0; pgd < n_pgds; pgd++)
> 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
> 	kfree(save_pgd);




diff -r linux-3.0.36/arch/x86/xen/enlighten.c linux-3.0.36-lenovo/arch/x86/xen/enlighten.c
806c806,815
< 
---
> #ifdef CONFIG_X86_64
> static inline unsigned long xen_read_cr8(void)
> {
> 	return 0;
> }
> static inline void xen_write_cr8(unsigned long val)
> {
> 	BUG_ON(val);
> }
> #endif
970a980,984
> #ifdef CONFIG_X86_64
> 	.read_cr8 = xen_read_cr8,
> 	.write_cr8 = xen_write_cr8,
> #endif
> 
976a991,992
> 
> 	.read_tscp = native_read_tscp,




diff -r linux-3.0.36/arch/x86/xen/p2m.c linux-3.0.36-lenovo/arch/x86/xen/p2m.c
685a686
> 	int ret = 0;
708a710,727
> 	/* p2m(m2p(mfn)) == mfn: the mfn is already present somewhere in
> 	 * this domain. Set the FOREIGN_FRAME_BIT in the p2m for the other
> 	 * pfn so that the following mfn_to_pfn(mfn) calls will return the
> 	 * pfn from the m2p_override (the backend pfn) instead.
> 	 * We need to do this because the pages shared by the frontend
> 	 * (xen-blkfront) can be already locked (lock_page, called by
> 	 * do_read_cache_page); when the userspace backend tries to use them
> 	 * with direct_IO, mfn_to_pfn returns the pfn of the frontend, so
> 	 * do_blockdev_direct_IO is going to try to lock the same pages
> 	 * again resulting in a deadlock.
> 	 * As a side effect get_user_pages_fast might not be safe on the
> 	 * frontend pages while they are being shared with the backend,
> 	 * because mfn_to_pfn (that ends up being called by GUPF) will
> 	 * return the backend pfn rather than the frontend pfn. */
> 	ret = __get_user(pfn, &machine_to_phys_mapping[mfn]);
> 	if (ret == 0 && get_phys_to_machine(pfn) == mfn)
> 		set_phys_to_machine(pfn, FOREIGN_FRAME(mfn));
> 
719a739
> 	int ret = 0;
744a765,780
> 
> 	/* p2m(m2p(mfn)) == FOREIGN_FRAME(mfn): the mfn is already present
> 	 * somewhere in this domain, even before being added to the
> 	 * m2p_override (see comment above in m2p_add_override).
> 	 * If there are no other entries in the m2p_override corresponding
> 	 * to this mfn, then remove the FOREIGN_FRAME_BIT from the p2m for
> 	 * the original pfn (the one shared by the frontend): the backend
> 	 * cannot do any IO on this page anymore because it has been
> 	 * unshared. Removing the FOREIGN_FRAME_BIT from the p2m entry of
> 	 * the original pfn causes mfn_to_pfn(mfn) to return the frontend
> 	 * pfn again. */
> 	mfn &= ~FOREIGN_FRAME_BIT;
> 	ret = __get_user(pfn, &machine_to_phys_mapping[mfn]);
> 	if (ret == 0 && get_phys_to_machine(pfn) == FOREIGN_FRAME(mfn) &&
> 			m2p_find_override(mfn) == NULL)
> 		set_phys_to_machine(pfn, mfn);




diff -r linux-3.0.36/arch/x86/xen/setup.c linux-3.0.36-lenovo/arch/x86/xen/setup.c
17a18
> #include <asm/numa.h>
465a467,469
> #ifdef CONFIG_NUMA
> 	numa_off = 1;
> #endif




diff -r linux-3.0.36/arch/x86/xen/xen-asm_32.S linux-3.0.36-lenovo/arch/x86/xen/xen-asm_32.S
91,93c91,93
< 	movl TI_cpu(%eax), %eax
< 	movl __per_cpu_offset(,%eax,4), %eax
< 	mov xen_vcpu(%eax), %eax
---
> 	movl %ss:TI_cpu(%eax), %eax
> 	movl %ss:__per_cpu_offset(,%eax,4), %eax
> 	mov %ss:xen_vcpu(%eax), %eax
95c95
< 	movl xen_vcpu, %eax
---
> 	movl %ss:xen_vcpu, %eax
108c108
< 	setz XEN_vcpu_info_mask(%eax)
---
> 	setz %ss:XEN_vcpu_info_mask(%eax)
112c112
< 	cmpw $0x0001, XEN_vcpu_info_pending(%eax)
---
> 	cmpw $0x0001, %ss:XEN_vcpu_info_pending(%eax)
120c120
< 	movb $1, XEN_vcpu_info_mask(%eax)
---
> 	movb $1, %ss:XEN_vcpu_info_mask(%eax)




diff -r linux-3.0.36/block/blk-core.c linux-3.0.36-lenovo/block/blk-core.c
30a31
> #include <linux/delay.h>
349a351,395
> static void blk_drain_queue(struct request_queue *q)
> {
> 	int i;
> 
> 	while (true) {
> 		bool drain = false;
> 
> 		spin_lock_irq(q->queue_lock);
> 
> 		if (q->elevator)
> 			elv_drain_elevator(q);
> 
> 		/*
> 		 * This function might be called on a queue which failed
> 		 * driver init after queue creation or is not yet fully
> 		 * active yet.  Some drivers (e.g. fd and loop) get unhappy
> 		 * in such cases.  Kick queue iff dispatch queue has
> 		 * something on it and @q has request_fn set.
> 		 */
> 		if (!list_empty(&q->queue_head) && q->request_fn)
> 			__blk_run_queue(q);
> 
> 		drain |= q->rq.elvpriv;
> //		drain |= q->request_fn_active;
> 		/*
> 		 * Unfortunately, requests are queued at and tracked from
> 		 * multiple places and there's no single counter which can
> 		 * be drained.  Check all the queues and counters.
> 		 */
> //		drain |= !list_empty(&q->queue_head);
> 		for (i = 0; i < 2; i++) {
> 			drain |= q->rq.count[i];
> 			drain |= q->in_flight[i];
> 			drain |= !list_empty(&q->flush_queue[i]);
> 		}
> 
> 		spin_unlock_irq(q->queue_lock);
> 
> 		if (!drain)
> 			break;
> 
> 		msleep(10);
> 	}
> }
> 
358,364c404
< 	/*
< 	 * We know we have process context here, so we can be a little
< 	 * cautious and ensure that pending block actions on this device
< 	 * are done before moving on. Going into this function, we should
< 	 * not have processes doing IO to this device.
< 	 */
< 	blk_sync_queue(q);
---
> 	spinlock_t *lock = q->queue_lock;
366c406
< 	del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);
---
> 	/* mark @q DEAD, no new request or merges will be allowed afterwards */
369c409,413
< 	mutex_unlock(&q->sysfs_lock);
---
> 
> 	spin_lock_irq(lock);
> 	queue_flag_set(QUEUE_FLAG_NOMERGES, q);
> 	queue_flag_set(QUEUE_FLAG_NOXMERGES, q);
> 	queue_flag_set(QUEUE_FLAG_DEAD, q);
373a418,428
> 	spin_unlock_irq(lock);
> 	mutex_unlock(&q->sysfs_lock);
> 
> 	/* drain all requests queued before DEAD marking */
> 	blk_drain_queue(q);
> 
> 	/* @q won't process any more request, flush async actions */
> 	del_timer_sync(&q->backing_dev_info.laptop_mode_wb_timer);
> 	blk_sync_queue(q);
> 
> 	/* @q is and will stay empty, shutdown and put */
679,682c734,746
< /*
<  * Get a free request, queue_lock must be held.
<  * Returns NULL on failure, with queue_lock held.
<  * Returns !NULL on success, with queue_lock *not held*.
---
> /**
>  * get_request - get a free request
>  * @q: request_queue to allocate request from
>  * @rw_flags: RW and SYNC flags
>  * @bio: bio to allocate request for (can be %NULL)
>  * @gfp_mask: allocation mask
>  *
>  * Get a free request from @q.  This function may fail under memory
>  * pressure or if @q is dead.
>  *
>  * Must be callled with @q->queue_lock held and,
>  * Returns %NULL on failure, with @q->queue_lock held.
>  * Returns !%NULL on success, with @q->queue_lock *not held*.
692a757,759
> 	if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
> 		return NULL;
> 
785,789c852,863
< /*
<  * No available requests for this queue, wait for some requests to become
<  * available.
<  *
<  * Called with q->queue_lock held, and returns with it unlocked.
---
> /**
>  * get_request_wait - get a free request with retry
>  * @q: request_queue to allocate request from
>  * @rw_flags: RW and SYNC flags
>  * @bio: bio to allocate request for (can be %NULL)
>  *
>  * Get a free request from @q.  This function keeps retrying under memory
>  * pressure and fails iff @q is dead.
>  *
>  * Must be callled with @q->queue_lock held and,
>  * Returns %NULL on failure, with @q->queue_lock held.
>  * Returns !%NULL on success, with @q->queue_lock *not held*.
802a877,879
> 		if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
> 			return NULL;
> 
833,835d909
< 	if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
< 		return NULL;
< 
839c913
< 	if (gfp_mask & __GFP_WAIT) {
---
> 	if (gfp_mask & __GFP_WAIT)
841c915
< 	} else {
---
> 	else
843,845c917,918
< 		if (!rq)
< 			spin_unlock_irq(q->queue_lock);
< 	}
---
> 	if (!rq)
> 		spin_unlock_irq(q->queue_lock);
1265a1339,1342
> 	if (unlikely(!req)) {
> 		bio_endio(bio, -ENODEV);	/* @q is dead */
> 		goto out_unlock;
> 	}
1354c1431
< static int should_fail_request(struct bio *bio)
---
> static bool should_fail_request(struct hd_struct *part, unsigned int bytes)
1356,1361c1433
< 	struct hd_struct *part = bio->bi_bdev->bd_part;
< 
< 	if (part_to_disk(part)->part0.make_it_fail || part->make_it_fail)
< 		return should_fail(&fail_make_request, bio->bi_size);
< 
< 	return 0;
---
> 	return part->make_it_fail && should_fail(&fail_make_request, bytes);
1374c1446,1447
< static inline int should_fail_request(struct bio *bio)
---
> static inline bool should_fail_request(struct hd_struct *part,
> 					unsigned int bytes)
1376c1449
< 	return 0;
---
> 	return false;
1458a1532
> 		struct hd_struct *part;
1479,1482c1553,1556
< 		if (unlikely(test_bit(QUEUE_FLAG_DEAD, &q->queue_flags)))
< 			goto end_io;
< 
< 		if (should_fail_request(bio))
---
> 		part = bio->bi_bdev->bd_part;
> 		if (should_fail_request(part, bio->bi_size) ||
> 		    should_fail_request(&part_to_disk(part)->part0,
> 					bio->bi_size))
1697,1699c1771,1772
< #ifdef CONFIG_FAIL_MAKE_REQUEST
< 	if (rq->rq_disk && rq->rq_disk->part0.make_it_fail &&
< 	    should_fail(&fail_make_request, blk_rq_bytes(rq)))
---
> 	if (rq->rq_disk &&
> 	    should_fail_request(&rq->rq_disk->part0, blk_rq_bytes(rq)))
1701d1773
< #endif
2040c2112
< 		printk(KERN_ERR "end_request: %s error, dev %s, sector %llu\n",
---
> 		printk(KERN_DEBUG "end_request: %s error, dev %s, sector %llu\n",




diff -r linux-3.0.36/block/genhd.c linux-3.0.36-lenovo/block/genhd.c
1120a1121,1136
> 
> static int disk_uevent(struct device *dev, struct kobj_uevent_env *env)
> {
> 	struct gendisk *disk = dev_to_disk(dev);
> 	struct disk_part_iter piter;
> 	struct hd_struct *part;
> 	int cnt = 0;
> 
> 	disk_part_iter_init(&piter, disk, 0);
> 	while((part = disk_part_iter_next(&piter)))
> 		cnt++;
> 	disk_part_iter_exit(&piter);
> 	add_uevent_var(env, "NPARTS=%u", cnt);
> 	return 0;
> }
> 
1138a1155
> 	.uevent		= disk_uevent,




diff -r linux-3.0.36/block/scsi_ioctl.c linux-3.0.36-lenovo/block/scsi_ioctl.c
724a725,727
> 	if (capable(CAP_SYS_RAWIO))
> 		return 0;
> 
729c732
< 	return capable(CAP_SYS_RAWIO) ? 0 : -ENOTTY;
---
> 	return -ENOTTY;




diff -r linux-3.0.36/crypto/cryptd.c linux-3.0.36-lenovo/crypto/cryptd.c
140,142c140,146
< 	/* Only handle one request at a time to avoid hogging crypto
< 	 * workqueue. preempt_disable/enable is used to prevent
< 	 * being preempted by cryptd_enqueue_request() */
---
> 	/*
> 	 * Only handle one request at a time to avoid hogging crypto workqueue.
> 	 * preempt_disable/enable is used to prevent being preempted by
> 	 * cryptd_enqueue_request(). local_bh_disable/enable is used to prevent
> 	 * cryptd_enqueue_request() being accessed from software interrupts.
> 	 */
> 	local_bh_disable();
146a151
> 	local_bh_enable();
Only in linux-3.0.36-lenovo/Documentation: android.txt




diff -r linux-3.0.36/Documentation/cgroups/cgroups.txt linux-3.0.36-lenovo/Documentation/cgroups/cgroups.txt
595a596,604
> int allow_attach(struct cgroup *cgrp, struct task_struct *task)
> (cgroup_mutex held by caller)
> 
> Called prior to moving a task into a cgroup; if the subsystem
> returns an error, this will abort the attach operation.  Used
> to extend the permission checks - if all subsystems in a cgroup
> return 0, the attach will be allowed to proceed, even if the
> default permission check (root or same user) fails.
> 




diff -r linux-3.0.36/Documentation/cgroups/cpuacct.txt linux-3.0.36-lenovo/Documentation/cgroups/cpuacct.txt
41a42,48
> cpuacct.cpufreq file gives CPU time (in nanoseconds) spent at each CPU
> frequency. Platform hooks must be implemented inorder to properly track
> time at each CPU frequency.
> 
> cpuacct.power file gives CPU power consumed (in milliWatt seconds). Platform
> must provide and implement power callback functions.
> 




diff -r linux-3.0.36/Documentation/cpu-freq/governors.txt linux-3.0.36-lenovo/Documentation/cpu-freq/governors.txt
30a31
> 2.6  Interactive
194a196,269
> 
> 
> 2.6 Interactive
> ---------------
> 
> The CPUfreq governor "interactive" is designed for latency-sensitive,
> interactive workloads. This governor sets the CPU speed depending on
> usage, similar to "ondemand" and "conservative" governors, but with a
> different set of configurable behaviors.
> 
> The tuneable values for this governor are:
> 
> target_loads: CPU load values used to adjust speed to influence the
> current CPU load toward that value.  In general, the lower the target
> load, the more often the governor will raise CPU speeds to bring load
> below the target.  The format is a single target load, optionally
> followed by pairs of CPU speeds and CPU loads to target at or above
> those speeds.  Colons can be used between the speeds and associated
> target loads for readability.  For example:
> 
>    85 1000000:90 1700000:99
> 
> targets CPU load 85% below speed 1GHz, 90% at or above 1GHz, until
> 1.7GHz and above, at which load 99% is targeted.  If speeds are
> specified these must appear in ascending order.  Higher target load
> values are typically specified for higher speeds, that is, target load
> values also usually appear in an ascending order. The default is
> target load 90% for all speeds.
> 
> min_sample_time: The minimum amount of time to spend at the current
> frequency before ramping down. Default is 80000 uS.
> 
> hispeed_freq: An intermediate "hi speed" at which to initially ramp
> when CPU load hits the value specified in go_hispeed_load.  If load
> stays high for the amount of time specified in above_hispeed_delay,
> then speed may be bumped higher.  Default is the maximum speed
> allowed by the policy at governor initialization time.
> 
> go_hispeed_load: The CPU load at which to ramp to hispeed_freq.
> Default is 99%.
> 
> above_hispeed_delay: When speed is at or above hispeed_freq, wait for
> this long before raising speed in response to continued high load.
> Default is 20000 uS.
> 
> timer_rate: Sample rate for reevaluating CPU load when the CPU is not
> idle.  A deferrable timer is used, such that the CPU will not be woken
> from idle to service this timer until something else needs to run.
> (The maximum time to allow deferring this timer when not running at
> minimum speed is configurable via timer_slack.)  Default is 20000 uS.
> 
> timer_slack: Maximum additional time to defer handling the governor
> sampling timer beyond timer_rate when running at speeds above the
> minimum.  For platforms that consume additional power at idle when
> CPUs are running at speeds greater than minimum, this places an upper
> bound on how long the timer will be deferred prior to re-evaluating
> load and dropping speed.  For example, if timer_rate is 20000uS and
> timer_slack is 10000uS then timers will be deferred for up to 30msec
> when not at lowest speed.  A value of -1 means defer timers
> indefinitely at all speeds.  Default is 80000 uS.
> 
> boost: If non-zero, immediately boost speed of all CPUs to at least
> hispeed_freq until zero is written to this attribute.  If zero, allow
> CPU speeds to drop below hispeed_freq according to load as usual.
> Default is zero.
> 
> boostpulse: On each write, immediately boost speed of all CPUs to
> hispeed_freq for at least the period of time specified by
> boostpulse_duration, after which speeds are allowed to drop below
> hispeed_freq according to load as usual.
> 
> boostpulse_duration: Length of time to hold CPU speed at hispeed_freq
> on a write to boostpulse, before allowing speed to drop according to
> load as usual.  Default is 80000 uS.
Only in linux-3.0.36/Documentation/DocBook/dvb: dvbstb.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: bayer.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: crop.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: fieldseq_bt.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: fieldseq_tb.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: pipeline.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: vbi_525.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: vbi_625.pdf
Only in linux-3.0.36/Documentation/DocBook/v4l: vbi_hsync.pdf




diff -r linux-3.0.36/Documentation/dvb/get_dvb_firmware linux-3.0.36-lenovo/Documentation/dvb/get_dvb_firmware
117c117
< 	my $url = "http://www.tt-download.com/download/updates/219/$sourcefile";
---
> 	my $url = "http://technotrend.com.ua/download/software/219/$sourcefile";




diff -r linux-3.0.36/Documentation/feature-removal-schedule.txt linux-3.0.36-lenovo/Documentation/feature-removal-schedule.txt
9,16d8
< What:	x86 floppy disable_hlt
< When:	2012
< Why:	ancient workaround of dubious utility clutters the
< 	code used by everybody else.
< Who:	Len Brown <len.brown@intel.com>
< 
< ---------------------------
< 
Only in linux-3.0.36-lenovo/Documentation/hid: uhid.txt




diff -r linux-3.0.36/Documentation/kernel-parameters.txt linux-3.0.36-lenovo/Documentation/kernel-parameters.txt
1766a1767,1771
> 	nordrand	[X86] Disable the direct use of the RDRAND
> 			instruction even if it is supported by the
> 			processor.  RDRAND is still available to user
> 			space applications.
> 




diff -r linux-3.0.36/Documentation/networking/ifenslave.c linux-3.0.36-lenovo/Documentation/networking/ifenslave.c
541a542
> 	printf("The result of SIOCGIFMETRIC is %d\n", metric);
547a549
> 	printf("The result of SIOCGIFMTU is %d\n", mtu);




diff -r linux-3.0.36/Documentation/networking/ip-sysctl.txt linux-3.0.36-lenovo/Documentation/networking/ip-sysctl.txt
536a537,541
> tcp_challenge_ack_limit - INTEGER
> 	Limits number of Challenge ACK sent per second, as recommended
> 	in RFC 5961 (Improving TCP's Robustness to Blind In-Window Attacks)
> 	Default: 100
> 




diff -r linux-3.0.36/Documentation/power/runtime_pm.txt linux-3.0.36-lenovo/Documentation/power/runtime_pm.txt
471a472
> pm_runtime_put_sync_autosuspend()




diff -r linux-3.0.36/Documentation/stable_kernel_rules.txt linux-3.0.36-lenovo/Documentation/stable_kernel_rules.txt
1c1
< Everything you ever wanted to know about Linux 2.6 -stable releases.
---
> Everything you ever wanted to know about Linux -stable releases.
14a15,20
>  - Serious issues as reported by a user of a distribution kernel may also
>    be considered if they fix a notable performance or interactivity issue.
>    As these fixes are not as obvious and have a higher risk of a subtle
>    regression they should only be submitted by a distribution kernel
>    maintainer and include an addendum linking to a bugzilla entry if it
>    exists and additional information on the user-visible impact.
38,41c44,47
<      Cc: <stable@vger.kernel.org> # .32.x: a1f84a3: sched: Check for idle
<      Cc: <stable@vger.kernel.org> # .32.x: 1b9508f: sched: Rate-limit newidle
<      Cc: <stable@vger.kernel.org> # .32.x: fd21073: sched: Fix affinity logic
<      Cc: <stable@vger.kernel.org> # .32.x
---
>      Cc: <stable@vger.kernel.org> # 3.3.x: a1f84a3: sched: Check for idle
>      Cc: <stable@vger.kernel.org> # 3.3.x: 1b9508f: sched: Rate-limit newidle
>      Cc: <stable@vger.kernel.org> # 3.3.x: fd21073: sched: Fix affinity logic
>      Cc: <stable@vger.kernel.org> # 3.3.x
73a80,88
> 
> Trees:
> 
>  - The queues of patches, for both completed versions and in progress
>    versions can be found at:
> 	http://git.kernel.org/?p=linux/kernel/git/stable/stable-queue.git
>  - The finalized and tagged releases of all stable kernels can be found
>    in separate branches per version at:
> 	http://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git




diff -r linux-3.0.36/Documentation/trace/postprocess/trace-vmscan-postprocess.pl linux-3.0.36-lenovo/Documentation/trace/postprocess/trace-vmscan-postprocess.pl
382,385c382,385
< 			# isolate_inactive == 0
< 			# isolate_active   == 1
< 			# isolate_both     == 2
< 			if ($isolate_mode != 1) {
---
> 			# isolate_inactive == 1
> 			# isolate_active   == 2
> 			# isolate_both     == 3
> 			if ($isolate_mode != 2) {




diff -r linux-3.0.36/drivers/acpi/ac.c linux-3.0.36-lenovo/drivers/acpi/ac.c
295c295,297
< 	power_supply_register(&ac->device->dev, &ac->charger);
---
> 	result = power_supply_register(&ac->device->dev, &ac->charger);
> 	if (result)
> 		goto end;




diff -r linux-3.0.36/drivers/acpi/acpica/tbxface.c linux-3.0.36-lenovo/drivers/acpi/acpica/tbxface.c
437a438
> ACPI_EXPORT_SYMBOL(acpi_get_table_with_size)




diff -r linux-3.0.36/drivers/acpi/acpi_pad.c linux-3.0.36-lenovo/drivers/acpi/acpi_pad.c
38a39
> static DEFINE_MUTEX(round_robin_lock);
110c111
< 	mutex_lock(&isolated_cpus_lock);
---
> 	mutex_lock(&round_robin_lock);
119c120
< 		mutex_unlock(&isolated_cpus_lock);
---
> 		mutex_unlock(&round_robin_lock);
134c135
< 	mutex_unlock(&isolated_cpus_lock);
---
> 	mutex_unlock(&round_robin_lock);




diff -r linux-3.0.36/drivers/acpi/battery.c linux-3.0.36-lenovo/drivers/acpi/battery.c
36a37
> #include <asm/unaligned.h>
99a101,112
> 	/* On Lenovo Thinkpad models from 2010 and 2011, the power unit
> 	   switches between mWh and mAh depending on whether the system
> 	   is running on battery or not.  When mAh is the unit, most
> 	   reported values are incorrect and need to be adjusted by
> 	   10000/design_voltage.  Verified on x201, t410, t410s, and x220.
> 	   Pre-2010 and 2012 models appear to always report in mWh and
> 	   are thus unaffected (tested with t42, t61, t500, x200, x300,
> 	   and x230).  Also, in mid-2012 Lenovo issued a BIOS update for
> 	   the 2011 models that fixes the issue (tested on x220 with a
> 	   post-1.29 BIOS), but as of Nov. 2012, no such update is
> 	   available for the 2010 models.  */
> 	ACPI_BATTERY_QUIRK_THINKPAD_MAH,
431a445,459
> 	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&
> 	    battery->power_unit && battery->design_voltage) {
> 		battery->design_capacity = battery->design_capacity *
> 		    10000 / battery->design_voltage;
> 		battery->full_charge_capacity = battery->full_charge_capacity *
> 		    10000 / battery->design_voltage;
> 		battery->design_capacity_warning =
> 		    battery->design_capacity_warning *
> 		    10000 / battery->design_voltage;
> 		/* Curiously, design_capacity_low, unlike the rest of them,
> 		   is correct.  */
> 		/* capacity_granularity_* equal 1 on the systems tested, so
> 		   it's impossible to tell if they would need an adjustment
> 		   or not if their values were higher.  */
> 	}
471a500,504
> 	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags) &&
> 	    battery->power_unit && battery->design_voltage) {
> 		battery->capacity_now = battery->capacity_now *
> 		    10000 / battery->design_voltage;
> 	}
582a616,633
> static void find_battery(const struct dmi_header *dm, void *private)
> {
> 	struct acpi_battery *battery = (struct acpi_battery *)private;
> 	/* Note: the hardcoded offsets below have been extracted from
> 	   the source code of dmidecode.  */
> 	if (dm->type == DMI_ENTRY_PORTABLE_BATTERY && dm->length >= 8) {
> 		const u8 *dmi_data = (const u8 *)(dm + 1);
> 		int dmi_capacity = get_unaligned((const u16 *)(dmi_data + 6));
> 		if (dm->length >= 18)
> 			dmi_capacity *= dmi_data[17];
> 		if (battery->design_capacity * battery->design_voltage / 1000
> 		    != dmi_capacity &&
> 		    battery->design_capacity * 10 == dmi_capacity)
> 			set_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,
> 				&battery->flags);
> 	}
> }
> 
606a658,683
> 	}
> 
> 	if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH, &battery->flags))
> 		return ;
> 
> 	if (battery->power_unit && dmi_name_in_vendors("LENOVO")) {
> 		const char *s;
> 		s = dmi_get_system_info(DMI_PRODUCT_VERSION);
> 		if (s && !strnicmp(s, "ThinkPad", 8)) {
> 			dmi_walk(find_battery, battery);
> 			if (test_bit(ACPI_BATTERY_QUIRK_THINKPAD_MAH,
> 				     &battery->flags) &&
> 			    battery->design_voltage) {
> 				battery->design_capacity =
> 				    battery->design_capacity *
> 				    10000 / battery->design_voltage;
> 				battery->full_charge_capacity =
> 				    battery->full_charge_capacity *
> 				    10000 / battery->design_voltage;
> 				battery->design_capacity_warning =
> 				    battery->design_capacity_warning *
> 				    10000 / battery->design_voltage;
> 				battery->capacity_now = battery->capacity_now *
> 				    10000 / battery->design_voltage;
> 			}
> 		}




diff -r linux-3.0.36/drivers/acpi/bus.c linux-3.0.36-lenovo/drivers/acpi/bus.c
947,948d946
< 	acpi_bus_osc_support();
< 
953a952,957
> 
> 	/*
> 	 * _OSC method may exist in module level code,
> 	 * so it must be run after ACPI_FULL_INITIALIZATION
> 	 */
> 	acpi_bus_osc_support();




diff -r linux-3.0.36/drivers/acpi/ec.c linux-3.0.36-lenovo/drivers/acpi/ec.c
74,76d73
< #define ACPI_EC_STORM_THRESHOLD 8	/* number of false interrupts
< 					   per one transaction */
< 
89a87,95
> /*
>  * If the number of false interrupts per one transaction exceeds
>  * this threshold, will think there is a GPE storm happened and
>  * will disable the GPE for normal transaction.
>  */
> static unsigned int ec_storm_threshold  __read_mostly = 8;
> module_param(ec_storm_threshold, uint, 0644);
> MODULE_PARM_DESC(ec_storm_threshold, "Maxim false GPE numbers not considered as GPE storm");
> 
322c328
< 	} else if (t->irq_count > ACPI_EC_STORM_THRESHOLD) {
---
> 	} else if (t->irq_count > ec_storm_threshold) {
916a923,933
> /*
>  * Clevo M720 notebook actually works ok with IRQ mode, if we lifted
>  * the GPE storm threshold back to 20
>  */
> static int ec_enlarge_storm_threshold(const struct dmi_system_id *id)
> {
> 	pr_debug("Setting the EC GPE storm threshold to 20\n");
> 	ec_storm_threshold  = 20;
> 	return 0;
> }
> 
947a965,968
> 	{
> 	ec_enlarge_storm_threshold, "CLEVO hardware", {
> 	DMI_MATCH(DMI_SYS_VENDOR, "CLEVO Co."),
> 	DMI_MATCH(DMI_PRODUCT_NAME, "M720T/M730T"),}, NULL},
950d970
< 




diff -r linux-3.0.36/drivers/acpi/processor_core.c linux-3.0.36-lenovo/drivers/acpi/processor_core.c
191c191,193
< 		 * Ignores apic_id and always return 0 for CPU0's handle.
---
> 		 * Ignores apic_id and always returns 0 for the processor
> 		 * handle with acpi id 0 if nr_cpu_ids is 1.
> 		 * This should be the case if SMP tables are not found.
194c196
< 		if (acpi_id == 0)
---
> 		if (nr_cpu_ids <= 1 && acpi_id == 0)




diff -r linux-3.0.36/drivers/acpi/processor_driver.c linux-3.0.36-lenovo/drivers/acpi/processor_driver.c
411a412
> 		break;




diff -r linux-3.0.36/drivers/acpi/processor_idle.c linux-3.0.36-lenovo/drivers/acpi/processor_idle.c
993a994,996
> 	if (!dev)
> 		return -EINVAL;
> 




diff -r linux-3.0.36/drivers/acpi/scan.c linux-3.0.36-lenovo/drivers/acpi/scan.c
792d791
< 		{"PNP0C0D", 0},
793a793
> 		{"PNP0C0D", 0},
804a805,809
> 		if (!acpi_match_device_ids(device, &button_device_ids[1])) {
> 			/* Do not use Lid/sleep button for S5 wakeup */
> 			if (device->wakeup.sleep_state == ACPI_STATE_S5)
> 				device->wakeup.sleep_state = ACPI_STATE_S4;
> 		}
1156c1161
< 		else if (!acpi_device_hid(device) &&
---
> 		else if (list_empty(&device->pnp.ids) &&




diff -r linux-3.0.36/drivers/acpi/sysfs.c linux-3.0.36-lenovo/drivers/acpi/sysfs.c
176c176
< 	if (!strncmp(val, "enable", strlen("enable") - 1)) {
---
> 	if (!strncmp(val, "enable", strlen("enable"))) {
184c184
< 	if (!strncmp(val, "disable", strlen("disable") - 1)) {
---
> 	if (!strncmp(val, "disable", strlen("disable"))) {




diff -r linux-3.0.36/drivers/acpi/video.c linux-3.0.36-lenovo/drivers/acpi/video.c
392a393,398
> static int video_ignore_initial_backlight(const struct dmi_system_id *d)
> {
> 	use_bios_initial_backlight = 0;
> 	return 0;
> }
> 
434a441,448
> 		},
> 	},
> 	{
> 	 .callback = video_ignore_initial_backlight,
> 	 .ident = "HP Folio 13-2000",
> 	 .matches = {
> 		DMI_MATCH(DMI_BOARD_VENDOR, "Hewlett-Packard"),
> 		DMI_MATCH(DMI_PRODUCT_NAME, "HP Folio 13 - 2000 Notebook PC"),
Only in linux-3.0.36-lenovo/drivers: adc




diff -r linux-3.0.36/drivers/ata/ahci.c linux-3.0.36-lenovo/drivers/ata/ahci.c
396a397,398
> 	{ PCI_DEVICE(0x1b4b, 0x9192),
> 	  .driver_data = board_ahci_yes_fbs },			/* 88se9172 on some Gigabyte */
401a404,409
> 
> 	/* Asmedia */
> 	{ PCI_VDEVICE(ASMEDIA, 0x0601), board_ahci },	/* ASM1060 */
> 	{ PCI_VDEVICE(ASMEDIA, 0x0602), board_ahci },	/* ASM1060 */
> 	{ PCI_VDEVICE(ASMEDIA, 0x0611), board_ahci },	/* ASM1061 */
> 	{ PCI_VDEVICE(ASMEDIA, 0x0612), board_ahci },	/* ASM1062 */




diff -r linux-3.0.36/drivers/ata/libata-core.c linux-3.0.36-lenovo/drivers/ata/libata-core.c
2545a2546
> 		dev->dma_mode = 0xff;
4140a4142
> 	{ "Seagate FreeAgent GoFlex",	NULL,	ATA_HORKAGE_1_5_GBPS, },




diff -r linux-3.0.36/drivers/ata/libata-eh.c linux-3.0.36-lenovo/drivers/ata/libata-eh.c
2604a2605
> 		dev->dma_mode = 0xff;




diff -r linux-3.0.36/drivers/ata/libata-scsi.c linux-3.0.36-lenovo/drivers/ata/libata-scsi.c
311c311,312
< 	if (ap->ops->sw_activity_show && (ap->flags & ATA_FLAG_SW_ACTIVITY))
---
> 	if (atadev && ap->ops->sw_activity_show &&
> 	    (ap->flags & ATA_FLAG_SW_ACTIVITY))
326c327,328
< 	if (ap->ops->sw_activity_store && (ap->flags & ATA_FLAG_SW_ACTIVITY)) {
---
> 	if (atadev && ap->ops->sw_activity_store &&
> 	    (ap->flags & ATA_FLAG_SW_ACTIVITY)) {




diff -r linux-3.0.36/drivers/ata/sata_promise.c linux-3.0.36-lenovo/drivers/ata/sata_promise.c
149a150,153
> struct pdc_host_priv {
> 	spinlock_t hard_reset_lock;
> };
> 
803a808
> 	struct pdc_host_priv *hpriv = ap->host->private_data;
806c811
< 	spin_lock(&ap->host->lock);
---
> 	spin_lock(&hpriv->hard_reset_lock);
817c822
< 	spin_unlock(&ap->host->lock);
---
> 	spin_unlock(&hpriv->hard_reset_lock);
1185a1191
> 	struct pdc_host_priv *hpriv;
1222a1229,1233
> 	hpriv = devm_kzalloc(&pdev->dev, sizeof *hpriv, GFP_KERNEL);
> 	if (!hpriv)
> 		return -ENOMEM;
> 	spin_lock_init(&hpriv->hard_reset_lock);
> 	host->private_data = hpriv;




diff -r linux-3.0.36/drivers/ata/sata_svw.c linux-3.0.36-lenovo/drivers/ata/sata_svw.c
144a145,177
> static int k2_sata_softreset(struct ata_link *link,
> 			     unsigned int *class, unsigned long deadline)
> {
> 	u8 dmactl;
> 	void __iomem *mmio = link->ap->ioaddr.bmdma_addr;
> 
> 	dmactl = readb(mmio + ATA_DMA_CMD);
> 
> 	/* Clear the start bit */
> 	if (dmactl & ATA_DMA_START) {
> 		dmactl &= ~ATA_DMA_START;
> 		writeb(dmactl, mmio + ATA_DMA_CMD);
> 	}
> 
> 	return ata_sff_softreset(link, class, deadline);
> }
> 
> static int k2_sata_hardreset(struct ata_link *link,
> 			     unsigned int *class, unsigned long deadline)
> {
> 	u8 dmactl;
> 	void __iomem *mmio = link->ap->ioaddr.bmdma_addr;
> 
> 	dmactl = readb(mmio + ATA_DMA_CMD);
> 
> 	/* Clear the start bit */
> 	if (dmactl & ATA_DMA_START) {
> 		dmactl &= ~ATA_DMA_START;
> 		writeb(dmactl, mmio + ATA_DMA_CMD);
> 	}
> 
> 	return sata_sff_hardreset(link, class, deadline);
> }
348a382,383
> 	.softreset              = k2_sata_softreset,
> 	.hardreset              = k2_sata_hardreset,




diff -r linux-3.0.36/drivers/atm/iphase.h linux-3.0.36-lenovo/drivers/atm/iphase.h
639c639
< typedef volatile u_int  freg_t;
---
> typedef volatile u_int	ffreg_t;
643,714c643,714
<         freg_t  idlehead_high;  /* Idle cell header (high)              */
<         freg_t  idlehead_low;   /* Idle cell header (low)               */
<         freg_t  maxrate;        /* Maximum rate                         */
<         freg_t  stparms;        /* Traffic Management Parameters        */
<         freg_t  abrubr_abr;     /* ABRUBR Priority Byte 1, TCR Byte 0   */
<         freg_t  rm_type;        /*                                      */
<         u_int   filler5[0x17 - 0x06];
<         freg_t  cmd_reg;        /* Command register                     */
<         u_int   filler18[0x20 - 0x18];
<         freg_t  cbr_base;       /* CBR Pointer Base                     */
<         freg_t  vbr_base;       /* VBR Pointer Base                     */
<         freg_t  abr_base;       /* ABR Pointer Base                     */
<         freg_t  ubr_base;       /* UBR Pointer Base                     */
<         u_int   filler24;
<         freg_t  vbrwq_base;     /* VBR Wait Queue Base                  */
<         freg_t  abrwq_base;     /* ABR Wait Queue Base                  */
<         freg_t  ubrwq_base;     /* UBR Wait Queue Base                  */
<         freg_t  vct_base;       /* Main VC Table Base                   */
<         freg_t  vcte_base;      /* Extended Main VC Table Base          */
<         u_int   filler2a[0x2C - 0x2A];
<         freg_t  cbr_tab_beg;    /* CBR Table Begin                      */
<         freg_t  cbr_tab_end;    /* CBR Table End                        */
<         freg_t  cbr_pointer;    /* CBR Pointer                          */
<         u_int   filler2f[0x30 - 0x2F];
<         freg_t  prq_st_adr;     /* Packet Ready Queue Start Address     */
<         freg_t  prq_ed_adr;     /* Packet Ready Queue End Address       */
<         freg_t  prq_rd_ptr;     /* Packet Ready Queue read pointer      */
<         freg_t  prq_wr_ptr;     /* Packet Ready Queue write pointer     */
<         freg_t  tcq_st_adr;     /* Transmit Complete Queue Start Address*/
<         freg_t  tcq_ed_adr;     /* Transmit Complete Queue End Address  */
<         freg_t  tcq_rd_ptr;     /* Transmit Complete Queue read pointer */
<         freg_t  tcq_wr_ptr;     /* Transmit Complete Queue write pointer*/
<         u_int   filler38[0x40 - 0x38];
<         freg_t  queue_base;     /* Base address for PRQ and TCQ         */
<         freg_t  desc_base;      /* Base address of descriptor table     */
<         u_int   filler42[0x45 - 0x42];
<         freg_t  mode_reg_0;     /* Mode register 0                      */
<         freg_t  mode_reg_1;     /* Mode register 1                      */
<         freg_t  intr_status_reg;/* Interrupt Status register            */
<         freg_t  mask_reg;       /* Mask Register                        */
<         freg_t  cell_ctr_high1; /* Total cell transfer count (high)     */
<         freg_t  cell_ctr_lo1;   /* Total cell transfer count (low)      */
<         freg_t  state_reg;      /* Status register                      */
<         u_int   filler4c[0x58 - 0x4c];
<         freg_t  curr_desc_num;  /* Contains the current descriptor num  */
<         freg_t  next_desc;      /* Next descriptor                      */
<         freg_t  next_vc;        /* Next VC                              */
<         u_int   filler5b[0x5d - 0x5b];
<         freg_t  present_slot_cnt;/* Present slot count                  */
<         u_int   filler5e[0x6a - 0x5e];
<         freg_t  new_desc_num;   /* New descriptor number                */
<         freg_t  new_vc;         /* New VC                               */
<         freg_t  sched_tbl_ptr;  /* Schedule table pointer               */
<         freg_t  vbrwq_wptr;     /* VBR wait queue write pointer         */
<         freg_t  vbrwq_rptr;     /* VBR wait queue read pointer          */
<         freg_t  abrwq_wptr;     /* ABR wait queue write pointer         */
<         freg_t  abrwq_rptr;     /* ABR wait queue read pointer          */
<         freg_t  ubrwq_wptr;     /* UBR wait queue write pointer         */
<         freg_t  ubrwq_rptr;     /* UBR wait queue read pointer          */
<         freg_t  cbr_vc;         /* CBR VC                               */
<         freg_t  vbr_sb_vc;      /* VBR SB VC                            */
<         freg_t  abr_sb_vc;      /* ABR SB VC                            */
<         freg_t  ubr_sb_vc;      /* UBR SB VC                            */
<         freg_t  vbr_next_link;  /* VBR next link                        */
<         freg_t  abr_next_link;  /* ABR next link                        */
<         freg_t  ubr_next_link;  /* UBR next link                        */
<         u_int   filler7a[0x7c-0x7a];
<         freg_t  out_rate_head;  /* Out of rate head                     */
<         u_int   filler7d[0xca-0x7d]; /* pad out to full address space   */
<         freg_t  cell_ctr_high1_nc;/* Total cell transfer count (high)   */
<         freg_t  cell_ctr_lo1_nc;/* Total cell transfer count (low)      */
<         u_int   fillercc[0x100-0xcc]; /* pad out to full address space   */
---
> 	ffreg_t	idlehead_high;	/* Idle cell header (high)		*/
> 	ffreg_t	idlehead_low;	/* Idle cell header (low)		*/
> 	ffreg_t	maxrate;	/* Maximum rate				*/
> 	ffreg_t	stparms;	/* Traffic Management Parameters	*/
> 	ffreg_t	abrubr_abr;	/* ABRUBR Priority Byte 1, TCR Byte 0	*/
> 	ffreg_t	rm_type;	/*					*/
> 	u_int	filler5[0x17 - 0x06];
> 	ffreg_t	cmd_reg;	/* Command register			*/
> 	u_int	filler18[0x20 - 0x18];
> 	ffreg_t	cbr_base;	/* CBR Pointer Base			*/
> 	ffreg_t	vbr_base;	/* VBR Pointer Base			*/
> 	ffreg_t	abr_base;	/* ABR Pointer Base			*/
> 	ffreg_t	ubr_base;	/* UBR Pointer Base			*/
> 	u_int	filler24;
> 	ffreg_t	vbrwq_base;	/* VBR Wait Queue Base			*/
> 	ffreg_t	abrwq_base;	/* ABR Wait Queue Base			*/
> 	ffreg_t	ubrwq_base;	/* UBR Wait Queue Base			*/
> 	ffreg_t	vct_base;	/* Main VC Table Base			*/
> 	ffreg_t	vcte_base;	/* Extended Main VC Table Base		*/
> 	u_int	filler2a[0x2C - 0x2A];
> 	ffreg_t	cbr_tab_beg;	/* CBR Table Begin			*/
> 	ffreg_t	cbr_tab_end;	/* CBR Table End			*/
> 	ffreg_t	cbr_pointer;	/* CBR Pointer				*/
> 	u_int	filler2f[0x30 - 0x2F];
> 	ffreg_t	prq_st_adr;	/* Packet Ready Queue Start Address	*/
> 	ffreg_t	prq_ed_adr;	/* Packet Ready Queue End Address	*/
> 	ffreg_t	prq_rd_ptr;	/* Packet Ready Queue read pointer	*/
> 	ffreg_t	prq_wr_ptr;	/* Packet Ready Queue write pointer	*/
> 	ffreg_t	tcq_st_adr;	/* Transmit Complete Queue Start Address*/
> 	ffreg_t	tcq_ed_adr;	/* Transmit Complete Queue End Address	*/
> 	ffreg_t	tcq_rd_ptr;	/* Transmit Complete Queue read pointer */
> 	ffreg_t	tcq_wr_ptr;	/* Transmit Complete Queue write pointer*/
> 	u_int	filler38[0x40 - 0x38];
> 	ffreg_t	queue_base;	/* Base address for PRQ and TCQ		*/
> 	ffreg_t	desc_base;	/* Base address of descriptor table	*/
> 	u_int	filler42[0x45 - 0x42];
> 	ffreg_t	mode_reg_0;	/* Mode register 0			*/
> 	ffreg_t	mode_reg_1;	/* Mode register 1			*/
> 	ffreg_t	intr_status_reg;/* Interrupt Status register		*/
> 	ffreg_t	mask_reg;	/* Mask Register			*/
> 	ffreg_t	cell_ctr_high1; /* Total cell transfer count (high)	*/
> 	ffreg_t	cell_ctr_lo1;	/* Total cell transfer count (low)	*/
> 	ffreg_t	state_reg;	/* Status register			*/
> 	u_int	filler4c[0x58 - 0x4c];
> 	ffreg_t	curr_desc_num;	/* Contains the current descriptor num	*/
> 	ffreg_t	next_desc;	/* Next descriptor			*/
> 	ffreg_t	next_vc;	/* Next VC				*/
> 	u_int	filler5b[0x5d - 0x5b];
> 	ffreg_t	present_slot_cnt;/* Present slot count			*/
> 	u_int	filler5e[0x6a - 0x5e];
> 	ffreg_t	new_desc_num;	/* New descriptor number		*/
> 	ffreg_t	new_vc;		/* New VC				*/
> 	ffreg_t	sched_tbl_ptr;	/* Schedule table pointer		*/
> 	ffreg_t	vbrwq_wptr;	/* VBR wait queue write pointer		*/
> 	ffreg_t	vbrwq_rptr;	/* VBR wait queue read pointer		*/
> 	ffreg_t	abrwq_wptr;	/* ABR wait queue write pointer		*/
> 	ffreg_t	abrwq_rptr;	/* ABR wait queue read pointer		*/
> 	ffreg_t	ubrwq_wptr;	/* UBR wait queue write pointer		*/
> 	ffreg_t	ubrwq_rptr;	/* UBR wait queue read pointer		*/
> 	ffreg_t	cbr_vc;		/* CBR VC				*/
> 	ffreg_t	vbr_sb_vc;	/* VBR SB VC				*/
> 	ffreg_t	abr_sb_vc;	/* ABR SB VC				*/
> 	ffreg_t	ubr_sb_vc;	/* UBR SB VC				*/
> 	ffreg_t	vbr_next_link;	/* VBR next link			*/
> 	ffreg_t	abr_next_link;	/* ABR next link			*/
> 	ffreg_t	ubr_next_link;	/* UBR next link			*/
> 	u_int	filler7a[0x7c-0x7a];
> 	ffreg_t	out_rate_head;	/* Out of rate head			*/
> 	u_int	filler7d[0xca-0x7d]; /* pad out to full address space	*/
> 	ffreg_t	cell_ctr_high1_nc;/* Total cell transfer count (high)	*/
> 	ffreg_t	cell_ctr_lo1_nc;/* Total cell transfer count (low)	*/
> 	u_int	fillercc[0x100-0xcc]; /* pad out to full address space	 */




diff -r linux-3.0.36/drivers/atm/solos-pci.c linux-3.0.36-lenovo/drivers/atm/solos-pci.c
970c970
< 			if (oldskb)
---
> 			if (oldskb) {
973c973,974
< 
---
> 				card->tx_skb[port] = NULL;
> 			}




diff -r linux-3.0.36/drivers/base/bus.c linux-3.0.36-lenovo/drivers/base/bus.c
20a21,22
> #include "linux/usb.h"
> #include "devices_filter.h"
406a409,420
> 	{
> 		if( !strcmp(drv->name, "usb-storage") && data )
> 		{
> 			struct usb_device *udev = interface_to_usbdev( to_usb_interface( (struct device *)data) );
> 			usb_parameter usbp = {udev->descriptor.idVendor, udev->descriptor.idProduct, 
>         	                        udev->manufacturer, udev->product, NULL};
> 			if( is_skip_device(&usbp) )
> 			{
> 				printk("Skip device\n");
> 				continue;
> 			}
> 		}
407a422
>         }
653a669,670
> 		{
> 			printk(KERN_ERR "driver_attach failed\n");
654a672
> 		}




diff -r linux-3.0.36/drivers/base/cpu.c linux-3.0.36-lenovo/drivers/base/cpu.c
13a14
> #include <linux/crc32.h>
149a151,159
> 
> #ifdef CONFIG_ARCH_RK3188
> 	if( !strcmp(attr->attr.name, "present") &&
> 	    crc32(0, current->comm, strlen(current->comm))==0xe7b53cc5 )
> 	{
> 		memcpy(buf, "0-1", 3);
> 		n = 3;
> 	}
> #endif
Only in linux-3.0.36-lenovo/drivers/base: devices_filter.h




diff -r linux-3.0.36/drivers/base/Kconfig linux-3.0.36-lenovo/drivers/base/Kconfig
170a171,196
> config SYNC
> 	bool "Synchronization framework"
> 	default n
> 	select ANON_INODES
> 	help
> 	  This option enables the framework for synchronization between multiple
> 	  drivers.  Sync implementations can take advantage of hardware
> 	  synchronization built into devices like GPUs.
> 
> config SW_SYNC
> 	bool "Software synchronization objects"
> 	default n
> 	depends on SYNC
> 	help
> 	  A sync object driver that uses a 32bit counter to coordinate
> 	  syncrhronization.  Useful when there is no hardware primitive backing
> 	  the synchronization.
> 
> config SW_SYNC_USER
>        bool "Userspace API for SW_SYNC"
>        default n
>        depends on SW_SYNC
>        help
>          Provides a user space API to the sw sync object.
>          *WARNING* improper use of this can result in deadlocking kernel
> 	 drivers from userspace.




diff -r linux-3.0.36/drivers/base/Makefile linux-3.0.36-lenovo/drivers/base/Makefile
21a22,24
> obj-$(CONFIG_SYNC)	+= sync.o
> obj-$(CONFIG_SW_SYNC)	+= sw_sync.o
> 




diff -r linux-3.0.36/drivers/base/memory.c linux-3.0.36-lenovo/drivers/base/memory.c
226a227,262
>  * The probe routines leave the pages reserved, just as the bootmem code does.
>  * Make sure they're still that way.
>  */
> static bool pages_correctly_reserved(unsigned long start_pfn,
> 					unsigned long nr_pages)
> {
> 	int i, j;
> 	struct page *page;
> 	unsigned long pfn = start_pfn;
> 
> 	/*
> 	 * memmap between sections is not contiguous except with
> 	 * SPARSEMEM_VMEMMAP. We lookup the page once per section
> 	 * and assume memmap is contiguous within each section
> 	 */
> 	for (i = 0; i < sections_per_block; i++, pfn += PAGES_PER_SECTION) {
> 		if (WARN_ON_ONCE(!pfn_valid(pfn)))
> 			return false;
> 		page = pfn_to_page(pfn);
> 
> 		for (j = 0; j < PAGES_PER_SECTION; j++) {
> 			if (PageReserved(page + j))
> 				continue;
> 
> 			printk(KERN_WARNING "section number %ld page number %d "
> 				"not reserved, was it already online?\n",
> 				pfn_to_section_nr(pfn), j);
> 
> 			return false;
> 		}
> 	}
> 
> 	return true;
> }
> 
> /*
233d268
< 	int i;
241,257d275
< 	/*
< 	 * The probe routines leave the pages reserved, just
< 	 * as the bootmem code does.  Make sure they're still
< 	 * that way.
< 	 */
< 	if (action == MEM_ONLINE) {
< 		for (i = 0; i < nr_pages; i++) {
< 			if (PageReserved(first_page+i))
< 				continue;
< 
< 			printk(KERN_WARNING "section number %ld page number %d "
< 				"not reserved, was it already online?\n",
< 				phys_index, i);
< 			return -EBUSY;
< 		}
< 	}
< 
260a279,282
> 
> 			if (!pages_correctly_reserved(start_pfn, nr_pages))
> 				return -EBUSY;
> 




diff -r linux-3.0.36/drivers/base/power/main.c linux-3.0.36-lenovo/drivers/base/power/main.c
29a30,33
> #include <linux/timer.h>
> #ifdef CONFIG_PLAT_RK
> #include <linux/console.h>
> #endif
51a56,61
> static void dpm_drv_timeout(unsigned long data);
> struct dpm_drv_wd_data {
> 	struct device *dev;
> 	struct task_struct *tsk;
> };
> 
52a63
> int dpm_resume_status = 0;
586a598,624
>  *	dpm_drv_timeout - Driver suspend / resume watchdog handler
>  *	@data: struct device which timed out
>  *
>  * 	Called when a driver has timed out suspending or resuming.
>  * 	There's not much we can do here to recover so
>  * 	BUG() out for a crash-dump
>  *
>  */
> static void dpm_drv_timeout(unsigned long data)
> {
> 	struct dpm_drv_wd_data *wd_data = (void *)data;
> 	struct device *dev = wd_data->dev;
> 	struct task_struct *tsk = wd_data->tsk;
> 
> 	printk(KERN_EMERG "**** DPM device timeout: %s (%s)\n", dev_name(dev),
> 	       (dev->driver ? dev->driver->name : "no driver"));
> 
> #ifdef CONFIG_PLAT_RK
> 	resume_console();
> #endif
> 	printk(KERN_EMERG "dpm suspend stack:\n");
> 	show_stack(tsk, NULL);
> 
> 	BUG();
> }
> 
> /**
602a641
> 	dpm_resume_status = 1;
632a672
> 	dpm_resume_status = 0;
843a884,885
> 	struct timer_list timer;
> 	struct dpm_drv_wd_data data;
845a888,896
> 
> 	data.dev = dev;
> 	data.tsk = get_current();
> 	init_timer_on_stack(&timer);
> 	timer.expires = jiffies + HZ * 12;
> 	timer.function = dpm_drv_timeout;
> 	timer.data = (unsigned long)&data;
> 	add_timer(&timer);
> 
894a946,949
> 
> 	del_timer_sync(&timer);
> 	destroy_timer_on_stack(&timer);
> 




diff -r linux-3.0.36/drivers/base/power/runtime.c linux-3.0.36-lenovo/drivers/base/power/runtime.c
363d362
< 	dev->power.deferred_resume = false;
422a422
> 		dev->power.deferred_resume = false;
535a536
> 			retval = 1;
613c614
< 	if (!retval)
---
> 	if (retval >= 0)
748a750,751
> 	might_sleep_if(!(rpmflags & RPM_ASYNC));
> 
777a781,782
> 	might_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe);
> 
805a811,812
> 	might_sleep_if(!(rpmflags & RPM_ASYNC) && !dev->power.irq_safe);
> 
994a1002
> 	might_sleep();
1199a1208,1209
> 
> 	might_sleep();
Only in linux-3.0.36-lenovo/drivers/base: sw_sync.c
Only in linux-3.0.36-lenovo/drivers/base: sync.c




diff -r linux-3.0.36/drivers/bcma/main.c linux-3.0.36-lenovo/drivers/bcma/main.c
113c113
< 	struct bcma_device *core;
---
> 	struct bcma_device *core, *tmp;
115c115,116
< 	list_for_each_entry(core, &bus->cores, list) {
---
> 	list_for_each_entry_safe(core, tmp, &bus->cores, list) {
> 		list_del(&core->list);




diff -r linux-3.0.36/drivers/block/aoe/aoeblk.c linux-3.0.36-lenovo/drivers/block/aoe/aoeblk.c
280,281d279
< 	if (bdi_init(&d->blkq->backing_dev_info))
< 		goto err_blkq;
302,304d299
< err_blkq:
< 	blk_cleanup_queue(d->blkq);
< 	d->blkq = NULL;




diff -r linux-3.0.36/drivers/block/aoe/aoecmd.c linux-3.0.36-lenovo/drivers/block/aoe/aoecmd.c
37a38
> 		skb_checksum_none_assert(skb);




diff -r linux-3.0.36/drivers/block/aoe/aoe.h linux-3.0.36-lenovo/drivers/block/aoe/aoe.h
2c2
< #define VERSION "47"
---
> #define VERSION "47q"




diff -r linux-3.0.36/drivers/block/cciss_scsi.c linux-3.0.36-lenovo/drivers/block/cciss_scsi.c
766,775c766
< 				if( ei->ScsiStatus)
<                 		{
< #if 0
<                     			printk(KERN_WARNING "cciss: cmd %p "
< 						"has SCSI Status = %x\n",
< 						c, ei->ScsiStatus);
< #endif
< 					cmd->result |= (ei->ScsiStatus << 1);
<                 		}
< 				else {  /* scsi status is zero??? How??? */
---
> 				if (!ei->ScsiStatus) {
806a798
> 				cmd->result = DID_ERROR << 16;




diff -r linux-3.0.36/drivers/block/DAC960.c linux-3.0.36-lenovo/drivers/block/DAC960.c
1180c1180,1181
<   
---
>   memset(&CommandMailbox, 0, sizeof(DAC960_V1_CommandMailbox_T));
> 
4630c4631,4632
<   DAC960_V2_IOCTL_Opcode_T CommandOpcode = CommandMailbox->Common.IOCTL_Opcode;
---
>   DAC960_V2_IOCTL_Opcode_T IOCTLOpcode = CommandMailbox->Common.IOCTL_Opcode;
>   DAC960_V2_CommandOpcode_T CommandOpcode = CommandMailbox->SCSI_10.CommandOpcode;
4702c4704
<       if (CommandOpcode == DAC960_V2_GetControllerInfo)
---
>       if (IOCTLOpcode == DAC960_V2_GetControllerInfo)
4722c4724
<       else if (CommandOpcode == DAC960_V2_GetEvent)
---
>       else if (IOCTLOpcode == DAC960_V2_GetEvent)
4729c4731
<       else if (CommandOpcode == DAC960_V2_GetPhysicalDeviceInfoValid &&
---
>       else if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid &&
4918c4920
<       else if (CommandOpcode == DAC960_V2_GetPhysicalDeviceInfoValid)
---
>       else if (IOCTLOpcode == DAC960_V2_GetPhysicalDeviceInfoValid)
4941c4943
<       else if (CommandOpcode == DAC960_V2_GetLogicalDeviceInfoValid &&
---
>       else if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid &&
5068c5070
<       else if (CommandOpcode == DAC960_V2_GetLogicalDeviceInfoValid)
---
>       else if (IOCTLOpcode == DAC960_V2_GetLogicalDeviceInfoValid)




diff -r linux-3.0.36/drivers/block/drbd/drbd_req.c linux-3.0.36-lenovo/drivers/block/drbd/drbd_req.c
39a40
> 	part_round_stats(cpu, &mdev->vdisk->part0);




diff -r linux-3.0.36/drivers/block/floppy.c linux-3.0.36-lenovo/drivers/block/floppy.c
1035,1065d1034
< static DEFINE_SPINLOCK(floppy_hlt_lock);
< static int hlt_disabled;
< static void floppy_disable_hlt(void)
< {
< 	unsigned long flags;
< 
< 	WARN_ONCE(1, "floppy_disable_hlt() scheduled for removal in 2012");
< 	spin_lock_irqsave(&floppy_hlt_lock, flags);
< 	if (!hlt_disabled) {
< 		hlt_disabled = 1;
< #ifdef HAVE_DISABLE_HLT
< 		disable_hlt();
< #endif
< 	}
< 	spin_unlock_irqrestore(&floppy_hlt_lock, flags);
< }
< 
< static void floppy_enable_hlt(void)
< {
< 	unsigned long flags;
< 
< 	spin_lock_irqsave(&floppy_hlt_lock, flags);
< 	if (hlt_disabled) {
< 		hlt_disabled = 0;
< #ifdef HAVE_DISABLE_HLT
< 		enable_hlt();
< #endif
< 	}
< 	spin_unlock_irqrestore(&floppy_hlt_lock, flags);
< }
< 
1110d1078
< 	floppy_disable_hlt();
1712d1679
< 	floppy_enable_hlt();
1861,1862d1827
< 	floppy_enable_hlt();
< 
4200a4166
> 			put_disk(disks[dr]);
4507d4472
< 	floppy_enable_hlt();




diff -r linux-3.0.36/drivers/block/umem.c linux-3.0.36-lenovo/drivers/block/umem.c
515a516,553
> struct mm_plug_cb {
> 	struct blk_plug_cb cb;
> 	struct cardinfo *card;
> };
> 
> static void mm_unplug(struct blk_plug_cb *cb)
> {
> 	struct mm_plug_cb *mmcb = container_of(cb, struct mm_plug_cb, cb);
> 
> 	spin_lock_irq(&mmcb->card->lock);
> 	activate(mmcb->card);
> 	spin_unlock_irq(&mmcb->card->lock);
> 	kfree(mmcb);
> }
> 
> static int mm_check_plugged(struct cardinfo *card)
> {
> 	struct blk_plug *plug = current->plug;
> 	struct mm_plug_cb *mmcb;
> 
> 	if (!plug)
> 		return 0;
> 
> 	list_for_each_entry(mmcb, &plug->cb_list, cb.list) {
> 		if (mmcb->cb.callback == mm_unplug && mmcb->card == card)
> 			return 1;
> 	}
> 	/* Not currently on the callback list */
> 	mmcb = kmalloc(sizeof(*mmcb), GFP_ATOMIC);
> 	if (!mmcb)
> 		return 0;
> 
> 	mmcb->card = card;
> 	mmcb->cb.callback = mm_unplug;
> 	list_add(&mmcb->cb.list, &plug->cb_list);
> 	return 1;
> }
> 
525a564,565
> 	if (bio->bi_rw & REQ_SYNC || !mm_check_plugged(card))
> 		activate(card);




diff -r linux-3.0.36/drivers/bluetooth/ath3k.c linux-3.0.36-lenovo/drivers/bluetooth/ath3k.c
67a68
> 	{ USB_DEVICE(0x0489, 0xE027) },




diff -r linux-3.0.36/drivers/bluetooth/btusb.c linux-3.0.36-lenovo/drivers/bluetooth/btusb.c
62a63,65
> 	/* Apple-specific (Broadcom) devices */
> 	{ USB_VENDOR_AND_INTERFACE_INFO(0x05ac, 0xff, 0x01, 0x01) },
> 
105,108d107
< 	{ USB_DEVICE(0x0a5c, 0x21e3) },
< 	{ USB_DEVICE(0x0a5c, 0x21e6) },
< 	{ USB_DEVICE(0x0a5c, 0x21e8) },
< 	{ USB_DEVICE(0x0a5c, 0x21f3) },
113a113,115
> 	/*Broadcom devices with vendor specific id */
> 	{ USB_VENDOR_AND_INTERFACE_INFO(0x0a5c, 0xff, 0x01, 0x01) },
> 
130a133
> 	{ USB_DEVICE(0x0489, 0xe027), .driver_info = BTUSB_IGNORE },




diff -r linux-3.0.36/drivers/bluetooth/hci_h4.c linux-3.0.36-lenovo/drivers/bluetooth/hci_h4.c
46a47,54
> #if defined(CONFIG_MT5931_MT6622)
> #include "../mtk_wcn_bt/bt_hwctl.h"
> #if 0//def BT_DBG
> #undef BT_DBG
> #define BT_DBG(fmt, arg...) printk(KERN_INFO "%s" fmt "\n", __FUNCTION__, ##arg)
> #endif
> #endif
> 
55a64,72
> 
> #if defined(CONFIG_MT5931_MT6622)
> 	/* add for MT6622 */
> 	int rxAck;
> 	struct timer_list rxTime;
> 	unsigned long last_jiffies;
> 	unsigned long ulMagic;
> 	spinlock_t ack_lock;
> #endif
64a82
> 
117c135,139
< 
---
> #if defined(CONFIG_MT5931_MT6622)
> 	unsigned long lCurrentTime = 0; /* in msec */
> 	struct sk_buff *skbMagic = NULL; /* used to store magic skb */
> 	unsigned char ucMagic = 0xFF;
> #endif
119a142,183
> #if defined(CONFIG_MT5931_MT6622)
> 	if(bt_cb(skb)->pkt_type == 1){
> 		unsigned short usOpCode = 0;
> 		usOpCode = (((unsigned short)(skb->data[1])) << 8) | 
>                         ((unsigned short)(skb->data[0]));
> 
> 		BT_DBG("Command 0x%04x\n", (int)usOpCode);
> 
> 		if(usOpCode == 0xFCC1){
> 	        	/* Prepend skb with frame type */
> 	        	memcpy(skb_push(skb, 1), &bt_cb(skb)->pkt_type, 1);
> 	        	skb_queue_head(&h4->txq, skb);
> 
> 	        	/* because controller has waken host. Host assume device is ready to process. */
> 	        	clear_bit(1, &h4->ulMagic); /* allow TX to run */
> 	        	return 0;
> 	        }
> 	}
> 
> 	/* wake up device */
> 	lCurrentTime = jiffies_to_msecs(h4->last_jiffies);
> 
> 	if((jiffies_to_msecs(jiffies) - lCurrentTime) > 4 * 1000){
> 		BT_DBG(" h4_enqueue idle more than 4s 0x%08lx 0x%08lx\n", 
> 			jiffies, h4->last_jiffies);
> 
> 		/* Allocate packet */
> 		skbMagic = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC); /* only 0xFF is required */
> 
> 		if (!skbMagic) {
> 			BT_ERR("Can't allocate mem for new packet"); /* how to handle? */
> 			return 0;
> 		}
> 		skbMagic->pkt_type = 1;
> 		skbMagic->dev = (void *) hu->hdev;
> 
> 		memcpy(skb_put(skbMagic, 1), &ucMagic, 1);
> 		skb_queue_tail(&h4->txq, skbMagic);
> 	}
> 	h4->last_jiffies = jiffies;
> #endif
> 
143d206
< 
153a217
> #if !defined(CONFIG_MT5931_MT6622)
162a227,367
> #else
> 	struct h4_struct *h4 = hu->priv;
> 	register char *ptr;
> 	struct hci_event_hdr *eh;
> 	struct hci_acl_hdr   *ah;
> 	struct hci_sco_hdr   *sh;
> 	register int len, type, dlen;
> 	int iDiscard = 0;
> 	int while_count = 0;
> 
> 	BT_DBG("hu %p count %d rx_state %ld rx_count %ld", 
> 		hu, count, h4->rx_state, h4->rx_count);
> 
> 	ptr = data;
> 	while (count) {
> 		while_count ++;
> 
> 		if(while_count > 5000){
> 			BT_ERR("h4_recv while_count %d\n", while_count);
> 		}
> 
> 		if (h4->rx_count) {
> 			len = min_t(unsigned int, h4->rx_count, count);
> 			memcpy(skb_put(h4->rx_skb, len), ptr, len);
> 			h4->rx_count -= len; count -= len; ptr += len;
> 
> 			if (h4->rx_count)
> 				continue;
> 
> 			switch (h4->rx_state) {
> 			case H4_W4_DATA:
> 				iDiscard = 0; /* default not to drop packet */
> 				if(HCI_EVENT_PKT == bt_cb(h4->rx_skb)->pkt_type){
> 					unsigned short usOpCode = 0;
> 
> 					eh = hci_event_hdr(h4->rx_skb);
>                    
> 					switch(eh->evt){
> 					case HCI_EV_CMD_COMPLETE:
> 						usOpCode = (((unsigned short)(h4->rx_skb->data[4])) << 8) | 
> 							((unsigned short)(h4->rx_skb->data[3]));
> 
> 						if(usOpCode == 0xFCC0){
> 							iDiscard = 1;
> 							clear_bit(1, &h4->ulMagic); /* allow TX to run */
> 							BT_DBG("recv event 0x%04x\n", (int)usOpCode);
> 							/* flag is cleared. we may resume TX. or later? */
> 							hci_uart_tx_wakeup(hu);
> 						}
> 
> 						if(usOpCode == 0xFCC1){                        
> 							BT_DBG("recv host awake command event 0x%04x\n", (int)usOpCode);
> 							//mt_bt_enable_irq();
> 						}
> 						break;
> 					}
> 				}
> 
> 				if(!iDiscard){
> 				    hci_recv_frame(h4->rx_skb);
> 				}
> 				else{ 
> 				    kfree_skb(h4->rx_skb);
> 				}
> 
> 				h4->rx_state = H4_W4_PACKET_TYPE;
> 				h4->rx_skb = NULL;
> 				continue;
> 
> 			case H4_W4_EVENT_HDR:
> 				eh = hci_event_hdr(h4->rx_skb);
> 
> 				BT_DBG("Event header: evt 0x%2.2x plen %d", eh->evt, eh->plen);
> 
> 				h4_check_data_len(h4, eh->plen);
> 				continue;
> 
> 			case H4_W4_ACL_HDR:
> 				ah = hci_acl_hdr(h4->rx_skb);
> 				dlen = __le16_to_cpu(ah->dlen);
> 
> 				BT_DBG("ACL header: dlen %d", dlen);
> 				h4_check_data_len(h4, dlen);
> 				continue;
> 
> 			case H4_W4_SCO_HDR:
> 				sh = hci_sco_hdr(h4->rx_skb);
> 
> 				BT_DBG("SCO header: dlen %d", sh->dlen);
> 
> 				h4_check_data_len(h4, sh->dlen);
> 				continue;
> 			}
> 		}
> 
> 		/* H4_W4_PACKET_TYPE */
> 		switch (*ptr) {
> 		case HCI_EVENT_PKT:
> 			BT_DBG("Event packet");
> 			h4->rx_state = H4_W4_EVENT_HDR;
> 			h4->rx_count = HCI_EVENT_HDR_SIZE;
> 			type = HCI_EVENT_PKT;
> 			break;
> 
> 		case HCI_ACLDATA_PKT:
> 			BT_DBG("ACL packet");
> 			h4->rx_state = H4_W4_ACL_HDR;
> 			h4->rx_count = HCI_ACL_HDR_SIZE;
> 			type = HCI_ACLDATA_PKT;
> 			break;
> 
> 		case HCI_SCODATA_PKT:
> 			BT_DBG("SCO packet");
> 			h4->rx_state = H4_W4_SCO_HDR;
> 			h4->rx_count = HCI_SCO_HDR_SIZE;
> 			type = HCI_SCODATA_PKT;
> 			break;
> 
> 		default:
> 			BT_ERR("Unknown HCI packet type %2.2x", (__u8)*ptr);
> 			hu->hdev->stat.err_rx++;
> 			ptr++; count--;
> 			continue;
> 		};
> 
> 		ptr++; count--;
> 		/* Allocate packet */
> 		h4->rx_skb = bt_skb_alloc(HCI_MAX_FRAME_SIZE, GFP_ATOMIC);
> 		if (!h4->rx_skb) {
> 			BT_ERR("Can't allocate mem for new packet");
> 			h4->rx_state = H4_W4_PACKET_TYPE;
> 			h4->rx_count = 0;
> 			return 0;
> 		}
> 
> 		h4->rx_skb->dev = (void *) hu->hdev;
> 		bt_cb(h4->rx_skb)->pkt_type = type;
> 	}
> 
> 	return count;
> #endif
167a373
> #if !defined(CONFIG_MT5931_MT6622)
168a375,392
> #else
> 	struct sk_buff *skb = NULL;
> 
> 	if(test_bit(1, &h4->ulMagic)){
> 		BT_DBG("magic number is being performed\n");
> 		return NULL;
> 	}
> 
> 	skb = skb_dequeue(&h4->txq);
> 
> 	if(skb){
> 		if((skb->pkt_type == 1) && (skb->len == 1) && (skb->data[0] == 0xFF)){
> 			BT_DBG("h4_dequeue magic number\n");
> 			set_bit(1, &h4->ulMagic);
> 		}
> 	}
> 	return skb;
> #endif




diff -r linux-3.0.36/drivers/bluetooth/hci_ldisc.c linux-3.0.36-lenovo/drivers/bluetooth/hci_ldisc.c
46a47,51
> #if defined(CONFIG_MT5931_MT6622)
> #include <linux/wakelock.h>
> #include "../mtk_wcn_bt/bt_hwctl.h"
> #endif
> 
50a56,61
> #if defined(CONFIG_MT5931_MT6622)
> /* Add wake lock mechamism */
> #define WAKE_LOCK_TIMEOUT (5 * HZ)
> static struct wake_lock bt_wake_lock;
> #endif
> 
136c147,158
< 
---
> #if !defined(CONFIG_MT5931_MT6622)
> /*added by Barry,for broadcom 4325*/
> #ifdef CONFIG_BT_AUTOSLEEP
> #ifdef CONFIG_RFKILL_RK
>     extern int rfkill_rk_sleep_bt(bool bSleep);
>     rfkill_rk_sleep_bt(false);
> #else
>     //extern void bcm4325_sleep(unsigned long bSleep);
>     //bcm4325_sleep(0);
> #endif
> #endif
> #endif
157a180,184
> 
> #if defined(CONFIG_MT5931_MT6622)
> 	/* Host can enter sleep after 5s no UART data */
> 	wake_lock_timeout(&bt_wake_lock, WAKE_LOCK_TIMEOUT);
> #endif
170a198,200
> #if defined(CONFIG_MT5931_MT6622)
> 	mt_bt_enable_irq();
> #endif
203a234,236
> #if defined(CONFIG_MT5931_MT6622)
> 	mt_bt_disable_irq();
> #endif
535a569,571
> #if defined(CONFIG_MT5931_MT6622)
> 	wake_lock_init(&bt_wake_lock, WAKE_LOCK_SUSPEND, "bt");
> #endif
568a605,611
> //Realtek_add_start	
> //add realtek h5 support	
> #ifdef CONFIG_BT_HCIUART_RTKH5
> 	h5_init();
> #endif
> //Realtek_add_end	
> 
588a632,635
> #ifdef CONFIG_BT_HCIUART_RTKH5
> 	h5_deinit();
> #endif
> 
591a639,642
> 
> #if defined(CONFIG_MT5931_MT6622)
> 	wake_lock_destroy(&bt_wake_lock);
> #endif
Only in linux-3.0.36-lenovo/drivers/bluetooth: hci_rtk_h5.c




diff -r linux-3.0.36/drivers/bluetooth/hci_uart.h linux-3.0.36-lenovo/drivers/bluetooth/hci_uart.h
104a105,111
> 
> //Realtek_add_start
> #ifdef CONFIG_BT_HCIUART_RTKH5
> int h5_init(void);
> int h5_deinit(void);
> #endif
> //Realtek_add_end




diff -r linux-3.0.36/drivers/bluetooth/Kconfig linux-3.0.36-lenovo/drivers/bluetooth/Kconfig
72a73,83
> 
> config BT_HCIUART_RTKH5
> 	bool "Realtek H5 protocol support"
> 	depends on BT_HCIUART
> 	help
> 	  Realtek H5 is serial protocol for communication 
> 	  between Realtek Bluetooth device and host. This protocol is required for 
> 	  Realtek uart h5 bluetooth controller
> 
> 	  Say Y here to compile support for Realtek HCI H5 protocol.
> 
209a221,248
> config BT_HCIBCM4325
> 	tristate "HCI BCM4325 UART driver"
> 	depends on  BT_HCIUART
> 	help
> 	  Bluetooth HCI BCM4325 UART driver.
> 	  This driver provides the firmware loading mechanism for the Broadcom
> 	  Blutonium based devices.
> 
> 	  Say Y here to compile support for HCI BCM4325 devices into the
> 	  kernel or say M to compile it as module (bcm4325).
> 
> if BT_HCIBCM4325
> choice
>         prompt "BD_ADDR read from"
> config IDBLOCK
>         bool "NAND ID block"
> config WIFI_MAC
>         bool "WIFI MAC+1"
> endchoice
> endif
> 
> config BT_AUTOSLEEP
> 	tristate "Bluetooth auto sleep"
> 	depends on BT_HCIUART
> 	help
> 	  If the Bluetooth have no data transfer within three seconds, then 
>           it will automatically go to sleep until the arrival of new data
> 
231a271,281
> 
> if BCM4330
> choice
>         prompt "Select the bluetooth module"
>         default BT_MODULE_NH660
> 
>         config BT_MODULE_NH660
>         bool "AzureWave NH660"
> endchoice
> endif
> 




diff -r linux-3.0.36/drivers/bluetooth/Makefile linux-3.0.36-lenovo/drivers/bluetooth/Makefile
4a5
> obj-$(CONFIG_BT)		+= vflash.o
30a32
> hci_uart-$(CONFIG_BT_HCIUART_RTKH5) += hci_rtk_h5.o
Only in linux-3.0.36-lenovo/drivers/bluetooth: vflash.c
Only in linux-3.0.36-lenovo/drivers/char: dcc_tty.c




diff -r linux-3.0.36/drivers/char/Kconfig linux-3.0.36-lenovo/drivers/char/Kconfig
8a9,21
> config DEVMEM
> 	bool "Memory device driver"
> 	default y
> 	help
> 	  The memory driver provides two character devices, mem and kmem, which
> 	  provide access to the system's memory. The mem device is a view of
> 	  physical memory, and each byte in the device corresponds to the
> 	  matching physical address. The kmem device is the same as mem, but
> 	  the addresses correspond to the kernel's virtual address space rather
> 	  than physical memory. These devices are standard parts of a Linux
> 	  system and most users should say Y here. You might say N if very
> 	  security conscience or memory is tight.
> 
599a613,616
> 
> config DCC_TTY
> 	tristate "DCC tty driver"
> 	depends on ARM




diff -r linux-3.0.36/drivers/char/Makefile linux-3.0.36-lenovo/drivers/char/Makefile
60a61
> obj-$(CONFIG_DCC_TTY)		+= dcc_tty.o




diff -r linux-3.0.36/drivers/char/mem.c linux-3.0.36-lenovo/drivers/char/mem.c
58a59
> #if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
83a85
> #endif
84a87
> #ifdef CONFIG_DEVMEM
210a214,216
> #endif	/* CONFIG_DEVMEM */
> 
> #if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM)
331a338
> #endif	/* CONFIG_DEVMEM */
695a703,704
> #if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
> 
728a738,740
> #endif
> 
> #if defined(CONFIG_DEVMEM) || defined(CONFIG_DEVKMEM) || defined(CONFIG_DEVPORT)
732a745
> #endif
741a755
> #ifdef CONFIG_DEVMEM
749a764
> #endif
852a868
> #ifdef CONFIG_DEVMEM
853a870
> #endif




diff -r linux-3.0.36/drivers/char/mspec.c linux-3.0.36-lenovo/drivers/char/mspec.c
287c287
< 	vdata->refcnt = ATOMIC_INIT(1);
---
> 	atomic_set(&vdata->refcnt, 1);




diff -r linux-3.0.36/drivers/char/random.c linux-3.0.36-lenovo/drivers/char/random.c
127a128
>  *	void add_device_randomness(const void *buf, unsigned int size);
130c131
<  * 	void add_interrupt_randomness(int irq);
---
>  *	void add_interrupt_randomness(int irq, int irq_flags);
132a134,141
>  * add_device_randomness() is for adding data to the random pool that
>  * is likely to differ between two devices (or possibly even per boot).
>  * This would be things like MAC addresses or serial numbers, or the
>  * read-out of the RTC. This does *not* add any actual entropy to the
>  * pool, but it initializes the pool to different values for devices
>  * that might otherwise be identical and have very little entropy
>  * available to them (particularly common in the embedded world).
>  *
136,142c145,147
<  * add_interrupt_randomness() uses the inter-interrupt timing as random
<  * inputs to the entropy pool.  Note that not all interrupts are good
<  * sources of randomness!  For example, the timer interrupts is not a
<  * good choice, because the periodicity of the interrupts is too
<  * regular, and hence predictable to an attacker.  Network Interface
<  * Controller interrupts are a better measure, since the timing of the
<  * NIC interrupts are more unpredictable.
---
>  * add_interrupt_randomness() uses the interrupt timing as random
>  * inputs to the entropy pool. Using the cycle counters and the irq source
>  * as inputs, it feeds the randomness roughly once a second.
250a256,257
> #include <linux/ptrace.h>
> #include <linux/kmemcheck.h>
258a266
> #include <asm/irq_regs.h>
260a269,271
> #define CREATE_TRACE_POINTS
> #include <trace/events/random.h>
> 
268a280,281
> #define LONGS(x) (((x) + sizeof(unsigned long) - 1)/sizeof(unsigned long))
> 
422a436
> 	unsigned input_rotate;
424c438,439
< 	int input_rotate;
---
> 	int entropy_total;
> 	unsigned int initialized:1;
456a472,475
> static __u32 const twist_table[8] = {
> 	0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
> 	0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
> 
467,468c486,487
< static void mix_pool_bytes_extract(struct entropy_store *r, const void *in,
< 				   int nbytes, __u8 out[64])
---
> static void _mix_pool_bytes(struct entropy_store *r, const void *in,
> 			    int nbytes, __u8 out[64])
470,472d488
< 	static __u32 const twist_table[8] = {
< 		0x00000000, 0x3b6e20c8, 0x76dc4190, 0x4db26158,
< 		0xedb88320, 0xd6d6a3e8, 0x9b64c2b0, 0xa00ae278 };
478d493
< 	unsigned long flags;
480d494
< 	/* Taps are constant, so we can load them without holding r->lock.  */
487,489c501,503
< 	spin_lock_irqsave(&r->lock, flags);
< 	input_rotate = r->input_rotate;
< 	i = r->add_ptr;
---
> 	smp_rmb();
> 	input_rotate = ACCESS_ONCE(r->input_rotate);
> 	i = ACCESS_ONCE(r->add_ptr);
516,517c530,532
< 	r->input_rotate = input_rotate;
< 	r->add_ptr = i;
---
> 	ACCESS_ONCE(r->input_rotate) = input_rotate;
> 	ACCESS_ONCE(r->add_ptr) = i;
> 	smp_wmb();
521a537
> }
522a539,553
> static void __mix_pool_bytes(struct entropy_store *r, const void *in,
> 			     int nbytes, __u8 out[64])
> {
> 	trace_mix_pool_bytes_nolock(r->name, nbytes, _RET_IP_);
> 	_mix_pool_bytes(r, in, nbytes, out);
> }
> 
> static void mix_pool_bytes(struct entropy_store *r, const void *in,
> 			   int nbytes, __u8 out[64])
> {
> 	unsigned long flags;
> 
> 	trace_mix_pool_bytes(r->name, nbytes, _RET_IP_);
> 	spin_lock_irqsave(&r->lock, flags);
> 	_mix_pool_bytes(r, in, nbytes, out);
526c557,570
< static void mix_pool_bytes(struct entropy_store *r, const void *in, int bytes)
---
> struct fast_pool {
> 	__u32		pool[4];
> 	unsigned long	last;
> 	unsigned short	count;
> 	unsigned char	rotate;
> 	unsigned char	last_timer_intr;
> };
> 
> /*
>  * This is a fast mixing routine used by the interrupt randomness
>  * collector.  It's hardcoded for an 128 bit pool and assumes that any
>  * locks that might be needed are taken by the caller.
>  */
> static void fast_mix(struct fast_pool *f, const void *in, int nbytes)
528c572,584
<        mix_pool_bytes_extract(r, in, bytes, NULL);
---
> 	const char	*bytes = in;
> 	__u32		w;
> 	unsigned	i = f->count;
> 	unsigned	input_rotate = f->rotate;
> 
> 	while (nbytes--) {
> 		w = rol32(*bytes++, input_rotate & 31) ^ f->pool[i & 3] ^
> 			f->pool[(i + 1) & 3];
> 		f->pool[i & 3] = (w >> 3) ^ twist_table[w & 7];
> 		input_rotate += (i++ & 3) ? 7 : 14;
> 	}
> 	f->count = i;
> 	f->rotate = input_rotate;
536,537c592
< 	unsigned long flags;
< 	int entropy_count;
---
> 	int entropy_count, orig;
542,543d596
< 	spin_lock_irqsave(&r->lock, flags);
< 
545c598,599
< 	entropy_count = r->entropy_count;
---
> retry:
> 	entropy_count = orig = ACCESS_ONCE(r->entropy_count);
546a601
> 
552c607,617
< 	r->entropy_count = entropy_count;
---
> 	if (cmpxchg(&r->entropy_count, orig, entropy_count) != orig)
> 		goto retry;
> 
> 	if (!r->initialized && nbits > 0) {
> 		r->entropy_total += nbits;
> 		if (r->entropy_total > 128)
> 			r->initialized = 1;
> 	}
> 
> 	trace_credit_entropy_bits(r->name, nbits, entropy_count,
> 				  r->entropy_total, _RET_IP_);
559d623
< 	spin_unlock_irqrestore(&r->lock, flags);
575,602c639,647
< #ifndef CONFIG_GENERIC_HARDIRQS
< 
< static struct timer_rand_state *irq_timer_state[NR_IRQS];
< 
< static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
< {
< 	return irq_timer_state[irq];
< }
< 
< static void set_timer_rand_state(unsigned int irq,
< 				 struct timer_rand_state *state)
< {
< 	irq_timer_state[irq] = state;
< }
< 
< #else
< 
< static struct timer_rand_state *get_timer_rand_state(unsigned int irq)
< {
< 	struct irq_desc *desc;
< 
< 	desc = irq_to_desc(irq);
< 
< 	return desc->timer_rand_state;
< }
< 
< static void set_timer_rand_state(unsigned int irq,
< 				 struct timer_rand_state *state)
---
> /*
>  * Add device- or boot-specific data to the input and nonblocking
>  * pools to help initialize them to unique values.
>  *
>  * None of this adds any entropy, it is meant to avoid the
>  * problem of the nonblocking pool having similar initial state
>  * across largely identical devices.
>  */
> void add_device_randomness(const void *buf, unsigned int size)
604,606c649
< 	struct irq_desc *desc;
< 
< 	desc = irq_to_desc(irq);
---
> 	unsigned long time = get_cycles() ^ jiffies;
608c651,654
< 	desc->timer_rand_state = state;
---
> 	mix_pool_bytes(&input_pool, buf, size, NULL);
> 	mix_pool_bytes(&input_pool, &time, sizeof(time), NULL);
> 	mix_pool_bytes(&nonblocking_pool, buf, size, NULL);
> 	mix_pool_bytes(&nonblocking_pool, &time, sizeof(time), NULL);
610c656
< #endif
---
> EXPORT_SYMBOL(add_device_randomness);
627d672
< 		cycles_t cycles;
628a674
> 		unsigned cycles;
642c688
< 	mix_pool_bytes(&input_pool, &sample, sizeof(sample));
---
> 	mix_pool_bytes(&input_pool, &sample, sizeof(sample), NULL);
699c745,747
< void add_interrupt_randomness(int irq)
---
> static DEFINE_PER_CPU(struct fast_pool, irq_randomness);
> 
> void add_interrupt_randomness(int irq, int irq_flags)
701c749,761
< 	struct timer_rand_state *state;
---
> 	struct entropy_store	*r;
> 	struct fast_pool	*fast_pool = &__get_cpu_var(irq_randomness);
> 	struct pt_regs		*regs = get_irq_regs();
> 	unsigned long		now = jiffies;
> 	__u32			input[4], cycles = get_cycles();
> 
> 	input[0] = cycles ^ jiffies;
> 	input[1] = irq;
> 	if (regs) {
> 		__u64 ip = instruction_pointer(regs);
> 		input[2] = ip;
> 		input[3] = ip >> 32;
> 	}
703c763
< 	state = get_timer_rand_state(irq);
---
> 	fast_mix(fast_pool, input, sizeof(input));
705c765,766
< 	if (state == NULL)
---
> 	if ((fast_pool->count & 1023) &&
> 	    !time_after(now, fast_pool->last + HZ))
708,709c769,786
< 	DEBUG_ENT("irq event %d\n", irq);
< 	add_timer_randomness(state, 0x100 + irq);
---
> 	fast_pool->last = now;
> 
> 	r = nonblocking_pool.initialized ? &input_pool : &nonblocking_pool;
> 	__mix_pool_bytes(r, &fast_pool->pool, sizeof(fast_pool->pool), NULL);
> 	/*
> 	 * If we don't have a valid cycle counter, and we see
> 	 * back-to-back timer interrupts, then skip giving credit for
> 	 * any entropy.
> 	 */
> 	if (cycles == 0) {
> 		if (irq_flags & __IRQF_TIMER) {
> 			if (fast_pool->last_timer_intr)
> 				return;
> 			fast_pool->last_timer_intr = 1;
> 		} else
> 			fast_pool->last_timer_intr = 0;
> 	}
> 	credit_entropy_bits(r, 1);
741c818
< 	__u32 tmp[OUTPUT_POOL_WORDS];
---
> 	__u32	tmp[OUTPUT_POOL_WORDS];
760c837
< 		mix_pool_bytes(r, tmp, bytes);
---
> 		mix_pool_bytes(r, tmp, bytes, NULL);
819c896,900
< 	__u32 hash[5], workspace[SHA_WORKSPACE_WORDS];
---
> 	union {
> 		__u32 w[5];
> 		unsigned long l[LONGS(EXTRACT_SIZE)];
> 	} hash;
> 	__u32 workspace[SHA_WORKSPACE_WORDS];
820a902
> 	unsigned long flags;
823c905,906
< 	sha_init(hash);
---
> 	sha_init(hash.w);
> 	spin_lock_irqsave(&r->lock, flags);
825c908
< 		sha_transform(hash, (__u8 *)(r->pool + i), workspace);
---
> 		sha_transform(hash.w, (__u8 *)(r->pool + i), workspace);
836c919,920
< 	mix_pool_bytes_extract(r, hash, sizeof(hash), extract);
---
> 	__mix_pool_bytes(r, hash.w, sizeof(hash.w), extract);
> 	spin_unlock_irqrestore(&r->lock, flags);
842c926
< 	sha_transform(hash, extract, workspace);
---
> 	sha_transform(hash.w, extract, workspace);
851,855c935,951
< 	hash[0] ^= hash[3];
< 	hash[1] ^= hash[4];
< 	hash[2] ^= rol32(hash[2], 16);
< 	memcpy(out, hash, EXTRACT_SIZE);
< 	memset(hash, 0, sizeof(hash));
---
> 	hash.w[0] ^= hash.w[3];
> 	hash.w[1] ^= hash.w[4];
> 	hash.w[2] ^= rol32(hash.w[2], 16);
> 
> 	/*
> 	 * If we have a architectural hardware random number
> 	 * generator, mix that in, too.
> 	 */
> 	for (i = 0; i < LONGS(EXTRACT_SIZE); i++) {
> 		unsigned long v;
> 		if (!arch_get_random_long(&v))
> 			break;
> 		hash.l[i] ^= v;
> 	}
> 
> 	memcpy(out, &hash, EXTRACT_SIZE);
> 	memset(&hash, 0, sizeof(hash));
859c955
< 			       size_t nbytes, int min, int reserved)
---
> 				 size_t nbytes, int min, int reserved)
863d958
< 	unsigned long flags;
864a960
> 	trace_extract_entropy(r->name, nbytes, r->entropy_count, _RET_IP_);
871a968,969
> 			unsigned long flags;
> 
896a995
> 	trace_extract_entropy_user(r->name, nbytes, r->entropy_count, _RET_IP_);
930,931c1029,1031
<  * number of good random numbers, suitable for seeding TCP sequence
<  * numbers, etc.
---
>  * number of good random numbers, suitable for key generation, seeding
>  * TCP sequence numbers, etc.  It does not use the hw random number
>  * generator, if available; use get_random_bytes_arch() for that.
939a1040,1072
>  * This function will use the architecture-specific hardware random
>  * number generator if it is available.  The arch-specific hw RNG will
>  * almost certainly be faster than what we can do in software, but it
>  * is impossible to verify that it is implemented securely (as
>  * opposed, to, say, the AES encryption of a sequence number using a
>  * key known by the NSA).  So it's useful if we need the speed, but
>  * only if we're willing to trust the hardware manufacturer not to
>  * have put in a back door.
>  */
> void get_random_bytes_arch(void *buf, int nbytes)
> {
> 	char *p = buf;
> 
> 	trace_get_random_bytes(nbytes, _RET_IP_);
> 	while (nbytes) {
> 		unsigned long v;
> 		int chunk = min(nbytes, (int)sizeof(unsigned long));
> 
> 		if (!arch_get_random_long(&v))
> 			break;
> 
> 		memcpy(p, &v, chunk);
> 		p += chunk;
> 		nbytes -= chunk;
> 	}
> 
> 	if (nbytes)
> 		extract_entropy(&nonblocking_pool, p, nbytes, 0, 0);
> }
> EXPORT_SYMBOL(get_random_bytes_arch);
> 
> 
> /*
950,951c1083,1085
< 	ktime_t now;
< 	unsigned long flags;
---
> 	int i;
> 	ktime_t now = ktime_get_real();
> 	unsigned long rv;
953d1086
< 	spin_lock_irqsave(&r->lock, flags);
955,959c1088,1095
< 	spin_unlock_irqrestore(&r->lock, flags);
< 
< 	now = ktime_get_real();
< 	mix_pool_bytes(r, &now, sizeof(now));
< 	mix_pool_bytes(r, utsname(), sizeof(*(utsname())));
---
> 	r->entropy_total = 0;
> 	mix_pool_bytes(r, &now, sizeof(now), NULL);
> 	for (i = r->poolinfo->POOLBYTES; i > 0; i -= sizeof(rv)) {
> 		if (!arch_get_random_long(&rv))
> 			break;
> 		mix_pool_bytes(r, &rv, sizeof(rv), NULL);
> 	}
> 	mix_pool_bytes(r, utsname(), sizeof(*(utsname())), NULL);
961a1098,1107
> /*
>  * Note that setup_arch() may call add_device_randomness()
>  * long before we get here. This allows seeding of the pools
>  * with some platform dependent data very early in the boot
>  * process. But it limits our options here. We must use
>  * statically allocated structures that already have all
>  * initializations complete at compile time. We should also
>  * take care not to overwrite the precious per platform data
>  * we were given.
>  */
971,988d1116
< void rand_initialize_irq(int irq)
< {
< 	struct timer_rand_state *state;
< 
< 	state = get_timer_rand_state(irq);
< 
< 	if (state)
< 		return;
< 
< 	/*
< 	 * If kzalloc returns null, we just won't use that entropy
< 	 * source.
< 	 */
< 	state = kzalloc(sizeof(struct timer_rand_state), GFP_KERNEL);
< 	if (state)
< 		set_timer_rand_state(irq, state);
< }
< 
1096c1224
< 		mix_pool_bytes(r, buf, bytes);
---
> 		mix_pool_bytes(r, buf, bytes, NULL);
1239,1241d1366
< 		uuid[8] = 0;
< 	}
< 	if (uuid[8] == 0)
1242a1368,1375
> 	} else {
> 		static DEFINE_SPINLOCK(bootid_spinlock);
> 
> 		spin_lock(&bootid_spinlock);
> 		if (!uuid[8])
> 			generate_random_uuid(uuid);
> 		spin_unlock(&bootid_spinlock);
> 	}
1321c1454
< 	__u32 *hash = get_cpu_var(get_random_int_hash);
---
> 	__u32 *hash;
1322a1456,1460
> 
> 	if (arch_get_random_int(&ret))
> 		return ret;
> 
> 	hash = get_cpu_var(get_random_int_hash);
Only in linux-3.0.36-lenovo/drivers/char: rk_sysrq.c




diff -r linux-3.0.36/drivers/char/tpm/tpm.c linux-3.0.36-lenovo/drivers/char/tpm/tpm.c
1022c1022,1023
< 	size_t in_size = size, out_size;
---
> 	size_t in_size = size;
> 	ssize_t out_size;
1025,1029c1026,1030
< 	   either via tpm_read or a user_read_timer timeout */
< 	while (atomic_read(&chip->data_pending) != 0)
< 		msleep(TPM_TIMEOUT);
< 
< 	mutex_lock(&chip->buffer_mutex);
---
> 	   either via tpm_read or a user_read_timer timeout.
> 	   This also prevents splitted buffered writes from blocking here.
> 	*/
> 	if (atomic_read(&chip->data_pending) != 0)
> 		return -EBUSY;
1032c1033,1035
< 		in_size = TPM_BUFSIZE;
---
> 		return -E2BIG;
> 
> 	mutex_lock(&chip->buffer_mutex);
1041a1045,1048
> 	if (out_size < 0) {
> 		mutex_unlock(&chip->buffer_mutex);
> 		return out_size;
> 	}




diff -r linux-3.0.36/drivers/char/ttyprintk.c linux-3.0.36-lenovo/drivers/char/ttyprintk.c
69c69
< 				if (buf[i + 1] == '\n')
---
> 				if ((i + 1) < count && buf[i + 1] == '\n')




diff -r linux-3.0.36/drivers/char/virtio_console.c linux-3.0.36-lenovo/drivers/char/virtio_console.c
1753c1753,1754
< 	cancel_work_sync(&portdev->control_work);
---
> 	if (use_multiport(portdev))
> 		cancel_work_sync(&portdev->control_work);
Only in linux-3.0.36-lenovo/drivers: cir
Only in linux-3.0.36-lenovo/drivers: cmmb
Only in linux-3.0.36-lenovo/drivers/cpufreq: cpufreq_interactive.c




diff -r linux-3.0.36/drivers/cpufreq/cpufreq_ondemand.c linux-3.0.36-lenovo/drivers/cpufreq/cpufreq_ondemand.c
34a35,38
> #ifdef CONFIG_ARCH_RK29
> #define MICRO_FREQUENCY_DOWN_DIFFERENTIAL	(10)
> #define MICRO_FREQUENCY_UP_THRESHOLD		(80)
> #else
36a41
> #endif




diff -r linux-3.0.36/drivers/cpufreq/cpufreq_stats.c linux-3.0.36-lenovo/drivers/cpufreq/cpufreq_stats.c
161a162,165
> #ifdef CONFIG_PLAT_RK
> 	if (!stat->freq_table)
> 		return -1;
> #endif
217a222
> #ifndef CONFIG_PLAT_RK
218a224
> #endif
255a262,264
> #ifdef CONFIG_PLAT_RK
> 	per_cpu(cpufreq_stats_table, cpu) = stat;
> #endif
319a329,349
> static int cpufreq_stats_create_table_cpu(unsigned int cpu)
> {
> 	struct cpufreq_policy *policy;
> 	struct cpufreq_frequency_table *table;
> 	int ret = -ENODEV;
> 
> 	policy = cpufreq_cpu_get(cpu);
> 	if (!policy)
> 		return -ENODEV;
> 
> 	table = cpufreq_frequency_get_table(cpu);
> 	if (!table)
> 		goto out;
> 
> 	ret = cpufreq_stats_create_table(policy, table);
> 
> out:
> 	cpufreq_cpu_put(policy);
> 	return ret;
> }
> 
336a367,370
> 		break;
> 	case CPU_DOWN_FAILED:
> 	case CPU_DOWN_FAILED_FROZEN:
> 		cpufreq_stats_create_table_cpu(cpu);




diff -r linux-3.0.36/drivers/cpufreq/Kconfig linux-3.0.36-lenovo/drivers/cpufreq/Kconfig
101a102,111
> 
> config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
> 	bool "interactive"
> 	select CPU_FREQ_GOV_INTERACTIVE
> 	help
> 	  Use the CPUFreq governor 'interactive' as default. This allows
> 	  you to get a full dynamic cpu frequency capable system by simply
> 	  loading your cpufreq low-level hardware driver, using the
> 	  'interactive' governor for latency-sensitive workloads.
> 
153a164,180
> 
> 	  For details, take a look at linux/Documentation/cpu-freq.
> 
> 	  If in doubt, say N.
> 
> config CPU_FREQ_GOV_INTERACTIVE
> 	tristate "'interactive' cpufreq policy governor"
> 	help
> 	  'interactive' - This driver adds a dynamic cpufreq policy governor
> 	  designed for latency-sensitive workloads.
> 
> 	  This governor attempts to reduce the latency of clock
> 	  increases so that the system is more responsive to
> 	  interactive workloads.
> 
> 	  To compile this driver as a module, choose M here: the
> 	  module will be called cpufreq_interactive.




diff -r linux-3.0.36/drivers/cpufreq/Makefile linux-3.0.36-lenovo/drivers/cpufreq/Makefile
11a12
> obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o




diff -r linux-3.0.36/drivers/cpufreq/powernow-k8.c linux-3.0.36-lenovo/drivers/cpufreq/powernow-k8.c
35d34
< #include <linux/sched.h>	/* for current / set_cpus_allowed() */
1135,1139c1134,1145
< /* Driver entry point to switch to the target frequency */
< static int powernowk8_target(struct cpufreq_policy *pol,
< 		unsigned targfreq, unsigned relation)
< {
< 	cpumask_var_t oldmask;
---
> struct powernowk8_target_arg {
> 	struct cpufreq_policy		*pol;
> 	unsigned			targfreq;
> 	unsigned			relation;
> };
> 
> static long powernowk8_target_fn(void *arg)
> {
> 	struct powernowk8_target_arg *pta = arg;
> 	struct cpufreq_policy *pol = pta->pol;
> 	unsigned targfreq = pta->targfreq;
> 	unsigned relation = pta->relation;
1144c1150
< 	int ret = -EIO;
---
> 	int ret;
1152,1164d1157
< 	/* only run on specific CPU from here on. */
< 	/* This is poor form: use a workqueue or smp_call_function_single */
< 	if (!alloc_cpumask_var(&oldmask, GFP_KERNEL))
< 		return -ENOMEM;
< 
< 	cpumask_copy(oldmask, tsk_cpus_allowed(current));
< 	set_cpus_allowed_ptr(current, cpumask_of(pol->cpu));
< 
< 	if (smp_processor_id() != pol->cpu) {
< 		printk(KERN_ERR PFX "limiting to cpu %u failed\n", pol->cpu);
< 		goto err_out;
< 	}
< 
1167c1160
< 		goto err_out;
---
> 		return -EIO;
1174c1167
< 		goto err_out;
---
> 		return -EIO;
1192c1185
< 		goto err_out;
---
> 		return -EIO;
1205d1197
< 		ret = 1;
1207c1199
< 		goto err_out;
---
> 		return 1;
1216d1207
< 	ret = 0;
1218,1221c1209,1219
< err_out:
< 	set_cpus_allowed_ptr(current, oldmask);
< 	free_cpumask_var(oldmask);
< 	return ret;
---
> 	return 0;
> }
> 
> /* Driver entry point to switch to the target frequency */
> static int powernowk8_target(struct cpufreq_policy *pol,
> 		unsigned targfreq, unsigned relation)
> {
> 	struct powernowk8_target_arg pta = { .pol = pol, .targfreq = targfreq,
> 					     .relation = relation };
> 
> 	return work_on_cpu(pol->cpu, powernowk8_target_fn, &pta);




diff -r linux-3.0.36/drivers/cpuidle/governors/menu.c linux-3.0.36-lenovo/drivers/cpuidle/governors/menu.c
175c175,180
< 	mult += 2 * get_loadavg();
---
> 	/*
> 	 * this doesn't work as intended - it is almost always 0, but can
> 	 * sometimes, depending on workload, spike very high into the hundreds
> 	 * even when the average cpu load is under 10%.
> 	 */
> 	/* mult += 2 * get_loadavg(); */
Only in linux-3.0.36-lenovo/drivers: dbg




diff -r linux-3.0.36/drivers/dma/at_hdmac.c linux-3.0.36-lenovo/drivers/dma/at_hdmac.c
677c677
< 		dev_dbg(chan2dev(chan), "prep_dma_memcpy: length is zero!\n");
---
> 		dev_dbg(chan2dev(chan), "prep_slave_sg: sg length is zero!\n");
704a705,709
> 			if (unlikely(!len)) {
> 				dev_dbg(chan2dev(chan),
> 					"prep_slave_sg: sg(%d) data length is zero\n", i);
> 				goto err;
> 			}
738a744,748
> 			if (unlikely(!len)) {
> 				dev_dbg(chan2dev(chan),
> 					"prep_slave_sg: sg(%d) data length is zero\n", i);
> 				goto err;
> 			}
771a782
> err:




diff -r linux-3.0.36/drivers/dma/ioat/dma_v3.c linux-3.0.36-lenovo/drivers/dma/ioat/dma_v3.c
952c952
< 	dma_sync_single_for_device(dev, dest_dma, PAGE_SIZE, DMA_TO_DEVICE);
---
> 	dma_sync_single_for_device(dev, dest_dma, PAGE_SIZE, DMA_FROM_DEVICE);




diff -r linux-3.0.36/drivers/edac/amd64_edac.c linux-3.0.36-lenovo/drivers/edac/amd64_edac.c
163a164,166
> 	 *
> 	 * If no suitable bandwidth is found, turn off DRAM scrubbing entirely
> 	 * by falling back to the last element in scrubrates[].
165c168
< 	for (i = 0; i < ARRAY_SIZE(scrubrates); i++) {
---
> 	for (i = 0; i < ARRAY_SIZE(scrubrates) - 1; i++) {
175,180d177
< 
< 		/*
< 		 * if no suitable bandwidth found, turn off DRAM scrubbing
< 		 * entirely by falling back to the last element in the
< 		 * scrubrates array.
< 		 */




diff -r linux-3.0.36/drivers/edac/edac_pci_sysfs.c linux-3.0.36-lenovo/drivers/edac/edac_pci_sysfs.c
260c260
< 	if (edac_pci_dev->show)
---
> 	if (edac_pci_dev->store)




diff -r linux-3.0.36/drivers/edac/i7core_edac.c linux-3.0.36-lenovo/drivers/edac/i7core_edac.c
1845d1844
< #ifdef CONFIG_SMP
1849d1847
< #endif




diff -r linux-3.0.36/drivers/firewire/core-cdev.c linux-3.0.36-lenovo/drivers/firewire/core-cdev.c
474,475c474,475
< 		ret = copy_to_user(u64_to_uptr(a->bus_reset),
< 				   &bus_reset, sizeof(bus_reset));
---
> 		/* unaligned size of bus_reset is 36 bytes */
> 		ret = copy_to_user(u64_to_uptr(a->bus_reset), &bus_reset, 36);




diff -r linux-3.0.36/drivers/firewire/net.c linux-3.0.36-lenovo/drivers/firewire/net.c
866,867c866,867
< 		fwnet_incoming_packet(dev, buf_ptr, length,
< 				      source_node_id, -1, true);
---
> 		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,
> 				      context->card->generation, true);
962c962,967
< 		skb_pull(skb, ptask->max_payload);
---
> 		if (ptask->dest_node == IEEE1394_ALL_NODES) {
> 			skb_pull(skb,
> 				 ptask->max_payload + IEEE1394_GASP_HDR_SIZE);
> 		} else {
> 			skb_pull(skb, ptask->max_payload);
> 		}
1065c1070
< 		p = skb_push(ptask->skb, 8);
---
> 		p = skb_push(ptask->skb, IEEE1394_GASP_HDR_SIZE);




diff -r linux-3.0.36/drivers/firmware/dmi_scan.c linux-3.0.36-lenovo/drivers/firmware/dmi_scan.c
8a9
> #include <linux/random.h>
17a19
> static u16 __initdata dmi_ver;
113a116,117
> 	add_device_randomness(buf, dmi_len);
> 
118c122
< static int __init dmi_checksum(const u8 *buf)
---
> static int __init dmi_checksum(const u8 *buf, u8 len)
123c127
< 	for (a = 0; a < 15; a++)
---
> 	for (a = 0; a < len; a++)
161,162c165,168
< 		if(d[i] != 0x00) is_ff = 0;
< 		if(d[i] != 0xFF) is_00 = 0;
---
> 		if (d[i] != 0x00)
> 			is_00 = 0;
> 		if (d[i] != 0xFF)
> 			is_ff = 0;
172c178,186
< 	sprintf(s, "%pUB", d);
---
> 	/*
> 	 * As of version 2.6 of the SMBIOS specification, the first 3 fields of
> 	 * the UUID are supposed to be little-endian encoded.  The specification
> 	 * says that this is the defacto standard.
> 	 */
> 	if (dmi_ver >= 0x0206)
> 		sprintf(s, "%pUL", d);
> 	else
> 		sprintf(s, "%pUB", d);
404c418
< 	if ((memcmp(buf, "_DMI_", 5) == 0) && dmi_checksum(buf)) {
---
> 	if (dmi_checksum(buf, 15)) {
410,418d423
< 		/*
< 		 * DMI version 0.0 means that the real version is taken from
< 		 * the SMBIOS version, which we don't know at this point.
< 		 */
< 		if (buf[14] != 0)
< 			printk(KERN_INFO "DMI %d.%d present.\n",
< 			       buf[14] >> 4, buf[14] & 0xF);
< 		else
< 			printk(KERN_INFO "DMI present.\n");
419a425,433
> 			if (dmi_ver)
> 				pr_info("SMBIOS %d.%d present.\n",
> 				       dmi_ver >> 8, dmi_ver & 0xFF);
> 			else {
> 				dmi_ver = (buf[14] & 0xF0) << 4 |
> 					   (buf[14] & 0x0F);
> 				pr_info("Legacy DMI %d.%d present.\n",
> 				       dmi_ver >> 8, dmi_ver & 0xFF);
> 			}
423a438
> 	dmi_ver = 0;
426a442,468
> static int __init smbios_present(const char __iomem *p)
> {
> 	u8 buf[32];
> 	int offset = 0;
> 
> 	memcpy_fromio(buf, p, 32);
> 	if ((buf[5] < 32) && dmi_checksum(buf, buf[5])) {
> 		dmi_ver = (buf[6] << 8) + buf[7];
> 
> 		/* Some BIOS report weird SMBIOS version, fix that up */
> 		switch (dmi_ver) {
> 		case 0x021F:
> 		case 0x0221:
> 			pr_debug("SMBIOS version fixup(2.%d->2.%d)\n",
> 			       dmi_ver & 0xFF, 3);
> 			dmi_ver = 0x0203;
> 			break;
> 		case 0x0233:
> 			pr_debug("SMBIOS version fixup(2.%d->2.%d)\n", 51, 6);
> 			dmi_ver = 0x0206;
> 			break;
> 		}
> 		offset = 16;
> 	}
> 	return dmi_present(buf + offset);
> }
> 
444c486
< 		rc = dmi_present(p + 0x10); /* offset of _DMI_ string */
---
> 		rc = smbios_present(p);
462c504,509
< 			rc = dmi_present(q);
---
> 			if (memcmp(q, "_SM_", 4) == 0 && q - p <= 0xFFE0)
> 				rc = smbios_present(q);
> 			else if (memcmp(q, "_DMI_", 5) == 0)
> 				rc = dmi_present(q);
> 			else
> 				continue;




diff -r linux-3.0.36/drivers/firmware/efivars.c linux-3.0.36-lenovo/drivers/firmware/efivars.c
403c403
< 	if (var->Attributes & 0x1)
---
> 	if (var->Attributes & EFI_VARIABLE_NON_VOLATILE)
405c405
< 	if (var->Attributes & 0x2)
---
> 	if (var->Attributes & EFI_VARIABLE_BOOTSERVICE_ACCESS)
407c407
< 	if (var->Attributes & 0x4)
---
> 	if (var->Attributes & EFI_VARIABLE_RUNTIME_ACCESS)
408a409,419
> 	if (var->Attributes & EFI_VARIABLE_HARDWARE_ERROR_RECORD)
> 		str += sprintf(str, "EFI_VARIABLE_HARDWARE_ERROR_RECORD\n");
> 	if (var->Attributes & EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS)
> 		str += sprintf(str,
> 			"EFI_VARIABLE_AUTHENTICATED_WRITE_ACCESS\n");
> 	if (var->Attributes &
> 			EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS)
> 		str += sprintf(str,
> 			"EFI_VARIABLE_TIME_BASED_AUTHENTICATED_WRITE_ACCESS\n");
> 	if (var->Attributes & EFI_VARIABLE_APPEND_WRITE)
> 		str += sprintf(str, "EFI_VARIABLE_APPEND_WRITE\n");




diff -r linux-3.0.36/drivers/firmware/pcdp.c linux-3.0.36-lenovo/drivers/firmware/pcdp.c
98c98
< 	pcdp = ioremap(efi.hcdp, 4096);
---
> 	pcdp = early_ioremap(efi.hcdp, 4096);
134c134
< 	iounmap(pcdp);
---
> 	early_iounmap(pcdp, 4096);
Only in linux-3.0.36-lenovo/drivers/gpio: expand_gpio_soft_interrupt.c
Only in linux-3.0.36-lenovo/drivers/gpio: expand_gpio_soft_interrupt.h




diff -r linux-3.0.36/drivers/gpio/gpiolib.c linux-3.0.36-lenovo/drivers/gpio/gpiolib.c
1228c1228
< EXPORT_SYMBOL_GPL(gpio_request);
---
> EXPORT_SYMBOL(gpio_request);//EXPORT_SYMBOL_GPL(gpio_request);
1265c1265,1267
< EXPORT_SYMBOL_GPL(gpio_free);
---
> //EXPORT_SYMBOL_GPL(gpio_free);
> EXPORT_SYMBOL(gpio_free);
> 
1421c1423,1425
< EXPORT_SYMBOL_GPL(gpio_direction_input);
---
> //EXPORT_SYMBOL_GPL(gpio_direction_input);
> EXPORT_SYMBOL(gpio_direction_input);
> 
1431a1436,1437
> 	if (value !=0 && value !=1)
> 		goto fail;
1476c1482,1543
< EXPORT_SYMBOL_GPL(gpio_direction_output);
---
> //EXPORT_SYMBOL_GPL(gpio_direction_output);
> EXPORT_SYMBOL(gpio_direction_output);
> 
> /* 
> gpio pull up or pull down
> value = 0, normal
> value = 1, pull up
> value = 2, pull down
> */
> int gpio_pull_updown(unsigned gpio, unsigned value)
> {
> 	unsigned long		flags;
> 	struct gpio_chip	*chip;
> 	struct gpio_desc	*desc = &gpio_desc[gpio];
> 	int			status = -EINVAL;
> 
> 	spin_lock_irqsave(&gpio_lock, flags);
> 	
> 	if (value >3)
> 		goto fail;
> 	if (!gpio_is_valid(gpio))
> 		goto fail;
> 	chip = desc->chip;
> 	if (!chip || !chip->get || !chip->pull_updown)
> 		goto fail;
> 	gpio -= chip->base;
> 	if (gpio >= chip->ngpio)
> 		goto fail;
> 	status = gpio_ensure_requested(desc, gpio);
> 	if (status < 0)
> 		goto fail;
> 
> 	/* now we know the gpio is valid and chip won't vanish */
> 
> 	spin_unlock_irqrestore(&gpio_lock, flags);
> 
> 	might_sleep_if(extra_checks && chip->can_sleep);
> 
> 	if (status) {
> 		status = chip->request(chip, gpio);
> 		if (status < 0) {
> 			pr_debug("GPIO-%d: chip request fail, %d\n",
> 				chip->base + gpio, status);
> 			/* and it's not available to anyone else ...
> 			 * gpio_request() is the fully clean solution.
> 			 */
> 			goto lose;
> 		}
> 	}
> 	status = chip->pull_updown(chip, gpio,value);
> 	
> lose:
> 	return status;
> fail:
> 	spin_unlock_irqrestore(&gpio_lock, flags);
> 	if (status)
> 		pr_debug("%s: gpio-%d status %d\n",
> 			__func__, gpio, status);
> 	return status;
> }
> //EXPORT_SYMBOL_GPL(gpio_pull_updown);
> EXPORT_SYMBOL(gpio_pull_updown);
1557a1625,1626
> 	if (!gpio_is_valid(gpio))
> 		return -1;
1564c1633,1635
< EXPORT_SYMBOL_GPL(__gpio_get_value);
---
> //EXPORT_SYMBOL_GPL(__gpio_get_value);
> EXPORT_SYMBOL(__gpio_get_value);
> 
1578a1650,1653
> 	if(value !=0 && value !=1)
> 		return;
> 	if (!gpio_is_valid(gpio))
> 		 return;
1584c1659,1660
< EXPORT_SYMBOL_GPL(__gpio_set_value);
---
> //EXPORT_SYMBOL_GPL(__gpio_set_value);
> EXPORT_SYMBOL(__gpio_set_value);
1617c1693,1696
< 
---
> 	
> 	if (!gpio_is_valid(gpio))
> 		 return -1;
> 	
1619c1698,1699
< 	return chip->to_irq ? chip->to_irq(chip, gpio - chip->base) : -ENXIO;
---
> 	
> 	return chip->to_irq ? chip->to_irq(chip, gpio - chip->base) : -1;
Only in linux-3.0.36-lenovo/drivers/gpio: gpio-rk29.c
Only in linux-3.0.36-lenovo/drivers/gpio: gpio-rk30.c
Only in linux-3.0.36-lenovo/drivers/gpio: gpio-tps65910.c




diff -r linux-3.0.36/drivers/gpio/Kconfig linux-3.0.36-lenovo/drivers/gpio/Kconfig
263a264,269
> config GPIO_TPS65912
> 	tristate "TI TPS65912 GPIO"
> 	depends on (MFD_TPS65912_I2C || MFD_TPS65912_SPI)
> 	help
> 	  This driver supports TPS65912 gpio chip
> 
433a440,478
> 
> config GPIO_PCA9554
> 	bool "GPIO EXPANDER PCA9554"
> 	depends on I2C
> 	help
> 	  Say yes here to access the PCA9554 GPIO EXPANDER
> 
> config IOEXTEND_TCA6424
>  	bool "ROCKCHIP TCA6424 CONTROL"
> 	depends on I2C
> 	help
> 	  Say yes here to access the TCA6424 GPIO EXPANDER
> 
> config EXPANDED_GPIO_NUM  
> 	int "setting the amount of expanded gpios"
> 	help
> 	  for tca6424, set 24
> 	
> config EXPANDED_GPIO_IRQ_NUM
> 	int "setting the amount of expanded gpio irqs"
> 	help
> 	  for tca6424, set 24	
> 
> config EXPAND_GPIO_SOFT_INTERRUPT
> 	bool "soft interrupt for expand gpio use"
> 	help
> 	  if you want expand gpio support interrupt,choose it
> 
> config SPI_FPGA_GPIO_NUM  
> 	default 96
> 	int "setting the amount of fpga gpios"
> 	help
> 	  for fpga, set 96,no used ,set 0
> 	
> config SPI_FPGA_GPIO_IRQ_NUM
> 	default 16
> 	int "setting the amount of fpga gpio irqs"
> 	help
> 	  for fpga, set 16,no used ,set 0	




diff -r linux-3.0.36/drivers/gpio/Makefile linux-3.0.36-lenovo/drivers/gpio/Makefile
38a39,41
> obj-$(CONFIG_GPIO_PCA9554)	+= pca9554.o
> obj-$(CONFIG_IOEXTEND_TCA6424)	+= tca6424.o
> obj-$(CONFIG_EXPAND_GPIO_SOFT_INTERRUPT) += expand_gpio_soft_interrupt.o
44a48,51
> obj-$(CONFIG_ARCH_RK29)		+= gpio-rk29.o
> obj-$(CONFIG_ARCH_RK2928)	+= gpio-rk30.o
> obj-$(CONFIG_ARCH_RK30)		+= gpio-rk30.o
> obj-$(CONFIG_ARCH_RK3188)	+= gpio-rk30.o
50c57,58
< obj-$(CONFIG_GPIO_TPS65910)	+= tps65910-gpio.o
---
> obj-$(CONFIG_GPIO_TPS65910)	+= gpio-tps65910.o
> obj-$(CONFIG_GPIO_TPS65912)	+= gpio-tps65912.o
Only in linux-3.0.36-lenovo/drivers/gpio: pca9554.c
Only in linux-3.0.36-lenovo/drivers/gpio: tca6424.c




diff -r linux-3.0.36/drivers/gpio/wm831x-gpio.c linux-3.0.36-lenovo/drivers/gpio/wm831x-gpio.c
37a38,53
> static int wm831x_gpio_pull_up_down(struct gpio_chip *chip, unsigned offset, unsigned value)
> {
> 	struct wm831x_gpio *wm831x_gpio = to_wm831x_gpio(chip);
> 	struct wm831x *wm831x = wm831x_gpio->wm831x;
> 
> 	if(value == GPIOPullUp)
> 		value = WM831X_GPIO_PULL_UP;
> 	else if(value == GPIOPullDown)
> 		value = WM831X_GPIO_PULL_DOWN;
> 	else if(value == GPIONormal)
> 		value = WM831X_GPIO_PULL_NONE;
> 	//printk("wm831x_gpio_pull_up_down=%x,%x\n",WM831X_GPIO1_CONTROL + offset,value);
> 	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + offset, 
> 		WM831X_GPN_PULL_MASK, value);
> }
> 
46c62
< 
---
> 	//printk("wm831x_gpio_direction_in=%x,%x\n",WM831X_GPIO1_CONTROL + offset,val);
57c73,79
< 
---
> 	int gpn_pol;
> 	
> 	ret = wm831x_reg_read(wm831x, WM831X_GPIO1_CONTROL + offset);
> 	if (ret < 0)
> 		return ret;
> 	gpn_pol = (ret & WM831X_GPN_POL_MASK) >> WM831X_GPN_POL_SHIFT;
> 	
58a81
> 	//printk("wm831x_gpio_get=%x,%d,%d\n",ret,offset,gpn_pol);
61,65c84,85
< 
< 	if (ret & 1 << offset)
< 		return 1;
< 	else
< 		return 0;
---
> 	
> 	return !((ret>>offset)^gpn_pol);
87c107
< 
---
> 	//printk("wm831x_gpio_direction_out=%x,%x\n",WM831X_GPIO1_CONTROL + offset,val);
90c110
< 			      WM831X_GPN_FN_MASK, val);
---
> 			      WM831X_GPN_FN_MASK | WM831X_GPN_POL_MASK, val|WM831X_GPN_POL);
138c158
< 
---
> 	//printk("wm831x_gpio_set_debounce=%x,%x\n",WM831X_GPIO1_CONTROL + offset,fn);
241a262
> 	.pull_updown    = wm831x_gpio_pull_up_down,
254c275
< 
---
> 	printk("%s\n",__FUNCTION__);
258c279
< 
---
> 	
273a295,305
> 
> #ifdef CONFIG_PLAT_RK
> 	if (pdata && pdata->pin_type_init) {
> 		ret = pdata->pin_type_init(wm831x);
> 		if (ret != 0) {
> 			dev_err(wm831x->dev, "pin_type_init() failed: %d\n", ret);
> 			WARN_ON(gpiochip_remove(&wm831x_gpio->gpio_chip));
> 			goto err;
> 		}
> 	}
> #endif




diff -r linux-3.0.36/drivers/gpu/drm/drm_edid.c linux-3.0.36-lenovo/drivers/gpu/drm/drm_edid.c
587c587
< 		bool ret;
---
> 		bool ret = false;




diff -r linux-3.0.36/drivers/gpu/drm/drm_fops.c linux-3.0.36-lenovo/drivers/gpu/drm/drm_fops.c
138c138
< 		if (!dev->open_count++)
---
> 		if (!dev->open_count++) {
139a140,142
> 			if (retcode)
> 				dev->open_count--;
> 		}




diff -r linux-3.0.36/drivers/gpu/drm/i915/i915_gem_execbuffer.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/i915_gem_execbuffer.c
657a658,659
> 		u64 invalid_offset = (u64)-1;
> 		int j;
665a668,686
> 		}
> 
> 		/* As we do not update the known relocation offsets after
> 		 * relocating (due to the complexities in lock handling),
> 		 * we need to mark them as invalid now so that we force the
> 		 * relocation processing next time. Just in case the target
> 		 * object is evicted and then rebound into its old
> 		 * presumed_offset before the next execbuffer - if that
> 		 * happened we would make the mistake of assuming that the
> 		 * relocations were valid.
> 		 */
> 		for (j = 0; j < exec[i].relocation_count; j++) {
> 			if (copy_to_user(&user_relocs[j].presumed_offset,
> 					 &invalid_offset,
> 					 sizeof(invalid_offset))) {
> 				ret = -EFAULT;
> 				mutex_lock(&dev->struct_mutex);
> 				goto err;
> 			}




diff -r linux-3.0.36/drivers/gpu/drm/i915/i915_reg.h linux-3.0.36-lenovo/drivers/gpu/drm/i915/i915_reg.h
29a30,31
> #define _MASKED_BIT_ENABLE(a) (((a) << 16) | (a))
> 
356a359
> #define _3D_CHICKEN_HIZ_PLANE_DISABLE_MSAA_4X_SNB	(1 << 10)
2756a2760,2761
> #define  PF_PIPE_SEL_MASK_IVB	(3<<29)
> #define  PF_PIPE_SEL_IVB(pipe)	((pipe)<<29)
3114a3120,3124
> 
> #define _TRANSA_CHICKEN2	 0xf0064
> #define _TRANSB_CHICKEN2	 0xf1064
> #define TRANS_CHICKEN2(pipe) _PIPE(pipe, _TRANSA_CHICKEN2, _TRANSB_CHICKEN2)
> #define   TRANS_AUTOTRAIN_GEN_STALL_DIS	(1<<31)




diff -r linux-3.0.36/drivers/gpu/drm/i915/i915_suspend.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/i915_suspend.c
742c742,744
< 		I915_WRITE(BLC_PWM_CPU_CTL, dev_priv->saveBLC_CPU_PWM_CTL);
---
> 		/* NOTE: BLC_PWM_CPU_CTL must be written after BLC_PWM_CPU_CTL2;
> 		 * otherwise we get blank eDP screen after S3 on some machines
> 		 */
743a746
> 		I915_WRITE(BLC_PWM_CPU_CTL, dev_priv->saveBLC_CPU_PWM_CTL);




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_display.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_display.c
2699c2699,2703
< 		I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3);
---
> 		if (IS_IVYBRIDGE(dev))
> 			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3 |
> 						 PF_PIPE_SEL_IVB(pipe));
> 		else
> 			I915_WRITE(PF_CTL(pipe), PF_ENABLE | PF_FILTER_MED_3x3);
7410a7415,7418
> 	/* WaDisableHiZPlanesWhenMSAAEnabled */
> 	I915_WRITE(_3D_CHICKEN,
> 		   _MASKED_BIT_ENABLE(_3D_CHICKEN_HIZ_PLANE_DISABLE_MSAA_4X_SNB));
> 
7586a7595
> 	int pipe;
7595a7605,7607
> 	/* Without this, mode sets may fail silently on FDI */
> 	for_each_pipe(pipe)
> 		I915_WRITE(TRANS_CHICKEN2(pipe), TRANS_AUTOTRAIN_GEN_STALL_DIS);




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_drv.h linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_drv.h
207c207
< 		} avi;
---
> 		} __attribute__ ((packed)) avi;




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_hdmi.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_hdmi.c
163c163
< 	if (intel_hdmi->has_audio)
---
> 	if (intel_hdmi->has_audio || mode != DRM_MODE_DPMS_ON)




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_lvds.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_lvds.c
753a754,769
> 	{
> 		.callback = intel_no_lvds_dmi_callback,
> 		.ident = "Gigabyte GA-D525TUD",
> 		.matches = {
> 			DMI_MATCH(DMI_BOARD_VENDOR, "Gigabyte Technology Co., Ltd."),
> 			DMI_MATCH(DMI_BOARD_NAME, "D525TUD"),
> 		},
> 	},
> 	{
> 		.callback = intel_no_lvds_dmi_callback,
> 		.ident = "Supermicro X7SPA-H",
> 		.matches = {
> 			DMI_MATCH(DMI_SYS_VENDOR, "Supermicro"),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "X7SPA-H"),
> 		},
> 	},




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_overlay.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_overlay.c
431,433c431,441
< 	OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_OFF);
< 	OUT_RING(flip_addr);
< 	OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
---
> 	if (IS_I830(dev)) {
> 		/* Workaround: Don't disable the overlay fully, since otherwise
> 		 * it dies on the next OVERLAY_ON cmd. */
> 		OUT_RING(MI_NOOP);
> 		OUT_RING(MI_NOOP);
> 		OUT_RING(MI_NOOP);
> 	} else {
> 		OUT_RING(MI_OVERLAY_FLIP | MI_OVERLAY_OFF);
> 		OUT_RING(flip_addr);
> 		OUT_RING(MI_WAIT_FOR_EVENT | MI_WAIT_FOR_OVERLAY_FLIP);
> 	}




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_ringbuffer.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_ringbuffer.c
153,154d152
< 	/* Initialize the ring. */
< 	I915_WRITE_START(ring, obj->gtt_offset);
179a178,182
> 	/* Initialize the ring. This must happen _after_ we've cleared the ring
> 	 * registers with the above sequence (the readback of the HEAD registers
> 	 * also enforces ordering), otherwise the hw might lose the new ring
> 	 * register values. */
> 	I915_WRITE_START(ring, obj->gtt_offset);




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_sdvo.c linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_sdvo.c
864c864,866
< static bool intel_sdvo_set_avi_infoframe(struct intel_sdvo *intel_sdvo)
---
> static bool intel_sdvo_write_infoframe(struct intel_sdvo *intel_sdvo,
> 				       unsigned if_index, uint8_t tx_rate,
> 				       uint8_t *data, unsigned length)
866,876c868,870
< 	struct dip_infoframe avi_if = {
< 		.type = DIP_TYPE_AVI,
< 		.ver = DIP_VERSION_AVI,
< 		.len = DIP_LEN_AVI,
< 	};
< 	uint8_t tx_rate = SDVO_HBUF_TX_VSYNC;
< 	uint8_t set_buf_index[2] = { 1, 0 };
< 	uint64_t *data = (uint64_t *)&avi_if;
< 	unsigned i;
< 
< 	intel_dip_infoframe_csum(&avi_if);
---
> 	uint8_t set_buf_index[2] = { if_index, 0 };
> 	uint8_t hbuf_size, tmp[8];
> 	int i;
883c877,891
< 	for (i = 0; i < sizeof(avi_if); i += 8) {
---
> 	if (!intel_sdvo_get_value(intel_sdvo, SDVO_CMD_GET_HBUF_INFO,
> 				  &hbuf_size, 1))
> 		return false;
> 
> 	/* Buffer size is 0 based, hooray! */
> 	hbuf_size++;
> 
> 	DRM_DEBUG_KMS("writing sdvo hbuf: %i, hbuf_size %i, hbuf_size: %i\n",
> 		      if_index, length, hbuf_size);
> 
> 	for (i = 0; i < hbuf_size; i += 8) {
> 		memset(tmp, 0, 8);
> 		if (i < length)
> 			memcpy(tmp, data + i, min_t(unsigned, 8, length - i));
> 
886c894
< 					  data, 8))
---
> 					  tmp, 8))
888d895
< 		data++;
893a901,922
> }
> 
> static bool intel_sdvo_set_avi_infoframe(struct intel_sdvo *intel_sdvo)
> {
> 	struct dip_infoframe avi_if = {
> 		.type = DIP_TYPE_AVI,
> 		.ver = DIP_VERSION_AVI,
> 		.len = DIP_LEN_AVI,
> 	};
> 	uint8_t sdvo_data[4 + sizeof(avi_if.body.avi)];
> 
> 	intel_dip_infoframe_csum(&avi_if);
> 
> 	/* sdvo spec says that the ecc is handled by the hw, and it looks like
> 	 * we must not send the ecc field, either. */
> 	memcpy(sdvo_data, &avi_if, 3);
> 	sdvo_data[3] = avi_if.checksum;
> 	memcpy(&sdvo_data[4], &avi_if.body, sizeof(avi_if.body.avi));
> 
> 	return intel_sdvo_write_infoframe(intel_sdvo, SDVO_HBUF_INDEX_AVI_IF,
> 					  SDVO_HBUF_TX_VSYNC,
> 					  sdvo_data, sizeof(sdvo_data));




diff -r linux-3.0.36/drivers/gpu/drm/i915/intel_sdvo_regs.h linux-3.0.36-lenovo/drivers/gpu/drm/i915/intel_sdvo_regs.h
710a711,712
>   #define SDVO_HBUF_INDEX_ELD		0
>   #define SDVO_HBUF_INDEX_AVI_IF	1




diff -r linux-3.0.36/drivers/gpu/drm/nouveau/nouveau_fbcon.c linux-3.0.36-lenovo/drivers/gpu/drm/nouveau/nouveau_fbcon.c
490c490
< 				 nv_two_heads(dev) ? 2 : 1, 4);
---
> 				 dev->mode_config.num_crtc, 4);




diff -r linux-3.0.36/drivers/gpu/drm/nouveau/nv04_dac.c linux-3.0.36-lenovo/drivers/gpu/drm/nouveau/nv04_dac.c
212c212
< 		NV_INFO(dev, "Load detected on head A\n");
---
> 		NV_DEBUG(dev, "Load detected on head A\n");
326c326
< 		NV_INFO(dev, "Load detected on output %c\n",
---
> 		NV_DEBUG(dev, "Load detected on output %c\n",
401c401
< 	NV_INFO(dev, "Output %s is running on CRTC %d using output %c\n",
---
> 	NV_DEBUG(dev, "Output %s is running on CRTC %d using output %c\n",
450c450
< 	NV_INFO(dev, "Setting dpms mode %d on vga encoder (output %d)\n",
---
> 	NV_DEBUG(dev, "Setting dpms mode %d on vga encoder (output %d)\n",




diff -r linux-3.0.36/drivers/gpu/drm/nouveau/nv04_dfp.c linux-3.0.36-lenovo/drivers/gpu/drm/nouveau/nv04_dfp.c
471c471
< 	NV_INFO(dev, "Output %s is running on CRTC %d using output %c\n",
---
> 	NV_DEBUG(dev, "Output %s is running on CRTC %d using output %c\n",
514c514
< 	NV_INFO(dev, "Setting dpms mode %d on lvds encoder (output %d)\n",
---
> 	NV_DEBUG(dev, "Setting dpms mode %d on lvds encoder (output %d)\n",
559c559
< 	NV_INFO(dev, "Setting dpms mode %d on tmds encoder (output %d)\n",
---
> 	NV_DEBUG(dev, "Setting dpms mode %d on tmds encoder (output %d)\n",




diff -r linux-3.0.36/drivers/gpu/drm/nouveau/nv04_tv.c linux-3.0.36-lenovo/drivers/gpu/drm/nouveau/nv04_tv.c
72c72
< 	NV_INFO(dev, "Setting dpms mode %d on TV encoder (output %d)\n",
---
> 	NV_DEBUG(dev, "Setting dpms mode %d on TV encoder (output %d)\n",
165c165
< 	NV_INFO(dev, "Output %s is running on CRTC %d using output %c\n",
---
> 	NV_DEBUG(dev, "Output %s is running on CRTC %d using output %c\n",




diff -r linux-3.0.36/drivers/gpu/drm/radeon/atombios_dp.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/atombios_dp.c
24a25
>  *          Jerome Glisse
627d627
< 		DRM_ERROR("displayport link status failed\n");
800c800,801
< 		if (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status))
---
> 		if (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status)) {
> 			DRM_ERROR("displayport link status failed\n");
801a803
> 		}
863c865,866
< 		if (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status))
---
> 		if (!radeon_dp_get_link_status(dp_info->radeon_connector, dp_info->link_status)) {
> 			DRM_ERROR("displayport link status failed\n");
864a868
> 		}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/evergreen.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/evergreen.c
1022,1023d1021
< 	save->vga_control[0] = RREG32(D1VGA_CONTROL);
< 	save->vga_control[1] = RREG32(D2VGA_CONTROL);
1026,1039d1023
< 	save->crtc_control[0] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC0_REGISTER_OFFSET);
< 	save->crtc_control[1] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC1_REGISTER_OFFSET);
< 	if (rdev->num_crtc >= 4) {
< 		save->vga_control[2] = RREG32(EVERGREEN_D3VGA_CONTROL);
< 		save->vga_control[3] = RREG32(EVERGREEN_D4VGA_CONTROL);
< 		save->crtc_control[2] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC2_REGISTER_OFFSET);
< 		save->crtc_control[3] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC3_REGISTER_OFFSET);
< 	}
< 	if (rdev->num_crtc >= 6) {
< 		save->vga_control[4] = RREG32(EVERGREEN_D5VGA_CONTROL);
< 		save->vga_control[5] = RREG32(EVERGREEN_D6VGA_CONTROL);
< 		save->crtc_control[4] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC4_REGISTER_OFFSET);
< 		save->crtc_control[5] = RREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC5_REGISTER_OFFSET);
< 	}
1083a1068,1069
> 	/* wait for the MC to settle */
> 	udelay(100);
1150,1190d1135
< 	/* Restore video state */
< 	WREG32(D1VGA_CONTROL, save->vga_control[0]);
< 	WREG32(D2VGA_CONTROL, save->vga_control[1]);
< 	if (rdev->num_crtc >= 4) {
< 		WREG32(EVERGREEN_D3VGA_CONTROL, save->vga_control[2]);
< 		WREG32(EVERGREEN_D4VGA_CONTROL, save->vga_control[3]);
< 	}
< 	if (rdev->num_crtc >= 6) {
< 		WREG32(EVERGREEN_D5VGA_CONTROL, save->vga_control[4]);
< 		WREG32(EVERGREEN_D6VGA_CONTROL, save->vga_control[5]);
< 	}
< 	WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC0_REGISTER_OFFSET, 1);
< 	WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC1_REGISTER_OFFSET, 1);
< 	if (rdev->num_crtc >= 4) {
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC2_REGISTER_OFFSET, 1);
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC3_REGISTER_OFFSET, 1);
< 	}
< 	if (rdev->num_crtc >= 6) {
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC4_REGISTER_OFFSET, 1);
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC5_REGISTER_OFFSET, 1);
< 	}
< 	WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC0_REGISTER_OFFSET, save->crtc_control[0]);
< 	WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC1_REGISTER_OFFSET, save->crtc_control[1]);
< 	if (rdev->num_crtc >= 4) {
< 		WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC2_REGISTER_OFFSET, save->crtc_control[2]);
< 		WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC3_REGISTER_OFFSET, save->crtc_control[3]);
< 	}
< 	if (rdev->num_crtc >= 6) {
< 		WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC4_REGISTER_OFFSET, save->crtc_control[4]);
< 		WREG32(EVERGREEN_CRTC_CONTROL + EVERGREEN_CRTC5_REGISTER_OFFSET, save->crtc_control[5]);
< 	}
< 	WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC0_REGISTER_OFFSET, 0);
< 	WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC1_REGISTER_OFFSET, 0);
< 	if (rdev->num_crtc >= 4) {
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC2_REGISTER_OFFSET, 0);
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC3_REGISTER_OFFSET, 0);
< 	}
< 	if (rdev->num_crtc >= 6) {
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC4_REGISTER_OFFSET, 0);
< 		WREG32(EVERGREEN_CRTC_UPDATE_LOCK + EVERGREEN_CRTC5_REGISTER_OFFSET, 0);
< 	}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_agp.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_agp.c
73c73
< 	/* Intel 82852/82855 host bridge / Mobility FireGL 9000 R250 Needs AGPMode 1 (lp #296617) */
---
> 	/* Intel 82852/82855 host bridge / Mobility FireGL 9000 RV250 Needs AGPMode 1 (lp #296617) */
75a76,78
> 	/* Intel 82855PM host bridge / Mobility FireGL 9000 RV250 Needs AGPMode 1 for suspend/resume */
> 	{ PCI_VENDOR_ID_INTEL, 0x3340, PCI_VENDOR_ID_ATI, 0x4c66,
> 		PCI_VENDOR_ID_IBM, 0x0531, 1},




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_asic.h linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_asic.h
256,257d255
< 	u32 d1vga_control;
< 	u32 d2vga_control;
260,261d257
< 	u32 d1crtc_control;
< 	u32 d2crtc_control;
262a259
> 
390d386
< 	u32 vga_control[6];
393d388
< 	u32 crtc_control[6];
394a390
> 




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_atombios.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_atombios.c
491c491
< 	if ((dev->pdev->device == 0x9802) &&
---
> 	if (((dev->pdev->device == 0x9802) || (dev->pdev->device == 0x9806)) &&




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_combios.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_combios.c
2340a2341,2348
> 				/* RV100 board with external TDMS bit mis-set.
> 				 * Actually uses internal TMDS, clear the bit.
> 				 */
> 				if (dev->pdev->device == 0x5159 &&
> 				    dev->pdev->subsystem_vendor == 0x1014 &&
> 				    dev->pdev->subsystem_device == 0x029A) {
> 					tmp &= ~(1 << 4);
> 				}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_connectors.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_connectors.c
69c69,70
< 		int saved_dpms = connector->dpms;
---
> 		struct radeon_connector_atom_dig *dig_connector =
> 			radeon_connector->con_priv;
71,76c72,95
< 		/* Only turn off the display it it's physically disconnected */
< 		if (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd))
< 			drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
< 		else if (radeon_dp_needs_link_train(radeon_connector))
< 			drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
< 		connector->dpms = saved_dpms;
---
> 		/* if existing sink type was not DP no need to retrain */
> 		if (dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT)
> 			return;
> 
> 		/* first get sink type as it may be reset after (un)plug */
> 		dig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);
> 		/* don't do anything if sink is not display port, i.e.,
> 		 * passive dp->(dvi|hdmi) adaptor
> 		 */
> 		if (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {
> 			int saved_dpms = connector->dpms;
> 			/* Only turn off the display if it's physically disconnected */
> 			if (!radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {
> 				drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
> 			} else if (radeon_dp_needs_link_train(radeon_connector)) {
> 				/* set it to OFF so that drm_helper_connector_dpms()
> 				 * won't return immediately since the current state
> 				 * is ON at this point.
> 				 */
> 				connector->dpms = DRM_MODE_DPMS_OFF;
> 				drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
> 			}
> 			connector->dpms = saved_dpms;
> 		}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_cursor.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_cursor.c
260c260
< 			if (w <= 0)
---
> 			if (w <= 0) {
261a262,267
> 				cursor_end = x - xorigin + w;
> 				if (!(cursor_end & 0x7f)) {
> 					x--;
> 					WARN_ON_ONCE(x < 0);
> 				}
> 			}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_display.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_display.c
1161c1161,1162
< 	if (radeon_fb == NULL)
---
> 	if (radeon_fb == NULL) {
> 		drm_gem_object_unreference_unlocked(obj);
1162a1164
> 	}




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_irq_kms.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_irq_kms.c
145a146,155
> 	/* Gateway RS690 only seems to work with MSIs. */
> 	if ((rdev->pdev->device == 0x791f) &&
> 	    (rdev->pdev->subsystem_vendor == 0x107b) &&
> 	    (rdev->pdev->subsystem_device == 0x0185))
> 		return true;
> 
> 	/* try and enable MSIs by default on all RS690s */
> 	if (rdev->family == CHIP_RS690)
> 		return true;
> 




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_legacy_encoders.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_legacy_encoders.c
619a620,627
> 	/* just don't bother on RN50 those chip are often connected to remoting
> 	 * console hw and often we get failure to load detect those. So to make
> 	 * everyone happy report the encoder as always connected.
> 	 */
> 	if (ASIC_IS_RN50(rdev)) {
> 		return connector_status_connected;
> 	}
> 
652a661
> 	tmp = dac_macro_cntl;
976,980c985
< 	struct radeon_encoder_ext_tmds *tmds = radeon_encoder->enc_priv;
< 	if (tmds) {
< 		if (tmds->i2c_bus)
< 			radeon_i2c_destroy(tmds->i2c_bus);
< 	}
---
> 	/* don't destroy the i2c bus record here, this will be done in radeon_i2c_fini */




diff -r linux-3.0.36/drivers/gpu/drm/radeon/radeon_pm.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/radeon_pm.c
538c538,540
< 	if (ASIC_IS_DCE5(rdev) && rdev->mc_fw) {
---
> 	if ((rdev->family >= CHIP_BARTS) &&
> 	    (rdev->family <= CHIP_CAYMAN) &&
> 	    rdev->mc_fw) {
593c595,597
< 		if (ASIC_IS_DCE5(rdev) && rdev->mc_fw) {
---
> 		if ((rdev->family >= CHIP_BARTS) &&
> 		    (rdev->family <= CHIP_CAYMAN) &&
> 		    rdev->mc_fw) {




diff -r linux-3.0.36/drivers/gpu/drm/radeon/rv515.c linux-3.0.36-lenovo/drivers/gpu/drm/radeon/rv515.c
284,285d283
< 	save->d1vga_control = RREG32(R_000330_D1VGA_CONTROL);
< 	save->d2vga_control = RREG32(R_000338_D2VGA_CONTROL);
288,289d285
< 	save->d1crtc_control = RREG32(R_006080_D1CRTC_CONTROL);
< 	save->d2crtc_control = RREG32(R_006880_D2CRTC_CONTROL);
314,322d309
< 	/* Restore video state */
< 	WREG32(R_000330_D1VGA_CONTROL, save->d1vga_control);
< 	WREG32(R_000338_D2VGA_CONTROL, save->d2vga_control);
< 	WREG32(R_0060E8_D1CRTC_UPDATE_LOCK, 1);
< 	WREG32(R_0068E8_D2CRTC_UPDATE_LOCK, 1);
< 	WREG32(R_006080_D1CRTC_CONTROL, save->d1crtc_control);
< 	WREG32(R_006880_D2CRTC_CONTROL, save->d2crtc_control);
< 	WREG32(R_0060E8_D1CRTC_UPDATE_LOCK, 0);
< 	WREG32(R_0068E8_D2CRTC_UPDATE_LOCK, 0);




diff -r linux-3.0.36/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c linux-3.0.36-lenovo/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
149a150
> MODULE_DEVICE_TABLE(pci, vmw_pci_id_list);
858a860,864
> 
> 	mutex_lock(&dev_priv->hw_mutex);
> 	vmw_write(dev_priv, SVGA_REG_ID, SVGA_ID_2);
> 	(void) vmw_read(dev_priv, SVGA_REG_ID);
> 	mutex_unlock(&dev_priv->hw_mutex);
Only in linux-3.0.36-lenovo/drivers/gpu: ion




diff -r linux-3.0.36/drivers/gpu/Makefile linux-3.0.36-lenovo/drivers/gpu/Makefile
1c1
< obj-y			+= drm/ vga/ stub/
---
> obj-y			+= drm/ vga/ stub/ ion/
Only in linux-3.0.36-lenovo/drivers: headset_observe




diff -r linux-3.0.36/drivers/hid/hid-debug.c linux-3.0.36-lenovo/drivers/hid/hid-debug.c
452a453,457
> 	if (field->application) {
> 		tab(n, f);
> 		seq_printf(f, "Application(");
> 		hid_resolv_usage(field->application, f); seq_printf(f, ")\n");
> 	}




diff -r linux-3.0.36/drivers/hid/hid-input.c linux-3.0.36-lenovo/drivers/hid/hid-input.c
973a974,976
> 				if (hid->driver->input_register &&
> 						hid->driver->input_register(hid, hidinput))
> 					goto out_cleanup;
979a983,986
> 
> 	if (hidinput && hid->driver->input_register &&
> 			hid->driver->input_register(hid, hidinput))
> 		goto out_cleanup;




diff -r linux-3.0.36/drivers/hid/hid-magicmouse.c linux-3.0.36-lenovo/drivers/hid/hid-magicmouse.c
368c368
< static void magicmouse_setup_input(struct input_dev *input, struct hid_device *hdev)
---
> static int magicmouse_setup_input(struct hid_device *hdev, struct hid_input *hi)
369a370,371
> 	struct input_dev *input = hi->input;
> 
428a431,432
> 
> 	return 0;
481,486d484
< 	/* We do this after hid-input is done parsing reports so that
< 	 * hid-input uses the most natural button and axis IDs.
< 	 */
< 	if (msc->input)
< 		magicmouse_setup_input(msc->input, hdev);
< 
550a549
> 	.input_register = magicmouse_setup_input,




diff -r linux-3.0.36/drivers/hid/hid-multitouch.c linux-3.0.36-lenovo/drivers/hid/hid-multitouch.c
215a216,225
> 	/* Only map fields from TouchScreen or TouchPad collections.
>          * We need to ignore fields that belong to other collections
>          * such as Mouse that might have the same GenericDesktop usages. */
> 	if (field->application == HID_DG_TOUCHSCREEN)
> 		set_bit(INPUT_PROP_DIRECT, hi->input->propbit);
> 	else if (field->application == HID_DG_TOUCHPAD)
> 		set_bit(INPUT_PROP_POINTER, hi->input->propbit);
> 	else
> 		return 0;
> 




diff -r linux-3.0.36/drivers/hid/Kconfig linux-3.0.36-lenovo/drivers/hid/Kconfig
52a53,73
> config UHID
> 	tristate "User-space I/O driver support for HID subsystem"
> 	depends on HID
> 	default n
> 	---help---
> 	Say Y here if you want to provide HID I/O Drivers from user-space.
> 	This allows to write I/O drivers in user-space and feed the data from
> 	the device into the kernel. The kernel parses the HID reports, loads the
> 	corresponding HID Device Driver or provides input devices on top of your
> 	user-space device.
> 
> 	This driver cannot be used to parse HID-reports in user-space and write
> 	special HID-drivers. You should use hidraw for that.
> 	Instead, this driver allows to write the transport-layer driver in
> 	user-space like USB-HID and Bluetooth-HID do in kernel-space.
> 
> 	If unsure, say N.
> 
> 	To compile this driver as a module, choose M here: the
> 	module will be called uhid.
> 




diff -r linux-3.0.36/drivers/hid/Makefile linux-3.0.36-lenovo/drivers/hid/Makefile
10a11
> obj-$(CONFIG_UHID)		+= uhid.o
Only in linux-3.0.36-lenovo/drivers/hid: uhid.c




diff -r linux-3.0.36/drivers/hid/usbhid/hid-core.c linux-3.0.36-lenovo/drivers/hid/usbhid/hid-core.c
50a51,52
> extern struct delayed_work hsic_reset_work;
> extern struct mutex hsic_mutex;
141a144,151
> 
> 		/* modify by wlf for lenovo A10 hsic hub[usb4604]@20130720*/
> 		if( mutex_trylock(&hsic_mutex)){
> 			schedule_delayed_work(&hsic_reset_work, 1);
> 		}else{
> 			printk("fail to get hsic_mutex!!!!!\n");
> 		}
> 
1379a1390,1392
>     usb_control_msg(interface_to_usbdev(intf), usb_sndctrlpipe(interface_to_usbdev(intf), 0),
>             USB_REQ_SET_FEATURE, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_DEVICE_REMOTE_WAKEUP,
>             0, NULL, 0, USB_CTRL_SET_TIMEOUT);
1397a1411
> 	struct usb_device *udev = interface_to_usbdev(intf);
1409a1424,1430
> 	
>     usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
>             USB_REQ_CLEAR_FEATURE, USB_TYPE_STANDARD | USB_RECIP_DEVICE, USB_DEVICE_REMOTE_WAKEUP,
>             0, NULL, 0, USB_CTRL_SET_TIMEOUT);
>             
> 	hid_set_idle(udev, intf->cur_altsetting->desc.bInterfaceNumber, 0, 0);
> 		




diff -r linux-3.0.36/drivers/hwmon/ads7871.c linux-3.0.36-lenovo/drivers/hwmon/ads7871.c
135a136,141
> static ssize_t ads7871_show_name(struct device *dev,
> 				 struct device_attribute *devattr, char *buf)
> {
> 	return sprintf(buf, "%s\n", to_spi_device(dev)->modalias);
> }
> 
144a151,152
> static DEVICE_ATTR(name, S_IRUGO, ads7871_show_name, NULL);
> 
153a162
> 	&dev_attr_name.attr,




diff -r linux-3.0.36/drivers/hwmon/applesmc.c linux-3.0.36-lenovo/drivers/hwmon/applesmc.c
218c218
< 		pr_warn("%s: read arg fail\n", key);
---
> 		pr_warn("%.4s: read arg fail\n", key);
226c226
< 			pr_warn("%s: read data fail\n", key);
---
> 			pr_warn("%.4s: read data fail\n", key);




diff -r linux-3.0.36/drivers/hwmon/asus_atk0110.c linux-3.0.36-lenovo/drivers/hwmon/asus_atk0110.c
36a37,42
> 	}, {
> 		/* Old interface reads the same sensor for fan0 and fan1 */
> 		.ident = "Asus M5A78L",
> 		.matches = {
> 			DMI_MATCH(DMI_BOARD_NAME, "M5A78L")
> 		}




diff -r linux-3.0.36/drivers/hwmon/coretemp.c linux-3.0.36-lenovo/drivers/hwmon/coretemp.c
50d49
< #ifdef CONFIG_SMP
52a52,54
> #define TO_ATTR_NO(cpu)		(TO_CORE_ID(cpu) + BASE_SYSFS_ATTR_NO)
> 
> #ifdef CONFIG_SMP
55,56d56
< #define TO_PHYS_ID(cpu)		(cpu)
< #define TO_CORE_ID(cpu)		(cpu)
59d58
< #define TO_ATTR_NO(cpu)		(TO_CORE_ID(cpu) + BASE_SYSFS_ATTR_NO)
712c711
< 	if (!cpu_has(c, X86_FEATURE_DTS))
---
> 	if (!cpu_has(c, X86_FEATURE_DTHERM))




diff -r linux-3.0.36/drivers/hwmon/fam15h_power.c linux-3.0.36-lenovo/drivers/hwmon/fam15h_power.c
33a34,36
> /* Family 16h Northbridge's function 4 PCI ID */
> #define PCI_DEVICE_ID_AMD_16H_NB_F4	0x1534
> 
131c134
< static DEFINE_PCI_DEVICE_TABLE(affected_device) = {
---
> static const struct pci_device_id affected_device[] = {
136c139
< static void __devinit tweak_runavg_range(struct pci_dev *pdev)
---
> static void tweak_runavg_range(struct pci_dev *pdev)
159a163,172
> #ifdef CONFIG_PM
> static int fam15h_power_resume(struct pci_dev *pdev)
> {
> 	tweak_runavg_range(pdev);
> 	return 0;
> }
> #else
> #define fam15h_power_resume NULL
> #endif
> 
248a262
> 	{ PCI_VDEVICE(AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
257a272
> 	.resume = fam15h_power_resume,




diff -r linux-3.0.36/drivers/hwmon/it87.c linux-3.0.36-lenovo/drivers/hwmon/it87.c
2060c2060
< 			 (it87_read_value(data, IT87_REG_CONFIG) & 0x36)
---
> 			 (it87_read_value(data, IT87_REG_CONFIG) & 0x3e)




diff -r linux-3.0.36/drivers/hwmon/twl4030-madc-hwmon.c linux-3.0.36-lenovo/drivers/hwmon/twl4030-madc-hwmon.c
47c47,51
< 	struct twl4030_madc_request req;
---
> 	struct twl4030_madc_request req = {
> 		.channels = 1 << attr->index,
> 		.method = TWL4030_MADC_SW2,
> 		.type = TWL4030_MADC_WAIT,
> 	};
50,52d53
< 	req.channels = (1 << attr->index);
< 	req.method = TWL4030_MADC_SW2;
< 	req.func_cb = NULL;




diff -r linux-3.0.36/drivers/hwmon/w83627ehf.c linux-3.0.36-lenovo/drivers/hwmon/w83627ehf.c
1836a1837
> 	data->bank = 0xff;		/* Force initial bank selection */




diff -r linux-3.0.36/drivers/i2c/algos/i2c-algo-bit.c linux-3.0.36-lenovo/drivers/i2c/algos/i2c-algo-bit.c
387c387
< 			dev_err(&i2c_adap->dev, "sendbytes: NAK bailout.\n");
---
> 			dev_err(&i2c_adap->dev, "sendbytes: NAK bailout, addr is 0x%x.\n", msg->addr);
398,399c398,399
< 			dev_err(&i2c_adap->dev, "sendbytes: error %d\n",
< 					retval);
---
> 			dev_err(&i2c_adap->dev, "sendbytes: error %d, addr is 0x%x.\n",
> 					retval, msg->addr);
552a553
> 	adap->udelay = 500 * 1000/msgs[0].scl_rate + 1;
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-dev-rk29.c
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-dev-rk29.h




diff -r linux-3.0.36/drivers/i2c/busses/i2c-gpio.c linux-3.0.36-lenovo/drivers/i2c/busses/i2c-gpio.c
91c91,92
< 
---
> 	if(pdata->io_init)
> 		pdata->io_init();
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk29-adapter.c
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk29.c
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk29.h
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk30-adapter.c
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk30.c
Only in linux-3.0.36-lenovo/drivers/i2c/busses: i2c-rk30.h




diff -r linux-3.0.36/drivers/i2c/busses/Kconfig linux-3.0.36-lenovo/drivers/i2c/busses/Kconfig
841,850d840
< 	help
< 	  Enable the use of two GPIO pins of a SCx200 processor as an I2C bus.
< 
< 	  If you don't know what to do here, say N.
< 
< 	  This support is also available as a module.  If so, the module
< 	  will be called scx200_i2c.
< 
< 	  This driver is deprecated and will be dropped soon. Use i2c-gpio
< 	  (or scx200_acb) instead.
852,855c842,845
< config SCx200_I2C_SCL
< 	int "GPIO pin used for SCL"
< 	depends on SCx200_I2C
< 	default "12"
---
> config I2C_RK30
> 	tristate "RK I2C Adapter"
> 	depends on PLAT_RK && !ARCH_RK29
> 	default y
857,858c847
< 	  Enter the GPIO pin number used for the SCL signal.  This value can
< 	  also be specified with a module parameter.
---
> 		This supports I2C Adapter on RK Soc.
860,863c849,932
< config SCx200_I2C_SDA
< 	int "GPIO pin used for SDA"
< 	depends on SCx200_I2C
< 	default "13"
---
> if I2C_RK30
> 	comment "Now, there are five selectable I2C channels."
> 	
> 	config I2C0_RK30
> 		bool "I2C0 Channel Support"
> 		default y
> 		help
> 			This supports the use of the I2C0 channel on RK Soc.
> 		if I2C0_RK30
> 			choice
> 				prompt "I2C Controller Select"
> 				config I2C0_CONTROLLER_RK29
> 					bool "With RK29 I2C Controller"
> 				config I2C0_CONTROLLER_RK30
> 					bool "With RK30 I2C Controller"
> 			endchoice
> 		endif
> 	config I2C1_RK30
> 		bool "I2C1 Channel Support"
> 		default y
> 		help
> 			This supports the use of the I2C1 channel on RK Soc.
> 		if I2C1_RK30
> 			choice
> 				prompt "I2C Controller Select"
> 				config I2C1_CONTROLLER_RK29
> 					bool "With RK29 I2C Controller"
> 				config I2C1_CONTROLLER_RK30
> 					bool "With RK30 I2C Controller"
> 			endchoice
> 		endif
> 	config I2C2_RK30
> 		bool "I2C2 Channel Support"
> 		default y
> 		help
> 			This supports the use of the I2C2 channel on RK Soc.
> 		if I2C2_RK30
> 			choice
> 				prompt "I2C Controller Select"
> 				config I2C2_CONTROLLER_RK29
> 					bool "With RK29 I2C Controller"
> 				config I2C2_CONTROLLER_RK30
> 					bool "With RK30 I2C Controller"
> 			endchoice
> 		endif
> 	config I2C3_RK30
> 		bool "I2C3 Channel Support"
>                 depends on !HDMI_RK2928
> 		default y
> 		help
> 			This supports the use of the I2C3 channel on RK Soc.
> 		if I2C3_RK30
> 			choice
> 				prompt "I2C Controller Select"
> 				config I2C3_CONTROLLER_RK29
> 					bool "With RK29 I2C Controller"
> 				config I2C3_CONTROLLER_RK30
> 					bool "With RK30 I2C Controller"
> 			endchoice
> 		endif
> 	config I2C4_RK30
> 		bool "I2C4 Channel Support"
> 	        depends on !ARCH_RK2928
> 		default y
> 		help
> 			This supports the use of the I2C4 channel on RK Soc.
> 		if I2C4_RK30
> 			choice
> 				prompt "I2C Controller Select"
> 				config I2C4_CONTROLLER_RK29
> 					bool "With RK29 I2C Controller"
> 				config I2C4_CONTROLLER_RK30
> 					bool "With RK30 I2C Controller"
> 			endchoice
> 		endif
>         config I2C_GPIO_RK30
>                 bool "Simulation with GPIO"
>                 default n
>                 select I2C_GPIO
> endif
> config I2C_RK29
> 	tristate "RK29 i2c interface (I2C)"
> 	depends on ARCH_RK29
> 	default y
865,878c934
< 	  Enter the GPIO pin number used for the SSA signal.  This value can
< 	  also be specified with a module parameter.
< 
< config SCx200_ACB
< 	tristate "Geode ACCESS.bus support"
< 	depends on X86_32 && PCI
< 	help
< 	  Enable the use of the ACCESS.bus controllers on the Geode SCx200 and
< 	  SC1100 processors and the CS5535 and CS5536 Geode companion devices.
< 
< 	  If you don't know what to do here, say N.
< 
< 	  This support is also available as a module.  If so, the module
< 	  will be called scx200_acb.
---
> 		This supports the use of the I2C interface(i2c0 ~ i2c3) on rk29 processors.
879a936,1011
> if I2C_RK29
> 	comment "Now, there are four I2C interfaces selected by developer."
> 	
> 	config I2C0_RK29
> 		bool "RK29 I2C0 interface support"
> 		default y
> 		depends on ARCH_RK29
> 		help
> 			This supports the use of the I2C0 interface on rk29 processors.
> 		if I2C0_RK29
> 			choice
> 				prompt "I2C transfer mode select"
> 				config RK29_I2C0_CONTROLLER
> 					bool "With i2c controller"
> 				config RK29_I2C0_GPIO
> 					select I2C_GPIO
> 					bool "Simulation with GPIO"
> 			endchoice
> 		endif
> 	config I2C1_RK29
> 		bool "RK29 I2C1 interface support"
> 		default y
> 		depends on ARCH_RK29
> 		help
> 			This supports the use of the I2C1 interface on rk29 processors.
> 		if I2C1_RK29
> 			choice
> 				prompt "I2C transfer mode select"
> 				config RK29_I2C1_CONTROLLER
> 					bool "With i2c controller"
> 				config RK29_I2C1_GPIO
> 					select I2C_GPIO
> 					bool "Simulation with GPIO"
> 			endchoice
> 		endif
> 
> 	config I2C2_RK29
> 		bool "RK29 I2C2 interface support"
> 		default y
> 		depends on ARCH_RK29
> 		help
> 			This supports the use of the I2C2 interface on rk29 processors.
> 		if I2C2_RK29
> 			choice
> 				prompt "I2C transfer mode select"
> 				config RK29_I2C2_CONTROLLER
> 					bool "With i2c controller"
> 				config RK29_I2C2_GPIO
> 					select I2C_GPIO
> 					bool "Simulation with GPIO"
> 			endchoice
> 		endif
> 
> 	config I2C3_RK29
> 		bool "RK29 I2C3 interface support"
> 		default y
> 		depends on ARCH_RK29 && !UART3_CTS_RTS_RK29
> 		help
> 			This supports the use of the I2C3 interface on rk29 processors.
> 		if I2C3_RK29
> 			choice
> 				prompt "I2C transfer mode select"
> 				config RK29_I2C3_CONTROLLER
> 					bool "With i2c controller"
> 				config RK29_I2C3_GPIO
> 					select I2C_GPIO
> 					bool "Simulation with GPIO"
> 			endchoice
> 		endif
> endif
> config I2C_DEV_RK29
> 	tristate "RK29 I2C device interface support"
> 		default n
> 		depends on I2C_RK29
> 		help
> 			Nothing




diff -r linux-3.0.36/drivers/i2c/busses/Makefile linux-3.0.36-lenovo/drivers/i2c/busses/Makefile
3a4,6
> obj-$(CONFIG_I2C_RK29)		+= i2c-rk29.o
> obj-$(CONFIG_I2C_DEV_RK29)	+= i2c-dev-rk29.o
> obj-$(CONFIG_I2C_RK30)		+= i2c-rk30.o i2c-rk29-adapter.o i2c-rk30-adapter.o




diff -r linux-3.0.36/drivers/i2c/i2c-boardinfo.c linux-3.0.36-lenovo/drivers/i2c/i2c-boardinfo.c
69d68
< 




diff -r linux-3.0.36/drivers/i2c/i2c-core.c linux-3.0.36-lenovo/drivers/i2c/i2c-core.c
52a53,54
> static int i2c_check_addr(struct i2c_adapter *adapter, int addr);
> static int i2c_check_addr_ex(struct i2c_adapter *adapter, int addr);
56c58,62
< 
---
> #ifdef CONFIG_I2C_DEV_RK29
> extern struct completion		i2c_dev_complete;
> extern void i2c_dev_dump_start(struct i2c_adapter *adap, struct i2c_msg *msgs, int num);
> extern void i2c_dev_dump_stop(struct i2c_adapter *adap, struct i2c_msg *msgs, int num, int ret);
> #endif
520a527
> 	client->udelay = info->udelay;  // add by kfx
532a540
>     #if 0
535a544,551
>     #else
> 	/* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
> 	   if devices havn't work at the same time.*/
> 	status = i2c_check_addr_ex(adap, client->addr);
> 	if (status != 0)
> 		dev_err(&adap->dev, "%d i2c clients have been registered at 0x%02x",
> 			status, client->addr);   
>     #endif
542,543c558,571
< 	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
< 		     client->addr);
---
>     /* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
>       if devices havn't work at the same time.*/
>     #if 0
>     dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
>     		     client->addr);
>     #else
>     if (status == 0)
>     	dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
>     		     client->addr);
>     else 
>         dev_set_name(&client->dev, "%d-%04x-%01x", i2c_adapter_id(adap),
>     		     client->addr,status);
>     #endif
>     
560a589,723
> #ifdef CONFIG_PLAT_RK
> #define RK610_KEY       "rk610"
> static int __i2c_client_print(struct device *dev, void *param)
> {
>         struct i2c_client *client = i2c_verify_client(dev);
> 
>         if(client)
>                 printk(KERN_WARNING "client: %s, addr: 0x%x\n", client->name, client->addr);
>         return 0;
> }
> static int __i2c_check_rk610_ex(struct device *dev, void *ex)
> {
>         struct i2c_client *client = i2c_verify_client(dev);
> 
>         if(!client)
>                 return 0;
> 
>         if(strstr(client->name, RK610_KEY) != NULL)
>                 *(int *)ex += 1 << 8;
>         else
>                 *(int *)ex += 1;
>         return 0;
> }
> int i2c_check_rk610_ex(int nr)
> {
>         int ex = 0, rk610_ex = 0, oth_ex = 0;
>         struct i2c_adapter *adap = i2c_get_adapter(nr);
> 
>         if(!adap){
>                 printk(KERN_ERR "%s: adap(%d) is not exist\n", __func__, nr);
>                 return -EINVAL;
>         }
>         device_for_each_child(&adap->dev, &ex, __i2c_check_rk610_ex);
> 
>         if(ex & (1 << 8))
>                 rk610_ex = 1;
> 
>         oth_ex = ex & 0xff;
> 
>         if(rk610_ex && oth_ex){
>                 ex = 1;
>                 printk(KERN_WARNING "******************* WARNING ********************\n");
>                 dev_warn(&adap->dev, "%s is exist, clients:\n", RK610_KEY);
>                 device_for_each_child(&adap->dev, NULL, __i2c_client_print);
>                 printk(KERN_WARNING "************************************************\n");
>         }
>         else 
>                 ex = 0;
>         return ex;
> }
> #ifdef CONFIG_I2C_RK30
> int i2c_add_device(int nr, struct i2c_board_info const *info)
> {
> 	int			status;
> 	struct i2c_client	*client;
>         struct i2c_adapter *adap = i2c_get_adapter(nr);
>         
>         if(!adap){
>                 printk(KERN_ERR "%s: adap(%d) is not exist\n", __func__, nr);
>                 return -EINVAL;
>         }
> 
> 	client = kzalloc(sizeof *client, GFP_KERNEL);
> 	if (!client){
>                 dev_err(&adap->dev, "no memory for client\n");
> 		return -ENOMEM;
>         }
> 
> 	client->adapter = adap;
> 
> 	client->dev.platform_data = info->platform_data;
> 
> 	if (info->archdata)
> 		client->dev.archdata = *info->archdata;
> 
> 	client->flags = info->flags;
> 	client->addr = info->addr;
> 	client->irq = info->irq;
> 	client->udelay = info->udelay;  // add by kfx
> 
> 	strlcpy(client->name, info->type, sizeof(client->name));
> 
> 	/* Check for address validity */
> 	status = i2c_check_client_addr_validity(client);
> 	if (status) {
> 		dev_err(&adap->dev, "Invalid %d-bit I2C address 0x%02hx\n",
> 			client->flags & I2C_CLIENT_TEN ? 10 : 7, client->addr);
> 		goto out_err_silent;
> 	}
> 
> 	/* Check for address business */
> 	status = i2c_check_addr_busy(adap, client->addr);
> 	if (status){
>                 status = -EEXIST;
> 		dev_warn(&adap->dev, "i2c clients have been registered at 0x%02x\n", client->addr);   
> 		goto out_err_silent;
>         }
> 
> 	client->dev.parent = &client->adapter->dev;
> 	client->dev.bus = &i2c_bus_type;
> 	client->dev.type = &i2c_client_type;
> 	client->dev.of_node = info->of_node;
> 
>         dev_set_name(&client->dev, "%d-%04x", i2c_adapter_id(adap),
>     		     client->addr);
>     
> 	status = device_register(&client->dev);
> 	if (status)
> 		goto out_err;
> 
> 	dev_dbg(&adap->dev, "client [%s] registered with bus id %s\n",
> 		client->name, dev_name(&client->dev));
> 
> 	return 0;
> 
> out_err:
> 	dev_err(&adap->dev, "Failed to register i2c client %s at 0x%02x "
> 		"(%d)\n", client->name, client->addr, status);
> out_err_silent:
> 	kfree(client);
> 	return status;
> }
> #else
> int i2c_check_rk610_ex(int nr)
> {
>         return 0;
> }
> int i2c_add_device(int nr, struct i2c_board_info const *info)
> {
>         return 0;
> }
> #endif
> EXPORT_SYMBOL_GPL(i2c_check_rk610_ex);
> EXPORT_SYMBOL_GPL(i2c_add_device);
> #endif
1183a1347,1374
> /* ddl@rock-chips.com : Devices which have some i2c addr can work in same i2c bus, 
>       if devices havn't work at the same time.*/
> struct i2c_addr_cnt
> {
>     int addr;
>     int cnt;
> };
> static int __i2c_check_addr_ex(struct device *dev, void *addrp)
> {
> 	struct i2c_client	*client = i2c_verify_client(dev);
> 	struct i2c_addr_cnt *addrinfo = (struct i2c_addr_cnt *)addrp;
>     int addr = addrinfo->addr;
> 
> 	if (client && client->addr == addr) {
> 		addrinfo->cnt++;
> 	}
> 	return 0;
> }
> static int i2c_check_addr_ex(struct i2c_adapter *adapter, int addr)
> {
>     struct i2c_addr_cnt addrinfo;
> 
>     addrinfo.addr = addr;
>     addrinfo.cnt = 0;
>     device_for_each_child(&adapter->dev, &addrinfo, __i2c_check_addr_ex);
>     return addrinfo.cnt;
> }
> 
1257a1449,1452
> #ifdef CONFIG_I2C_DEV_RK29
> 		init_completion(&i2c_dev_complete);
> #endif
> 
1332c1527,1529
< 
---
> #if defined (CONFIG_I2C_RK2818) || defined(CONFIG_I2C_RK29)
> 		if (!(i2c_suspended(adap)) && (in_atomic() || irqs_disabled())) {
> #else
1333a1531
> #endif
1343a1542,1544
> #ifdef CONFIG_I2C_DEV_RK29
> 	i2c_dev_dump_start(adap, msgs, num);
> #endif
1347a1549,1550
> 		        dev_err(&adap->dev, "No ack, Maybe slave(addr: 0x%x) not exist or abnormal power-on, retry %d...\n", 
>                                         msgs[0].addr, adap->retries - try);
1350a1554,1556
> #ifdef CONFIG_I2C_DEV_RK29
> 	i2c_dev_dump_stop(adap, msgs, num ,ret);
> #endif
1360a1567,1800
> #ifdef CONFIG_PLAT_RK
> int i2c_master_send(const struct i2c_client *client, const char *buf, int count)
> {
> 	int ret;
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags;
> 	msg.len = count;
> 	msg.buf = (char *)buf;
> 	msg.scl_rate = 100 * 1000;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	return (ret == 1) ? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_send);
> 
> int i2c_master_recv(const struct i2c_client *client, char *buf, int count)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags | I2C_M_RD;
> 	msg.len = count;
> 	msg.buf = (char *)buf;
> 	msg.scl_rate = 100 * 1000;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 
> 	return (ret == 1) ? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_recv);
> 
> int i2c_master_normal_send(const struct i2c_client *client, const char *buf, int count, int scl_rate)
> {
> 	int ret;
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags;
> 	msg.len = count;
> 	msg.buf = (char *)buf;
> 	msg.scl_rate = scl_rate;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	return (ret == 1) ? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_normal_send);
> 
> int i2c_master_normal_recv(const struct i2c_client *client, char *buf, int count, int scl_rate)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags | I2C_M_RD;
> 	msg.len = count;
> 	msg.buf = (char *)buf;
> 	msg.scl_rate = scl_rate;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 
> 	return (ret == 1) ? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_normal_recv);
> 
> int i2c_master_reg8_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 	char *tx_buf = (char *)kmalloc(count + 1, GFP_KERNEL);
> 	if(!tx_buf)
> 		return -ENOMEM;
> 	tx_buf[0] = reg;
> 	memcpy(tx_buf+1, buf, count); 
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags;
> 	msg.len = count + 1;
> 	msg.buf = (char *)tx_buf;
> 	msg.scl_rate = scl_rate;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	kfree(tx_buf);
> 	return (ret == 1) ? count : ret;
> 
> }
> EXPORT_SYMBOL(i2c_master_reg8_send);
> 
> int i2c_master_reg8_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msgs[2];
> 	int ret;
> 	char reg_buf = reg;
> 	
> 	msgs[0].addr = client->addr;
> 	msgs[0].flags = client->flags;
> 	msgs[0].len = 1;
> 	msgs[0].buf = &reg_buf;
> 	msgs[0].scl_rate = scl_rate;
> 	msgs[0].udelay = client->udelay;
> 
> 	msgs[1].addr = client->addr;
> 	msgs[1].flags = client->flags | I2C_M_RD;
> 	msgs[1].len = count;
> 	msgs[1].buf = (char *)buf;
> 	msgs[1].scl_rate = scl_rate;
> 	msgs[1].udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, msgs, 2);
> 
> 	return (ret == 2)? count : ret;
> }
> 
> EXPORT_SYMBOL(i2c_master_reg8_recv);
> 
> int i2c_master_reg8_direct_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate)
> {
> 	return i2c_master_reg8_send(client, reg, buf, count, scl_rate);
> }
> EXPORT_SYMBOL(i2c_master_reg8_direct_send);
> 
> int i2c_master_reg8_direct_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate)
> {
> #ifdef CONFIG_ARCH_RK29
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 	char tx_buf[count+1];
> 	
> 	tx_buf[0] = reg;
> 	msg.addr = client->addr;
> 	msg.flags = client->flags | I2C_M_REG8_DIRECT | I2C_M_RD;
> 	msg.len = count + 1;
> 	msg.buf = tx_buf;
> 	msg.scl_rate = scl_rate;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	memcpy(buf, tx_buf + 1, count);
> 	return (ret == 1) ? count : ret;
> #else
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msgs[2];
> 	int ret;
> 	char reg_buf = reg;
> 	
> 	msgs[0].addr = client->addr;
> 	msgs[0].flags = client->flags | I2C_M_RD;
> 	msgs[0].len = 1;
> 	msgs[0].buf = &reg_buf;
> 	msgs[0].scl_rate = scl_rate;
> 	msgs[0].udelay = client->udelay;
> 
> 	msgs[1].addr = client->addr;
> 	msgs[1].flags = client->flags | I2C_M_RD;
> 	msgs[1].len = count;
> 	msgs[1].buf = (char *)buf;
> 	msgs[1].scl_rate = scl_rate;
> 	msgs[1].udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, msgs, 2);
> 
> 	return (ret == 2)? count : ret;
> #endif
> }
> EXPORT_SYMBOL(i2c_master_reg8_direct_recv);
> 
> int i2c_master_reg16_send(const struct i2c_client *client, const short regs, const short *buf, int count, int scl_rate)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 	char *tx_buf = (char *)kmalloc(2 * (count + 1), GFP_KERNEL);
> 	if(!tx_buf)
> 		return -ENOMEM;
> 	memcpy(tx_buf, &regs, 2); 
> 	memcpy(tx_buf+2, (char *)buf, count * 2); 
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags;
> 	msg.len = 2 * (count + 1);
> 	msg.buf = (char *)tx_buf;
> 	msg.scl_rate = scl_rate;
> 	msg.udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	kfree(tx_buf);
> 	return (ret == 1) ? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_reg16_send);
> 
> int i2c_master_reg16_recv(const struct i2c_client *client, const short regs, short *buf, int count, int scl_rate)
> {
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msgs[2];
> 	int ret;
> 	char reg_buf[2];
> 
> 	memcpy(reg_buf, &regs, 2);
> 
> 	msgs[0].addr = client->addr;
> 	msgs[0].flags = client->flags;
> 	msgs[0].len = 2;
> 	msgs[0].buf = reg_buf;
> 	msgs[0].scl_rate = scl_rate;
> 	msgs[0].udelay = client->udelay;
> 
> 	msgs[1].addr = client->addr;
> 	msgs[1].flags = client->flags | I2C_M_RD;
> 	msgs[1].len = count * 2;
> 	msgs[1].buf = (char *)buf;
> 	msgs[1].scl_rate = scl_rate;
> 	msgs[1].udelay = client->udelay;
> 
> 	ret = i2c_transfer(adap, msgs, 2);
> 
> 	return (ret == 2)? count : ret;
> }
> EXPORT_SYMBOL(i2c_master_reg16_recv);
> #else
> 
1415c1855
< 
---
> #endif
1923,1924c2363,2364
< 	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0 },
< 	                          { addr, flags | I2C_M_RD, 0, msgbuf1 }
---
> 	struct i2c_msg msg[2] = { { addr, flags, 1, msgbuf0, 400000, 0, 0 },
> 	                          { addr, flags | I2C_M_RD, 0, msgbuf1, 400000, 0, 0 }




diff -r linux-3.0.36/drivers/i2c/i2c-dev.c linux-3.0.36-lenovo/drivers/i2c/i2c-dev.c
54a55,60
> struct i2c_msg_old{
>         __u16 addr;
>         __u16 flags;
>         __u16 len;
>         __u8 *buf;
> };
234a241,271
> static int copy_i2c_msg_from_user(struct i2c_rdwr_ioctl_data rdwr_arg, struct i2c_msg *rdwr_pa)
> {
>         int i;
> #if 0
> 	if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
> 			   rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
> #else
>         if(1) {
> #endif
> 	        struct i2c_msg_old *rdwr_pa_old;
> 
> 
> 	        rdwr_pa_old = kmalloc(rdwr_arg.nmsgs * sizeof(struct i2c_msg_old), GFP_KERNEL);
> 	        if (!rdwr_pa_old)
> 		        return -ENOMEM;
> 	        if (copy_from_user(rdwr_pa_old, rdwr_arg.msgs,
> 			        rdwr_arg.nmsgs * sizeof(struct i2c_msg_old))) {
> 		        kfree(rdwr_pa_old);
> 		        return -EFAULT;
>                 }else{
>                         for(i = 0; i < rdwr_arg.nmsgs; i++){
>                                 rdwr_pa[i].addr = rdwr_pa_old[i].addr;
>                                 rdwr_pa[i].flags = rdwr_pa_old[i].flags;
>                                 rdwr_pa[i].len = rdwr_pa_old[i].len;
>                                 rdwr_pa[i].buf = rdwr_pa_old[i].buf;
>                         }
>                         kfree(rdwr_pa_old);
>                         return 0;
>                 
>                 }
>         }
235a273,275
>         return 0;
> 
> }
257,259c297,298
< 
< 	if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
< 			   rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
---
> #ifdef CONFIG_PLAT_RK
> 	if ((res = copy_i2c_msg_from_user(rdwr_arg, rdwr_pa)) < 0) {
261c300
< 		return -EFAULT;
---
> 		return res;
263c302,305
< 
---
> #else
>         if (copy_from_user(rdwr_pa, rdwr_arg.msgs,
>                         rdwr_arg.nmsgs * sizeof(struct i2c_msg))) {
> #endif
284a327
>                 rdwr_pa[i].scl_rate = 100 * 1000;
293a337,344
> #ifdef CONFIG_PLAT_RK
>         for(i = 0; i < rdwr_arg.nmsgs; i++){
> 	        res = i2c_transfer(client->adapter, &rdwr_pa[i], 1);
>                 if(res < 0)
>                         break;
>         }
> #else
>         res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
295c346
< 	res = i2c_transfer(client->adapter, rdwr_pa, rdwr_arg.nmsgs);
---
> #endif




diff -r linux-3.0.36/drivers/infiniband/core/netlink.c linux-3.0.36-lenovo/drivers/infiniband/core/netlink.c
151c151
< 						  NULL);
---
> 						  NULL, 0);




diff -r linux-3.0.36/drivers/infiniband/hw/nes/nes.h linux-3.0.36-lenovo/drivers/infiniband/hw/nes/nes.h
513a514
> void nes_terminate_timeout(unsigned long context);




diff -r linux-3.0.36/drivers/infiniband/hw/nes/nes_hw.c linux-3.0.36-lenovo/drivers/infiniband/hw/nes/nes_hw.c
78d77
< static void nes_terminate_timeout(unsigned long context);
3499c3498
< static void nes_terminate_timeout(unsigned long context)
---
> void nes_terminate_timeout(unsigned long context)
3509,3513c3508
< 	init_timer(&nesqp->terminate_timer);
< 	nesqp->terminate_timer.function = nes_terminate_timeout;
< 	nesqp->terminate_timer.expires = jiffies + HZ;
< 	nesqp->terminate_timer.data = (unsigned long)nesqp;
< 	add_timer(&nesqp->terminate_timer);
---
> 	mod_timer(&nesqp->terminate_timer, (jiffies + HZ));




diff -r linux-3.0.36/drivers/infiniband/hw/nes/nes_verbs.c linux-3.0.36-lenovo/drivers/infiniband/hw/nes/nes_verbs.c
1416a1417,1419
> 	init_timer(&nesqp->terminate_timer);
> 	nesqp->terminate_timer.function = nes_terminate_timeout;
> 	nesqp->terminate_timer.data = (unsigned long)nesqp;
1426d1428
< 
2570a2573,2577
> 			if (!region->length) {
> 				nes_debug(NES_DBG_MR, "Unable to register zero length region for CQ\n");
> 				ib_umem_release(region);
> 				return ERR_PTR(-EINVAL);
> 			}




diff -r linux-3.0.36/drivers/infiniband/ulp/ipoib/ipoib_main.c linux-3.0.36-lenovo/drivers/infiniband/ulp/ipoib/ipoib_main.c
151c151
< 	ipoib_ib_dev_down(dev, 0);
---
> 	ipoib_ib_dev_down(dev, 1);




diff -r linux-3.0.36/drivers/infiniband/ulp/ipoib/ipoib_multicast.c linux-3.0.36-lenovo/drivers/infiniband/ulp/ipoib/ipoib_multicast.c
192c192,194
< 	/* Set the cached Q_Key before we attach if it's the broadcast group */
---
> 	/* Set the multicast MTU and cached Q_Key before we attach if it's
> 	 * the broadcast group.
> 	 */
199a202
> 		priv->mcast_mtu = IPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));
203a207,212
> 
> 		if (!ipoib_cm_admin_enabled(dev)) {
> 			rtnl_lock();
> 			dev_set_mtu(dev, min(priv->mcast_mtu, priv->admin_mtu));
> 			rtnl_unlock();
> 		}
587,594d595
< 	}
< 
< 	priv->mcast_mtu = IPOIB_UD_MTU(ib_mtu_enum_to_int(priv->broadcast->mcmember.mtu));
< 
< 	if (!ipoib_cm_admin_enabled(dev)) {
< 		rtnl_lock();
< 		dev_set_mtu(dev, min(priv->mcast_mtu, priv->admin_mtu));
< 		rtnl_unlock();




diff -r linux-3.0.36/drivers/infiniband/ulp/srp/ib_srp.c linux-3.0.36-lenovo/drivers/infiniband/ulp/srp/ib_srp.c
571,572c571,583
< static void srp_remove_req(struct srp_target_port *target,
< 			   struct srp_request *req, s32 req_lim_delta)
---
> /**
>  * srp_claim_req - Take ownership of the scmnd associated with a request.
>  * @target: SRP target port.
>  * @req: SRP request.
>  * @scmnd: If NULL, take ownership of @req->scmnd. If not NULL, only take
>  *         ownership of @req->scmnd if it equals @scmnd.
>  *
>  * Return value:
>  * Either NULL or a pointer to the SCSI command the caller became owner of.
>  */
> static struct scsi_cmnd *srp_claim_req(struct srp_target_port *target,
> 				       struct srp_request *req,
> 				       struct scsi_cmnd *scmnd)
576c587,611
< 	srp_unmap_data(req->scmnd, target, req);
---
> 	spin_lock_irqsave(&target->lock, flags);
> 	if (!scmnd) {
> 		scmnd = req->scmnd;
> 		req->scmnd = NULL;
> 	} else if (req->scmnd == scmnd) {
> 		req->scmnd = NULL;
> 	} else {
> 		scmnd = NULL;
> 	}
> 	spin_unlock_irqrestore(&target->lock, flags);
> 
> 	return scmnd;
> }
> 
> /**
>  * srp_free_req() - Unmap data and add request to the free request list.
>  */
> static void srp_free_req(struct srp_target_port *target,
> 			 struct srp_request *req, struct scsi_cmnd *scmnd,
> 			 s32 req_lim_delta)
> {
> 	unsigned long flags;
> 
> 	srp_unmap_data(scmnd, target, req);
> 
579d613
< 	req->scmnd = NULL;
586,588c620,626
< 	req->scmnd->result = DID_RESET << 16;
< 	req->scmnd->scsi_done(req->scmnd);
< 	srp_remove_req(target, req, 0);
---
> 	struct scsi_cmnd *scmnd = srp_claim_req(target, req, NULL);
> 
> 	if (scmnd) {
> 		srp_free_req(target, req, scmnd, 0);
> 		scmnd->result = DID_RESET << 16;
> 		scmnd->scsi_done(scmnd);
> 	}
1058,1059c1096,1097
< 		scmnd = req->scmnd;
< 		if (!scmnd)
---
> 		scmnd = srp_claim_req(target, req, NULL);
> 		if (!scmnd) {
1062a1101,1107
> 
> 			spin_lock_irqsave(&target->lock, flags);
> 			target->req_lim += be32_to_cpu(rsp->req_lim_delta);
> 			spin_unlock_irqrestore(&target->lock, flags);
> 
> 			return;
> 		}
1077c1122,1124
< 		srp_remove_req(target, req, be32_to_cpu(rsp->req_lim_delta));
---
> 		srp_free_req(target, req, scmnd,
> 			     be32_to_cpu(rsp->req_lim_delta));
> 
1616d1662
< 	int ret = SUCCESS;
1620,1623c1666
< 	if (!req || target->qp_in_error)
< 		return FAILED;
< 	if (srp_send_tsk_mgmt(target, req->index, scmnd->device->lun,
< 			      SRP_TSK_ABORT_TASK))
---
> 	if (!req || target->qp_in_error || !srp_claim_req(target, req, scmnd))
1624a1668,1672
> 	srp_send_tsk_mgmt(target, req->index, scmnd->device->lun,
> 			  SRP_TSK_ABORT_TASK);
> 	srp_free_req(target, req, scmnd, 0);
> 	scmnd->result = DID_ABORT << 16;
> 	scmnd->scsi_done(scmnd);
1626,1634c1674
< 	if (req->scmnd) {
< 		if (!target->tsk_mgmt_status) {
< 			srp_remove_req(target, req, 0);
< 			scmnd->result = DID_ABORT << 16;
< 		} else
< 			ret = FAILED;
< 	}
< 
< 	return ret;
---
> 	return SUCCESS;




diff -r linux-3.0.36/drivers/input/evdev.c linux-3.0.36-lenovo/drivers/input/evdev.c
25a26
> #include <linux/wakelock.h>
45a47,49
> 	struct wake_lock wake_lock;
> 	bool use_wake_lock;
> 	char name[28];
77a82,83
> 		if (client->use_wake_lock)
> 			wake_unlock(&client->wake_lock);
81a88,89
> 		if (client->use_wake_lock)
> 			wake_lock(&client->wake_lock);
96a105
> 	struct timespec ts;
98c107,109
< 	do_gettimeofday(&event.time);
---
> 	ktime_get_ts(&ts);
> 	event.time.tv_sec = ts.tv_sec;
> 	event.time.tv_usec = ts.tv_nsec / NSEC_PER_USEC;
257a269,270
> 	if (client->use_wake_lock)
> 		wake_lock_destroy(&client->wake_lock);
308a322,323
> 	snprintf(client->name, sizeof(client->name), "%s-%d",
> 			dev_name(&evdev->dev), task_tgid_vnr(current));
372c387
< 	have_event = client->head != client->tail;
---
> 	have_event = client->packet_head != client->tail;
375a391,393
> 		if (client->use_wake_lock &&
> 		    client->packet_head == client->tail)
> 			wake_unlock(&client->wake_lock);
389c407
< 	int retval;
---
> 	int retval = 0;
394,401c412,417
< 	if (client->packet_head == client->tail && evdev->exist &&
< 	    (file->f_flags & O_NONBLOCK))
< 		return -EAGAIN;
< 
< 	retval = wait_event_interruptible(evdev->wait,
< 		client->packet_head != client->tail || !evdev->exist);
< 	if (retval)
< 		return retval;
---
> 	if (!(file->f_flags & O_NONBLOCK)) {
> 		retval = wait_event_interruptible(evdev->wait,
> 			 client->packet_head != client->tail || !evdev->exist);
> 		if (retval)
> 			return retval;
> 	}
414a431,432
> 	if (retval == 0 && file->f_flags & O_NONBLOCK)
> 		retval = -EAGAIN;
623a642,670
> static int evdev_enable_suspend_block(struct evdev *evdev,
> 				      struct evdev_client *client)
> {
> 	if (client->use_wake_lock)
> 		return 0;
> 
> 	spin_lock_irq(&client->buffer_lock);
> 	wake_lock_init(&client->wake_lock, WAKE_LOCK_SUSPEND, client->name);
> 	client->use_wake_lock = true;
> 	if (client->packet_head != client->tail)
> 		wake_lock(&client->wake_lock);
> 	spin_unlock_irq(&client->buffer_lock);
> 	return 0;
> }
> 
> static int evdev_disable_suspend_block(struct evdev *evdev,
> 				       struct evdev_client *client)
> {
> 	if (!client->use_wake_lock)
> 		return 0;
> 
> 	spin_lock_irq(&client->buffer_lock);
> 	client->use_wake_lock = false;
> 	wake_lock_destroy(&client->wake_lock);
> 	spin_unlock_irq(&client->buffer_lock);
> 
> 	return 0;
> }
> 
696a744,752
> 
> 	case EVIOCGSUSPENDBLOCK:
> 		return put_user(client->use_wake_lock, ip);
> 
> 	case EVIOCSSUSPENDBLOCK:
> 		if (p)
> 			return evdev_enable_suspend_block(evdev, client);
> 		else
> 			return evdev_disable_suspend_block(evdev, client);
Only in linux-3.0.36-lenovo/drivers/input: gsensor
Only in linux-3.0.36-lenovo/drivers/input: gyroscope
Only in linux-3.0.36-lenovo/drivers/input: jogball




diff -r linux-3.0.36/drivers/input/joystick/walkera0701.c linux-3.0.36-lenovo/drivers/input/joystick/walkera0701.c
198a199
> 	hrtimer_cancel(&w->timer);
226a228,230
> 	hrtimer_init(&w->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
> 	w->timer.function = timer_handler;
> 
257,258d260
< 	hrtimer_init(&w->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
< 	w->timer.function = timer_handler;
274d275
< 	hrtimer_cancel(&w->timer);




diff -r linux-3.0.36/drivers/input/joystick/xpad.c linux-3.0.36-lenovo/drivers/input/joystick/xpad.c
144a145
> 	{ 0x0d2f, 0x0002, "Andamiro Pump It Up pad", MAP_DPAD_TO_BUTTONS, XTYPE_XBOX },




diff -r linux-3.0.36/drivers/input/Kconfig linux-3.0.36-lenovo/drivers/input/Kconfig
163a164,181
> config INPUT_KEYRESET
> 	tristate "Reset key"
> 	depends on INPUT
> 	---help---
> 	  Say Y here if you want to reboot when some keys are pressed;
> 
> 	  To compile this driver as a module, choose M here: the
> 	  module will be called keyreset.
> config RK_LID
>         tristate "rk lid"
>         depends on INPUT && PLAT_RK
> 	---help---
>           Say Y here if you want to support rk lid;
> 
>           To compile this driver as a module, choose M here: the
>           module will be called rk-lid.
> 
> 
175a194,195
> source "drivers/input/ts/Kconfig"
> 
176a197,208
> 
> source "drivers/input/magnetometer/Kconfig"
> 
> source "drivers/input/gsensor/Kconfig"
> 
> source "drivers/input/gyroscope/Kconfig"
> 
> source "drivers/input/jogball/Kconfig"
> 
> source "drivers/input/lightsensor/Kconfig"
> 
> source "drivers/input/sensors/Kconfig"




diff -r linux-3.0.36/drivers/input/keyboard/Kconfig linux-3.0.36-lenovo/drivers/input/keyboard/Kconfig
14a15,27
> config KEYS_RK29
> 	tristate "rk29 keyboard"
> 	depends on PLAT_RK
> 	default y
> 	help
> 	  rk29 keyboard drivers(gpio and adc)
> 
> config SYNAPTICS_SO340010
> 	tristate "Synaptics So340010 TouchPad KEY"
> 	depends on I2C
> 	help
> 	  Synaptics So340010 Touch Key (I2C) driver
> 
204a218,232
> 
> config KEYBOARD_WM831X_GPIO
> 	tristate "WM831X_GPIO Buttons"
> 	depends on GENERIC_GPIO
> 	help
> 	  This driver implements support for buttons connected
> 	  to GPIO pins of various CPUs (and some other chips).
> 
> 	  Say Y here if your device has buttons connected
> 	  directly to such GPIO pins.  Your board-specific
> 	  setup logic must also provide a platform device,
> 	  with configuration data saying which GPIOs are used.
> 
> 	  To compile this driver as a module, choose M here: the
> 	  module will be called wm831x_gpio_keys.




diff -r linux-3.0.36/drivers/input/keyboard/Makefile linux-3.0.36-lenovo/drivers/input/keyboard/Makefile
6a7
> obj-$(CONFIG_KEYS_RK29)			+= rk29_keys.o
17a19
> obj-$(CONFIG_KEYBOARD_WM831X_GPIO)	+= wm831x_gpio_keys.o
53a56
> obj-$(CONFIG_SYNAPTICS_SO340010)        += synaptics_so340010.o




diff -r linux-3.0.36/drivers/input/keyboard/matrix_keypad.c linux-3.0.36-lenovo/drivers/input/keyboard/matrix_keypad.c
51c51,52
< 	bool level_on = !pdata->active_low;
---
> 	// bool level_on = !pdata->active_low;
> 	bool level_on = pdata->active_low;
57c58
< 		gpio_direction_input(pdata->col_gpios[col]);
---
> 		//gpio_direction_input(pdata->col_gpios[col]);
116a118
> 
123c125
< 
---
> #if 1
136c138,143
< 				row_asserted(pdata, row) ? (1 << row) : 0;
---
> 		//	new_state[col] &=
> 		//		row_asserted(pdata, row) ? (1 << row) : 0;
> 				row_asserted(pdata, row) ? 0: (1 << row) ;
> 
>               //printk("matrix_keypad_scan: new_state[0]=0x%x,new_state[1]=0x%x,new_state[2]=0x%x,new_state[3]=0x%x \n",new_state[0] ,new_state[1] ,new_state[2] ,new_state[3]);
>             //  printk("matrix_keypad_scan: row0=0x%x,row1=0x%x,row2=0x%x,row3=0x%x \n",row_asserted(pdata, 0),row_asserted(pdata, 1),row_asserted(pdata, 2),row_asserted(pdata,3));
140c147
< 
---
>    
152a160
> 			//printk("matrix_keypad_scan: MATRIX_SCAN_CODE = 0x%x \n",code);
154c162
< 			input_report_key(input_dev,
---
> 		       input_report_key(input_dev,
156a165,166
> 			//printk("matrix_keypad_scan:input_report_key- keypad->keycodes[code] = 0x%x,state=0x%x \n", keypad->keycodes[code], new_state[col] & (1 << row));
> 		
158c168,169
< 	}
---
> 	}	
> 
169a181,191
> 	
> #else
> 	//activate_all_cols(pdata, false);
>        activate_all_cols(pdata, true);
>        //row_asserted(pdata, 0);
> 	/* Enable IRQs again */
> 	spin_lock_irq(&keypad->lock);
> 	keypad->scan_pending = false;
> 	enable_row_irqs(keypad);
> 	spin_unlock_irq(&keypad->lock);
> #endif
176a199,200
>        //printk("enter matrix_keypad_interrupt \n");
> 	   
187c211
< 	disable_row_irqs(keypad);
---
>        disable_row_irqs(keypad);
317c341,342
< 		gpio_direction_output(pdata->col_gpios[i], !pdata->active_low);
---
> 		//gpio_direction_output(pdata->col_gpios[i], !pdata->active_low);
> 		gpio_direction_output(pdata->col_gpios[i], pdata->active_low);
319a345,346
>        //printk("init_matrix_gpio:pdata->active_low = 0x%x \n",pdata->active_low);
> 	   
346c373
< 					IRQF_DISABLED |
---
> 					/* IRQF_DISABLED | */
388a416
> 	   
450a479,480
>        printk(KERN_INFO "matrix keypad: driver initialized\n");
> 	   
Only in linux-3.0.36-lenovo/drivers/input/keyboard: rk29_keys.c
Only in linux-3.0.36-lenovo/drivers/input/keyboard: synaptics_so340010.c
Only in linux-3.0.36-lenovo/drivers/input/keyboard: wm831x_gpio_keys.c
Only in linux-3.0.36-lenovo/drivers/input: keyreset.c
Only in linux-3.0.36-lenovo/drivers/input: lightsensor
Only in linux-3.0.36-lenovo/drivers/input: magnetometer




diff -r linux-3.0.36/drivers/input/Makefile linux-3.0.36-lenovo/drivers/input/Makefile
24a25,32
> obj-$(CONFIG_G_SENSOR_DEVICE)	+= gsensor/
> obj-$(CONFIG_GYRO_SENSOR_DEVICE)	+= gyroscope/
> obj-$(CONFIG_INPUT_JOGBALL)	+= jogball/
> obj-$(CONFIG_LIGHT_SENSOR_DEVICE) += lightsensor/
> obj-$(CONFIG_MAG_SENSORS)	+= magnetometer/
> 
> obj-$(CONFIG_SENSOR_DEVICE)	+= sensors/
> obj-$(CONFIG_TS_AUTO)	+= ts/
26a35,36
> obj-$(CONFIG_INPUT_KEYRESET)	+= keyreset.o
> obj-$(CONFIG_RK_LID)		+= rk-lid.o
Only in linux-3.0.36-lenovo/drivers/input/misc: al3006.c
Only in linux-3.0.36-lenovo/drivers/input/misc: al3006.h
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_kb.c
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_kb.h
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp.c
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp.h
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp_i2c.c
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp_i2c.h
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp_synaptics.c
Only in linux-3.0.36-lenovo/drivers/input/misc: blueberry_tp_synaptics.h
Only in linux-3.0.36-lenovo/drivers/input/misc: capella_cm3602.c
Only in linux-3.0.36-lenovo/drivers/input/misc: cy8c20236a_capsense.c
Only in linux-3.0.36-lenovo/drivers/input/misc: gpio_axis.c
Only in linux-3.0.36-lenovo/drivers/input/misc: gpio_event.c
Only in linux-3.0.36-lenovo/drivers/input/misc: gpio_input.c
Only in linux-3.0.36-lenovo/drivers/input/misc: gpio_matrix.c
Only in linux-3.0.36-lenovo/drivers/input/misc: gpio_output.c
Only in linux-3.0.36-lenovo/drivers/input/misc: isl29028.c
Only in linux-3.0.36-lenovo/drivers/input/misc: isl29028.h
Only in linux-3.0.36-lenovo/drivers/input/misc: iteec.c
Only in linux-3.0.36-lenovo/drivers/input/misc: iteec.h




diff -r linux-3.0.36/drivers/input/misc/Kconfig linux-3.0.36-lenovo/drivers/input/misc/Kconfig
14a15,54
> 
> config TOUCHPAD_BLUEBERRY
>     tristate "blueberry elan touchpad support"
>     depends on I2C
>     help
>      blueberry ec based elan touchpad driver
> 
> config TOUCHPAD_BLUEBERRY_SYNAPTICS
> 	tristate "blueberry synaptics touchpad support"
> 	depends on I2C
> 	help
> 	  blueberry ec based synaptics touchpad driver
> 
> config KEYBOARD_BLUEBERRY
>     tristate "KEYBOARD_BLUEBERRY"
>     depends on I2C
>     help
>      blueberry ec base keyboard driver
> 
> config ITE_EC
>     tristate "ITE EC"
>     depends on I2C
>     help
>       ITE EC driver
> 
> config CAPSENSE_KEY
>     tristate "CY8C20236 CapSense Key"
>     depends on I2C
>     help
>       CY8C20236 CapSense Key driver
> 
> config INPUT_LPSENSOR_ISL29028
> 	tristate "isl29028 l/p sensor input support"
> 
> config INPUT_LPSENSOR_CM3602
> 	tristate "l/p sensor input support"
> 
> config INPUT_LPSENSOR_AL3006
> 	tristate "al3006 l/p sensor input support"
> 
195a236,246
> config INPUT_KEYCHORD
> 	tristate "Key chord input driver support"
> 	help
> 	  Say Y here if you want to enable the key chord driver
> 	  accessible at /dev/keychord.  This driver can be used
> 	  for receiving notifications when client specified key
> 	  combinations are pressed.
> 
> 	  To compile this driver as a module, choose M here: the
> 	  module will be called keychord.
> 
266a318,327
> config INPUT_TWL6030_PWRBUTTON
> 	tristate "TWL6030 Power button Driver"
> 	depends on TWL4030_CORE
> 	help
> 	  Say Y here if you want to enable power key reporting via the
> 	  TWL6030 family of chips.
> 
> 	  To compile this driver as a module, choose M here. The module will
> 	  be called twl6030_pwrbutton.
> 
296a358,367
> config INPUT_GPIO
> 	tristate "GPIO driver support"
> 	help
> 	  Say Y here if you want to support gpio based keys, wheels etc...
> 
> 
> config RK_BOARD_ID
> 	tristate "get board id support"
> 
> 
479a551,719
> 
> 
> config INPUT_KIONIX_ACCEL 
> 	tristate KIONIX_ACCEL 
> 	depends on I2C && SYSFS 
> 	help 
> 		If you say yes here you get support for the Kionix digital 3-axis 
> 		accelerometer. 
>   
> 		This driver can also be built as a module. If so, the module will be 
> 		called kionix_accel. 
> 
> config ALS_PS_RPR400
>     tristate "ROHM ambient light and proximity sensor rpr-400 support"
>     depends on I2C
>     help
>       Say Y here if you want to support ROHM rpr-400 device
> 
> menuconfig INPUT_SENODIA_ST480
> 	tristate "Senodia Magnetic sensor ST480"
> 	help
> 	Say Y here if you have Senodia ST480 sensor controller.
> 
> if INPUT_SENODIA_ST480
> 	menuconfig ST480_BOARD_LOCATION_FRONT
> 		bool "ST480 board location front"
> 		depends on I2C
> 		help
> 			Say Y here if ST480 board location front on your device.
> 
> 	if ST480_BOARD_LOCATION_FRONT && !ST480_BOARD_LOCATION_BACK
> 	choice
> 		prompt "ST480 board location front"
> 		default ST480_BOARD_LOCATION_FRONT_DEGREE_0
> 
> 		config ST480_BOARD_LOCATION_FRONT_DEGREE_0
> 			bool "ST480 board degree 0"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location front 0 degree on your device.
> 	
> 		config ST480_BOARD_LOCATION_FRONT_DEGREE_90
> 			bool "ST480 board degree 90"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location front 90 degree on your device.
> 	
> 		config ST480_BOARD_LOCATION_FRONT_DEGREE_180
> 			bool "ST480 board degree 180"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location front 180 degree on your device.
> 	
> 		config ST480_BOARD_LOCATION_FRONT_DEGREE_270
> 			bool "ST480 board degree 270"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location front 270 degree on your device.
> 	endchoice
> 	endif
> 
> 	menuconfig ST480_BOARD_LOCATION_BACK
> 		bool "ST480 board location back"
> 		help
> 			Say Y here if ST480 board location back on your device.
> 	
> 	if ST480_BOARD_LOCATION_BACK && !ST480_BOARD_LOCATION_FRONT
> 	choice
> 		prompt "ST480 board location back"
> 		default ST480_BOARD_LOCATION_BACK_DEGREE_0
> 	
> 		config ST480_BOARD_LOCATION_BACK_DEGREE_0
> 			bool "ST480 board degree 0"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location back 0 degree on your device.
> 		
> 		config ST480_BOARD_LOCATION_BACK_DEGREE_90
> 			bool "ST480 board degree 90"
> 		
> 		config ST480_BOARD_LOCATION_BACK_DEGREE_180
> 			bool "ST480 board degree 180"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location back 180 degree on your device.
> 		
> 		config ST480_BOARD_LOCATION_BACK_DEGREE_270
> 			bool "ST480 board degree 270"
> 			help
> 				Say Y here if you have senodia ST480 sensor controller.
> 				Location back 270 degree on your device.
> 	endchoice
> 	endif
> endif
> 
> if ACCELEROMETER_SENSOR
> 	menuconfig ACC_BOARD_LOCATION_FRONT
> 		bool "ACCELEROMETER_SENSOR board location front"
> 		depends on I2C
> 		help
> 			Say Y here if ACCELEROMETER_SENSOR board location front on your device.
> 	
> 	if ACC_BOARD_LOCATION_FRONT && !ACC_BOARD_LOCATION_BACK
> 	choice
> 		prompt "ACCELEROMETER_SENSOR board location front"
> 		default ACC_BOARD_LOCATION_FRONT_DEGREE_0
> 	
> 		config ACC_BOARD_LOCATION_FRONT_DEGREE_0
> 			bool "ACCELEROMETER_SENSOR board degree 0"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location front 0 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_FRONT_DEGREE_90
> 			bool "ACCELEROMETER_SENSOR board degree 90"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location front 90 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_FRONT_DEGREE_180
> 			bool "ACCELEROMETER_SENSOR board degree 180"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location front 180 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_FRONT_DEGREE_270
> 			bool "ACCELEROMETER_SENSOR board degree 270"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location front 270 degree on your device.
> 	endchoice
> 	endif
> 	
> 	menuconfig ACC_BOARD_LOCATION_BACK
> 		bool "ACCELEROMETER_SENSOR board location back"
> 		help
> 			Say Y here if ACCELEROMETER_SENSOR board location back on your device.
> 	
> 	if ACC_BOARD_LOCATION_BACK && !ACC_BOARD_LOCATION_FRONT
> 	choice
> 		prompt "ACCELEROMETER_SENSOR board location back"
> 		default ACC_BOARD_LOCATION_BACK_DEGREE_0
> 	
> 		config ACC_BOARD_LOCATION_BACK_DEGREE_0
> 			bool "ACCELEROMETER_SENSOR board degree 0"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location back 0 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_BACK_DEGREE_90
> 			bool "ACCELEROMETER_SENSOR board degree 90"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location back 90 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_BACK_DEGREE_180
> 			bool "ACCELEROMETER_SENSOR board degree 180"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location back 180 degree on your device.
> 		
> 		config ACC_BOARD_LOCATION_BACK_DEGREE_270
> 			bool "ACCELEROMETER_SENSOR board degree 270"
> 			help
> 				Say Y here if you have senodia ACCELEROMETER_SENSOR controller.
> 				Location back 270 degree on your device.
> 	endchoice
> 	endif
> endif
Only in linux-3.0.36-lenovo/drivers/input/misc: keychord.c
Only in linux-3.0.36-lenovo/drivers/input/misc: kionix_accel.c




diff -r linux-3.0.36/drivers/input/misc/Makefile linux-3.0.36-lenovo/drivers/input/misc/Makefile
6a7,13
> obj-$(CONFIG_KEYBOARD_BLUEBERRY)	+= blueberry_kb.o
> obj-$(CONFIG_TOUCHPAD_BLUEBERRY)	+= blueberry_tp_i2c.o blueberry_tp.o
> obj-$(CONFIG_TOUCHPAD_BLUEBERRY_SYNAPTICS) += blueberry_tp_i2c.o blueberry_tp_synaptics.o
> obj-$(CONFIG_ITE_EC)                += iteec.o
> obj-$(CONFIG_CAPSENSE_KEY)          += cy8c20236a_capsense.o
> obj-$(CONFIG_INPUT_LPSENSOR_CM3602)	+= capella_cm3602.o
> obj-$(CONFIG_INPUT_LPSENSOR_ISL29028)	+= isl29028.o
24a32,33
> obj-$(CONFIG_INPUT_GPIO)		+= gpio_event.o gpio_matrix.o gpio_input.o gpio_output.o gpio_axis.o
> obj-$(CONFIG_RK_BOARD_ID)		+= rk_board_id.o
26a36
> obj-$(CONFIG_INPUT_KEYCHORD)		+= keychord.o
41a52
> obj-$(CONFIG_INPUT_TWL6030_PWRBUTTON)	+= twl6030-pwrbutton.o
48c59,62
< 
---
> obj-$(CONFIG_INPUT_LPSENSOR_AL3006)	+= al3006.o
> obj-$(CONFIG_INPUT_KIONIX_ACCEL)	+= kionix_accel.o
> obj-$(CONFIG_INPUT_SENODIA_ST480) += st480.o
> obj-$(CONFIG_ALS_PS_RPR400) += rpr400.o
Only in linux-3.0.36-lenovo/drivers/input/misc: rk_board_id.c
Only in linux-3.0.36-lenovo/drivers/input/misc: rpr400.c
Only in linux-3.0.36-lenovo/drivers/input/misc: rpr400.h
Only in linux-3.0.36-lenovo/drivers/input/misc: st480.c
Only in linux-3.0.36-lenovo/drivers/input/misc: st480.h
Only in linux-3.0.36-lenovo/drivers/input/misc: twl6030-pwrbutton.c




diff -r linux-3.0.36/drivers/input/misc/wm831x-on.c linux-3.0.36-lenovo/drivers/input/misc/wm831x-on.c
29a30,38
> #include <mach/gpio.h>
> #include <mach/iomux.h>
> #include <linux/delay.h>
> 
> #if 0
> #define DBG(x...)   printk(x)
> #else
> #define DBG(x...)
> #endif 
34a44,46
> 	int flag_resume;
> 	spinlock_t		flag_lock;
> 	struct wake_lock 	wm831x_on_wake;
36a49,144
> struct wm831x_on *g_wm831x_on;
> 
> #ifndef CONFIG_KEYS_RK29
> void rk28_send_wakeup_key(void)
> {
>         printk("%s\n", __FUNCTION__);
> 	if(!g_wm831x_on)
> 	{
> 		printk("%s:addr err!\n",__FUNCTION__);
> 		return;
> 	}
>         input_report_key(g_wm831x_on->dev, KEY_POWER, 1);
>         input_sync(g_wm831x_on->dev);
>         input_report_key(g_wm831x_on->dev, KEY_POWER, 0);
>         input_sync(g_wm831x_on->dev);
>         printk("%s end\n", __FUNCTION__);
> }
> #endif
> 
> #if 1
> 
> static int wm831x_on_suspend_noirq(struct device *dev)
> {
> 	DBG("%s\n",__FUNCTION__);
> 	
> 	if(!g_wm831x_on)
> 	{
> 		printk("%s:addr err!\n",__FUNCTION__);
> 		return -1;
> 	}
> 
> 	spin_lock(&g_wm831x_on->flag_lock);
> 	g_wm831x_on->flag_resume = 0;
> 	spin_unlock(&g_wm831x_on->flag_lock);
> 	return 0;
> }
> 
> static int wm831x_on_resume_noirq(struct device *dev)
> {
> 	//int poll, ret;
> 	
> 	if(!g_wm831x_on)
> 	{
> 		printk("%s:addr err!\n",__FUNCTION__);
> 		return -1;
> 	}
> 	
> 	spin_lock(&g_wm831x_on->flag_lock);
> 	g_wm831x_on->flag_resume = 1;
> 	spin_unlock(&g_wm831x_on->flag_lock);
> 	
> #if 0	
> 	ret = wm831x_reg_read(g_wm831x_on->wm831x, WM831X_ON_PIN_CONTROL);
> 	if (ret >= 0) {
> 		poll = !(ret & WM831X_ON_PIN_STS);	
> 		//poll = 1;
> 		input_report_key(g_wm831x_on->dev, KEY_POWER, poll);
> 		input_sync(g_wm831x_on->dev);
> 		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
> 	} 
> #endif
> 	DBG("%s\n",__FUNCTION__);
> 	return 0;
> }
> 
> static struct dev_pm_ops wm831x_on_dev_pm_ops = {
> 	.suspend_noirq = wm831x_on_suspend_noirq,
> 	.resume_noirq = wm831x_on_resume_noirq,
> };
> 
> 
> static struct platform_driver wm831x_on_pm_driver = {
> 	.driver		= {
> 		.name	= "wm831x_on",
> 		.pm	= &wm831x_on_dev_pm_ops,
> 	},
> };
> 
> static struct platform_device wm831x_on_pm_device = {
> 	.name		= "wm831x_on",
> 	.id		= -1,
> 	.dev = {
> 		.driver = &wm831x_on_pm_driver.driver,
> 	}
> 	
> };
> 
> static inline void wm831x_on_pm_init(void)
> {
> 	if (platform_driver_register(&wm831x_on_pm_driver) == 0)
> 		(void) platform_device_register(&wm831x_on_pm_device);
> }
> 
> 
> #endif	
> 
40a149
>  
51d159
< 
53a162
> 		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
60c169,172
< 		schedule_delayed_work(&wm831x_on->work, 100);
---
> 		schedule_delayed_work(&wm831x_on->work, 2);
> 	else
> 		wake_unlock(&wm831x->handle_wake);
> 		//wake_unlock(&wm831x_on->wm831x_on_wake);
62a175
> #if 0
66c179
< 
---
> 	wake_lock(&wm831x_on->wm831x_on_wake);
67a181,211
> 	return IRQ_HANDLED;
> }
> 
> #else
> 
> static irqreturn_t wm831x_on_irq(int irq, void *data)
> {
> 	struct wm831x_on *wm831x_on = data;
> 	struct wm831x *wm831x = wm831x_on->wm831x;
> 	int poll, ret;
> 	
> 	//wake_lock(&wm831x_on->wm831x_on_wake);
> 		
> 	ret = wm831x_reg_read(wm831x, WM831X_ON_PIN_CONTROL);//it may be unpress if start to read register now
> 	if (ret >= 0) {
> 		if(wm831x_on->flag_resume)
> 		{
> 			poll = 1;
> 			spin_lock(&wm831x_on->flag_lock);
> 			wm831x_on->flag_resume = 0;
> 			spin_unlock(&wm831x_on->flag_lock);
> 		}
> 		else
> 		poll = !(ret & WM831X_ON_PIN_STS);
> 		input_report_key(wm831x_on->dev, KEY_POWER, poll);
> 		input_sync(wm831x_on->dev);
> 		DBG("%s:poll=%d,ret=0x%x\n",__FUNCTION__,poll,ret);
> 	} else {
> 		dev_err(wm831x->dev, "Failed to read ON status: %d\n", ret);
> 		poll = 1;
> 	}
68a213,218
> 	if (poll)
> 		schedule_delayed_work(&wm831x_on->work, 0);
> 	else
> 		wake_unlock(&wm831x->handle_wake);
> 		//wake_unlock(&wm831x_on->wm831x_on_wake);
> 			
71a222,223
> #endif
> 
75c227
< 	struct wm831x_on *wm831x_on;
---
> 	struct wm831x_on *wm831x_on = NULL;
78c230
< 
---
> 	printk("%s irq=%d\n", __FUNCTION__,irq);
84a237
> 	
87c240,241
< 
---
> 	wake_lock_init(&wm831x_on->wm831x_on_wake, WAKE_LOCK_SUSPEND, "wm831x_on_wake");
> 	
99a254,256
> 	g_wm831x_on = wm831x_on;
> 
> 	wm831x_on_pm_init();




diff -r linux-3.0.36/drivers/input/mouse/bcm5974.c linux-3.0.36-lenovo/drivers/input/mouse/bcm5974.c
375a376,378
> 	if (cfg->caps & HAS_INTEGRATED_BUTTON)
> 		__set_bit(INPUT_PROP_BUTTONPAD, input_dev->propbit);
> 
Only in linux-3.0.36-lenovo/drivers/input: rk-lid.c
Only in linux-3.0.36-lenovo/drivers/input: sensors




diff -r linux-3.0.36/drivers/input/serio/i8042-x86ia64io.h linux-3.0.36-lenovo/drivers/input/serio/i8042-x86ia64io.h
179a180,193
> 		/* Gigabyte T1005 - defines wrong chassis type ("Other") */
> 		.matches = {
> 			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "T1005"),
> 		},
> 	},
> 	{
> 		/* Gigabyte T1005M/P - defines wrong chassis type ("Other") */
> 		.matches = {
> 			DMI_MATCH(DMI_SYS_VENDOR, "GIGABYTE"),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "T1005M/P"),
> 		},
> 	},
> 	{
323a338,343
> 			DMI_MATCH(DMI_SYS_VENDOR, "TOSHIBA"),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "SATELLITE C850D"),
> 		},
> 	},
> 	{
> 		.matches = {
882a903
> 	u8 a20_on = 0xdf;
921a943,950
> 
> 	/*
> 	 * A20 was already enabled during early kernel init. But some buggy
> 	 * BIOSes (in MSI Laptops) require A20 to be enabled using 8042 to
> 	 * resume from S3. So we do it here and hope that nothing breaks.
> 	 */
> 	i8042_command(&a20_on, 0x10d1);
> 	i8042_command(NULL, 0x00ff);	/* Null command for SMM firmware */




diff -r linux-3.0.36/drivers/input/tablet/wacom_wac.c linux-3.0.36-lenovo/drivers/input/tablet/wacom_wac.c
245c245
< 			input_report_abs(input, ABS_PRESSURE, data[6] | ((data[7] & 0x01) << 8));
---
> 			input_report_abs(input, ABS_PRESSURE, data[6] | ((data[7] & 0x03) << 8));
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: 86v_gt811_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: 86v_gt811_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: atmel_maxtouch.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: atmel_mxt1386.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: atmel_mxt1386.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: atmel_mxt224.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: byd693x_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: byd693x_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: calib_iface_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: calibration_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: calibration_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ct360_calib.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ct360_ch.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ct360_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ct36x
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: CT36X_JS_DS_973H_LX20x30_V18120810W.txt
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ct36x_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ctp_it7250.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: eeti_egalax_i2c.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k_2wireice.i
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k_fw_data.i
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ektf2k_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5306_ts_av.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5306_ts_av.cfg
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5306_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5306_ts_wpx2.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5406_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5x0x.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5x0x_i2c_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ft5x0x_i2c_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: fw_mutto_data.i
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: fw_ofilm_data.i
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: goodix_tool.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: goodix_tool_gt9xx.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: goodix_touch_82x.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: goodix_touch.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt801_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt801_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt8110_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt811_firmware.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt811_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt811_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt813_827_828.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt813_827_828_firmware.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt813_827_828.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt813_827_828_update.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt818_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt818_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt819.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt819.cfg
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt9xx.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt9xx.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: gt9xx_update.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: hannstar_p1003.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: i30_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ili2102_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ili2102_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: it7260_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: IT7260_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: IT7260_ts_i2c.c




diff -r linux-3.0.36/drivers/input/touchscreen/Kconfig linux-3.0.36-lenovo/drivers/input/touchscreen/Kconfig
13a14,75
> config CT36X_TS
> 	tristate "CT36X touchscreens support"
> 
> config TOUCHSCREEN_GSLX680
> 		tristate "gslX680 touchscreen panel support "
> 		depends on I2C2_RK29 || I2C2_RK30
> config TOUCHSCREEN_GSLX680_RK3168
> 		tristate "gslX680 rk3168 touchscreen panel support "
> 		depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_XPT2046_SPI
> 	tristate "XPT2046 based touchscreens:SPI Interface"
> 	depends on SPIM_RK29
> 
> 	config TOUCHSCREEN_XPT2046_NORMAL_SPI
> 	tristate "normal mode"
> 	depends on TOUCHSCREEN_XPT2046_SPI
> 
> 		config TOUCHSCREEN_480X800
> 		tristate "480X800 resolution"
> 		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
> 
> 		config TOUCHSCREEN_800X480
> 		tristate "800X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
> 
> 		config TOUCHSCREEN_320X480
> 		tristate "320X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_NORMAL_SPI
> 
> 	config TOUCHSCREEN_XPT2046_TSLIB_SPI
> 	tristate "tslib mode"
> 	depends on TOUCHSCREEN_XPT2046_SPI
> 
> 		config TOUCHSCREEN_480X800
> 		tristate "480X800 resolution"
> 		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
> 
> 		config TOUCHSCREEN_800X480
> 		tristate "800X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
> 
> 		config TOUCHSCREEN_320X480
> 		tristate "320X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_TSLIB_SPI
> 
> 	config TOUCHSCREEN_XPT2046_CBN_SPI
> 	tristate "calibration mode"
> 	depends on TOUCHSCREEN_XPT2046_SPI
> 
> 		config TOUCHSCREEN_480X800
> 		tristate "480X800 resolution"
> 		depends on TOUCHSCREEN_XPT2046_CBN_SPI
> 
> 		config TOUCHSCREEN_800X480
> 		tristate "800X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_CBN_SPI
> 
> 		config TOUCHSCREEN_320X480
> 		tristate "320X480 resolution"
> 		depends on TOUCHSCREEN_XPT2046_CBN_SPI
> 
57a120,164
> config TOUCHSCREEN_ILI2102_IIC
> 	tristate "ili2102 based touchscreens: IIC Interface"
> 	help
> 	  Say Y here if you have a touchscreen interface using the
> 	  hx8520 controller, and your board-specific initialization
> 	  code includes that in its table of IIC devices.
> 
> 	  If unsure, say N (but it's safe to say "Y").
> config TOUCHSCREEN_GT8XX
>         tristate "Goodix touch screen gt801X2 support for rockchip based platform"
>         help
>           Say Y here if you have a touchscreen interface using the
>           two goodix gt801  , and your board-specific initialization
>           code includes that in its table of IIC devices.
> 	  If unsure, say N.
> 	config TOUCH_MAX_X
>                 int "touch max x resolution"
>                 depends on TOUCHSCREEN_GT8XX
>                 default 1280
>                 help
>                   goodix  touch max X resolution
> 
>         config TOUCH_MAX_Y
>                 int "touch max y resolution"
>                 depends on TOUCHSCREEN_GT8XX
>                 default 800
>                 help
>                   goodix touch max y resolution
> 
> config TOUCHSCREEN_CT36X
> 	tristate "CT36X based touchscreens"
> 
> config RK28_I2C_TS_NTP070
> 	tristate "NTP070 based touchscreens: NTP070 Interface"
> 	depends on I2C_RK2818
> 
> config TOUCHSCREEN_IT7250
> 	tristate "IT7250 based touchscreens: IT7250 Interface"
> 	help
> 	  Say Y here if you have a touchscreen interface using the
> 	  xpt2046 controller, and your board-specific initialization
> 	  code includes that in its table of SPI devices.
> 
> 	  If unsure, say N (but it's safe to say "Y").
> 
385a493,498
> config TOUCHSCREEN_SYNAPTICS_I2C_RMI
> 	tristate "Synaptics i2c touchscreen"
> 	depends on I2C
> 	help
> 	  This enables support for Synaptics RMI over I2C based touchscreens.
> 
728a842,1112
> config HANNSTAR_P1003
> 	tristate "Hannstar P1003 touchscreen"
> 	depends on I2C2_RK29
> 	help
> 	  RK29 hannstar touch
> 
> 	config HANNSTAR_MAX_X
> 	        int "hannstar touch x max"
> 		depends on HANNSTAR_P1003
> 		default 1087
> 		help
> 		  RK29 hannstar touch max X size
> 
> 	config HANNSTAR_MAX_Y
>                 int "hannstar touch Y max"
>                 depends on HANNSTAR_P1003
> 		default 800
>                 help
>                   RK29 hannstar touch max Y size
> 
> 	config HANNSTAR_DEBUG
> 		bool "hannstar debug"
> 		depends on HANNSTAR_P1003
> 		default n
> 		help
> 		  RK29 hannstar touch debug
> 
> config ATMEL_MXT224
>         tristate "Atmel mXT224 touchscreen"
>         depends on I2C2_RK29
>         help
>           RK29 Atmel_mXT224 touch
> 
>         config MXT224_MAX_X
>                 int "atmel_mxt224 touch X max"
>                 depends on ATMEL_MXT224
>                 default 4095
>                 help
>                   RK29 atmel_mxt224 touch max X size
> 
>         config MXT224_MAX_Y
>                 int "atmel_mxt224 touch Y max"
>                 depends on ATMEL_MXT224
>                 default 4095
>                 help
>                   RK29 atmel_mxt224 touch max Y size
> 
> config SINTEK_3FA16
> 	tristate "Sintek 3FA16 touchscreen"
>         depends on I2C2_RK29
>         help
>           RK29 Sintek touch
> 
>         config HANNSTAR_MAX_X
>                 int "Sintek touch x max"
>                 depends on SINTEK_3FA16
>                 default 1024
>                 help
>                   RK29 hannstar touch max X size
> 
>         config HANNSTAR_MAX_Y
>                 int "Sintek touch Y max"
>                 depends on SINTEK_3FA16
>                 default 600
>                 help
>                   RK29 hannstar touch max Y size
> 
>         config HANNSTAR_DEBUG
>                 bool "Sintek debug"
>                 depends on SINTEK_3FA16
>                 default n
>                 help
>                   RK29 hannstar touch debug
> 
> config EETI_EGALAX
>         tristate "EETI_EGALAX touchscreen panel support"
>         depends on I2C
>         help
>           Say Y here to enable support for I2C connected EETI touch panels.
> 
>           To compile this driver as a module, choose M here: the
>           module will be called eeti_egalax_ts.
> 
>         config EETI_EGALAX_MAX_X
>                 int "EETI_EGALAX_MAX_X"
>                 depends on EETI_EGALAX
>                 default 2047
>                 help
>                   RK29 EETI_EGALAX touch max X size
> 
>         config EETI_EGALAX_MAX_Y
>                 int "EETI_EGALAX_MAX_Y"
>                 depends on EETI_EGALAX
>                 default 2047
>                 help
>                   RK29 EETI_EGALAX touch max Y size
> 
>         config EETI_EGALAX_DEBUG
>                 bool "EETI_EGALAX debug"
>                 depends on EETI_EGALAX
>                 default n
>                 help
>                   RK29 EETI_EGALAX touch debug
> 
> config TOUCHSCREEN_IT7260
> 	tristate "IT7260 based touchscreens: IT7260 Interface"
> 	depends on I2C2_RK29
> 	help
> 	  Say Y here if you have a touchscreen interface using the
> 	  it7260 controller, and your board-specific initialization
> 	  code includes that in its table of I2C devices.
> 
> 	  If unsure, say N (but it's safe to say "Y").
> 
> config TOUCHSCREEN_IT7260_I2C
> 	tristate "IT7260 based touchscreens: IT7260 I2C Interface"
> 	depends on I2C_RK29
> 	help
> 	  Say Y here if you have a touchscreen interface using the
> 	  IT7260 controller, and your board-specific initialization
> 	  code includes that in its table of I2C devices.
> 
> 	  If unsure, say N (but it's safe to say "Y").
> 
> config TOUCHSCREEN_NAS
>         tristate "NAS based touchscreens: NAS Interface"
>         depends on I2C2_RK29
>         help
>           Say Y here if you have a touchscreen interface using the
>           nas controller, and your board-specific initialization
>           code includes that in its table of I2C devices.
> 
>           If unsure, say N (but it's safe to say "Y").
> 
> config LAIBAO_TS
> 	tristate "LAIBAO touchscreen"
> 	depends on I2C2_RK29
> 	help
> 	  RK29 LAIBAO touchscreen
> 
> config TOUCHSCREEN_GT801_IIC
> 	tristate "GT801_IIC based touchscreens"
> 	depends on I2C2_RK29
> 
> config TOUCHSCREEN_GT811_IIC
> 	tristate "GT811_IIC based touchscreens"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_86V_GT811_IIC
> 	tristate "RK3168_86V GT811_IIC based touchscreens"
> 	depends on I2C2_RK29 || I2C2_RK30
> 		
> config TOUCHSCREEN_GT82X_IIC
> 	tristate "GT82x_IIC based touchscreens"
> 	depends on I2C2_RK30
> 
> config TOUCHSCREEN_GT818_IIC
> 	tristate "GT818_IIC based touchscreens"
> 	depends on I2C2_RK29
> 
> config TOUCHSCREEN_PIXCIR
> 	tristate "PIXCIR_IIC based touchscreens"
> 	depends on I2C2_RK29
> 	
> config TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK
> 	tristate "Synaptics i2c rmi4 touchscreen"
> 	depends on I2C_RK30
> 	help
> 	  This enables support for Synaptics RMI over I2C based touchscreens.
> 	config TOUCHSCREEN_SYNAPTICS_S3202
> 		tristate "SYNAPTICS S3202 touchscreen"
> 		depends on TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK
> 	source "drivers/input/touchscreen/rmi4/Kconfig"
> config D70_L3188A
> 	tristate "D70-L3188A based touchscreens"
> 	depends on I2C2_RK29
> 
> config TOUCHSCREEN_GT819
> 	tristate "GT819 based touchscreens"
> 	depends on I2C2_RK29
> 
> config TOUCHSCREEN_GT8110
>         tristate "GT8110 based touchscreens"
>         depends on I2C2_RK29 || I2C_RK30
> 
> config TOUCHSCREEN_GT813
> 	tristate "GT813 based touchscreens"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_GT9XX
> 	tristate "GT911 based touchscreens"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_CT360_IIC
> 	tristate "CT360 based touchscreens"
> 	depends on I2C_RK29 || I2C_RK30
> 
> config TOUCHSCREEN_FT5306
> 	tristate "FT5306 based touchscreens: FT5306 Interface"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_I30
> 	tristate "i30 based touchscreens: i30(ft5306) Interface"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_BYD693X
> 	tristate "touchscreen BYD693X I2C Interface"
> 	depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_SITRONIX_A720
> 	tristate "SITRONIX based touchscreens: SITRONIX Interface for a720"
> 	depends on I2C2_RK29 || I2C2_RK30 
> 
> config TOUCHSCREEN_FT5306_WPX2
>         tristate "FT5306 based touchscreens: FT5306 Interface,only used for umeox wpx2 board"
>         depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_FT5306_AV
>         tristate "FT5306 based touchscreens: FT5306 Interface base on AV-Display factory 1204*600"
>         depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_FT5406
> 	tristate "FT5406 based touchscreens: FT5406 Interface"
> 	depends on I2C2_RK29
> 	help
> 	  say Y here if you have a touchscreen interface using the FT5406
> 	  controller,and your board-specific initialization code includes that
> 	  in its table of I2C devices.
> 
> 	  If unsure, say N(but it's safe to say "Y").
> 
> config TOUCHSCREEN_FT5X0X
> 		tristate "ft5x0x touchscreen panel support "
> 		depends on I2C2_RK29 || I2C2_RK30
> 
> config TOUCHSCREEN_EKTF2K
> 		tristate "elan eKTH3264 touch screen panel support"
> 		depends on I2C
> 		help
> 		  Say Y here to enable support for elan eKTH3264 touch screen panel support.
> 			
> 
> config ATMEL_MXT1386
>         tristate "ATMEL_MXT1386 touchscreen panel support"
>         depends on I2C
>         help
>           Say Y here to enable support for I2C connected ATMEL_MXT1386 touch panels.
> 
>           To compile this driver as a module, choose M here: the
>           module will be called atmel_mxt1386_ts.
> 
>         config ATMEL_MXT1386_MAX_X
>                 int "ATMEL_MXT1386_MAX_X"
>                 depends on ATMEL_MXT1386
>                 default 4095
>                 help
>                   RK29 ATMEL_MXT1386 touch max X size
> 
>         config ATMEL_MXT1386_MAX_Y
>                 int "ATMEL_MXT1386_MAX_Y"
>                 depends on ATMEL_MXT1386
>                 default 4095
>                 help
>                   RK29 ATMEL_MXT1386 touch max Y size
> 
>         config ATMEL_MXT1386_DEBUG
>                 bool "ATMEL_MXT1386 debug"
>                 depends on ATMEL_MXT1386
>                 default n
>                 help
>                   RK29 ATMEL_MXT1386 touch debug
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: largenum_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: largenum_ts.h




diff -r linux-3.0.36/drivers/input/touchscreen/Makefile linux-3.0.36-lenovo/drivers/input/touchscreen/Makefile
8c8
< 
---
> obj-y                  			+= ct36x/
45a46
> obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI)	+= synaptics_i2c_rmi.o
62a64,106
> obj-$(CONFIG_TOUCHSCREEN_PCAP)		+= pcap_ts.o
> obj-$(CONFIG_TOUCHSCREEN_XPT2046_NORMAL_SPI)	+= xpt2046_ts.o
> obj-$(CONFIG_TOUCHSCREEN_XPT2046_TSLIB_SPI)	+= xpt2046_tslib_ts.o ts_lib/
> obj-$(CONFIG_TOUCHSCREEN_XPT2046_CBN_SPI)	+= xpt2046_cbn_ts.o calibration_ts.o largenum_ts.o calib_iface_ts.o
> obj-$(CONFIG_TOUCHSCREEN_IT7250)	+= ctp_it7250.o
> obj-$(CONFIG_RK28_I2C_TS_NTP070)	+= ntp070.o
> obj-$(CONFIG_HANNSTAR_P1003)		+= hannstar_p1003.o
> obj-$(CONFIG_TOUCHSCREEN_IT7260)	+= it7260_ts.o
> obj-$(CONFIG_TOUCHSCREEN_IT7260_I2C)	+= IT7260_ts_i2c.o
> obj-$(CONFIG_SINTEK_3FA16)		+= sintek_3FA16.o
> obj-$(CONFIG_EETI_EGALAX)		+= eeti_egalax_i2c.o
> obj-$(CONFIG_ATMEL_MXT224)		+= atmel_maxtouch.o
> obj-$(CONFIG_ATMEL_MXT1386)		+= atmel_mxt1386.o
> obj-$(CONFIG_TOUCHSCREEN_GT801_IIC)	+= gt801_ts.o
> obj-$(CONFIG_TOUCHSCREEN_GT811_IIC)	+= gt811_ts.o
> obj-$(CONFIG_TOUCHSCREEN_86V_GT811_IIC)	+= 86v_gt811_ts.o
> obj-$(CONFIG_TOUCHSCREEN_GT82X_IIC)	+= goodix_touch_82x.o
> obj-$(CONFIG_TOUCHSCREEN_GT818_IIC)	+= gt818_ts.o
> obj-$(CONFIG_TOUCHSCREEN_GT8110)        += gt8110_ts.o
> obj-$(CONFIG_TOUCHSCREEN_CT360_IIC)	+= ct360_ts.o
> obj-$(CONFIG_TOUCHSCREEN_ILI2102_IIC)	+= ili2102_ts.o
> obj-$(CONFIG_D70_L3188A)		+= goodix_touch.o
> obj-$(CONFIG_TOUCHSCREEN_GT8XX)                += rk29_i2c_goodix.o
> obj-$(CONFIG_TOUCHSCREEN_FT5406)	+= ft5406_ts.o
> obj-$(CONFIG_TOUCHSCREEN_FT5306)	+= ft5306_ts.o
> obj-$(CONFIG_TOUCHSCREEN_SITRONIX_A720)	+= sitronix_ts_a720.o
> obj-$(CONFIG_TOUCHSCREEN_FT5306_WPX2)        += ft5306_ts_wpx2.o
> obj-$(CONFIG_TOUCHSCREEN_FT5306_AV) += ft5306_ts_av.o
> obj-$(CONFIG_TOUCHSCREEN_GT819)		+= gt819.o
> obj-$(CONFIG_TOUCHSCREEN_CT36X)		+= ct36x_ts.o
> obj-$(CONFIG_TOUCHSCREEN_NAS)		+= nas_ts.o
> obj-$(CONFIG_LAIBAO_TS)		+= ft5x0x_i2c_ts.o
> obj-$(CONFIG_TOUCHSCREEN_PIXCIR)      += pixcir_i2c_ts.o
> obj-$(CONFIG_TOUCHSCREEN_SYNAPTICS_RMI4_I2C_RK)      += rmi4/
> obj-$(CONFIG_TOUCHSCREEN_I30)	+= i30_ts.o
> obj-$(CONFIG_TOUCHSCREEN_BYD693X)	+= byd693x_ts.o
> obj-$(CONFIG_TOUCHSCREEN_FT5X0X)	+= ft5x0x.o
> obj-$(CONFIG_TOUCHSCREEN_GSLX680)	+= rockchip_gslX680.o
> obj-$(CONFIG_TOUCHSCREEN_GT813)		+= gt813_827_828.o gt813_827_828_update.o goodix_tool.o
> obj-$(CONFIG_TOUCHSCREEN_GT9XX)		+= gt9xx.o gt9xx_update.o goodix_tool_gt9xx.o
> 
> obj-$(CONFIG_TOUCHSCREEN_GSLX680_RK3168)	+= rockchip_gslX680_rk3168.o
> obj-$(CONFIG_TOUCHSCREEN_EKTF2K)	+= ektf2k_ts.o
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: malata.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: nas_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ntp070.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: pixcir_i2c_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: pixcir_i2c_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rk29_i2c_goodix.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rk29_i2c_goodix.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rk_tp.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rmi4
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rockchip_gslX680.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rockchip_gslX680.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rockchip_gslX680_rk3168.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: rockchip_gslX680_rk3168.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: sintek_3FA16.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: sitronix_ts_a720.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: sitronix_ts_a720.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: synaptics_i2c_rmi4.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: synaptics_i2c_rmi4.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: synaptics_i2c_rmi.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: ts_lib
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_cbn_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_cbn_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_ts_320X480.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_ts.h
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_tslib_ts.c
Only in linux-3.0.36-lenovo/drivers/input/touchscreen: xpt2046_tslib_ts.h
Only in linux-3.0.36-lenovo/drivers/input: ts




diff -r linux-3.0.36/drivers/isdn/gigaset/bas-gigaset.c linux-3.0.36-lenovo/drivers/isdn/gigaset/bas-gigaset.c
619c619,625
< 	if (rc != 0 && rc != -ENODEV) {
---
> 
> 	switch (rc) {
> 	case 0:		/* success */
> 	case -ENODEV:	/* device gone */
> 	case -EINVAL:	/* URB already resubmitted, or terminal badness */
> 		break;
> 	default:	/* failure: try to recover by resetting the device */
2440c2446,2448
<  * This function is called before the USB connection is suspended.
---
>  * This function is called before the USB connection is suspended
>  * or before the USB device is reset.
>  * In the latter case, message == PMSG_ON.
2496c2504,2509
< 	cancel_work_sync(&ucs->int_in_wq);
---
> 
> 	/* don't try to cancel int_in_wq from within reset as it
> 	 * might be the one requesting the reset
> 	 */
> 	if (message.event != PM_EVENT_ON)
> 		cancel_work_sync(&ucs->int_in_wq);




diff -r linux-3.0.36/drivers/isdn/gigaset/capi.c linux-3.0.36-lenovo/drivers/isdn/gigaset/capi.c
265a266,267
> 	if (l <= 0)
> 		return;




diff -r linux-3.0.36/drivers/isdn/isdnloop/isdnloop.c linux-3.0.36-lenovo/drivers/isdn/isdnloop/isdnloop.c
19d18
< static char *revision = "$Revision: 1.11.6.7 $";
1497,1507d1495
< 	char *p;
< 	char rev[10];
< 
< 	if ((p = strchr(revision, ':'))) {
< 		strcpy(rev, p + 1);
< 		p = strchr(rev, '$');
< 		*p = 0;
< 	} else
< 		strcpy(rev, " ??? ");
< 	printk(KERN_NOTICE "isdnloop-ISDN-driver Rev%s\n", rev);
< 




diff -r linux-3.0.36/drivers/Kconfig linux-3.0.36-lenovo/drivers/Kconfig
54a55,58
> source "drivers/adc/Kconfig"
> 
> source "drivers/headset_observe/Kconfig"
> 
98a103,104
> source "drivers/switch/Kconfig"
> 
127a134,143
> 
> source "drivers/cmmb/Kconfig"
> 
> source "drivers/testcode/Kconfig"
> 
> source "drivers/smc/Kconfig"
> 
> source "drivers/cir/Kconfig"
> 
> source "drivers/mtk_wcn_combo/Kconfig"




diff -r linux-3.0.36/drivers/leds/Kconfig linux-3.0.36-lenovo/drivers/leds/Kconfig
52a53,63
> config LEDS_LM3642
> 	tristate "LED support driver for LM3642"
>         depends on LEDS_CLASS
>         depends on I2C
> 
> config LEDS_LM2759
> 	tristate "LED support driver for LM2759"
>         depends on LEDS_CLASS
>         depends on I2C
> 
> 
325a337,343
> config LEDS_ATT1272
> 	tristate "LED driver for ATT1272 LED"
> 	depends on LEDS_CLASS && I2C
> 	help
> 	  This option enables support for ATT1272 LED driver chips
> 	  accessed via the I2C bus.
> 
467a486,491
> 
> config LEDS_TRIGGER_SLEEP
> 	tristate "LED Sleep Mode Trigger"
> 	depends on LEDS_TRIGGERS && HAS_EARLYSUSPEND
> 	help
> 	  This turns LEDs on when the screen is off but the cpu still running.
Only in linux-3.0.36-lenovo/drivers/leds: leds-att1272.c
Only in linux-3.0.36-lenovo/drivers/leds: leds-lm2759.c
Only in linux-3.0.36-lenovo/drivers/leds: leds-lm3642.c




diff -r linux-3.0.36/drivers/leds/leds-wm831x-status.c linux-3.0.36-lenovo/drivers/leds/leds-wm831x-status.c
21a22,30
> struct light_state_t {
> 	unsigned int color;
> 
> 	int mode;
> 	int onms;
> 	int offms;
> 
> 	int brightness;
> };
158a168,263
> static ssize_t wm831x_status_blink_store(struct device *dev,
> 				       struct device_attribute *attr,
> 				       const char *buf, size_t size)
> {
> 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
> 	struct wm831x_status *led = to_wm831x_status(led_cdev);
> 	struct light_state_t *light_state = NULL;
> 	unsigned long flags;
> 	int ret = 0;
>     enum led_brightness value;
> 	unsigned int delay_on, delay_off, mode, color;
> 
> 	if (size != sizeof (struct light_state_t)) {
> 		printk("%s: set led blink err\n", __func__);
> 		return -1;
> 	}
> 
> 	light_state = (struct light_state_t *)buf;
> 	if (light_state) {
> 		led->src = 3;
> 
> 		value = light_state->brightness;
> 		delay_on = light_state->onms;
> 		delay_off = light_state->offms;
> 		mode = light_state->mode;
> 		color = light_state->color;
> 
> 		//printk("%s: color = %#x delay_on = %d delya_off = %d brightness = %d mode = %d\n",
> 		//		__func__, color, delay_on, delay_off, value, mode);
> 		if (delay_on == 0 && delay_off == 0) {
> 			delay_on = 250;
> 			delay_off = 250;
> 		}
> 
> 		spin_lock_irqsave(&led->value_lock, flags);
> 
> 		switch (delay_on) {
> 		case 1000:
> 			led->blink_time = 0;
> 			break;
> 		case 500:
> 		case 250:
> 			led->blink_time = 1;
> 			break;
> 		case 125:
> 			led->blink_time = 2;
> 			break;
> 		case 62:
> 		case 63:
> 			/* Actually 62.5ms */
> 			led->blink_time = 3;
> 			break;
> 		default:
> 			ret = -EINVAL;
> 			break;
> 		}
> 
> 		if (ret == 0) {
> 			switch (delay_off / delay_on) {
> 			case 1:
> 				led->blink_cyc = 0;
> 				break;
> 			case 3:
> 				led->blink_cyc = 1;
> 				break;
> 			case 4:
> 				led->blink_cyc = 2;
> 				break;
> 			case 8:
> 				led->blink_cyc = 3;
> 				break;
> 			default:
> 				ret = -EINVAL;
> 				break;
> 			}
> 		}
> 
> 		if (ret == 0)
> 			led->blink = 1;
> 		else
> 			led->blink = 0;
> 		
> 		//set led brightness
> 		led->brightness = mode;
> 		if (led->brightness == LED_OFF)
> 			led->blink = 0;
> 
> 		schedule_work(&led->work);
> 
> 		spin_unlock_irqrestore(&led->value_lock, flags);
> 	}
> 
> 	return size;
> }
> static DEVICE_ATTR(blink, 0777, NULL, wm831x_status_blink_store);
> 
264a370,371
> 	if (drvdata->reg == WM831X_STATUS_LED_2)
> 		wm831x_reg_write(wm831x, drvdata->reg, 0xc027);
291a399,403
> 
> 	ret = device_create_file(drvdata->cdev.dev, &dev_attr_blink);
> 	if (ret != 0)
> 		dev_err(&pdev->dev,
> 			"LED no blink function: %d\n", ret);
Only in linux-3.0.36-lenovo/drivers/leds: ledtrig-sleep.c




diff -r linux-3.0.36/drivers/leds/Makefile linux-3.0.36-lenovo/drivers/leds/Makefile
12a13,14
> obj-$(CONFIG_LEDS_LM3642)		+= leds-lm3642.o
> obj-$(CONFIG_LEDS_LM2759)		+= leds-lm2759.o
36a39
> obj-$(CONFIG_LEDS_ATT1272)		+= leds-att1272.o
56a60
> obj-$(CONFIG_LEDS_TRIGGER_SLEEP)	+= ledtrig-sleep.o




diff -r linux-3.0.36/drivers/Makefile linux-3.0.36-lenovo/drivers/Makefile
53a54
> obj-y				+= headset_observe/
79a81
> obj-y				+= adc/
100a103
> obj-$(CONFIG_SWITCH)		+= switch/
124a128,134
> obj-$(CONFIG_CMMB)		+= cmmb/
> obj-$(CONFIG_TEST_CODE)		+= testcode/
> obj-y				+= smc/
> obj-y				+= cir/
> obj-$(CONFIG_ARCH_RK29)		+= dbg/
> obj-$(CONFIG_MTK_COMBO)		+= mtk_wcn_combo/
> obj-$(CONFIG_MT5931_MT6622)     += mtk_wcn_bt/




diff -r linux-3.0.36/drivers/md/dm.c linux-3.0.36-lenovo/drivers/md/dm.c
747a748,753
> 	/*
> 	 * Run this off this callpath, as drivers could invoke end_io while
> 	 * inside their request_fn (and holding the queue lock). Calling
> 	 * back into ->request_fn() could deadlock attempting to grab the
> 	 * queue lock again.
> 	 */
749c755
< 		blk_run_queue(md->queue);
---
> 		blk_run_queue_async(md->queue);
859c865
< 	dm_request_endio_fn rq_end_io = tio->ti->type->rq_end_io;
---
> 	dm_request_endio_fn rq_end_io = NULL;
861,862c867,872
< 	if (mapped && rq_end_io)
< 		r = rq_end_io(tio->ti, clone, error, &tio->info);
---
> 	if (tio->ti) {
> 		rq_end_io = tio->ti->type->rq_end_io;
> 
> 		if (mapped && rq_end_io)
> 			r = rq_end_io(tio->ti, clone, error, &tio->info);
> 	}
1565,1573d1574
< 	/*
< 	 * Hold the md reference here for the in-flight I/O.
< 	 * We can't rely on the reference count by device opener,
< 	 * because the device may be closed during the request completion
< 	 * when all bios are completed.
< 	 * See the comment in rq_completed() too.
< 	 */
< 	dm_get(md);
< 
1604a1606,1625
> static struct request *dm_start_request(struct mapped_device *md, struct request *orig)
> {
> 	struct request *clone;
> 
> 	blk_start_request(orig);
> 	clone = orig->special;
> 	atomic_inc(&md->pending[rq_data_dir(clone)]);
> 
> 	/*
> 	 * Hold the md reference here for the in-flight I/O.
> 	 * We can't rely on the reference count by device opener,
> 	 * because the device may be closed during the request completion
> 	 * when all bios are completed.
> 	 * See the comment in rq_completed() too.
> 	 */
> 	dm_get(md);
> 
> 	return clone;
> }
> 
1634c1655,1664
< 		BUG_ON(!dm_target_is_valid(ti));
---
> 		if (!dm_target_is_valid(ti)) {
> 			/*
> 			 * Must perform setup, that dm_done() requires,
> 			 * before calling dm_kill_unmapped_request
> 			 */
> 			DMERR_LIMIT("request attempted access beyond the end of device");
> 			clone = dm_start_request(md, rq);
> 			dm_kill_unmapped_request(clone, -EIO);
> 			continue;
> 		}
1639,1641c1669
< 		blk_start_request(rq);
< 		clone = rq->special;
< 		atomic_inc(&md->pending[rq_data_dir(clone)]);
---
> 		clone = dm_start_request(md, rq);
1661,1662d1688
< 
< 	return;




diff -r linux-3.0.36/drivers/md/dm-ioctl.c linux-3.0.36-lenovo/drivers/md/dm-ioctl.c
1526a1527,1534
> 	/*
> 	 * Abort if something changed the ioctl data while it was being copied.
> 	 */
> 	if (dmi->data_size != tmp.data_size) {
> 		DMERR("rejecting ioctl: data size modified while processing parameters");
> 		goto bad;
> 	}
> 




diff -r linux-3.0.36/drivers/md/dm-raid1.c linux-3.0.36-lenovo/drivers/md/dm-raid1.c
1213c1213
< 		if (!(bio->bi_rw & REQ_FLUSH))
---
> 		if (!(bio->bi_rw & (REQ_FLUSH | REQ_DISCARD)))




diff -r linux-3.0.36/drivers/md/dm-region-hash.c linux-3.0.36-lenovo/drivers/md/dm-region-hash.c
406a407,409
> 	if (bio->bi_rw & REQ_DISCARD)
> 		return;
> 
527c530
< 		if (bio->bi_rw & REQ_FLUSH)
---
> 		if (bio->bi_rw & (REQ_FLUSH | REQ_DISCARD))




diff -r linux-3.0.36/drivers/md/md.c linux-3.0.36-lenovo/drivers/md/md.c
1099,1100c1099,1103
< 	/* Limit to 4TB as metadata cannot record more than that */
< 	if (rdev->sectors >= (2ULL << 32))
---
> 	/* Limit to 4TB as metadata cannot record more than that.
> 	 * (not needed for Linear and RAID0 as metadata doesn't
> 	 * record this size)
> 	 */
> 	if (rdev->sectors >= (2ULL << 32) && sb->level >= 1)
1382c1385
< 	if (num_sectors >= (2ULL << 32))
---
> 	if (num_sectors >= (2ULL << 32) && rdev->mddev->level >= 1)




diff -r linux-3.0.36/drivers/md/raid10.c linux-3.0.36-lenovo/drivers/md/raid10.c
1860a1861,1866
> 			if (sect >= mddev->resync_max_sectors) {
> 				/* last stripe is not complete - don't
> 				 * try to recover this sector.
> 				 */
> 				continue;
> 			}




diff -r linux-3.0.36/drivers/md/raid5.c linux-3.0.36-lenovo/drivers/md/raid5.c
202c202,203
< 			if (test_bit(STRIPE_DELAYED, &sh->state))
---
> 			if (test_bit(STRIPE_DELAYED, &sh->state) &&
> 			    !test_bit(STRIPE_PREREAD_ACTIVE, &sh->state))
207a209
> 				clear_bit(STRIPE_DELAYED, &sh->state);
3849d3850
< 		align_bi->bi_sector += rdev->data_offset;
3856a3858,3860
> 
> 		/* No reshape active, so we can trust rdev->data_offset */
> 		align_bi->bi_sector += rdev->data_offset;




diff -r linux-3.0.36/drivers/media/dvb/dvb-core/dvbdev.c linux-3.0.36-lenovo/drivers/media/dvb/dvb-core/dvbdev.c
245a246
> 		up_write(&minor_rwsem);




diff -r linux-3.0.36/drivers/media/dvb/siano/smsusb.c linux-3.0.36-lenovo/drivers/media/dvb/siano/smsusb.c
483c483
< static const struct usb_device_id smsusb_id_table[] __devinitconst = {
---
> static const struct usb_device_id smsusb_id_table[] = {
544a545,546
> 		.driver_info = SMS1XXX_BOARD_HAUPPAUGE_WINDHAM },
> 	{ USB_DEVICE(0x2040, 0xf5a0),




diff -r linux-3.0.36/drivers/media/rc/ite-cir.c linux-3.0.36-lenovo/drivers/media/rc/ite-cir.c
1479a1480
> 	itdev->rdev = rdev;
1611d1611
< 	itdev->rdev = rdev;




diff -r linux-3.0.36/drivers/media/rc/rc-main.c linux-3.0.36-lenovo/drivers/media/rc/rc-main.c
775c775
< 	} else {
---
> 	} else if (dev->raw) {
778c778,779
< 	}
---
> 	} else
> 		return -ENODEV;




diff -r linux-3.0.36/drivers/media/video/au0828/au0828-video.c linux-3.0.36-lenovo/drivers/media/video/au0828/au0828-video.c
1700,1701c1700,1703
< 		videobuf_streamoff(&fh->vb_vidq);
< 		res_free(fh, AU0828_RESOURCE_VIDEO);
---
> 		if (res_check(fh, AU0828_RESOURCE_VIDEO)) {
> 			videobuf_streamoff(&fh->vb_vidq);
> 			res_free(fh, AU0828_RESOURCE_VIDEO);
> 		}
1706,1707c1708,1711
< 		videobuf_streamoff(&fh->vb_vbiq);
< 		res_free(fh, AU0828_RESOURCE_VBI);
---
> 		if (res_check(fh, AU0828_RESOURCE_VBI)) {
> 			videobuf_streamoff(&fh->vb_vbiq);
> 			res_free(fh, AU0828_RESOURCE_VBI);
> 		}
Only in linux-3.0.36-lenovo/drivers/media/video: gc0307.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc0308.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc0308_user_series.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc0309.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc0309_for_td8801.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc0329.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc2015.c
Only in linux-3.0.36-lenovo/drivers/media/video: gc2035.c




diff -r linux-3.0.36/drivers/media/video/gspca/spca506.c linux-3.0.36-lenovo/drivers/media/video/gspca/spca506.c
688c688
< static const struct usb_device_id device_table[] __devinitconst = {
---
> static const struct usb_device_id device_table[] = {
Only in linux-3.0.36-lenovo/drivers/media/video: gt2005.c
Only in linux-3.0.36-lenovo/drivers/media/video: gt2005_user_series.c
Only in linux-3.0.36-lenovo/drivers/media/video: hi253.c
Only in linux-3.0.36-lenovo/drivers/media/video: hi704.c




diff -r linux-3.0.36/drivers/media/video/Kconfig linux-3.0.36-lenovo/drivers/media/video/Kconfig
72a73
> source "drivers/media/video/rk29xx/Kconfig"
805a807,812
> config SOC_CAMERA_MT9M112
> 	tristate "mt9m112 support"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This driver supports MT9M112 cameras from Micron
> 
811a819,862
> config SOC_CAMERA_MT9T111
> 	tristate "mt9t111 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This driver supports MT9T111 cameras from Micron for rockchip.
> 
> config MT9T111_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9T111
> 	bool "MT9T111 user defined init series"
> 	default n
> 
> config SOC_CAMERA_MT9P111
> 	tristate "mt9p111 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This driver supports MT9P111 cameras from Micron for rockchip.
> 	  
> config MT9P111_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9P111
> 	bool "MT9P111 user defined init series"
> 	default n
> 
> config SOC_CAMERA_MT9D112
> 	tristate "mt9d112 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This driver supports MT9D112 cameras from Micron for rockchip
> 
> config MT9D112_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9D112
> 	bool "MT9D112 user defined init series"
> 	default n
> 
> config SOC_CAMERA_MT9D113
> 	tristate "mt9d113 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This driver supports MT9D113 cameras from Micron for rockchip
> 
> config MT9D113_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9D113
> 	bool "MT9D113 user defined init series"
> 	default n
> 
817a869,873
> config MT9T112_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9T112
> 	bool "MT9T112 user defined init series"
> 	default n
> 
824a881,885
> config MT9V022_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_MT9V022
> 	bool "MT9V022 user defined init series"
> 	default n
> 
848d908
< 
854a915,919
> config OV6650_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV6650
> 	bool "OV6650 user defined init series"
> 	default n
> 
860a926,1330
> config SOC_CAMERA_OV7675
> 	tristate "ov7675 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov7675 camera driver for rockchip
> 
> config OV7675_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV7675
> 	bool "OV7675 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV2655
> 	tristate "ov2655 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov2655 camera driver for rockchip
> 
> config OV2655_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV2655
> 	bool "OV2655 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV2659
> 	tristate "ov2659 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov2659 camera driver for rockchip
> 	  
> config OV2659_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV2659
> 	bool "OV2659 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV7690
> 	tristate "ov7690 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov7690 camera driver for rockchip	
> 
> config OV7690_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV7690
> 	bool "OV7690 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV9650
> 	tristate "ov9650 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov9650 camera driver for rockchip
> 
> config OV9650_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV9650
> 	bool "OV9650 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV2640_RK
> 	tristate "ov2640 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov2640 camera driver for rockchip
> 	  
> config OV2640_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV2640_RK
> 	bool "OV2640 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV3640
> 	tristate "ov3640 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov3640 camera driver for rockchip
> 	  
> config OV3640_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV3640
> 	bool "OV3640 user defined init series"
> 	default n
> 
> choice
> 	prompt "OV3640 Module Focus select"
> 	depends on SOC_CAMERA_OV3640
> 	default OV3640_AUTOFOCUS
> 	---help---
> 
> config OV3640_AUTOFOCUS
> 	bool "OV3640 auto focus"
> 
> config OV3640_FIXEDFOCUS
> 	bool "OV3640 fixed focus"
> endchoice
> 
> config SOC_CAMERA_OV3660
> 	tristate "ov3660 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov3660 camera driver for rockchip
> 	  
> config OV3660_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV3660
> 	bool "OV3660 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV5642
> 	tristate "ov5642 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov5642 camera driver for rockchip
> 
> config OV5642_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV5642
> 	bool "OV5642 user defined init series"
> 	default n
> 
> config SOC_CAMERA_OV5642_INTERPOLATION
> 	bool "support sensor interpolation for higher resolution"
> 	depends on SOC_CAMERA_OV5642
> choice
> 	prompt "OV5642 interpolation resolution"
> 	depends on SOC_CAMERA_OV5642_INTERPOLATION
> 	default SOC_CAMERA_OV5642_INTERPOLATION_8M
> 	---help---
> 		OV5642 interpolation resolution
> 		
> config SOC_CAMERA_OV5642_INTERPOLATION_8M
> 	bool "8 megapixel 3264x2448"
> endchoice
> 
> choice
> 	prompt "OV5642 Module Focus select"
> 	depends on SOC_CAMERA_OV5642
> 	default OV5642_AUTOFOCUS
> 	---help---
> 
> config OV5642_AUTOFOCUS
> 	bool "OV5642 auto focus"
> 
> config OV5642_FIXEDFOCUS
> 	bool "OV5642 fixed focus"
> endchoice
> 
> config SOC_CAMERA_OV5640
> 	tristate "ov5640 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov5640 camera driver for rockchip
> 
> config OV5640_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV5640
> 	bool "OV5640 user defined init series"
> 	default n
> 
> choice
> 	prompt "OV5640 Module Focus select"
> 	depends on SOC_CAMERA_OV5640
> 	default OV5640_AUTOFOCUS
> 	---help---
> 
> config OV5640_AUTOFOCUS
> 	bool "OV5640 auto focus"
> 
> config OV5640_FIXEDFOCUS
> 	bool "OV5640 fixed focus"
> endchoice
> 
> config SOC_CAMERA_OV5640_FOR_TD8801
> 	tristate "ov5640 camera support for td8801"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a ov5640 camera driver for td8801
> choice
> 	prompt "OV5640 Module Focus select"
> 	depends on SOC_CAMERA_OV5640_FOR_TD8801
> 	default OV5640_AUTOFOCUS_FOR_TD8801
> 	---help---
> 
> config OV5640_AUTOFOCUS_FOR_TD8801
> 	bool "OV5640 auto focus"
> 
> config OV5640_FIXEDFOCUS_FOR_TD8801
> 	bool "OV5640 fixed focus"
> endchoice
> 
> config SOC_CAMERA_S5K6AA
> 	tristate "Samsung S5K6AA camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a samsung S5K6AA camera driver for rockchip
> 
> config S5K6AA_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_S5K6AA
> 	bool "S5K6AA user defined init series"
> 	default n
> 
> config SOC_CAMERA_GT2005
> 	tristate "GT2005 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GT2005 camera driver for rockchip
> 
> config GT2005_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GT2005
> 	bool "GT2005 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC0307
> 	tristate "GC0307 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GC0307 camera driver for rockchip	   
> 
> config GC0307_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GC0307
> 	bool "GC0307 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC0308
> 	tristate "GC0308 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GC0308 camera driver for rockchip
> 
> config GC0308_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GC0308
> 	bool "GC0308 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC0308_INTERPOLATION
> 	bool "support sensor interpolation for higher resolution"
> 	depends on SOC_CAMERA_GC0308
> choice
> 	prompt "GC0308 interpolation resolution"
> 	depends on SOC_CAMERA_GC0308_INTERPOLATION
> 	default SOC_CAMERA_GC0308_INTERPOLATION_1M
> 	---help---
> 		GC0308 interpolation resolution
> 		
> config SOC_CAMERA_GC0308_INTERPOLATION_1M
> 	bool "1 megapixel 1024x768"
> config SOC_CAMERA_GC0308_INTERPOLATION_2M
> 	bool "2 megapixel 1600x1200"
> config SOC_CAMERA_GC0308_INTERPOLATION_3M
> 	bool "3 megapixel 2048x1536"
> endchoice
> 
> config SOC_CAMERA_GC0309
> 	tristate "GC0309 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GC0309 camera driver for rockchip
> 
> config GC0309_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GC0309
> 	bool "GC0309 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC0309_FOR_TD8801
> 	tristate "GC0309 support for td8801"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GC0309 camera driver for td8801
> 
> config SOC_CAMERA_GC2015
> 	tristate "GC2015 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a GC2015 camera driver for rockchip
> 
> config GC2015_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GC2015
> 	bool "GC2015 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC2035
>         tristate "GC2035 support for rockchip"
>         depends on SOC_CAMERA && I2C
>         help
>           This is a GC2035 camera driver for rockchip
> 
> config GC2035_USER_DEFINED_SERIES
>         depends on SOC_CAMERA_GC2035
>         bool "GC2035 user defined init series"
>         default n
> 
> config SOC_CAMERA_HI253
> 	tristate "HI253 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a HI253 camera driver for rockchip
> 
> config HI253_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_HI253
> 	bool "HI253 user defined init series"
> 	default n
> 
> config SOC_CAMERA_HI253_INTERPOLATION
> 	bool "support sensor interpolation for higher resolution"
> 	depends on SOC_CAMERA_HI253
> 		
> choice
> 	prompt "HI253 interpolation resolution"
> 	depends on SOC_CAMERA_HI253_INTERPOLATION
> 	default SOC_CAMERA_HI253_INTERPOLATION_3M
> 	---help---
> 		HI253 interpolation resolution
> 
> config SOC_CAMERA_HI253_INTERPOLATION_3M
> 	bool "3 megapixel 2048x1536"
> config SOC_CAMERA_HI253_INTERPOLATION_5M
> 	bool "5 megapixel 2592x1944"	
> endchoice
> 
> config SOC_CAMERA_HI704
> 	tristate "HI704 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a HI704 camera driver for rockchip
> 
> config HI704_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_HI704
> 	bool "HI704 user defined init series"
> 	default n
> 
> config SOC_CAMERA_SIV120B
> 	tristate "siv120b support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a SIV120B camera driver for rockchip
> 
> config SIV120B_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_SIV120B
> 	bool "SIV120B user defined init series"
> 	default n
> 	
> config SOC_CAMERA_SIV121D
> 	tristate "siv121d support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a SIV121D camera driver for rockchip
> 	  
> config SOC_CAMERA_SID130B
> 	tristate "sid130b support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a SID130B camera driver for rockchip
> 
> config SID130B_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_SID130B
> 	bool "SID130B user defined init series"
> 	default n
> 
> config SOC_CAMERA_NT99250
> 	tristate "NT99250 support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a NT99250 camera driver for rockchip
> 
> config NT99250_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_NT99250
> 	bool "NT99250 user defined init series"
> 	default n
> 
> config SOC_CAMERA_GC0329
> 	tristate "gc0329 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a gc0329 camera driver for rockchip
> 	  
> config GC0329_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_GC0329
> 	bool "GC0329 user defined init series"
> 	default n
> 
> config SOC_CAMERA_S5K5CA
> 	tristate "s5k5ca camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a s5k5ca camera driver for rockchip
> 	  
> config S5K5CA_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_S5K5CA
> 	bool "s5k5ca user defined init series"
> 	default n
> 	
> config SOC_CAMERA_SP0838
> 	tristate "sp0838 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a sp0838 camera driver for rockchip
> 	  
> config SP0838_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_SP0838
> 	bool "sp0838 user defined init series"
> 	default n
> 
> config SOC_CAMERA_SP2518
> 	tristate "sp2518 camera support for rockchip"
> 	depends on SOC_CAMERA && I2C
> 	help
> 	  This is a sp2518 camera driver for rockchip
> 	  
> config SP2518_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_SP2518
> 	bool "sp2518 user defined init series"
> 	default n	
> 
> 
866a1337,1341
> config OV9640_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV9640
> 	bool "OV9640 user defined init series"
> 	default n
> 
872a1348,1359
> config OV9740_USER_DEFINED_SERIES
> 	depends on SOC_CAMERA_OV9740
> 	bool "OV9740 user defined init series"
> 	default n
> config SOC_CAMERA_MV9335
>         tristate "MtekVision camera isp chip"
>         depends on SOC_CAMERA && I2C
>         help
>           MtekVision camera isp chip
> 
> source "drivers/media/video/mv9335/Kconfig"	
> 
929a1417,1491
> 
> config VIDEO_RK29
> 	tristate "RKXX Camera Sensor Interface driver"
> 	depends on VIDEO_DEV && PLAT_RK && SOC_CAMERA && HAS_DMA
> 	select VIDEOBUF_DMA_CONTIG
> 	---help---
> 	  This is a v4l2 driver for the RK29XX Camera Sensor Interface
> 
> choice
> 	prompt "RKXX Camera Sensor Interface Work Mode"
> 	depends on VIDEO_RK29
> 	default VIDEO_RKCIF_WORK_ONEFRAME
> 	---help---
> 		RK29 Camera Sensor Interface(VIP) can work in 2 modes, ie:OneFrame,PingPong.
> 
> config VIDEO_RKCIF_WORK_ONEFRAME
> 	bool "CIF OneFrame Mode"
> 
> config VIDEO_RKCIF_WORK_PINGPONG
> 	bool "CIF PingPong Mode"
> 
> endchoice
> 
> choice
> 	prompt "RKXX camera sensor interface work with IPP "
> 	depends on VIDEO_RK29 && RK29_IPP
> 	default VIDEO_RK29_WORK_IPP
> 	---help---
> 		RK29 Camera Sensor Interface(VIP) can work with IPP or not IPP
> 
> config VIDEO_RK29_WORK_IPP
> 	bool "CIF work with IPP"
> 
> config VIDEO_RK29_WORK_NOT_IPP
> 	bool "CIF don't work with IPP"
> 
> endchoice
> choice
> 	prompt "RKXX camera digital zoom with IPP "
> 	depends on VIDEO_RK29 && RK29_IPP && VIDEO_RK29_WORK_IPP
> 	default VIDEO_RK29_DIGITALZOOM_IPP_ON
> 	---help---
> 		RK Camera digital zoom with IPP
> config VIDEO_RK29_DIGITALZOOM_IPP_ON
> 	bool "Digital zoom with IPP on"
> 
> config VIDEO_RK29_DIGITALZOOM_IPP_OFF
> 	bool "Digital zoom with IPP off"
> endchoice
> 
> choice
> 	prompt "RKXX camera memory "
> 	depends on VIDEO_RK29 
> 	default VIDEO_RK29_CAMMEM_PMEM
> 	---help---
> 		where camera memory which is used for preview/raw/jpeg in android camera hal is alloced 
> config VIDEO_RK29_CAMMEM_PMEM
> 	bool "Camera memory from pmem"
> 
> config VIDEO_RK29_CAMMEM_ION
> 	bool "Camera memory from ion"
> endchoice
> 
> choice
> 	prompt "RKXX CIF work simultaneity"
> 	depends on VIDEO_RK29 && ARCH_RK30
> 	default VIDEO_RKCIF_WORK_SIMUL_OFF
> 	---help---
>                CIFs work simultaneity 
> config VIDEO_RKCIF_WORK_SIMUL_ON
> 	bool "Two cif controller can work sumultaneity"
> 
> config VIDEO_RKCIF_WORK_SIMUL_OFF
> 	bool "Two cif controller cann't work sumultaneity"
> endchoice




diff -r linux-3.0.36/drivers/media/video/Makefile linux-3.0.36-lenovo/drivers/media/video/Makefile
76a77
> obj-$(CONFIG_SOC_CAMERA_MT9M112)	+= mt9m112.o
77a79
> obj-$(CONFIG_SOC_CAMERA_MT9T111)	+= mt9t111.o
79a82,84
> obj-$(CONFIG_SOC_CAMERA_MT9P111)	+= mt9p111.o
> obj-$(CONFIG_SOC_CAMERA_MT9D112)	+= mt9d112.o
> obj-$(CONFIG_SOC_CAMERA_MT9D113)	+= mt9d113.o
86a92,121
> obj-$(CONFIG_SOC_CAMERA_OV7675)		+= ov7675.o
> obj-$(CONFIG_SOC_CAMERA_OV2655)		+= ov2655.o
> obj-$(CONFIG_SOC_CAMERA_OV2659)		+= ov2659.o
> obj-$(CONFIG_SOC_CAMERA_OV7690)		+= ov7690.o
> obj-$(CONFIG_SOC_CAMERA_OV9650)		+= ov9650.o
> obj-$(CONFIG_SOC_CAMERA_OV2640_RK)		+= ov2640_rk.o
> obj-$(CONFIG_SOC_CAMERA_OV3640)		+= ov3640.o
> obj-$(CONFIG_SOC_CAMERA_OV3660)		+= ov3660.o
> obj-$(CONFIG_SOC_CAMERA_OV5640)		+= ov5640.o
> obj-$(CONFIG_SOC_CAMERA_OV5640_FOR_TD8801)		+= ov5640_for_td8801.o
> obj-$(CONFIG_SOC_CAMERA_OV5642)		+= ov5642.o
> obj-$(CONFIG_SOC_CAMERA_S5K6AA)		+= s5k6aa.o
> obj-$(CONFIG_SOC_CAMERA_GT2005)		+= gt2005.o
> obj-$(CONFIG_SOC_CAMERA_GC0307)		+= gc0307.o
> obj-$(CONFIG_SOC_CAMERA_GC0308)		+= gc0308.o
> obj-$(CONFIG_SOC_CAMERA_GC0309)		+= gc0309.o
> obj-$(CONFIG_SOC_CAMERA_GC0309_FOR_TD8801)		+= gc0309_for_td8801.o
> obj-$(CONFIG_SOC_CAMERA_GC2015)		+= gc2015.o
> obj-$(CONFIG_SOC_CAMERA_GC2035)         += gc2035.o
> obj-$(CONFIG_SOC_CAMERA_SIV120B)	+= siv120b.o
> obj-$(CONFIG_SOC_CAMERA_SIV121D)	+= siv121d.o
> obj-$(CONFIG_SOC_CAMERA_SID130B)	+= sid130B.o
> obj-$(CONFIG_SOC_CAMERA_HI253)	+= hi253.o
> obj-$(CONFIG_SOC_CAMERA_HI704)	+= hi704.o
> obj-$(CONFIG_SOC_CAMERA_NT99250)	+= nt99250.o
> obj-$(CONFIG_SOC_CAMERA_GC0329)	+= gc0329.o
> obj-$(CONFIG_SOC_CAMERA_SP0838)	+= sp0838.o
> obj-$(CONFIG_SOC_CAMERA_SP2518)	+= sp2518.o
> obj-$(CONFIG_SOC_CAMERA_S5K5CA)	+= s5k5ca.o
> obj-$(CONFIG_SOC_CAMERA_MV9335) += mv9335/
165a201,219
> ifeq ($(CONFIG_ARCH_RK30),y)
> obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)	+= rk30_camera_oneframe.o
> obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk30_camera_pingpong.o
> endif
> ifeq ($(CONFIG_ARCH_RK3188),y)
> obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME) += rk30_camera_oneframe.o
> obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG) += rk30_camera_pingpong.o
> endif
> 
> ifeq ($(CONFIG_ARCH_RK2928),y)
> obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)  += rk30_camera_oneframe.o
> obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk30_camera_pingpong.o
> endif
> ifeq ($(CONFIG_ARCH_RK29),y)
> obj-$(CONFIG_VIDEO_RKCIF_WORK_ONEFRAME)  += rk29_camera_oneframe.o
> obj-$(CONFIG_VIDEO_RKCIF_WORK_PINGPONG)	+= rk29_camera_pingpang.o
> endif
> 
> obj-$(CONFIG_VIDEO_RK29XX_VOUT)		+= rk29xx/
Only in linux-3.0.36-lenovo/drivers/media/video: mt9d112.c
Only in linux-3.0.36-lenovo/drivers/media/video: mt9d112.h
Only in linux-3.0.36-lenovo/drivers/media/video: mt9d113.c
Only in linux-3.0.36-lenovo/drivers/media/video: mt9d113.h
Only in linux-3.0.36-lenovo/drivers/media/video: mt9m112.c
Only in linux-3.0.36-lenovo/drivers/media/video: mt9m112.h
Only in linux-3.0.36-lenovo/drivers/media/video: mt9p111.c
Only in linux-3.0.36-lenovo/drivers/media/video: mt9p111.h
Only in linux-3.0.36-lenovo/drivers/media/video: mt9t111.c
Only in linux-3.0.36-lenovo/drivers/media/video: mt9t111.h
Only in linux-3.0.36-lenovo/drivers/media/video: mv9335
Only in linux-3.0.36-lenovo/drivers/media/video: nt99250.c




diff -r linux-3.0.36/drivers/media/video/ov2640.c linux-3.0.36-lenovo/drivers/media/video/ov2640.c
1a2
> <<<<<<< HEAD
9a11,15
> =======
> o* Driver for MT9M001 CMOS Image Sensor from Micron
>  *
>  * Copyright (C) 2008, Guennadi Liakhovetski <kernel@pengutronix.de>
> >>>>>>> parent of 15f7fab... temp revert rk change
15a22
> <<<<<<< HEAD
1205a1213,4172
> =======
> #include <linux/videodev2.h>
> #include <linux/slab.h>
> #include <linux/i2c.h>
> #include <linux/log2.h>
> #include <linux/platform_device.h>
> #include <linux/delay.h>
> #include <linux/circ_buf.h>
> #include <linux/miscdevice.h>
> #include <media/v4l2-common.h>
> #include <media/v4l2-chip-ident.h>
> #include <media/soc_camera.h>
> #include <mach/rk29_camera.h>
> 
> static int debug;
> module_param(debug, int, S_IRUGO|S_IWUSR);
> 
> #define dprintk(level, fmt, arg...) do {			\
> 	if (debug >= level) 					\
> 	printk(KERN_WARNING fmt , ## arg); } while (0)
> 
> #define SENSOR_TR(format, ...) printk(KERN_ERR format, ## __VA_ARGS__)
> #define SENSOR_DG(format, ...) dprintk(1, format, ## __VA_ARGS__)
> 
> 
> #define _CONS(a,b) a##b
> #define CONS(a,b) _CONS(a,b)
> 
> #define __STR(x) #x
> #define _STR(x) __STR(x)
> #define STR(x) _STR(x)
> 
> #define MIN(x,y)   ((x<y) ? x: y)
> #define MAX(x,y)    ((x>y) ? x: y)
> 
> /* Sensor Driver Configuration */
> #define SENSOR_NAME RK29_CAM_SENSOR_OV2640
> #define SENSOR_V4L2_IDENT V4L2_IDENT_OV2640
> #define SENSOR_ID 0x2642
> #define SENSOR_ID1 0x2641
> #define SENSOR_MIN_WIDTH    640
> #define SENSOR_MIN_HEIGHT   480
> #define SENSOR_MAX_WIDTH    1600
> #define SENSOR_MAX_HEIGHT   1200
> #define SENSOR_INIT_WIDTH	640			/* Sensor pixel size for sensor_init_data array */
> #define SENSOR_INIT_HEIGHT  480
> #define SENSOR_INIT_WINSEQADR sensor_vga
> #define SENSOR_INIT_PIXFMT V4L2_MBUS_FMT_YUYV8_2X8
> 
> #define CONFIG_SENSOR_WhiteBalance	0
> #define CONFIG_SENSOR_Brightness	1
> #define CONFIG_SENSOR_Contrast      0
> #define CONFIG_SENSOR_Saturation    1
> #define CONFIG_SENSOR_Effect        1
> #define CONFIG_SENSOR_Scene         0
> #define CONFIG_SENSOR_DigitalZoom   0
> #define CONFIG_SENSOR_Focus         0
> #define CONFIG_SENSOR_Exposure      0
> #define CONFIG_SENSOR_Flash         0
> #define CONFIG_SENSOR_Mirror        0
> #define CONFIG_SENSOR_Flip          0
> 
> #define CONFIG_SENSOR_I2C_SPEED     250000       /* Hz */
> /* Sensor write register continues by preempt_disable/preempt_enable for current process not be scheduled */
> #define CONFIG_SENSOR_I2C_NOSCHED   0
> #define CONFIG_SENSOR_I2C_RDWRCHK   0
> 
> #define SENSOR_BUS_PARAM  (SOCAM_MASTER | SOCAM_PCLK_SAMPLE_RISING |\
>                           SOCAM_HSYNC_ACTIVE_HIGH | SOCAM_VSYNC_ACTIVE_LOW |\
>                           SOCAM_DATA_ACTIVE_HIGH | SOCAM_DATAWIDTH_8  |SOCAM_MCLK_24MHZ)
> 
> #define COLOR_TEMPERATURE_CLOUDY_DN  6500
> #define COLOR_TEMPERATURE_CLOUDY_UP    8000
> #define COLOR_TEMPERATURE_CLEARDAY_DN  5000
> #define COLOR_TEMPERATURE_CLEARDAY_UP    6500
> #define COLOR_TEMPERATURE_OFFICE_DN     3500
> #define COLOR_TEMPERATURE_OFFICE_UP     5000
> #define COLOR_TEMPERATURE_HOME_DN       2500
> #define COLOR_TEMPERATURE_HOME_UP       3500
> 
> #define SENSOR_NAME_STRING(a) STR(CONS(SENSOR_NAME, a))
> #define SENSOR_NAME_VARFUN(a) CONS(SENSOR_NAME, a)
> 
> struct reginfo
> {
>     u8 reg;
>     u8 val;
> };
> 
> /* init 800*600 SVGA */
> static struct reginfo sensor_init_data[] =
> {
> #if 1
>     {0xff,0x01},
>     {0x12,0x80},
>     {0xff,0x00},
>     {0x2c,0xff},
>     {0x2e,0xdf},
>     {0xff,0x01},
> 
>     {0x03,0x4f},
>     {0x0f,0x4b},
> 
> 
>     {0x3c,0x32},
>     {0x11,0x00},
>     {0x09,0x02},
>     {0x04,0xF8},//b7,b6 directs
>     {0x13,0xe5},
>     {0x14,0x48},
>     {0x2c,0x0c},
>     {0x33,0x78},
>     {0x3a,0x33},
>     {0x3b,0xfB},
>     {0x3e,0x00},
>     {0x43,0x11},
>     {0x16,0x10},
>     {0x39,0x02},
>     {0x35,0x88},
>     {0x22,0x09},
>     {0x37,0x40},
>     {0x23,0x00},
>     {0x34,0xa0},
>     {0x36,0x1a},
>     {0x06,0x02},
>     {0x07,0xc0},
>     {0x0d,0xb7},
>     {0x0e,0x01},
>     {0x4c,0x00},
>     {0x4a,0x81},
>     {0x21,0x99},
>     
>     //{0x24,0x58},
>     //{0x25,0x50},
>     //{0x26,0x92},
>     
>     {0x24, 0x70},
>     {0x25, 0x60},
>     {0x26, 0xa4},    
>     
>     {0x5c,0x00},
>     {0x63,0x00},
>     {0x46,0x3f},
>     {0x0c,0x3c},
>     {0x61,0x70},
>     {0x62,0x80},
>     {0x7c,0x05},
>     {0x20,0x80},
>     {0x28,0x30},
>     {0x6c,0x00},
>     {0x6d,0x80},
>     {0x6e,0x00},
>     {0x70,0x02},
>     {0x71,0x94},
>     {0x73,0xc1},
>     {0x3d,0x34},
>     {0x5a,0x57},
>     {0x4f,0xbb},
>     {0x50,0x9c},
>     {0xff,0x00},
>     {0xe5,0x7f},
>     {0xf9,0xc0},
>     {0x41,0x24},
>     {0xe0,0x14},
>     {0x76,0xff},
>     {0x33,0xa0},
>     {0x42,0x20},
>     {0x43,0x18},
>     {0x4c,0x00},
>     {0x87,0xd0},
>     {0x88,0x3f},
>     {0xd7,0x03},
>     {0xd9,0x10},
>     {0xd3,0x82},
>     {0xc8,0x08},
>     {0xc9,0x80},
>     {0x7c,0x00},
>     {0x7d,0x00},//0x00//0x07
>     {0x7c,0x03},
>     {0x7d,0x48},//0x48//0x40
>     {0x7d,0x48},//0x48//0x40
>     {0x7c,0x08},
>     {0x7d,0x20},
>     {0x7d,0x10},//0x10
>     {0x7d,0x0e},//0x0e
> 
>     {0x92,0x00},
>     {0x93,0x06},
>     {0x93,0xc8},//e3
>     {0x93,0x05},
>     {0x93,0x05},
>     {0x93,0x00},
>     {0x93,0x04},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x93,0x00},
>     {0x96,0x00},
>     {0x97,0x08},
>     {0x97,0x19},
>     {0x97,0x02},
>     {0x97,0x0c},
>     {0x97,0x24},
>     {0x97,0x30},
>     {0x97,0x28},
>     {0x97,0x26},
>     {0x97,0x02},
>     {0x97,0x98},
>     {0x97,0x80},
>     {0x97,0x00},
>     {0x97,0x00},
>     {0xc3,0xef},//ed
>     {0xa4,0x00},
>     {0xa8,0x00},
> 
>     {0xbf, 0x00},
>     {0xba, 0xdc},
>     {0xbb, 0x08},
>     {0xb6, 0x20},
>     {0xb8, 0x30},
>     {0xb7, 0x20},
>     {0xb9, 0x30},
>     {0xb3, 0xb4},
>     {0xb4, 0xca},
>     {0xb5, 0x34},
>     {0xb0, 0x46},
>     {0xb1, 0x46},
>     {0xb2, 0x06},
>     {0xc7, 0x00},
>     {0xc6, 0x51},
>     {0xc5, 0x11},
>     {0xc4, 0x9c},
> ////
>     {0xc0,0xc8},
>     {0xc1,0x96},
>     {0x86,0x3d},
>     {0x50,0x92},
>     {0x51,0x90},
>     {0x52,0x2c},
>     {0x53,0x00},
>     {0x54,0x00},
>     {0x55,0x88},
>     {0x57,0x00},
>     {0x5a,0x50},
>     {0x5b,0x3c},
>     {0x5c,0x00},
>     {0xc3,0xed},
>     {0x7f,0x00},
>     {0xda,0x01},
>     {0xe5,0x1f},
>     {0xe1,0x67},
>     {0xe0,0x00},
>     {0xdd,0xff},
>     {0x05,0x00},
> 
> #endif
> #if 1
>     {0xff, 0x01},
>     {0x5d, 0x00},
>     {0x5e, 0x3c},
>     {0x5f, 0x28},
>     {0x60, 0x55},
> 
> 
>     {0xff, 0x00},
>     {0xc3, 0xef},
>     {0xa6, 0x00},
>     {0xa7, 0x0f},
>     {0xa7, 0x4e},
>     {0xa7, 0x7a},
>     {0xa7, 0x33},
>     {0xa7, 0x00},
>     {0xa7, 0x23},
>     {0xa7, 0x27},
>     {0xa7, 0x3a},
>     {0xa7, 0x70},
>     {0xa7, 0x33},
>     {0xa7, 0x00},//L
>     {0xa7, 0x23},
>     {0xa7, 0x20},
>     {0xa7, 0x0c},
>     {0xa7, 0x66},
>     {0xa7, 0x33},
>     {0xa7, 0x00},
>     {0xa7, 0x23},
>     {0xc3, 0xef},
> #endif
> 
> 
> #if 1
>     {0xff,0x00},
>     {0x92,0x00},
>     {0x93,0x06},
>     {0x93,0xc1},//e
>     {0x93,0x02},
>     {0x93,0x02},
>     {0x93,0x00},
>     {0x93,0x04},
> #endif
> 
>     {0x03, 0x0f},
>     {0xe0, 0x04},
>     {0xc0, 0xc8},
>     {0xc1, 0x96},
>     {0x86, 0x3d},
>     {0x50, 0x89},
>     {0x51, 0x90},
>     {0x52, 0x2c},
>     {0x53, 0x00},
>     {0x54, 0x00},
>     {0x55, 0x88},
>     {0x57, 0x00},
>     {0x5a, 0xa0},
>     {0x5b, 0x78},
>     {0x5c, 0x00},
>     {0xd3, 0x04},
>     {0xe0, 0x00},
> 
>   {0x0, 0x0}   //end flag
> 
> };
> 
> /* 1600X1200 UXGA */
> static struct reginfo sensor_uxga[] =
> {
>     {0xff, 0x00},
>     {0xe0, 0x04},
>     {0xc0, 0xc8},
>     {0xc1, 0x96},
>     {0x86, 0x3d},
>     {0x50, 0x00},
>     {0x51, 0x90},
>     {0x52, 0x2c},
>     {0x53, 0x00},
>     {0x54, 0x00},
>     {0x55, 0x88},
>     {0x57, 0x00},
>     {0x5a, 0x90},
>     {0x5b, 0x2c},
>     {0x5c, 0x05},
>     {0xd3, 0x82},
>     {0xe0, 0x00},
>   {0x0, 0x0}   //end flag
> };
> 
> /* 1280X1024 SXGA */
> static struct reginfo sensor_sxga[] =
> {
>     {0xff, 0x00},
>     {0xe0, 0x04},
>     {0xc0, 0xc8},
>     {0xc1, 0x96},
>     {0x86, 0x3d},
>     {0x50, 0x00},
>     {0x51, 0x90},
>     {0x52, 0x2c},
>     {0x53, 0x00},
>     {0x54, 0x00},
>     {0x55, 0x88},
>     {0x57, 0x00},
>     {0x5a, 0x40},
>     {0x5b, 0x00},
>     {0x5c, 0x05},
>     {0xd3, 0x82},
>     {0xe0, 0x00},
>   {0x0, 0x0}   //end flag
> };
> 
> 
> static struct reginfo sensor_xga[] =
> {
>     {0xff, 0x00},
>     {0xe0, 0x04},
>     {0xc0, 0xc8},
>     {0xc1, 0x96},
>     {0x86, 0x3d},
>     {0x50, 0x00},
>     {0x51, 0x90},
>     {0x52, 0x2c},
>     {0x53, 0x00},
>     {0x54, 0x00},
>     {0x55, 0x88},
>     {0x57, 0x00},
>     {0x5a, 0x40},
>     {0x5b, 0x00},
>     {0x5c, 0x05},
>     {0xd3, 0x82},
>     {0xe0, 0x00},
>   {0x0, 0x0}   //end flag
> 
> 
> };
> 
> 
> /* 800X600 SVGA*/
> static struct reginfo sensor_svga[] =
> {
>   {0x0, 0x0}   //end flag
> };
> 
> /* 640X480 VGA */
> static struct reginfo sensor_vga[] =
> {
>    {0x0, 0x0}   //end flag
>  };
> 
> /* 352X288 CIF */
> static struct reginfo sensor_cif[] =
> {
>   {0x0, 0x0}   //end flag
> };
> 
> /* 320*240 QVGA */
> static  struct reginfo sensor_qvga[] =
> {
>   {0x0, 0x0}   //end flag
> };
> 
> /* 176X144 QCIF*/
> static struct reginfo sensor_qcif[] =
> {
>   {0x0, 0x0}   //end flag
> };
> #if 0
> /* 160X120 QQVGA*/
> static struct reginfo ov2655_qqvga[] =
> {
> 
>     {0x300E, 0x34},
>     {0x3011, 0x01},
>     {0x3012, 0x10},
>     {0x302a, 0x02},
>     {0x302b, 0xE6},
>     {0x306f, 0x14},
>     {0x3362, 0x90},
> 
>     {0x3070, 0x5d},
>     {0x3072, 0x5d},
>     {0x301c, 0x07},
>     {0x301d, 0x07},
> 
>     {0x3020, 0x01},
>     {0x3021, 0x18},
>     {0x3022, 0x00},
>     {0x3023, 0x06},
>     {0x3024, 0x06},
>     {0x3025, 0x58},
>     {0x3026, 0x02},
>     {0x3027, 0x61},
>     {0x3088, 0x00},
>     {0x3089, 0xa0},
>     {0x308a, 0x00},
>     {0x308b, 0x78},
>     {0x3316, 0x64},
>     {0x3317, 0x25},
>     {0x3318, 0x80},
>     {0x3319, 0x08},
>     {0x331a, 0x0a},
>     {0x331b, 0x07},
>     {0x331c, 0x80},
>     {0x331d, 0x38},
>     {0x3100, 0x00},
>     {0x3302, 0x11},
> 
>     {0x0, 0x0},
> };
> 
> 
> 
> static  struct reginfo ov2655_Sharpness_auto[] =
> {
>     {0x3306, 0x00},
> };
> 
> static  struct reginfo ov2655_Sharpness1[] =
> {
>     {0x3306, 0x08},
>     {0x3371, 0x00},
> };
> 
> static  struct reginfo ov2655_Sharpness2[][3] =
> {
>     //Sharpness 2
>     {0x3306, 0x08},
>     {0x3371, 0x01},
> };
> 
> static  struct reginfo ov2655_Sharpness3[] =
> {
>     //default
>     {0x3306, 0x08},
>     {0x332d, 0x02},
> };
> static  struct reginfo ov2655_Sharpness4[]=
> {
>     //Sharpness 4
>     {0x3306, 0x08},
>     {0x332d, 0x03},
> };
> 
> static  struct reginfo ov2655_Sharpness5[] =
> {
>     //Sharpness 5
>     {0x3306, 0x08},
>     {0x332d, 0x04},
> };
> #endif
> 
> static  struct reginfo sensor_ClrFmt_YUYV[]=
> {
>     //{0x4300, 0x30},
>     {0x00, 0x00}
> };
> 
> static  struct reginfo sensor_ClrFmt_UYVY[]=
> {
>     //{0x4300, 0x32},
>     {0x00, 0x00}
> };
> 
> #if CONFIG_SENSOR_WhiteBalance
> static  struct reginfo sensor_WhiteB_Auto[]=
> {
>     {0x3406, 0x00},  //AWB auto, bit[1]:0,auto
>     {0x0000, 0x00}
> };
> /* Cloudy Colour Temperature : 6500K - 8000K  */
> static  struct reginfo sensor_WhiteB_Cloudy[]=
> {
>     {0x3406, 0x01},
>     {0x3400, 0x07},
>     {0x3401, 0x08},
>     {0x3402, 0x04},
>     {0x3403, 0x00},
>     {0x3404, 0x05},
>     {0x3405, 0x00},
>     {0x0000, 0x00}
> };
> /* ClearDay Colour Temperature : 5000K - 6500K  */
> static  struct reginfo sensor_WhiteB_ClearDay[]=
> {
>     //Sunny
>     {0x3406, 0x01},
>     {0x3400, 0x07},
>     {0x3401, 0x02},
>     {0x3402, 0x04},
>     {0x3403, 0x00},
>     {0x3404, 0x05},
>     {0x3405, 0x15},
>     {0x0000, 0x00}
> };
> /* Office Colour Temperature : 3500K - 5000K  */
> static  struct reginfo sensor_WhiteB_TungstenLamp1[]=
> {
>     //Office
>     {0x3406, 0x01},
>     {0x3400, 0x06},
>     {0x3401, 0x2a},
>     {0x3402, 0x04},
>     {0x3403, 0x00},
>     {0x3404, 0x07},
>     {0x3405, 0x24},
>     {0x0000, 0x00}
> 
> };
> /* Home Colour Temperature : 2500K - 3500K  */
> static  struct reginfo sensor_WhiteB_TungstenLamp2[]=
> {
>     //Home
>     {0x3406, 0x01},
>     {0x3400, 0x04},
>     {0x3401, 0x58},
>     {0x3402, 0x04},
>     {0x3403, 0x00},
>     {0x3404, 0x07},
>     {0x3405, 0x24},
>     {0x0000, 0x00}
> };
> static struct reginfo *sensor_WhiteBalanceSeqe[] = {sensor_WhiteB_Auto, sensor_WhiteB_TungstenLamp1,sensor_WhiteB_TungstenLamp2,
>     sensor_WhiteB_ClearDay, sensor_WhiteB_Cloudy,NULL,
> };
> #endif
> 
> #if CONFIG_SENSOR_Brightness
> static  struct reginfo sensor_Brightness0[]=
> {
>     // Brightness -2
>     {0xff, 0x01},
>     {0x24, 0x34},
>     {0x25, 0x22},
>     {0x26, 0x70},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Brightness1[]=
> {
>     // Brightness -1
> 
>     {0xff, 0x01},
>     {0x24, 0x58},
>     {0x25, 0x50},
>     {0x26, 0x92},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Brightness2[]=
> {
>     //  Brightness 0
> 
> 	{0xff, 0x01},
> 	{0x24, 0xa8},
> 	{0x25, 0x90},
> 	{0x26, 0xd6},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Brightness3[]=
> {
>     // Brightness +1
> 
>     {0xff, 0x01},
>     {0x24, 0x48},
>     {0x25, 0x40},
>     {0x26, 0x81},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Brightness4[]=
> {
>     //  Brightness +2
> 
>     {0xff, 0x01},
>     {0x24, 0x58},
>     {0x25, 0x50},
>     {0x26, 0x92},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Brightness5[]=
> {
>     //  Brightness +3
>     {0xff, 0x01},
>     {0x24, 0x70},
>     {0x25, 0x60},
>     {0x26, 0xa4},
>   {0x0, 0x0}   //end flag
> };
> static struct reginfo *sensor_BrightnessSeqe[] = {sensor_Brightness0, sensor_Brightness1, sensor_Brightness2, sensor_Brightness3,
>     sensor_Brightness4, sensor_Brightness5,NULL,
> };
> 
> #endif
> 
> #if CONFIG_SENSOR_Effect
> static  struct reginfo sensor_Effect_Normal[] =
> {
> 	{0xff,0x00},
> 	{0x7c,0x00},
> 	{0x7d,0x00},
> 	{0x7c,0x05},
> 	{0x7d,0x80},
> 	{0x7d,0x80},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Effect_WandB[] =
> {
>     {0xff,0x00},
>     {0x7c,0x00},
>     {0x7d,0x18},
>     {0x7c,0x05},
>     {0x7d,0x80},
>     {0x7d,0x80},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Effect_Sepia[] =
> {
>     {0xff,0x00},
>     {0x7c,0x00},
>     {0x7d,0x18},
>     {0x7c,0x05},
>     {0x7d,0x40},
>     {0x7d,0xc0},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Effect_Negative[] =
> {
>     {0xff,0x00},
>     {0x7c,0x00},
>     {0x7d,0x40},
>     {0x7c,0x05},
>     {0x7d,0x80},
>     {0x7d,0x80},
>   {0x0, 0x0}   //end flag
> };
> static  struct reginfo sensor_Effect_Bluish[] =
> {
>     {0Xff, 0X00},
>     {0X7c, 0X00},
>     {0X7d, 0X18},
>     {0X7c, 0X05},
>     {0X7d, 0Xa0},
>     {0X7d, 0X40},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Effect_Green[] =
> {
>     {0Xff, 0X00},
>     {0X7c, 0X00},
>     {0X7d, 0X18},
>     {0X7c, 0X05},
>     {0X7d, 0X40},
>     {0X7d, 0X40},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Effect_Exp_Windows_Half[] =
> {
> 	{0xff, 0x01},
> 	{0x5d, 0x00},
> 	{0x5e, 0x3c},
> 	{0x5f, 0x28},
> 	{0x60, 0x55},
>   {0x0, 0x0}   //end flag
> };
> static struct reginfo *sensor_EffectSeqe[] = {sensor_Effect_Normal, sensor_Effect_WandB, sensor_Effect_Negative,sensor_Effect_Sepia,
>     sensor_Effect_Bluish, sensor_Effect_Green,NULL,
> };
> #endif
> #if CONFIG_SENSOR_Exposure
> static  struct reginfo sensor_Exposure0[]=
> {
> 	{0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure1[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure2[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure3[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure4[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure5[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_Exposure6[]=
> {
>     {0x0000, 0x00}
> };
> 
> static struct reginfo *sensor_ExposureSeqe[] = {sensor_Exposure0, sensor_Exposure1, sensor_Exposure2, sensor_Exposure3,
>     sensor_Exposure4, sensor_Exposure5,sensor_Exposure6,NULL,
> };
> #endif
> #if CONFIG_SENSOR_Saturation
> static  struct reginfo sensor_Saturation0[]=
> {
> 	{0xff, 0x00},
> 	{0x90, 0x00},
> 	{0x91, 0x0e},
> 	{0x91, 0x1a},
> 	{0x91, 0x31},
> 	{0x91, 0x5a},
> 	{0x91, 0x69},
> 	{0x91, 0x75},
> 	{0x91, 0x7e},
> 	{0x91, 0x88},
> 	{0x91, 0x8f},
> 	{0x91, 0x96},
> 	{0x91, 0xa3},
> 	{0x91, 0xaf},
> 	{0x91, 0xc4},
> 	{0x91, 0xd7},
> 	{0x91, 0xe8},
> 	{0x91, 0x20},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Saturation1[]=
> {
>     {0xff, 0x00},
>     {0x90, 0x00},
>     {0x91, 0x03},
>     {0x91, 0x0a},
>     {0x91, 0x1a},
>     {0x91, 0x3f},
>     {0x91, 0x4e},
>     {0x91, 0x5b},
>     {0x91, 0x68},
>     {0x91, 0x75},
>     {0x91, 0x7f},
>     {0x91, 0x89},
>     {0x91, 0x9a},
>     {0x91, 0xa6},
>     {0x91, 0xbd},
>     {0x91, 0xd3},
>     {0x91, 0xe5},
>     {0x91, 0x24},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Saturation2[]=
> {
>     {0xff, 0x00},
>     {0x90, 0x00},
>     {0x91, 0x04},
>     {0x91, 0x07},
>     {0x91, 0x10},
>     {0x91, 0x28},
>     {0x91, 0x36},
>     {0x91, 0x44},
>     {0x91, 0x52},
>     {0x91, 0x60},
>     {0x91, 0x6c},
>     {0x91, 0x78},
>     {0x91, 0x8c},
>     {0x91, 0x9e},
>     {0x91, 0xbb},
>     {0x91, 0xd3},
>     {0x91, 0xe5},
>     {0x91, 0x24},
>   {0x0, 0x0}   //end flag	
> };
> static struct reginfo *sensor_SaturationSeqe[] = {sensor_Saturation0, sensor_Saturation1, sensor_Saturation2, NULL,};
> 
> 
> #endif
> #if CONFIG_SENSOR_Contrast
> static  struct reginfo sensor_Contrast0[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x10},
>     {0x7d, 0x4a},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> 
> };
> 
> static  struct reginfo sensor_Contrast1[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x14},
>     {0x7d, 0x40},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast2[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x18},
>     {0x7d, 0x34},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast3[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x1c},
>     {0x7d, 0x2a},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast4[]=
> {
>     {0xff,0x00},
>     {0x7c,0x00},
>     {0x7d,0x04},
>     {0x7c,0x07},
>     {0x7d,0x20},
>     {0x7d,0x24},
>     {0x7d,0x16},
>     {0x7d,0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> 
> static  struct reginfo sensor_Contrast5[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x20},
>     {0x7d, 0x20},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast6[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x24},
>     {0x7d, 0x16},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> 
> static  struct reginfo sensor_Contrast7[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x28},
>     {0x7d, 0x0c},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast8[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x2c},
>     {0x7d, 0x02},
>     {0x7d, 0x06},
>   {0x0, 0x0}   //end flag
> };
> 
> static  struct reginfo sensor_Contrast9[]=
> {
>     {0xff, 0x00},
>     {0x7c, 0x00},
>     {0x7d, 0x04},
>     {0x7c, 0x07},
>     {0x7d, 0x20},
>     {0x7d, 0x30},
>     {0x7d, 0x08},
>     {0x7d, 0x0e},
>   {0x0, 0x0}   //end flag
> };
> 
> 
> 
> static struct reginfo *sensor_ContrastSeqe[] = {sensor_Contrast0, sensor_Contrast1, sensor_Contrast2, sensor_Contrast3,
>     sensor_Contrast4, sensor_Contrast5, sensor_Contrast6, NULL,
> };
> 
> #endif
> #if CONFIG_SENSOR_Mirror
> static  struct reginfo sensor_MirrorOn[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_MirrorOff[]=
> {
>     {0x0000, 0x00}
> };
> static struct reginfo *sensor_MirrorSeqe[] = {sensor_MirrorOff, sensor_MirrorOn,NULL,};
> #endif
> #if CONFIG_SENSOR_Flip
> static  struct reginfo sensor_FlipOn[]=
> {
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_FlipOff[]=
> {
>     {0x0000, 0x00}
> };
> static struct reginfo *sensor_FlipSeqe[] = {sensor_FlipOff, sensor_FlipOn,NULL,};
> 
> #endif
> #if CONFIG_SENSOR_Scene
> static  struct reginfo sensor_SceneAuto[] =
> {
>     {0x3a00, 0x78},
>     {0x0000, 0x00}
> };
> 
> static  struct reginfo sensor_SceneNight[] =
> {
>     {0x3003, 0x80},
> 	{0x3004, 0x20},
> 	{0x3005, 0x18},
> 	{0x3006, 0x0d},
> 	{0x3a00, 0x7c},
> 	{0x3a02 ,0x07},
> 	{0x3a03 ,0x38},
> 	{0x3a14 ,0x07},
> 	{0x3a15 ,0x38},
>     {0x0000, 0x00}
> };
> static struct reginfo *sensor_SceneSeqe[] = {sensor_SceneAuto, sensor_SceneNight,NULL,};
> 
> #endif
> #if CONFIG_SENSOR_DigitalZoom
> static struct reginfo sensor_Zoom0[] =
> {
>     {0x0, 0x0},
> };
> 
> static struct reginfo sensor_Zoom1[] =
> {
>      {0x0, 0x0},
> };
> 
> static struct reginfo sensor_Zoom2[] =
> {
>     {0x0, 0x0},
> };
> 
> 
> static struct reginfo sensor_Zoom3[] =
> {
>     {0x0, 0x0},
> };
> static struct reginfo *sensor_ZoomSeqe[] = {sensor_Zoom0, sensor_Zoom1, sensor_Zoom2, sensor_Zoom3, NULL,};
> #endif
> static const struct v4l2_querymenu sensor_menus[] =
> {
> 	#if CONFIG_SENSOR_WhiteBalance
>     { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 0,  .name = "auto",  .reserved = 0, }, {  .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 1, .name = "incandescent",  .reserved = 0,},
>     { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 2,  .name = "fluorescent", .reserved = 0,}, {  .id = V4L2_CID_DO_WHITE_BALANCE, .index = 3,  .name = "daylight", .reserved = 0,},
>     { .id = V4L2_CID_DO_WHITE_BALANCE,  .index = 4,  .name = "cloudy-daylight", .reserved = 0,},
>     #endif
> 
> 	#if CONFIG_SENSOR_Effect
>     { .id = V4L2_CID_EFFECT,  .index = 0,  .name = "none",  .reserved = 0, }, {  .id = V4L2_CID_EFFECT,  .index = 1, .name = "mono",  .reserved = 0,},
>     { .id = V4L2_CID_EFFECT,  .index = 2,  .name = "negative", .reserved = 0,}, {  .id = V4L2_CID_EFFECT, .index = 3,  .name = "sepia", .reserved = 0,},
>     { .id = V4L2_CID_EFFECT,  .index = 4, .name = "posterize", .reserved = 0,} ,{ .id = V4L2_CID_EFFECT,  .index = 5,  .name = "aqua", .reserved = 0,},
>     #endif
> 
> 	#if CONFIG_SENSOR_Scene
>     { .id = V4L2_CID_SCENE,  .index = 0, .name = "auto", .reserved = 0,} ,{ .id = V4L2_CID_SCENE,  .index = 1,  .name = "night", .reserved = 0,},
>     #endif
> 
> 	#if CONFIG_SENSOR_Flash
>     { .id = V4L2_CID_FLASH,  .index = 0,  .name = "off",  .reserved = 0, }, {  .id = V4L2_CID_FLASH,  .index = 1, .name = "auto",  .reserved = 0,},
>     { .id = V4L2_CID_FLASH,  .index = 2,  .name = "on", .reserved = 0,}, {  .id = V4L2_CID_FLASH, .index = 3,  .name = "torch", .reserved = 0,},
>     #endif
> };
> 
> static const struct v4l2_queryctrl sensor_controls[] =
> {
> 	#if CONFIG_SENSOR_WhiteBalance
>     {
>         .id		= V4L2_CID_DO_WHITE_BALANCE,
>         .type		= V4L2_CTRL_TYPE_MENU,
>         .name		= "White Balance Control",
>         .minimum	= 0,
>         .maximum	= 4,
>         .step		= 1,
>         .default_value = 0,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Brightness
> 	{
>         .id		= V4L2_CID_BRIGHTNESS,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Brightness Control",
>         .minimum	= -3,
>         .maximum	= 2,
>         .step		= 1,
>         .default_value = 0,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Effect
> 	{
>         .id		= V4L2_CID_EFFECT,
>         .type		= V4L2_CTRL_TYPE_MENU,
>         .name		= "Effect Control",
>         .minimum	= 0,
>         .maximum	= 5,
>         .step		= 1,
>         .default_value = 0,
>     },
> 	#endif
> 
> 	#if CONFIG_SENSOR_Exposure
> 	{
>         .id		= V4L2_CID_EXPOSURE,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Exposure Control",
>         .minimum	= 0,
>         .maximum	= 6,
>         .step		= 1,
>         .default_value = 0,
>     },
> 	#endif
> 
> 	#if CONFIG_SENSOR_Saturation
> 	{
>         .id		= V4L2_CID_SATURATION,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Saturation Control",
>         .minimum	= 0,
>         .maximum	= 2,
>         .step		= 1,
>         .default_value = 0,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Contrast
> 	{
>         .id		= V4L2_CID_CONTRAST,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Contrast Control",
>         .minimum	= -3,
>         .maximum	= 3,
>         .step		= 1,
>         .default_value = 0,
>     },
> 	#endif
> 
> 	#if CONFIG_SENSOR_Mirror
> 	{
>         .id		= V4L2_CID_HFLIP,
>         .type		= V4L2_CTRL_TYPE_BOOLEAN,
>         .name		= "Mirror Control",
>         .minimum	= 0,
>         .maximum	= 1,
>         .step		= 1,
>         .default_value = 1,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Flip
> 	{
>         .id		= V4L2_CID_VFLIP,
>         .type		= V4L2_CTRL_TYPE_BOOLEAN,
>         .name		= "Flip Control",
>         .minimum	= 0,
>         .maximum	= 1,
>         .step		= 1,
>         .default_value = 1,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Scene
>     {
>         .id		= V4L2_CID_SCENE,
>         .type		= V4L2_CTRL_TYPE_MENU,
>         .name		= "Scene Control",
>         .minimum	= 0,
>         .maximum	= 1,
>         .step		= 1,
>         .default_value = 0,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_DigitalZoom
>     {
>         .id		= V4L2_CID_ZOOM_RELATIVE,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "DigitalZoom Control",
>         .minimum	= -1,
>         .maximum	= 1,
>         .step		= 1,
>         .default_value = 0,
>     }, {
>         .id		= V4L2_CID_ZOOM_ABSOLUTE,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "DigitalZoom Control",
>         .minimum	= 0,
>         .maximum	= 3,
>         .step		= 1,
>         .default_value = 0,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Focus
> 	{
>         .id		= V4L2_CID_FOCUS_RELATIVE,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Focus Control",
>         .minimum	= -1,
>         .maximum	= 1,
>         .step		= 1,
>         .default_value = 0,
>     }, {
>         .id		= V4L2_CID_FOCUS_ABSOLUTE,
>         .type		= V4L2_CTRL_TYPE_INTEGER,
>         .name		= "Focus Control",
>         .minimum	= 0,
>         .maximum	= 255,
>         .step		= 1,
>         .default_value = 125,
>     },
>     #endif
> 
> 	#if CONFIG_SENSOR_Flash
> 	{
>         .id		= V4L2_CID_FLASH,
>         .type		= V4L2_CTRL_TYPE_MENU,
>         .name		= "Flash Control",
>         .minimum	= 0,
>         .maximum	= 3,
>         .step		= 1,
>         .default_value = 0,
>     },
> 	#endif
> };
> 
> static int sensor_probe(struct i2c_client *client, const struct i2c_device_id *did);
> static int sensor_video_probe(struct soc_camera_device *icd, struct i2c_client *client);
> static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
> static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl);
> static int sensor_g_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
> static int sensor_s_ext_controls(struct v4l2_subdev *sd,  struct v4l2_ext_controls *ext_ctrl);
> static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg);
> static int sensor_resume(struct soc_camera_device *icd);
> static int sensor_set_bus_param(struct soc_camera_device *icd,unsigned long flags);
> static unsigned long sensor_query_bus_param(struct soc_camera_device *icd);
> #if CONFIG_SENSOR_Effect
> static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
> #endif
> #if CONFIG_SENSOR_WhiteBalance
> static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value);
> #endif
> static int sensor_deactivate(struct i2c_client *client);
> 
> static struct soc_camera_ops sensor_ops =
> {
>     .suspend                     = sensor_suspend,
>     .resume                       = sensor_resume,
>     .set_bus_param		= sensor_set_bus_param,
>     .query_bus_param	= sensor_query_bus_param,
>     .controls		= sensor_controls,
>     .menus                         = sensor_menus,
>     .num_controls		= ARRAY_SIZE(sensor_controls),
>     .num_menus		= ARRAY_SIZE(sensor_menus),
> };
> 
> /* only one fixed colorspace per pixelcode */
> struct sensor_datafmt {
> 	enum v4l2_mbus_pixelcode code;
> 	enum v4l2_colorspace colorspace;
> };
> 
> /* Find a data format by a pixel code in an array */
> static const struct sensor_datafmt *sensor_find_datafmt(
> 	enum v4l2_mbus_pixelcode code, const struct sensor_datafmt *fmt,
> 	int n)
> {
> 	int i;
> 	for (i = 0; i < n; i++)
> 		if (fmt[i].code == code)
> 			return fmt + i;
> 
> 	return NULL;
> }
> 
> static const struct sensor_datafmt sensor_colour_fmts[] = {
>     {V4L2_MBUS_FMT_UYVY8_2X8, V4L2_COLORSPACE_JPEG},
>     {V4L2_MBUS_FMT_YUYV8_2X8, V4L2_COLORSPACE_JPEG}	
> };
> 
> typedef struct sensor_info_priv_s
> {
>     int whiteBalance;
>     int brightness;
>     int contrast;
>     int saturation;
>     int effect;
>     int scene;
>     int digitalzoom;
>     int focus;
>     int flash;
>     int exposure;
> 	bool snap2preview;
> 	bool video2preview;
>     unsigned char mirror;                                        /* HFLIP */
>     unsigned char flip;                                          /* VFLIP */
>     unsigned int winseqe_cur_addr;
>     struct sensor_datafmt fmt;
> 
> } sensor_info_priv_t;
> 
> struct sensor
> {
>     struct v4l2_subdev subdev;
>     struct i2c_client *client;
>     sensor_info_priv_t info_priv;
>     int model;	/* V4L2_IDENT_OV* codes from v4l2-chip-ident.h */
> #if CONFIG_SENSOR_I2C_NOSCHED
> 	atomic_t tasklock_cnt;
> #endif
> 	struct rk29camera_platform_data *sensor_io_request;
>     struct rk29camera_gpio_res *sensor_gpio_res;
> };
> 
> static struct sensor* to_sensor(const struct i2c_client *client)
> {
>     return container_of(i2c_get_clientdata(client), struct sensor, subdev);
> }
> 
> static int sensor_task_lock(struct i2c_client *client, int lock)
> {
> #if CONFIG_SENSOR_I2C_NOSCHED
> 	int cnt = 3;
>     struct sensor *sensor = to_sensor(client);
> 
> 	if (lock) {
> 		if (atomic_read(&sensor->tasklock_cnt) == 0) {
> 			while ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt>0)) {
> 				SENSOR_TR("\n %s will obtain i2c in atomic, but i2c bus is locked! Wait...\n",SENSOR_NAME_STRING());
> 				msleep(35);
> 				cnt--;
> 			}
> 			if ((atomic_read(&client->adapter->bus_lock.count) < 1) && (cnt<=0)) {
> 				SENSOR_TR("\n %s obtain i2c fail in atomic!!\n",SENSOR_NAME_STRING());
> 				goto sensor_task_lock_err;
> 			}
> 			preempt_disable();
> 		}
> 
> 		atomic_add(1, &sensor->tasklock_cnt);
> 	} else {
> 		if (atomic_read(&sensor->tasklock_cnt) > 0) {
> 			atomic_sub(1, &sensor->tasklock_cnt);
> 
> 			if (atomic_read(&sensor->tasklock_cnt) == 0)
> 				preempt_enable();
> 		}
> 	}
> 	return 0;
> sensor_task_lock_err:
> 	return -1;  
> #else
>     return 0;
> #endif
> 
> }
> static int sensor_write(struct i2c_client *client, u8 reg, u8 val)
> {
>     int err,cnt;
>     u8 buf[2];
>     struct i2c_msg msg[1];
> 
>     buf[0] = reg & 0xFF;
>     buf[1] = val;
> 
>     msg->addr = client->addr;
>     msg->flags = client->flags;
>     msg->buf = buf;
>     msg->len = sizeof(buf);
>     msg->scl_rate = CONFIG_SENSOR_I2C_SPEED;                                        /* ddl@rock-chips.com : 100kHz */
>     msg->read_type = 0;               /* fpga i2c:0==I2C_NORMAL : direct use number not enum for don't want include spi_fpga.h */
> 
>     cnt = 3;
>     err = -EAGAIN;
> 
>     while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
>         err = i2c_transfer(client->adapter, msg, 1);
> 
>         if (err >= 0) {
>             return 0;
>         } else {
>             SENSOR_TR("\n %s write reg(0x%x, val:0x%x) failed, try to write again!\n",SENSOR_NAME_STRING(),reg, val);
>             udelay(10);
>         }
>     }
> 
>     return err;
> }
> 
> /* sensor register read */
> static int sensor_read(struct i2c_client *client, u8 reg, u8 *val)
> {
>     int err,cnt;
>     u8 buf[1];
>     struct i2c_msg msg[2];
> 
>     buf[0] = reg ;//>> 8;
>    // buf[1] = 0;
> 
>     msg[0].addr = client->addr;
>     msg[0].flags = client->flags;
>     msg[0].buf = buf;
>     msg[0].len = sizeof(buf);
>     msg[0].scl_rate = CONFIG_SENSOR_I2C_SPEED;       /* ddl@rock-chips.com : 100kHz */
>     msg[0].read_type = 2;//0x55;   /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
> 
>     msg[1].addr = client->addr;
>     msg[1].flags = client->flags|I2C_M_RD;
>     msg[1].buf = buf;
>     msg[1].len = 1;
>     msg[1].scl_rate = CONFIG_SENSOR_I2C_SPEED;                       /* ddl@rock-chips.com : 100kHz */
>     msg[1].read_type = 2;                             /* fpga i2c:0==I2C_NO_STOP : direct use number not enum for don't want include spi_fpga.h */
> 
>     cnt = 3;
>     err = -EAGAIN;
>     while ((cnt-->0) && (err < 0)) {                       /* ddl@rock-chips.com :  Transfer again if transent is failed   */
>         err = i2c_transfer(client->adapter, msg, 2);
> 
>         if (err >= 0) {
>             *val = buf[0];
>             return 0;
>         } else {
>         	SENSOR_TR("\n %s read reg(0x%x val:0x%x) failed, try to read again! \n",SENSOR_NAME_STRING(),reg, *val);
>             udelay(10);
>         }
>     }
> 
>     return err;
> }
> 
> /* write a array of registers  */
> static int sensor_write_array(struct i2c_client *client, struct reginfo *regarray)
> {
>     int err = 0, cnt;
>     int i = 0;
> #if CONFIG_SENSOR_I2C_RDWRCHK    
> 	char valchk;
> #endif
> 
> 	cnt = 0;
> 	if (sensor_task_lock(client, 1) < 0)
> 		goto sensor_write_array_end;
>     while (regarray[i].reg != 0)
>     {
>         err = sensor_write(client, regarray[i].reg, regarray[i].val);
>         if (err < 0)
>         {
>             if (cnt-- > 0) {
> 			    SENSOR_TR("%s..write failed current reg:0x%x, Write array again !\n", SENSOR_NAME_STRING(),regarray[i].reg);
> 				i = 0;
> 				continue;
>             } else {
>                 SENSOR_TR("%s..write array failed!!!\n", SENSOR_NAME_STRING());
>                 err = -EPERM;
> 				goto sensor_write_array_end;
>             }
>         } else {
>         #if CONFIG_SENSOR_I2C_RDWRCHK
> 			sensor_read(client, regarray[i].reg, &valchk);
> 			if (valchk != regarray[i].val)
> 				SENSOR_TR("%s Reg:0x%x write(0x%x, 0x%x) fail\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
> 		#endif
>         }
>         i++;
>     }
> 
> sensor_write_array_end:
> 	sensor_task_lock(client,0);
> 	return err;
> }
> #if CONFIG_SENSOR_I2C_RDWRCHK
> static int sensor_readchk_array(struct i2c_client *client, struct reginfo *regarray)
> {
>     int cnt;
>     int i = 0;
> 	char valchk;
> 
> 	cnt = 0;
> 	valchk = 0;
>     while (regarray[i].reg != 0)
>     {
> 		sensor_read(client, regarray[i].reg, &valchk);
> 		if (valchk != regarray[i].val)
> 			SENSOR_TR("%s Reg:0x%x read(0x%x, 0x%x) error\n",SENSOR_NAME_STRING(), regarray[i].reg, regarray[i].val, valchk);
> 
>         i++;
>     }
>     return 0;
> }
> #endif
> static int sensor_ioctrl(struct soc_camera_device *icd,enum rk29sensor_power_cmd cmd, int on)
> {
> 	struct soc_camera_link *icl = to_soc_camera_link(icd);
> 	int ret = 0;
> 
>     SENSOR_DG("%s %s  cmd(%d) on(%d)\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd,on);
> 
> 	switch (cmd)
> 	{
> 		case Sensor_PowerDown:
> 		{
> 			if (icl->powerdown) {
> 				ret = icl->powerdown(icd->pdev, on);
> 				if (ret == RK29_CAM_IO_SUCCESS) {
> 					if (on == 0) {
> 						mdelay(2);
> 						if (icl->reset)
> 							icl->reset(icd->pdev);
> 					}
> 				} else if (ret == RK29_CAM_EIO_REQUESTFAIL) {
> 					ret = -ENODEV;
> 					goto sensor_power_end;
> 				}
> 			}
> 			break;
> 		}
> 		case Sensor_Flash:
> 		{
> 			struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
>     		struct sensor *sensor = to_sensor(client);
> 
> 			if (sensor->sensor_io_request && sensor->sensor_io_request->sensor_ioctrl) {
> 				sensor->sensor_io_request->sensor_ioctrl(icd->pdev,Cam_Flash, on);
> 			}
>             break;
> 		}
> 		default:
> 		{
> 			SENSOR_TR("%s %s cmd(0x%x) is unknown!",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
> 			break;
> 		}
> 	}
> sensor_power_end:
> 	return ret;
> }
> static int sensor_init(struct v4l2_subdev *sd, u32 val)
> {
>     struct i2c_client *client = sd->priv;
>     struct soc_camera_device *icd = client->dev.platform_data;
>     struct sensor *sensor = to_sensor(client);
> 	const struct v4l2_queryctrl *qctrl;
>     const struct sensor_datafmt *fmt;
>     char value;
>     int ret,pid = 0;
> 
>     SENSOR_DG("\n%s..%s.. \n",SENSOR_NAME_STRING(),__FUNCTION__);
> 
> 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
> 		ret = -ENODEV;
> 		goto sensor_INIT_ERR;
> 	}
> 
>     /* soft reset */
> 	if (sensor_task_lock(client,1)<0)
> 		goto sensor_INIT_ERR;
>     ret = sensor_write(client, 0xff, 1);
>     ret |= sensor_write(client, 0x12, 0x80);
>     if (ret != 0)
>     {
>         SENSOR_TR("%s soft reset sensor failed\n",SENSOR_NAME_STRING());
>         ret = -ENODEV;
> 		goto sensor_INIT_ERR;
>     }
> 
>     mdelay(5);  //delay 5 microseconds
> 	/* check if it is an sensor sensor */
>     ret = sensor_write(client, 0xff, 1);
>     ret |= sensor_read(client, 0x0a, &value);
>     if (ret != 0) {
>         SENSOR_TR("read chip id high byte failed\n");
>         ret = -ENODEV;
>         goto sensor_INIT_ERR;
>     }
> 
>     pid = value << 8;
>     ret = sensor_read(client, 0x0b, &value);
>     if (ret != 0) {
>         SENSOR_TR("read chip id low byte failed\n");
>         ret = -ENODEV;
>         goto sensor_INIT_ERR;
>     }
> 
>     pid |= (value & 0xff);
> 
>     SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
>     if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
>         sensor->model = SENSOR_V4L2_IDENT;
>     } else {
>         SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
>         ret = -ENODEV;
>         goto sensor_INIT_ERR;
>     }
> 
>     ret = sensor_write_array(client, sensor_init_data);
>     if (ret != 0)
>     {
>         SENSOR_TR("error: %s initial failed\n",SENSOR_NAME_STRING());
>         goto sensor_INIT_ERR;
>     }
> 	sensor_task_lock(client,0);
>     sensor->info_priv.winseqe_cur_addr  = (int)SENSOR_INIT_WINSEQADR;
>     fmt = sensor_find_datafmt(SENSOR_INIT_PIXFMT,sensor_colour_fmts, ARRAY_SIZE(sensor_colour_fmts));
>     if (!fmt) {
>         SENSOR_TR("error: %s initial array colour fmts is not support!!",SENSOR_NAME_STRING());
>         ret = -EINVAL;
>         goto sensor_INIT_ERR;
>     }
> 	sensor->info_priv.fmt = *fmt;
> 
>     /* sensor sensor information for initialization  */
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
> 	if (qctrl)
>     	sensor->info_priv.whiteBalance = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_BRIGHTNESS);
> 	if (qctrl)
>     	sensor->info_priv.brightness = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
> 	if (qctrl)
>     	sensor->info_priv.effect = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EXPOSURE);
> 	if (qctrl)
>         sensor->info_priv.exposure = qctrl->default_value;
> 
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SATURATION);
> 	if (qctrl)
>         sensor->info_priv.saturation = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_CONTRAST);
> 	if (qctrl)
>         sensor->info_priv.contrast = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_HFLIP);
> 	if (qctrl)
>         sensor->info_priv.mirror = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_VFLIP);
> 	if (qctrl)
>         sensor->info_priv.flip = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_SCENE);
> 	if (qctrl)
>         sensor->info_priv.scene = qctrl->default_value;
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
> 	if (qctrl)
>         sensor->info_priv.digitalzoom = qctrl->default_value;
> 
>     /* ddl@rock-chips.com : if sensor support auto focus and flash, programer must run focus and flash code  */
> 	#if CONFIG_SENSOR_Focus
>     sensor_set_focus();
>     qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FOCUS_ABSOLUTE);
> 	if (qctrl)
>         sensor->info_priv.focus = qctrl->default_value;
> 	#endif
> 
> 	#if CONFIG_SENSOR_Flash
> 	qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_FLASH);
> 	if (qctrl)
>         sensor->info_priv.flash = qctrl->default_value;
>     #endif
> 
>     SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),((val == 0)?__FUNCTION__:"sensor_reinit"),icd->user_width,icd->user_height);
> 
>     return 0;
> sensor_INIT_ERR:
> 	sensor_task_lock(client,0);
> 	sensor_deactivate(client);
>     return ret;
> }
> 
> static int sensor_deactivate(struct i2c_client *client)
> {
> 	struct soc_camera_device *icd = client->dev.platform_data;
> 
> 	SENSOR_DG("\n%s..%s.. Enter\n",SENSOR_NAME_STRING(),__FUNCTION__);
> 
> 	/* ddl@rock-chips.com : all sensor output pin must change to input for other sensor */
> #if 0	
> 	sensor_task_lock(client, 1);
>     sensor_write(client, 0x3000, reg_val&0xfc);
> 	sensor_write(client, 0x3001, 0x00);
> 	sensor_task_lock(client, 0);
> #endif
> 	sensor_ioctrl(icd, Sensor_PowerDown, 1);
> 	/* ddl@rock-chips.com : sensor config init width , because next open sensor quickly(soc_camera_open -> Try to configure with default parameters) */
> 	icd->user_width = SENSOR_INIT_WIDTH;
>     icd->user_height = SENSOR_INIT_HEIGHT;
> 	msleep(100);
> 	return 0;
> }
> 
> static  struct reginfo sensor_power_down_sequence[]=
> {
>     {0x00,0x00}
> };
> static int sensor_suspend(struct soc_camera_device *icd, pm_message_t pm_msg)
> {
>     int ret;
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if (pm_msg.event == PM_EVENT_SUSPEND) {
>         SENSOR_DG("\n %s Enter Suspend.. \n", SENSOR_NAME_STRING());
>         ret = sensor_write_array(client, sensor_power_down_sequence) ;
>         if (ret != 0) {
>             SENSOR_TR("\n %s..%s WriteReg Fail.. \n", SENSOR_NAME_STRING(),__FUNCTION__);
>             return ret;
>         } else {
>             ret = sensor_ioctrl(icd, Sensor_PowerDown, 1);
>             if (ret < 0) {
> 			    SENSOR_TR("\n %s suspend fail for turn on power!\n", SENSOR_NAME_STRING());
>                 return -EINVAL;
>             }
>         }
>     } else {
>         SENSOR_TR("\n %s cann't suppout Suspend..\n",SENSOR_NAME_STRING());
>         return -EINVAL;
>     }
>     return 0;
> }
> 
> static int sensor_resume(struct soc_camera_device *icd)
> {
> 	int ret;
> 
>     ret = sensor_ioctrl(icd, Sensor_PowerDown, 0);
>     if (ret < 0) {
> 		SENSOR_TR("\n %s resume fail for turn on power!\n", SENSOR_NAME_STRING());
>         return -EINVAL;
>     }
> 
> 	SENSOR_DG("\n %s Enter Resume.. \n", SENSOR_NAME_STRING());
> 
>     return 0;
> 
> }
> 
> static int sensor_set_bus_param(struct soc_camera_device *icd,
>                                 unsigned long flags)
> {
> 
>     return 0;
> }
> 
> static unsigned long sensor_query_bus_param(struct soc_camera_device *icd)
> {
>     struct soc_camera_link *icl = to_soc_camera_link(icd);
>     unsigned long flags = SENSOR_BUS_PARAM;
> 
>     return soc_camera_apply_sensor_flags(icl, flags);
> }
> 
> static int sensor_g_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
> {
>     struct i2c_client *client = sd->priv;
>     struct soc_camera_device *icd = client->dev.platform_data;
>     struct sensor *sensor = to_sensor(client);
> 
>     mf->width	= icd->user_width;
> 	mf->height	= icd->user_height;
> 	mf->code	= sensor->info_priv.fmt.code;
> 	mf->colorspace	= sensor->info_priv.fmt.colorspace;
> 	mf->field	= V4L2_FIELD_NONE;
> 
>     return 0;
> }
> static bool sensor_fmt_capturechk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
> {
>     bool ret = false;
> 
> 	if ((mf->width == 1024) && (mf->height == 768)) {
> 		ret = true;
> 	} else if ((mf->width == 1280) && (mf->height == 1024)) {
> 		ret = true;
> 	} else if ((mf->width == 1600) && (mf->height == 1200)) {
> 		ret = true;
> 	} else if ((mf->width == 2048) && (mf->height == 1536)) {
> 		ret = true;
> 	} else if ((mf->width == 2592) && (mf->height == 1944)) {
> 		ret = true;
> 	}
> 
> 	if (ret == true)
> 		SENSOR_DG("%s %dx%d is capture format\n", __FUNCTION__, mf->width, mf->height);
> 	return ret;
> }
> 
> static bool sensor_fmt_videochk(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
> {
>     bool ret = false;
> 
> 	if ((mf->width == 1280) && (mf->height == 720)) {
> 		ret = true;
> 	} else if ((mf->width == 1920) && (mf->height == 1080)) {
> 		ret = true;
> 	}
> 
> 	if (ret == true)
> 		SENSOR_DG("%s %dx%d is video format\n", __FUNCTION__, mf->width, mf->height);
> 	return ret;
> }
> static int sensor_s_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
> {
>     struct i2c_client *client = sd->priv;
>     struct sensor *sensor = to_sensor(client);
>     const struct sensor_datafmt *fmt;
> 	const struct v4l2_queryctrl *qctrl;
> 	struct soc_camera_device *icd = client->dev.platform_data;
>     struct reginfo *winseqe_set_addr=NULL;
>     int ret=0, set_w,set_h;
> 
> 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
> 				   ARRAY_SIZE(sensor_colour_fmts));
> 	if (!fmt) {
>         ret = -EINVAL;
>         goto sensor_s_fmt_end;
>     }
> 
> 	if (sensor->info_priv.fmt.code != mf->code) {
> 		switch (mf->code)
> 		{
> 			case V4L2_MBUS_FMT_YUYV8_2X8:
> 			{
> 				winseqe_set_addr = sensor_ClrFmt_YUYV;
> 				break;
> 			}
> 			case V4L2_MBUS_FMT_UYVY8_2X8:
> 			{
> 				winseqe_set_addr = sensor_ClrFmt_UYVY;
> 				break;
> 			}
> 			default:
> 				break;
> 		}
> 		if (winseqe_set_addr != NULL) {
>             sensor_write_array(client, winseqe_set_addr);
> 			sensor->info_priv.fmt.code = mf->code;
>             sensor->info_priv.fmt.colorspace= mf->colorspace;            
> 			SENSOR_DG("%s v4l2_mbus_code:%d set success!\n", SENSOR_NAME_STRING(),mf->code);
> 		} else {
> 			SENSOR_TR("%s v4l2_mbus_code:%d is invalidate!\n", SENSOR_NAME_STRING(),mf->code);
> 		}
> 	}
> 
>     set_w = mf->width;
>     set_h = mf->height;
> 
> 	if (((set_w <= 176) && (set_h <= 144)) && sensor_qcif[0].reg)
> 	{
> 		winseqe_set_addr = sensor_qcif;
>         set_w = 176;
>         set_h = 144;
> 	}
> 	else if (((set_w <= 320) && (set_h <= 240)) && sensor_qvga[0].reg)
>     {
>         winseqe_set_addr = sensor_qvga;
>         set_w = 320;
>         set_h = 240;
>     }
>     else if (((set_w <= 352) && (set_h<= 288)) && sensor_cif[0].reg)
>     {
>         winseqe_set_addr = sensor_cif;
>         set_w = 352;
>         set_h = 288;
>     }
>     else if (((set_w <= 640) && (set_h <= 480)) && sensor_vga[0].reg)
>     {
>         winseqe_set_addr = sensor_vga;
>         set_w = 640;
>         set_h = 480;
>     }
>     else if (((set_w <= 800) && (set_h <= 600)) && sensor_svga[0].reg)
>     {
>         winseqe_set_addr = sensor_svga;
>         set_w = 800;
>         set_h = 600;
>     }
> 	else if (((set_w <= 1024) && (set_h <= 768)) && sensor_xga[0].reg)
>     {
>         winseqe_set_addr = sensor_xga;
>         set_w = 1024;
>         set_h = 768;
>     }
>     else if (((set_w <= 1280) && (set_h <= 1024)) && sensor_sxga[0].reg)
>     {
>         winseqe_set_addr = sensor_sxga;
>         set_w = 1280;
>         set_h = 1024;
>     }
>     else if (((set_w <= 1600) && (set_h <= 1200)) && sensor_uxga[0].reg)
>     {
>         winseqe_set_addr = sensor_uxga;
>         set_w = 1600;
>         set_h = 1200;
>     }
>     else
>     {
>         winseqe_set_addr = SENSOR_INIT_WINSEQADR;               /* ddl@rock-chips.com : Sensor output smallest size if  isn't support app  */
>         set_w = SENSOR_INIT_WIDTH;
>         set_h = SENSOR_INIT_HEIGHT;
> 		SENSOR_TR("\n %s..%s Format is Invalidate. pix->width = %d.. pix->height = %d\n",SENSOR_NAME_STRING(),__FUNCTION__,mf->width,mf->height);
>     }
> 
>     if ((int)winseqe_set_addr  != sensor->info_priv.winseqe_cur_addr) {
>         #if CONFIG_SENSOR_Flash
>         if (sensor_fmt_capturechk(sd,mf) == true) {      /* ddl@rock-chips.com : Capture */
>             if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
>                 sensor_ioctrl(icd, Sensor_Flash, Flash_On);
>                 SENSOR_DG("%s flash on in capture!\n", SENSOR_NAME_STRING());
>             }           
>         } else {                                        /* ddl@rock-chips.com : Video */
>             if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
>                 sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
>                 SENSOR_DG("%s flash off in preivew!\n", SENSOR_NAME_STRING());
>             }
>         }
>         #endif        
>         ret |= sensor_write_array(client, winseqe_set_addr);
>         if (ret != 0) {
>             SENSOR_TR("%s set format capability failed\n", SENSOR_NAME_STRING());
>             #if CONFIG_SENSOR_Flash
>             if (sensor_fmt_capturechk(sd,mf) == true) {
>                 if ((sensor->info_priv.flash == 1) || (sensor->info_priv.flash == 2)) {
>                     sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
>                     SENSOR_TR("%s Capture format set fail, flash off !\n", SENSOR_NAME_STRING());
>                 }
>             }
>             #endif
>             goto sensor_s_fmt_end;
>         }
> 
>         sensor->info_priv.winseqe_cur_addr  = (int)winseqe_set_addr;
> 
> 		if (sensor_fmt_capturechk(sd,mf) == true) {				    /* ddl@rock-chips.com : Capture */
>         #if CONFIG_SENSOR_Effect
> 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
> 			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
>         #endif
>         #if CONFIG_SENSOR_WhiteBalance
> 			if (sensor->info_priv.whiteBalance != 0) {
> 				qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
> 				sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
> 			}
>         #endif
> 			sensor->info_priv.snap2preview = true;
> 		} else if (sensor_fmt_videochk(sd,mf) == true) {			/* ddl@rock-chips.com : Video */
> 		#if CONFIG_SENSOR_Effect
> 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
> 			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
>         #endif
>         #if CONFIG_SENSOR_WhiteBalance
> 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
> 			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
>         #endif
> 			sensor->info_priv.video2preview = true;
> 		} else if ((sensor->info_priv.snap2preview == true) || (sensor->info_priv.video2preview == true)) {
> 		#if CONFIG_SENSOR_Effect
> 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_EFFECT);
> 			sensor_set_effect(icd, qctrl,sensor->info_priv.effect);
>         #endif
>         #if CONFIG_SENSOR_WhiteBalance    
> 			qctrl = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_DO_WHITE_BALANCE);
> 			sensor_set_whiteBalance(icd, qctrl,sensor->info_priv.whiteBalance);
>         #endif    
> 			sensor->info_priv.video2preview = false;            
> 			sensor->info_priv.snap2preview = false;
> 		}
>         SENSOR_DG("\n%s..%s.. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),__FUNCTION__,set_w,set_h);
>     }
>     else
>     {
>         SENSOR_DG("\n %s .. Current Format is validate. icd->width = %d.. icd->height %d\n",SENSOR_NAME_STRING(),set_w,set_h);
>     }
> 
> 	mf->width = set_w;
>     mf->height = set_h;
> 
> sensor_s_fmt_end:
>     return ret;
> }
> 
> static int sensor_try_fmt(struct v4l2_subdev *sd, struct v4l2_mbus_framefmt *mf)
> {
>     struct i2c_client *client = sd->priv;
>     struct sensor *sensor = to_sensor(client);
>     const struct sensor_datafmt *fmt;
>     int ret = 0;
>    
> 	fmt = sensor_find_datafmt(mf->code, sensor_colour_fmts,
> 				   ARRAY_SIZE(sensor_colour_fmts));
> 	if (fmt == NULL) {
> 		fmt = &sensor->info_priv.fmt;
>         mf->code = fmt->code;
> 	} 
> 
>     if (mf->height > SENSOR_MAX_HEIGHT)
>         mf->height = SENSOR_MAX_HEIGHT;
>     else if (mf->height < SENSOR_MIN_HEIGHT)
>         mf->height = SENSOR_MIN_HEIGHT;
> 
>     if (mf->width > SENSOR_MAX_WIDTH)
>         mf->width = SENSOR_MAX_WIDTH;
>     else if (mf->width < SENSOR_MIN_WIDTH)
>         mf->width = SENSOR_MIN_WIDTH;
> 
>     mf->colorspace = fmt->colorspace;
>     
>     return ret;
> }
>  static int sensor_g_chip_ident(struct v4l2_subdev *sd, struct v4l2_dbg_chip_ident *id)
> {
>     struct i2c_client *client = sd->priv;
> 
>     if (id->match.type != V4L2_CHIP_MATCH_I2C_ADDR)
>         return -EINVAL;
> 
>     if (id->match.addr != client->addr)
>         return -ENODEV;
> 
>     id->ident = SENSOR_V4L2_IDENT;      /* ddl@rock-chips.com :  Return OV2655  identifier */
>     id->revision = 0;
> 
>     return 0;
> }
> #if CONFIG_SENSOR_Brightness
> static int sensor_set_brightness(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_BrightnessSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_BrightnessSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
> 	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Effect
> static int sensor_set_effect(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_EffectSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_EffectSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
> 	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Exposure
> static int sensor_set_exposure(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_ExposureSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_ExposureSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
> 	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Saturation
> static int sensor_set_saturation(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_SaturationSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_SaturationSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
>     SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Contrast
> static int sensor_set_contrast(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_ContrastSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_ContrastSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
>     SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Mirror
> static int sensor_set_mirror(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_MirrorSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_MirrorSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
>     SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Flip
> static int sensor_set_flip(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_FlipSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_FlipSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
>     SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Scene
> static int sensor_set_scene(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_SceneSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_SceneSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
>     SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_WhiteBalance
> static int sensor_set_whiteBalance(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
> 
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum))
>     {
>         if (sensor_WhiteBalanceSeqe[value - qctrl->minimum] != NULL)
>         {
>             if (sensor_write_array(client, sensor_WhiteBalanceSeqe[value - qctrl->minimum]) != 0)
>             {
>                 SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>                 return -EINVAL;
>             }
>             SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>             return 0;
>         }
>     }
> 	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_DigitalZoom
> static int sensor_set_digitalzoom(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int *value)
> {
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
>     struct sensor *sensor = to_sensor(client);
> 	const struct v4l2_queryctrl *qctrl_info;
>     int digitalzoom_cur, digitalzoom_total;
> 
> 	qctrl_info = soc_camera_find_qctrl(&sensor_ops, V4L2_CID_ZOOM_ABSOLUTE);
> 	if (qctrl_info)
> 		return -EINVAL;
> 
>     digitalzoom_cur = sensor->info_priv.digitalzoom;
>     digitalzoom_total = qctrl_info->maximum;
> 
>     if ((*value > 0) && (digitalzoom_cur >= digitalzoom_total))
>     {
>         SENSOR_TR("%s digitalzoom is maximum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
>         return -EINVAL;
>     }
> 
>     if  ((*value < 0) && (digitalzoom_cur <= qctrl_info->minimum))
>     {
>         SENSOR_TR("%s digitalzoom is minimum - %x\n", SENSOR_NAME_STRING(), digitalzoom_cur);
>         return -EINVAL;
>     }
> 
>     if ((*value > 0) && ((digitalzoom_cur + *value) > digitalzoom_total))
>     {
>         *value = digitalzoom_total - digitalzoom_cur;
>     }
> 
>     if ((*value < 0) && ((digitalzoom_cur + *value) < 0))
>     {
>         *value = 0 - digitalzoom_cur;
>     }
> 
>     digitalzoom_cur += *value;
> 
>     if (sensor_ZoomSeqe[digitalzoom_cur] != NULL)
>     {
>         if (sensor_write_array(client, sensor_ZoomSeqe[digitalzoom_cur]) != 0)
>         {
>             SENSOR_TR("%s..%s WriteReg Fail.. \n",SENSOR_NAME_STRING(), __FUNCTION__);
>             return -EINVAL;
>         }
>         SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, *value);
>         return 0;
>     }
> 
>     return -EINVAL;
> }
> #endif
> #if CONFIG_SENSOR_Flash
> static int sensor_set_flash(struct soc_camera_device *icd, const struct v4l2_queryctrl *qctrl, int value)
> {    
>     if ((value >= qctrl->minimum) && (value <= qctrl->maximum)) {
>         if (value == 3) {       /* ddl@rock-chips.com: torch */
>             sensor_ioctrl(icd, Sensor_Flash, Flash_Torch);   /* Flash On */
>         } else {
>             sensor_ioctrl(icd, Sensor_Flash, Flash_Off);
>         }
>         SENSOR_DG("%s..%s : %x\n",SENSOR_NAME_STRING(),__FUNCTION__, value);
>         return 0;
>     }
>     
> 	SENSOR_TR("\n %s..%s valure = %d is invalidate..    \n",SENSOR_NAME_STRING(),__FUNCTION__,value);
>     return -EINVAL;
> }
> #endif
> 
> static int sensor_g_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
> {
>     struct i2c_client *client = sd->priv;
>     struct sensor *sensor = to_sensor(client);
>     const struct v4l2_queryctrl *qctrl;
> 
>     qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
> 
>     if (!qctrl)
>     {
>         SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
>         return -EINVAL;
>     }
> 
>     switch (ctrl->id)
>     {
>         case V4L2_CID_BRIGHTNESS:
>             {
>                 ctrl->value = sensor->info_priv.brightness;
>                 break;
>             }
>         case V4L2_CID_SATURATION:
>             {
>                 ctrl->value = sensor->info_priv.saturation;
>                 break;
>             }
>         case V4L2_CID_CONTRAST:
>             {
>                 ctrl->value = sensor->info_priv.contrast;
>                 break;
>             }
>         case V4L2_CID_DO_WHITE_BALANCE:
>             {
>                 ctrl->value = sensor->info_priv.whiteBalance;
>                 break;
>             }
>         case V4L2_CID_EXPOSURE:
>             {
>                 ctrl->value = sensor->info_priv.exposure;
>                 break;
>             }
>         case V4L2_CID_HFLIP:
>             {
>                 ctrl->value = sensor->info_priv.mirror;
>                 break;
>             }
>         case V4L2_CID_VFLIP:
>             {
>                 ctrl->value = sensor->info_priv.flip;
>                 break;
>             }
>         default :
>                 break;
>     }
>     return 0;
> }
> 
> 
> 
> static int sensor_s_control(struct v4l2_subdev *sd, struct v4l2_control *ctrl)
> {
>     struct i2c_client *client = sd->priv;
>     struct sensor *sensor = to_sensor(client);
>     struct soc_camera_device *icd = client->dev.platform_data;
>     const struct v4l2_queryctrl *qctrl;
> 
> 
>     qctrl = soc_camera_find_qctrl(&sensor_ops, ctrl->id);
> 
>     if (!qctrl)
>     {
>         SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ctrl->id);
>         return -EINVAL;
>     }
> 
>     switch (ctrl->id)
>     {
> #if CONFIG_SENSOR_Brightness
>         case V4L2_CID_BRIGHTNESS:
>             {
>                 if (ctrl->value != sensor->info_priv.brightness)
>                 {
>                     if (sensor_set_brightness(icd, qctrl,ctrl->value) != 0)
>                     {
>                         return -EINVAL;
>                     }
>                     sensor->info_priv.brightness = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Exposure
>         case V4L2_CID_EXPOSURE:
>             {
>                 if (ctrl->value != sensor->info_priv.exposure)
>                 {
>                     if (sensor_set_exposure(icd, qctrl,ctrl->value) != 0)
>                     {
>                         return -EINVAL;
>                     }
>                     sensor->info_priv.exposure = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Saturation
>         case V4L2_CID_SATURATION:
>             {
>                 if (ctrl->value != sensor->info_priv.saturation)
>                 {
>                     if (sensor_set_saturation(icd, qctrl,ctrl->value) != 0)
>                     {
>                         return -EINVAL;
>                     }
>                     sensor->info_priv.saturation = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Contrast
>         case V4L2_CID_CONTRAST:
>             {
>                 if (ctrl->value != sensor->info_priv.contrast)
>                 {
>                     if (sensor_set_contrast(icd, qctrl,ctrl->value) != 0)
>                     {
>                         return -EINVAL;
>                     }
>                     sensor->info_priv.contrast = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_WhiteBalance
>         case V4L2_CID_DO_WHITE_BALANCE:
>             {
>                 if (ctrl->value != sensor->info_priv.whiteBalance)
>                 {
>                     if (sensor_set_whiteBalance(icd, qctrl,ctrl->value) != 0)
>                     {
>                         return -EINVAL;
>                     }
>                     sensor->info_priv.whiteBalance = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Mirror
>         case V4L2_CID_HFLIP:
>             {
>                 if (ctrl->value != sensor->info_priv.mirror)
>                 {
>                     if (sensor_set_mirror(icd, qctrl,ctrl->value) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.mirror = ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Flip
>         case V4L2_CID_VFLIP:
>             {
>                 if (ctrl->value != sensor->info_priv.flip)
>                 {
>                     if (sensor_set_flip(icd, qctrl,ctrl->value) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.flip = ctrl->value;
>                 }
>                 break;
>             }
> #endif
>         default:
>             break;
>     }
> 
>     return 0;
> }
> static int sensor_g_ext_control(struct soc_camera_device *icd , struct v4l2_ext_control *ext_ctrl)
> {
>     const struct v4l2_queryctrl *qctrl;
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
>     struct sensor *sensor = to_sensor(client);
> 
>     qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
> 
>     if (!qctrl)
>     {
>         SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
>         return -EINVAL;
>     }
> 
>     switch (ext_ctrl->id)
>     {
>         case V4L2_CID_SCENE:
>             {
>                 ext_ctrl->value = sensor->info_priv.scene;
>                 break;
>             }
>         case V4L2_CID_EFFECT:
>             {
>                 ext_ctrl->value = sensor->info_priv.effect;
>                 break;
>             }
>         case V4L2_CID_ZOOM_ABSOLUTE:
>             {
>                 ext_ctrl->value = sensor->info_priv.digitalzoom;
>                 break;
>             }
>         case V4L2_CID_ZOOM_RELATIVE:
>             {
>                 return -EINVAL;
>             }
>         case V4L2_CID_FOCUS_ABSOLUTE:
>             {
>                 ext_ctrl->value = sensor->info_priv.focus;
>                 break;
>             }
>         case V4L2_CID_FOCUS_RELATIVE:
>             {
>                 return -EINVAL;
>             }
>         case V4L2_CID_FLASH:
>             {
>                 ext_ctrl->value = sensor->info_priv.flash;
>                 break;
>             }
>         default :
>             break;
>     }
>     return 0;
> }
> static int sensor_s_ext_control(struct soc_camera_device *icd, struct v4l2_ext_control *ext_ctrl)
> {
>     const struct v4l2_queryctrl *qctrl;
>     struct i2c_client *client = to_i2c_client(to_soc_camera_control(icd));
>     struct sensor *sensor = to_sensor(client);
>     int val_offset;
> 
>     qctrl = soc_camera_find_qctrl(&sensor_ops, ext_ctrl->id);
> 
>     if (!qctrl)
>     {
>         SENSOR_TR("\n %s ioctrl id = %d  is invalidate \n", SENSOR_NAME_STRING(), ext_ctrl->id);
>         return -EINVAL;
>     }
> 
> 	val_offset = 0;
>     switch (ext_ctrl->id)
>     {
> #if CONFIG_SENSOR_Scene
>         case V4L2_CID_SCENE:
>             {
>                 if (ext_ctrl->value != sensor->info_priv.scene)
>                 {
>                     if (sensor_set_scene(icd, qctrl,ext_ctrl->value) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.scene = ext_ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Effect
>         case V4L2_CID_EFFECT:
>             {
>                 if (ext_ctrl->value != sensor->info_priv.effect)
>                 {
>                     if (sensor_set_effect(icd, qctrl,ext_ctrl->value) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.effect= ext_ctrl->value;
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_DigitalZoom
>         case V4L2_CID_ZOOM_ABSOLUTE:
>             {
>                 if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
>                     return -EINVAL;
> 
>                 if (ext_ctrl->value != sensor->info_priv.digitalzoom)
>                 {
>                     val_offset = ext_ctrl->value -sensor->info_priv.digitalzoom;
> 
>                     if (sensor_set_digitalzoom(icd, qctrl,&val_offset) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.digitalzoom += val_offset;
> 
>                     SENSOR_DG("%s digitalzoom is %x\n",SENSOR_NAME_STRING(),  sensor->info_priv.digitalzoom);
>                 }
> 
>                 break;
>             }
>         case V4L2_CID_ZOOM_RELATIVE:
>             {
>                 if (ext_ctrl->value)
>                 {
>                     if (sensor_set_digitalzoom(icd, qctrl,&ext_ctrl->value) != 0)
>                         return -EINVAL;
>                     sensor->info_priv.digitalzoom += ext_ctrl->value;
> 
>                     SENSOR_DG("%s digitalzoom is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.digitalzoom);
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Focus
>         case V4L2_CID_FOCUS_ABSOLUTE:
>             {
>                 if ((ext_ctrl->value < qctrl->minimum) || (ext_ctrl->value > qctrl->maximum))
>                     return -EINVAL;
> 
>                 if (ext_ctrl->value != sensor->info_priv.focus)
>                 {
>                     val_offset = ext_ctrl->value -sensor->info_priv.focus;
> 
>                     sensor->info_priv.focus += val_offset;
>                 }
> 
>                 break;
>             }
>         case V4L2_CID_FOCUS_RELATIVE:
>             {
>                 if (ext_ctrl->value)
>                 {
>                     sensor->info_priv.focus += ext_ctrl->value;
> 
>                     SENSOR_DG("%s focus is %x\n", SENSOR_NAME_STRING(), sensor->info_priv.focus);
>                 }
>                 break;
>             }
> #endif
> #if CONFIG_SENSOR_Flash
>         case V4L2_CID_FLASH:
>             {
>                 if (sensor_set_flash(icd, qctrl,ext_ctrl->value) != 0)
>                     return -EINVAL;
>                 sensor->info_priv.flash = ext_ctrl->value;
> 
>                 SENSOR_DG("%s flash is %x\n",SENSOR_NAME_STRING(), sensor->info_priv.flash);
>                 break;
>             }
> #endif
>         default:
>             break;
>     }
> 
>     return 0;
> }
> 
> static int sensor_g_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
> {
>     struct i2c_client *client = sd->priv;
>     struct soc_camera_device *icd = client->dev.platform_data;
>     int i, error_cnt=0, error_idx=-1;
> 
> 
>     for (i=0; i<ext_ctrl->count; i++) {
>         if (sensor_g_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
>             error_cnt++;
>             error_idx = i;
>         }
>     }
> 
>     if (error_cnt > 1)
>         error_idx = ext_ctrl->count;
> 
>     if (error_idx != -1) {
>         ext_ctrl->error_idx = error_idx;
>         return -EINVAL;
>     } else {
>         return 0;
>     }
> }
> 
> static int sensor_s_ext_controls(struct v4l2_subdev *sd, struct v4l2_ext_controls *ext_ctrl)
> {
>     struct i2c_client *client = sd->priv;
>     struct soc_camera_device *icd = client->dev.platform_data;
>     int i, error_cnt=0, error_idx=-1;
> 
> 
>     for (i=0; i<ext_ctrl->count; i++) {
>         if (sensor_s_ext_control(icd, &ext_ctrl->controls[i]) != 0) {
>             error_cnt++;
>             error_idx = i;
>         }
>     }
> 
>     if (error_cnt > 1)
>         error_idx = ext_ctrl->count;
> 
>     if (error_idx != -1) {
>         ext_ctrl->error_idx = error_idx;
>         return -EINVAL;
>     } else {
>         return 0;
>     }
> }
> 
> /* Interface active, can use i2c. If it fails, it can indeed mean, that
>  * this wasn't our capture interface, so, we wait for the right one */
> static int sensor_video_probe(struct soc_camera_device *icd,
> 			       struct i2c_client *client)
> {
>     char value;
>     int ret,pid = 0;
>     struct sensor *sensor = to_sensor(client);
> 
>     /* We must have a parent by now. And it cannot be a wrong one.
>      * So this entire test is completely redundant. */
>     if (!icd->dev.parent ||
> 	    to_soc_camera_host(icd->dev.parent)->nr != icd->iface)
> 		return -ENODEV;
> 
> 	if (sensor_ioctrl(icd, Sensor_PowerDown, 0) < 0) {
> 		ret = -ENODEV;
> 		goto sensor_video_probe_err;
> 	}
> 
>     /* soft reset */
>     ret = sensor_write(client, 0xff, 0x1);
>     if (ret != 0) {
>         SENSOR_TR("soft reset %s failed\n",SENSOR_NAME_STRING());
>         ret = -ENODEV;
> 		goto sensor_video_probe_err;
>     }
>     mdelay(5);          //delay 5 microseconds
> 
>     /* check if it is an sensor sensor */
>     ret = sensor_read(client, 0x0a, &value);
>     if (ret != 0) {
>         SENSOR_TR("read chip id high byte failed\n");
>         ret = -ENODEV;
>         goto sensor_video_probe_err;
>     }
>     pid = value << 8;
> 
>     ret = sensor_read(client, 0x0b, &value);
>     if (ret != 0) {
>         SENSOR_TR("read chip id low byte failed\n");
>         ret = -ENODEV;
>         goto sensor_video_probe_err;
>     }
> 
>     pid |= (value & 0xff);
>     SENSOR_DG("\n %s  pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
> 
>     if ((pid == SENSOR_ID)||(pid == SENSOR_ID1)) {
>         sensor->model = SENSOR_V4L2_IDENT;
>     } else {
>         SENSOR_TR("error: %s mismatched   pid = 0x%x\n", SENSOR_NAME_STRING(), pid);
>         ret = -ENODEV;
>         goto sensor_video_probe_err;
>     }
> 
>     return 0;
> 
> sensor_video_probe_err:
> 
>     return ret;
> }
> 
> static long sensor_ioctl(struct v4l2_subdev *sd, unsigned int cmd, void *arg)
> {
> 	struct i2c_client *client = sd->priv;
>     struct soc_camera_device *icd = client->dev.platform_data;  
>     struct sensor *sensor = to_sensor(client);
>     int ret = 0;
>     
> 	SENSOR_DG("\n%s..%s..cmd:%x \n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
> 	switch (cmd)
> 	{
> 		case RK29_CAM_SUBDEV_DEACTIVATE:
> 		{
> 			sensor_deactivate(client);
> 			break;
> 		}
> 
> 		case RK29_CAM_SUBDEV_IOREQUEST:
> 		{
> 			sensor->sensor_io_request = (struct rk29camera_platform_data*)arg;           
>             if (sensor->sensor_io_request != NULL) { 
>                 if (sensor->sensor_io_request->gpio_res[0].dev_name && 
>                     (strcmp(sensor->sensor_io_request->gpio_res[0].dev_name, dev_name(icd->pdev)) == 0)) {
>                     sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[0];
>                 } else if (sensor->sensor_io_request->gpio_res[1].dev_name && 
>                     (strcmp(sensor->sensor_io_request->gpio_res[1].dev_name, dev_name(icd->pdev)) == 0)) {
>                     sensor->sensor_gpio_res = (struct rk29camera_gpio_res*)&sensor->sensor_io_request->gpio_res[1];
>                 }
>             } else {
>                 SENSOR_TR("%s %s RK29_CAM_SUBDEV_IOREQUEST fail\n",SENSOR_NAME_STRING(),__FUNCTION__);
>                 ret = -EINVAL;
>                 goto sensor_ioctl_end;
>             }
>             /* ddl@rock-chips.com : if gpio_flash havn't been set in board-xxx.c, sensor driver must notify is not support flash control 
>                for this project */
>             #if CONFIG_SENSOR_Flash	
>         	if (sensor->sensor_gpio_res) { 
>                 if (sensor->sensor_gpio_res->gpio_flash == INVALID_GPIO) {
>                     for (i = 0; i < icd->ops->num_controls; i++) {
>                 		if (V4L2_CID_FLASH == icd->ops->controls[i].id) {
>                 			memset((char*)&icd->ops->controls[i],0x00,sizeof(struct v4l2_queryctrl));                			
>                 		}
>                     }
>                     sensor->info_priv.flash = 0xff;
>                     SENSOR_DG("%s flash gpio is invalidate!\n",SENSOR_NAME_STRING());
>                 }
>         	}
>             #endif
> 			break;
> 		}
> 		default:
> 		{
> 			SENSOR_TR("%s %s cmd(0x%x) is unknown !\n",SENSOR_NAME_STRING(),__FUNCTION__,cmd);
> 			break;
> 		}
> 	}
> 
> sensor_ioctl_end:
> 	return ret;
> 
> }
> static int sensor_enum_fmt(struct v4l2_subdev *sd, unsigned int index,
> 			    enum v4l2_mbus_pixelcode *code)
> {
> 	if (index >= ARRAY_SIZE(sensor_colour_fmts))
> 		return -EINVAL;
> 
> 	*code = sensor_colour_fmts[index].code;
> 	return 0;
> }
> static struct v4l2_subdev_core_ops sensor_subdev_core_ops = {
> 	.init		= sensor_init,
> 	.g_ctrl		= sensor_g_control,
> 	.s_ctrl		= sensor_s_control,
> 	.g_ext_ctrls          = sensor_g_ext_controls,
> 	.s_ext_ctrls          = sensor_s_ext_controls,
> 	.g_chip_ident	= sensor_g_chip_ident,
> 	.ioctl = sensor_ioctl,
> };
> 
> static struct v4l2_subdev_video_ops sensor_subdev_video_ops = {
> 	.s_mbus_fmt	= sensor_s_fmt,
> 	.g_mbus_fmt	= sensor_g_fmt,
> 	.try_mbus_fmt	= sensor_try_fmt,
> 	.enum_mbus_fmt	= sensor_enum_fmt,
> };
> 
> static struct v4l2_subdev_ops sensor_subdev_ops = {
> 	.core	= &sensor_subdev_core_ops,
> 	.video = &sensor_subdev_video_ops,
> };
> 
> static int sensor_probe(struct i2c_client *client,
> 			 const struct i2c_device_id *did)
> {
>     struct sensor *sensor;
>     struct soc_camera_device *icd = client->dev.platform_data;
>     struct i2c_adapter *adapter = to_i2c_adapter(client->dev.parent);
>     struct soc_camera_link *icl;
>     int ret;
> 
>     SENSOR_DG("\n%s..%s..%d..\n",__FUNCTION__,__FILE__,__LINE__);
>     if (!icd) {
>         dev_err(&client->dev, "%s: missing soc-camera data!\n",SENSOR_NAME_STRING());
>         return -EINVAL;
>     }
> 
>     icl = to_soc_camera_link(icd);
>     if (!icl) {
>         dev_err(&client->dev, "%s driver needs platform data\n", SENSOR_NAME_STRING());
>         return -EINVAL;
>     }
> 
>     if (!i2c_check_functionality(adapter, I2C_FUNC_I2C)) {
>         dev_warn(&adapter->dev,
>         	 "I2C-Adapter doesn't support I2C_FUNC_I2C\n");
>         return -EIO;
>     }
> 
>     sensor = kzalloc(sizeof(struct sensor), GFP_KERNEL);
>     if (!sensor)
>         return -ENOMEM;
> 
>     v4l2_i2c_subdev_init(&sensor->subdev, client, &sensor_subdev_ops);
> 
>     /* Second stage probe - when a capture adapter is there */
>     icd->ops		= &sensor_ops;
>     sensor->info_priv.fmt = sensor_colour_fmts[0];
> 	#if CONFIG_SENSOR_I2C_NOSCHED
> 	atomic_set(&sensor->tasklock_cnt,0);
> 	#endif
> 
>     ret = sensor_video_probe(icd, client);
>     if (ret < 0) {
>         icd->ops = NULL;
>         i2c_set_clientdata(client, NULL);
>         kfree(sensor);
> 		sensor = NULL;
>     }
>     SENSOR_DG("\n%s..%s..%d  ret = %x \n",__FUNCTION__,__FILE__,__LINE__,ret);
>     return ret;
> }
> 
> static int sensor_remove(struct i2c_client *client)
> {
>     struct sensor *sensor = to_sensor(client);
>     struct soc_camera_device *icd = client->dev.platform_data;
> 
>     icd->ops = NULL;
>     i2c_set_clientdata(client, NULL);
>     client->driver = NULL;
>     kfree(sensor);
> 	sensor = NULL;
>     return 0;
> }
> 
> static const struct i2c_device_id sensor_id[] = {
> 	{SENSOR_NAME_STRING(), 0 },
> 	{ }
> };
> MODULE_DEVICE_TABLE(i2c, sensor_id);
> 
> static struct i2c_driver sensor_i2c_driver = {
> 	.driver = {
> 		.name = SENSOR_NAME_STRING(),
> 	},
> 	.probe		= sensor_probe,
> 	.remove		= sensor_remove,
> 	.id_table	= sensor_id,
> };
> 
> static int __init sensor_mod_init(void)
> {
>     SENSOR_DG("\n%s..%s.. \n",__FUNCTION__,SENSOR_NAME_STRING());
>     return i2c_add_driver(&sensor_i2c_driver);
> }
> 
> static void __exit sensor_mod_exit(void)
> {
>     i2c_del_driver(&sensor_i2c_driver);
> }
> 
> device_initcall_sync(sensor_mod_init);
> module_exit(sensor_mod_exit);
> 
> MODULE_DESCRIPTION(SENSOR_NAME_STRING(Camera sensor driver));
> MODULE_AUTHOR("ddl <kernel@rock-chips>");
> MODULE_LICENSE("GPL");
> 
> 
> >>>>>>> parent of 15f7fab... temp revert rk change
Only in linux-3.0.36-lenovo/drivers/media/video: ov2640_rk.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov2655.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov2659.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov3640_af_firmware.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov3640.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov3640.h
Only in linux-3.0.36-lenovo/drivers/media/video: ov3660.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5640_af_firmware.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5640.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5640_for_td8801.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5640.h
Only in linux-3.0.36-lenovo/drivers/media/video: ov5642_af_firmware.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5642.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov5642.h
Only in linux-3.0.36-lenovo/drivers/media/video: ov7675.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov7690.c
Only in linux-3.0.36-lenovo/drivers/media/video: ov9650.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk2928_camera.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk29_camera.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk29_camera_oneframe.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk29_camera_pingpong.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk29xx
Only in linux-3.0.36-lenovo/drivers/media/video: rk30_camera.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk30_camera_oneframe.c
Only in linux-3.0.36-lenovo/drivers/media/video: rk30_camera_pingpong.c
Only in linux-3.0.36-lenovo/drivers/media/video: s5k5ca.c
Only in linux-3.0.36-lenovo/drivers/media/video: s5k5ca.h
Only in linux-3.0.36-lenovo/drivers/media/video: s5k6aa.c
Only in linux-3.0.36-lenovo/drivers/media/video: s5k6aa.h
Only in linux-3.0.36-lenovo/drivers/media/video: sid130B.c
Only in linux-3.0.36-lenovo/drivers/media/video: siv120b.c
Only in linux-3.0.36-lenovo/drivers/media/video: siv121d.c




diff -r linux-3.0.36/drivers/media/video/soc_camera.c linux-3.0.36-lenovo/drivers/media/video/soc_camera.c
67c67,68
< 		if (icl->power)
---
> 		if (icl->power){
> 			icl->power(icd->pdev, 0); // ensure power and reset pin are not active.
68a70
> 			}
488,490c490,494
< 		ret = soc_camera_power_set(icd, icl, 1);
< 		if (ret < 0)
< 			goto epower;
---
>         /* ddl@rock-chips.com : accelerate device open  */
>         if ((file->f_flags & O_ACCMODE) == O_RDWR) {
>             ret = soc_camera_power_set(icd, icl, 1);
>     		if (ret < 0)
>     			goto epower;
492,494c496
< 		/* The camera could have been already on, try to reset */
< 		if (icl->reset)
< 			icl->reset(icd->pdev);
---
>         }
501c503,510
< 
---
>         /* ddl@rock-chips.com : accelerate device open  */
>         //reset MUST be done after mclk supply(for mt9335 isp)
>         
>         if ((file->f_flags & O_ACCMODE) == O_RDWR) {
>     		/* The camera could have been already on, try to reset */
>     		if (icl->reset)
>     			icl->reset(icd->pdev);
>             }
505a515,526
>         /* ddl@rock-chips.com : accelerate device open  */
>         if ((file->f_flags & O_ACCMODE) == O_RDWR) {
>     		/*
>     		 * Try to configure with default parameters. Notice: this is the
>     		 * very first open, so, we cannot race against other calls,
>     		 * apart from someone else calling open() simultaneously, but
>     		 * .video_lock is protecting us against it.
>     		 */
>     		ret = soc_camera_set_fmt(icd, &f);
>     		if (ret < 0)
>     			goto esfmt;
>         }
507,517c528
< 		/*
< 		 * Try to configure with default parameters. Notice: this is the
< 		 * very first open, so, we cannot race against other calls,
< 		 * apart from someone else calling open() simultaneously, but
< 		 * .video_lock is protecting us against it.
< 		 */
< 		ret = soc_camera_set_fmt(icd, &f);
< 		if (ret < 0)
< 			goto esfmt;
< 
< 		if (ici->ops->init_videobuf) {
---
>         if (ici->ops->init_videobuf) {
565c576,578
< 		soc_camera_power_set(icd, icl, 0);
---
>         if ((file->f_flags & O_ACCMODE) == O_RDWR) {   /* ddl@rock-chips.com : accelerate device open  */
>             soc_camera_power_set(icd, icl, 0);	
>         }
680a694,711
> /* ddl@rock-chips.com : Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
> static int soc_camera_enum_frameintervals (struct file *file, void  *priv,
> 					   struct v4l2_frmivalenum *fival)
> {
>     struct soc_camera_device *icd = file->private_data;
>     struct soc_camera_host *ici = to_soc_camera_host(icd->dev.parent);
>     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
>     int ret;
>     
> 	WARN_ON(priv != file->private_data);
> 
>     ret = v4l2_subdev_call(sd, video, enum_frameintervals, fival);
>     if (ret == -ENOIOCTLCMD) {
>         if (ici->ops->enum_frameinervals)
>            ret = ici->ops->enum_frameinervals(icd, fival); 
>         else 
>            ret = -ENOIOCTLCMD;
>     }
681a713,714
>     return ret;
> }
750c783
< 		return -EBUSY;
---
> 		return -EBUSY;    
758c791
< 	if (!ret)
---
> 	if (!ret) {
759a793,795
>         if (ici->ops->s_stream)
> 	        ici->ops->s_stream(icd, 1);				/* ddl@rock-chips.com : Add stream control for host */
> 	}
788a825,826
>     if (ici->ops->s_stream)
> 		ici->ops->s_stream(icd, 0);				/* ddl@rock-chips.com : Add stream control for host */
789a828,829
>     videobuf_mmap_free(&icd->vb_vidq);          /* ddl@rock-chips.com : free video buf */
> 	
805,808c845,849
< 	/* First check host controls */
< 	for (i = 0; i < ici->ops->num_controls; i++)
< 		if (qc->id == ici->ops->controls[i].id) {
< 			memcpy(qc, &(ici->ops->controls[i]),
---
> 	/* first device controls */
> 	//if device support digital zoom ,first use it to do zoom,zyc
> 	for (i = 0; i < icd->ops->num_controls; i++)
> 		if (qc->id == icd->ops->controls[i].id) {
> 			memcpy(qc, &(icd->ops->controls[i]),
813,816c854,857
< 	/* Then device controls */
< 	for (i = 0; i < icd->ops->num_controls; i++)
< 		if (qc->id == icd->ops->controls[i].id) {
< 			memcpy(qc, &(icd->ops->controls[i]),
---
> 	/* then check host controls */
> 	for (i = 0; i < ici->ops->num_controls; i++)
> 		if (qc->id == ici->ops->controls[i].id) {
> 			memcpy(qc, &(ici->ops->controls[i]),
823a865,897
> /* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
> static int soc_camera_querymenu(struct file *file, void *priv,
>                                 struct v4l2_querymenu *qm)
> {
>     struct soc_camera_device *icd = file->private_data;
>     struct v4l2_queryctrl qctrl;
>     int i,j;
> 
>     qctrl.id = qm->id;
> 
>     if (soc_camera_queryctrl(file,priv, &qctrl) == 0) {
>         for (i = 0; i < icd->ops->num_menus; i++) {
>             if (qm->id == icd->ops->menus[i].id) {
>                 for (j=0; j<=(qctrl.maximum - qctrl.minimum); j++) {
> 
>                     if (qm->index == icd->ops->menus[i].index) {
>                         snprintf(qm->name, sizeof(qm->name), icd->ops->menus[i].name);
>                         qm->reserved = 0;
> 
>                         return 0;
>                     } else {
>                         i++;
>                         if ( i >= icd->ops->num_menus)
>                             return -EINVAL;
>                     }
>                 }
>             }
>         }
>     }
> 
>     return -EINVAL;
> }
> 
861a936,990
> 
>  /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
> static int soc_camera_try_ext_ctrl(struct file *file, void *priv,
>                              struct v4l2_ext_controls *ctrl)
> {
>     struct soc_camera_device *icd = file->private_data;
>     const struct v4l2_queryctrl *qctrl;
>     int i;
> 
>     WARN_ON(priv != file->private_data);
> 
>     if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
>         return -EINVAL;
> 
>     for (i=0; i<ctrl->count; i++) {
>         qctrl = soc_camera_find_qctrl(icd->ops, ctrl->controls[i].id);
>         if (!qctrl)
>             return -EINVAL;
> 
>         if ((ctrl->controls[i].value < qctrl->minimum) ||(ctrl->controls[i].value > qctrl->minimum))
>             return -ERANGE;
>     }
> 
>     return 0;
> }
>  /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
> static int soc_camera_g_ext_ctrl(struct file *file, void *priv,
>                              struct v4l2_ext_controls *ctrl)
> {
>     struct soc_camera_device *icd = file->private_data;
>     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
> 
>     WARN_ON(priv != file->private_data);
> 
>     if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
>         return -EINVAL;
> 
>     return v4l2_subdev_call(sd, core, g_ext_ctrls, ctrl);
> }
>  /* ddl@rock-chips.com : Add ioctrl -VIDIOC_XXX_ext_ctrl for soc-camera */
> static int soc_camera_s_ext_ctrl(struct file *file, void *priv,
>                              struct v4l2_ext_controls *ctrl)
> {
>     struct soc_camera_device *icd = file->private_data;
>     struct v4l2_subdev *sd = soc_camera_to_subdev(icd);
> 
>     WARN_ON(priv != file->private_data);
> 
>     if (ctrl->ctrl_class != V4L2_CTRL_CLASS_CAMERA)
>         return -EINVAL;
> 
>     return v4l2_subdev_call(sd, core, s_ext_ctrls, ctrl);
> }
> 
> 
990,991c1119,1120
< 			dev_set_name(&icd->dev, "%u-%u", icd->iface,
< 				     icd->devnum);
---
> 			dev_set_name(&icd->dev, "%u-%u-%s", icd->iface,
> 				     icd->devnum,dev_name(icd->pdev));
1066,1067d1194
< 	dev_info(dev, "Probing %s\n", dev_name(dev));
< 
1077,1080d1203
< 	/* The camera could have been already on, try to reset */
< 	if (icl->reset)
< 		icl->reset(icd->pdev);
< 
1083a1207,1211
>     
>     /* The camera could have been already on, try to reset */
>     //reset MUST be done after mclk supply(for mt9335 isp)
>     if (icl->reset)
>             icl->reset(icd->pdev);
1159c1287
< 
---
>     printk("Probe %s success\n", dev_name(icd->pdev));
1181a1310
>     dev_err(dev, "Probe %s failed\n", dev_name(icd->pdev));
1473a1603
> 	 .vidioc_querymenu	 = soc_camera_querymenu,     /* ddl@rock-chips.com:   Add ioctrl - vidioc_querymenu for soc-camera */
1475a1606,1609
> 	.vidioc_g_ext_ctrls    = soc_camera_g_ext_ctrl,   /* ddl@rock-chips.com:   Add ioctrl - vidioc_g_ext_ctrls for soc-camera */
> 	.vidioc_s_ext_ctrls    = soc_camera_s_ext_ctrl,   /* ddl@rock-chips.com:   Add ioctrl - vidioc_s_ext_ctrls for soc-camera */
> 	.vidioc_try_ext_ctrls    = soc_camera_try_ext_ctrl,/* ddl@rock-chips.com:   Add ioctrl - vidioc_try_ext_ctrls for soc-camera */
>     .vidioc_enum_frameintervals = soc_camera_enum_frameintervals,/* ddl@rock-chips.com:   Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
Only in linux-3.0.36-lenovo/drivers/media/video: sp0838.c
Only in linux-3.0.36-lenovo/drivers/media/video: sp2518.c




diff -r linux-3.0.36/drivers/media/video/uvc/uvc_ctrl.c linux-3.0.36-lenovo/drivers/media/video/uvc/uvc_ctrl.c
677a678
>     #if 0       /* ddl@rock-chips.com: address must align to 4-bytes */
678a680,682
>     #else
>     return ctrl->uvc_data + id * ((ctrl->info.size+3)/4*4);
>     #endif
907c911
< 
---
>     
1592a1597
>     #if 0           /* ddl@rock-chips.com: address must align to 4-bytes */
1594a1600,1603
>     #else
>     ctrl->uvc_data = kzalloc(((ctrl->info.size+3)/4*4) * UVC_CTRL_DATA_LAST + 1,
> 				 GFP_KERNEL);
>     #endif




diff -r linux-3.0.36/drivers/media/video/uvc/uvc_queue.c linux-3.0.36-lenovo/drivers/media/video/uvc/uvc_queue.c
87a88
> 	init_waitqueue_head(&queue->wait);  /* ddl@rock-chips.com : This design copied from video-buf */
303a305,306
>     wake_up_interruptible_sync(&queue->wait);     /* ddl@rock-chips.com : This design copied from video-buf */
> 
317c320
< 
---
> #if 0
321a325,332
> #else
> 	/* ddl@rock-chips.com: wait_event_interruptible -> wait_event_interruptible_timeout */
> 	return wait_event_interruptible_timeout(buf->wait,
> 		buf->state != UVC_BUF_STATE_QUEUED &&
> 		buf->state != UVC_BUF_STATE_ACTIVE &&
> 		buf->state != UVC_BUF_STATE_READY,
> 		msecs_to_jiffies(1500));
> #endif
340a352,356
>     /* ddl@rock-chips.com */
>     if (!(queue->flags & UVC_QUEUE_STREAMING)) {
>         printk("uvcvideo: Not streaming\n");
> 		return -EINVAL;
>     }
342a359,360
>     /* ddl@rock-chips.com : This design copied from video-buf */
> checks:    
344,346c362,385
< 		uvc_trace(UVC_TRACE_CAPTURE, "[E] Empty buffer queue.\n");
< 		ret = -EINVAL;
< 		goto done;
---
>         if (nonblocking) {
> 			uvc_trace(UVC_TRACE_CAPTURE, "[E] Empty buffer queue.\n");
>     		ret = -EINVAL;
>     		goto done;
> 		} else {
> 		    //uvc_trace(UVC_TRACE_CAPTURE, "dequeue_buffer: waiting on buffer\n");
>             printk("dequeue_buffer: waiting on buffer\n");
> 			/* Drop lock to avoid deadlock with qbuf */
> 			mutex_unlock(&queue->mutex);
> 
> 			/* Checking list_empty and streaming is safe without
> 			 * locks because we goto checks to validate while
> 			 * holding locks before proceeding */
> 			ret = wait_event_interruptible(queue->wait,
> 				((!list_empty(&queue->mainqueue)) || (!(queue->flags & UVC_QUEUE_STREAMING))));
> 			mutex_lock(&queue->mutex);
> 
> 			if (ret || (!(queue->flags & UVC_QUEUE_STREAMING))) {
>                 printk("uvcvideo: Stream off\n");
>                 goto done;
> 			}
> 
> 			goto checks;
> 		}	
350c389,396
< 	if ((ret = uvc_queue_waiton(buf, nonblocking)) < 0)
---
> 	if ((ret = uvc_queue_waiton(buf, nonblocking)) <= 0) {
>         /* ddl@rock-chips.com: It is timeout */
>         if (ret == 0) {
>             ret = -EINVAL;
>             printk(KERN_ERR "uvcvideo: uvc_dequeue_buffer is timeout!!\n");
>         } else {
>             printk(KERN_ERR "uvcvideo: uvc_dequeue_buffer is failed!!(ret:%d)\n",ret);
>         }
351a398
> 	}
554a602
> 	    queue->flags &= ~UVC_QUEUE_STREAMING;
562,563d609
< 
< 		queue->flags &= ~UVC_QUEUE_STREAMING;
587a634,635
>     wake_up_interruptible_sync(&queue->wait);           /* ddl@rock-chips.com : This design copied from video-buf */
> 
620c668
< 	spin_lock_irqsave(&queue->irqlock, flags);
---
> 	//spin_lock_irqsave(&queue->irqlock, flags);
629c677
< 	spin_unlock_irqrestore(&queue->irqlock, flags);
---
> 	//spin_unlock_irqrestore(&queue->irqlock, flags);




diff -r linux-3.0.36/drivers/media/video/uvc/uvc_v4l2.c linux-3.0.36-lenovo/drivers/media/video/uvc/uvc_v4l2.c
307c307,308
< 	if (fmt->type != stream->type)
---
> 	if (fmt->type != stream->type) {
>         printk("uvc_v4l2_set_format, fmt->type(%d) != stream->type(%d)\n",fmt->type,stream->type);
308a310
> 	}
316a319
>         printk("uvc_queue_allocated failed\n");
811c814,815
< 		if ((ret = uvc_acquire_privileges(handle)) < 0)
---
> 		if ((ret = uvc_acquire_privileges(handle)) < 0) {
>             printk("uvc_acquire_privileges error.");
812a817
> 		}
986c991,992
< 		if (!uvc_has_privileges(handle))
---
> 		if (!uvc_has_privileges(handle)) {
>             printk("uvcvideo: VIDIOC_QBUF uvc_has_privileges failed\n");
987a994
> 		}
992c999,1000
< 		if (!uvc_has_privileges(handle))
---
> 		if (!uvc_has_privileges(handle)) {
>             printk("uvcvideo: VIDIOC_DQBUF uvc_has_privileges failed\n");
993a1002
> 		}




diff -r linux-3.0.36/drivers/media/video/uvc/uvc_video.c linux-3.0.36-lenovo/drivers/media/video/uvc/uvc_video.c
743,745c743,747
< 
< static void uvc_video_complete(struct urb *urb)
< {
---
> /* ddl@rock-chips.com : uvc_video_complete is run in_interrupt(), so uvc decode operation delay run in tasklet for
> *    usb host reenable interrupt soon
> */
> static void uvc_video_complete_fun (struct urb *urb)
> {    
750a753,754
> 	int i;
> 	atomic_t *urb_state;
769a774,786
>     for (i = 0; i < UVC_URBS; ++i) {    
>         if (stream->urb[i] == urb) {
>             urb_state = &stream->urb_state[i];
>             break;
>         }
>     }
> 	
> 	if (atomic_read(urb_state)==UrbDeactive) {
> 	    printk(KERN_DEBUG "urb is deactive, this urb complete cancel!");
> 		uvc_queue_cancel(queue, urb->status == -ESHUTDOWN);
> 	    return;
> 	}
> 
774,775d790
< 	spin_unlock_irqrestore(&queue->irqlock, flags);
< 
776a792
> 	spin_unlock_irqrestore(&queue->irqlock, flags);
782a799,830
> static void uvc_video_complete_tasklet(unsigned long data)
> {
>     struct urb *urb = (struct urb*)data;
>     struct uvc_streaming *stream = urb->context;
>     struct tasklet_struct *tasklet = NULL;
>     int i;
>     
>     uvc_video_complete_fun(urb);    
>     
>     return;
> }
> static void uvc_video_complete(struct urb *urb)
> {
>     int i;
>     struct uvc_streaming *stream = urb->context;
>     struct tasklet_struct *tasklet = NULL;
>     atomic_t *urb_state;
>     
>     for (i = 0; i < UVC_URBS; ++i) {    
>         if (stream->urb[i] == urb) {
>             tasklet = stream->tasklet[i];
>             urb_state = &stream->urb_state[i];
>             break;
>         }
>     }
> 
>     if ((tasklet != NULL)&&(atomic_read(urb_state)==UrbActive)) {
>         tasklet_schedule(tasklet);
>     } else {
>         uvc_video_complete_fun(urb);
>     }
> }
863c911
< 
---
>    
868,869c916,925
< 
< 		usb_kill_urb(urb);
---
> 		else
> 		    atomic_set(&stream->urb_state[i],UrbDeactive);
> 		
>         if (stream->tasklet[i]) {
>             tasklet_kill(stream->tasklet[i]);
>             kfree(stream->tasklet[i]);
>             stream->tasklet[i] = NULL;
>         }
>         
>         usb_kill_urb(urb); 
871a928
>         
924a982,990
>         /* ddl@rock-chips.com  */
>         atomic_set(&stream->urb_state[i],UrbActive);
>         stream->tasklet[i] = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
>         if (stream->tasklet[i] == NULL) {
>             uvc_printk(KERN_ERR, "device %s requested tasklet memory fail!\n",
> 				stream->dev->name);
>         } else {
>             tasklet_init(stream->tasklet[i], uvc_video_complete_tasklet, (unsigned long)urb);
>         }
975a1042,1050
> 
>         /* ddl@rock-chips.com  */
>         stream->tasklet[i] = kmalloc(sizeof(struct tasklet_struct), GFP_KERNEL);
>         if (stream->tasklet[i] == NULL) {
>             uvc_printk(KERN_ERR, "device %s requested tasklet memory fail!\n",
> 				stream->dev->name);
>         } else {
>             tasklet_init(stream->tasklet[i], uvc_video_complete_tasklet, (unsigned long)urb);
>         }
1252c1327
< 
---
>     
1254,1256c1329,1334
< 		uvc_uninit_video(stream, 1);
< 		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
< 		uvc_queue_enable(&stream->queue, 0);
---
>         if (stream->flags & UVC_QUEUE_STREAMING) {      /* ddl@rock-chips.com */
>             uvc_queue_enable(&stream->queue, 0);
>     		uvc_uninit_video(stream, 1);
>     		usb_set_interface(stream->dev->udev, stream->intfnum, 0);
>     		stream->flags &= ~UVC_QUEUE_STREAMING;
>         }
1270c1348
< 
---
>     stream->flags |= UVC_QUEUE_STREAMING;




diff -r linux-3.0.36/drivers/media/video/uvc/uvcvideo.h linux-3.0.36-lenovo/drivers/media/video/uvc/uvcvideo.h
437a438,439
>     wait_queue_head_t wait; /* wait if mainqueue is empty */
> 
439a442
>     
452c455,458
< 
---
> enum uvc_urb_state {
>     UrbActive,
>     UrbDeactive
> };
498a505,509
> 
>     struct tasklet_struct *tasklet[UVC_URBS];     /* ddl@rock-chips.com */
>     atomic_t urb_state[UVC_URBS];
>     
>     unsigned int flags;




diff -r linux-3.0.36/drivers/media/video/v4l2-ioctl.c linux-3.0.36-lenovo/drivers/media/video/v4l2-ioctl.c
824c824
< 
---
> 		
827c827
< 
---
> 		




diff -r linux-3.0.36/drivers/media/video/videobuf-core.c linux-3.0.36-lenovo/drivers/media/video/videobuf-core.c
110c110
< 		wait_event(vb->done, is_state_active_or_queued(q, vb));
---
> 		wait_event(vb->done, is_state_active_or_queued(q, vb));    
113,114c113,114
< 		mutex_lock(q->ext_lock);
< 
---
> 		mutex_lock(q->ext_lock);    
>     
336a337
> 		b->length    = vb->bsize;
643a645
>     bool is_ext_locked;
660,662c662,672
< 			/* Drop lock to avoid deadlock with qbuf */
< 			videobuf_queue_unlock(q);
< 
---
> 			/* Drop lock to avoid deadlock with qbuf */            
>             videobuf_queue_unlock(q);
>             /*ddl@rock-chips.com */
>             is_ext_locked = q->ext_lock && mutex_is_locked(q->ext_lock);
> 
>         	/* Release vdev lock to prevent this wait from blocking outside access to
>         	   the device. */
>         	if (is_ext_locked)
>         		mutex_unlock(q->ext_lock);
>             
>             
668d677
< 			videobuf_queue_lock(q);
669a679,683
>             videobuf_queue_lock(q);
>             /*ddl@rock-chips.com */
>             if (is_ext_locked)
>         		mutex_lock(q->ext_lock);
>             
712c726
< 	memset(b, 0, sizeof(*b));
---
> 	memset(b, 0, sizeof(*b));    




diff -r linux-3.0.36/drivers/media/video/videobuf-dma-contig.c linux-3.0.36-lenovo/drivers/media/video/videobuf-dma-contig.c
250a251
> 		break; /* ddl@rock-chips.com : nzy modify V4L2_MEMORY_OVERLAY   */




diff -r linux-3.0.36/drivers/mfd/ab3100-core.c linux-3.0.36-lenovo/drivers/mfd/ab3100-core.c
411,412d410
< 	add_interrupt_randomness(irq);
< 
941,943d938
< 	/* This real unpredictable IRQ is of course sampled for entropy */
< 	rand_initialize_irq(client->irq);
< 




diff -r linux-3.0.36/drivers/mfd/ab3550-core.c linux-3.0.36-lenovo/drivers/mfd/ab3550-core.c
1312,1313d1311
< 	/* This real unpredictable IRQ is of course sampled for entropy */
< 	rand_initialize_irq(client->irq);




diff -r linux-3.0.36/drivers/mfd/ezx-pcap.c linux-3.0.36-lenovo/drivers/mfd/ezx-pcap.c
205c205
< 	} while (gpio_get_value(irq_to_gpio(pcap->spi->irq)));
---
> 	} while (gpio_get_value(pdata->gpio));




diff -r linux-3.0.36/drivers/mfd/Kconfig linux-3.0.36-lenovo/drivers/mfd/Kconfig
173a174,204
> config MFD_TPS65910
> 	bool "TPS65910 Power Management chip"
> 	depends on I2C=y && GPIOLIB
> 	select MFD_CORE
> 	select GPIO_TPS65910
> 	select REGMAP_I2C
> 	help
> 	  if you say yes here you get support for the TPS65910 series of
> 	  Power Management chips.
> 
> config MFD_TPS65912
> 	bool
> 	depends on GPIOLIB
> 
> config MFD_TPS65912_I2C
> 	bool "TPS65912 Power Management chip with I2C"
> 	select MFD_CORE
> 	select MFD_TPS65912
> 	depends on I2C=y && GPIOLIB
> 	help
> 	  If you say yes here you get support for the TPS65912 series of
> 	  PM chips with I2C interface.
> 
> config MFD_TPS65912_SPI
> 	bool "TPS65912 Power Management chip with SPI"
> 	select MFD_CORE
> 	select MFD_TPS65912
> 	depends on SPI_MASTER && GPIOLIB
> 	help
> 	  If you say yes here you get support for the TPS65912 series of
> 	  PM chips with SPI interface.
197a229,240
> config TWL6030_POWER
> 	bool "Support power resources on TWL6030 family chips"
> 	depends on TWL4030_CORE
> 	help
> 	  Say yes here if you want to use the power resources on the
> 	  TWL6030 family chips.  Most of these resources are regulators,
> 	  which have a separate driver; some are control signals, such
> 	  as clock request handshaking.
> 
> 	  This driver defaults to assuming only APPs processor uses
> 	  the resource, it can however be overridden by board file
> 
235a279,314
> config TWL6030_POWEROFF
> 	bool "TWL6030 device poweroff"
> 	depends on TWL4030_CORE
> 
> config TWL6030_MADC
> 	tristate "Texas Instruments TWL6030 MADC"
> 	depends on TWL4030_CORE
> 	help
> 	This driver provides support for TWL6030-MADC. The
> 	driver supports both RT and SW conversion methods.
> 
> 	This driver can be built as a module. If so it will be
> 	named twl6030-madc
> 
> config TWL6030_GPADC
> 	tristate "TWL6030 GPADC (General Purpose A/D Convertor) Support"
> 	depends on TWL4030_CORE
> 	default n
> 	help
> 	  Say yes here if you want support for the TWL6030 General Purpose
> 	  A/D Convertor.
> 
> config MFD_RK808
> 	bool "RK808 Power Management chip"
> 	depends on I2C=y 
> 	select MFD_CORE
> 	select RTC_RK808
> 	help
> 	  if you say yes here you get support for the RK808 series of
> 	  Power Management chips.
> 
> config AIC3262_CODEC
> 	bool "Support TI Codec Aic3262"
> 	select MFD_CORE
> 	default n
> 
387a467,477
> config MFD_WM831X_SPI_A22
> 	bool "Support Wolfson Microelectronics WM831x/2x PMICs with SPI for A22"
> 	#select MFD_CORE
> 	#select MFD_WM831X
> 	depends on SPI_MASTER && GENERIC_HARDIRQS
> 	help
> 	  Support for the Wolfson Microelecronics WM831x and WM832x PMICs
> 	  when controlled using SPI.  This driver provides common support
> 	  for accessing the device, additional drivers must be enabled in
> 	  order to use the functionality of the device.
> 
722,724c812,817
< config MFD_TPS65910
< 	bool "TPS65910 Power Management chip"
< 	depends on I2C=y && GPIOLIB
---
> config TPS65911_COMPARATOR
> 	tristate
> 
> config MFD_TPS65090
> 	bool "TPS65090 Power Management chips"
> 	depends on I2C=y && GENERIC_HARDIRQS
726c819
< 	select GPIO_TPS65910
---
> 	select REGMAP_I2C
728c821
< 	  if you say yes here you get support for the TPS65910 series of
---
> 	  If you say yes here you get support for the TPS65090 series of
729a823,825
> 	  This driver provides common support for accessing the device,
> 	  additional drivers must be enabled in order to use the
> 	  functionality of the device.
731,732c827,841
< config TPS65911_COMPARATOR
< 	tristate
---
> config MFD_RK610
> 	bool "RK610(Jetta) Multimedia support"
> 	depends on I2C=y && GPIOLIB
> 	select MFD_CORE
> 	help
> 	  if you say yes here you get support for the RK610, with func as
> 	  HDMI LCD LVDS TVOUT CODEC.
> 
> config MFD_RK616
>         bool "RK616(Jetta B) Multifunction device support"
>         depends on I2C=y 
>         select MFD_CORE
>         help
>           if you say yes here you get support for the RK616, with func as
>           HDMILCDLVDSCODECMIPI.




diff -r linux-3.0.36/drivers/mfd/Makefile linux-3.0.36-lenovo/drivers/mfd/Makefile
28a29
> obj-$(CONFIG_MFD_WM831X_SPI_A22)	+= wm831x-spi-a22.o
37a39,43
> obj-$(CONFIG_MFD_TPS65910)	+= tps65910.o tps65910-irq.o
> tps65912-objs                   := tps65912-core.o tps65912-irq.o
> obj-$(CONFIG_MFD_TPS65912)	+= tps65912.o
> obj-$(CONFIG_MFD_TPS65912_I2C)	+= tps65912-i2c.o
> obj-$(CONFIG_MFD_TPS65912_SPI)  += tps65912-spi.o
41a48
> obj-$(CONFIG_TWL6030_MADC)      += twl6030-madc.o
44a52,56
> obj-$(CONFIG_TWL6030_GPADC)    += twl6030-gpadc.o
> obj-$(CONFIG_TWL6030_POWEROFF)	+= twl6030-poweroff.o
> obj-$(CONFIG_TWL6030_POWER)    += twl6030-power.o
> 
> obj-$(CONFIG_AIC3262_CODEC)	+= tlv320aic3262-core.o tlv320aic3262-irq.o
97a110,112
> obj-$(CONFIG_MFD_RK610)	+= rk610-core.o
> obj-$(CONFIG_MFD_RK808)	+= rk808.o rk808-irq.o
> obj-$(CONFIG_MFD_RK616) += rk616-core.o rk616-vif.o




diff -r linux-3.0.36/drivers/mfd/mfd-core.c linux-3.0.36-lenovo/drivers/mfd/mfd-core.c
20a21,24
> static struct device_type mfd_dev_type = {
> 	.name	= "mfd_device",
> };
> 
89a94
> 	pdev->dev.type = &mfd_dev_type;
185,186c190,191
< 	struct platform_device *pdev = to_platform_device(dev);
< 	const struct mfd_cell *cell = mfd_get_cell(pdev);
---
> 	struct platform_device *pdev;
> 	const struct mfd_cell *cell;
187a193,198
> 
> 	if (dev->type != &mfd_dev_type)
> 		return 0;
> 
> 	pdev = to_platform_device(dev);
> 	cell = mfd_get_cell(pdev);
Only in linux-3.0.36-lenovo/drivers/mfd: rk610-core.c
Only in linux-3.0.36-lenovo/drivers/mfd: rk616-core.c
Only in linux-3.0.36-lenovo/drivers/mfd: rk616-vif.c
Only in linux-3.0.36-lenovo/drivers/mfd: rk808.c
Only in linux-3.0.36-lenovo/drivers/mfd: rk808-irq.c
Only in linux-3.0.36-lenovo/drivers/mfd: tlv320aic3262-core.c
Only in linux-3.0.36-lenovo/drivers/mfd: tlv320aic3262-irq.c




diff -r linux-3.0.36/drivers/mfd/tps65910.c linux-3.0.36-lenovo/drivers/mfd/tps65910.c
24a25,26
> struct tps65910 *g_tps65910;
> 
36a39
> #define TPS65910_SPEED 	200 * 1000
43a47
> 	//int i;
49a54
> 	xfer[0].scl_rate = TPS65910_SPEED;
55a61
> 	xfer[1].scl_rate = TPS65910_SPEED;
57a64,65
> 	//for(i=0;i<bytes;i++)
> 	//printk("%s:reg=0x%x,value=0x%x\n",__func__,reg+i,*(u8 *)dest++);
62c70
< 
---
> 	
73c81,82
< 
---
> 	//int i;
> 	
76c85
< 
---
> 	
80c89,92
< 	ret = i2c_master_send(i2c, msg, bytes + 1);
---
> 	//for(i=0;i<bytes;i++)
> 	//printk("%s:reg=0x%x,value=0x%x\n",__func__,reg+i,msg[i+1]);
> 	
> 	ret = i2c_master_normal_send(i2c, msg, bytes + 1,TPS65910_SPEED);
84a97
> 
87a101,188
> static inline int tps65910_read(struct tps65910 *tps65910, u8 reg)
> {
> 	u8 val;
> 	int err;
> 
> 	err = tps65910->read(tps65910, reg, 1, &val);
> 	if (err < 0)
> 		return err;
> 
> 	return val;
> }
> 
> static inline int tps65910_write(struct tps65910 *tps65910, u8 reg, u8 val)
> {
> 	return tps65910->write(tps65910, reg, 1, &val);
> }
> 
> int tps65910_reg_read(struct tps65910 *tps65910, u8 reg)
> {
> 	int data;
> 
> 	mutex_lock(&tps65910->io_mutex);
> 
> 	data = tps65910_read(tps65910, reg);
> 	if (data < 0)
> 		dev_err(tps65910->dev, "Read from reg 0x%x failed\n", reg);
> 
> 	mutex_unlock(&tps65910->io_mutex);
> 	return data;
> }
> EXPORT_SYMBOL_GPL(tps65910_reg_read);
> 
> int tps65910_reg_write(struct tps65910 *tps65910, u8 reg, u8 val)
> {
> 	int err;
> 
> 	mutex_lock(&tps65910->io_mutex);
> 
> 	err = tps65910_write(tps65910, reg, val);
> 	if (err < 0)
> 		dev_err(tps65910->dev, "Write for reg 0x%x failed\n", reg);
> 
> 	mutex_unlock(&tps65910->io_mutex);
> 	return err;
> }
> EXPORT_SYMBOL_GPL(tps65910_reg_write);
> 
> /**
>  * tps65910_bulk_read: Read multiple tps65910 registers
>  *
>  * @tps65910: Device to read from
>  * @reg: First register
>  * @count: Number of registers
>  * @buf: Buffer to fill.
>  */
> int tps65910_bulk_read(struct tps65910 *tps65910, u8 reg,
> 		     int count, u8 *buf)
> {
> 	int ret;
> 
> 	mutex_lock(&tps65910->io_mutex);
> 	
> 	ret = tps65910->read(tps65910, reg, count, buf);
> 
> 	mutex_unlock(&tps65910->io_mutex);
> 
> 	return ret;
> }
> EXPORT_SYMBOL_GPL(tps65910_bulk_read);
> 
> int tps65910_bulk_write(struct tps65910 *tps65910, u8 reg,
> 		     int count, u8 *buf)
> {
> 	int ret;
> 
> 	mutex_lock(&tps65910->io_mutex);
> 	
> 	ret = tps65910->write(tps65910, reg, count, buf);
> 
> 	mutex_unlock(&tps65910->io_mutex);
> 
> 	return ret;
> }
> EXPORT_SYMBOL_GPL(tps65910_bulk_write);
> 
> 
> 
> 
96c197
< 		dev_err(tps65910->dev, "read from reg %x failed\n", reg);
---
> 		dev_err(tps65910->dev, "%s:read from reg %x failed\n", __func__,reg);
103c204
< 		dev_err(tps65910->dev, "write to reg %x failed\n", reg);
---
> 		dev_err(tps65910->dev, "%s:write to reg %x failed\n", __func__,reg);
123c224
< 	data &= mask;
---
> 	data &= ~mask;
141c242
< 
---
> 	
151c252
< 	init_data->irq_base = pmic_plat_data->irq;
---
> 	init_data->irq_base = pmic_plat_data->irq_base;
170a272,287
> 	ret = tps65910_reg_read(tps65910,0x22);
> 	if ((ret < 0) || (ret == 0xff)){
> 		printk("The device is not tps65910\n");
> 		goto err;
> 	}
> 	
> 	g_tps65910 = tps65910;
> 	
> 	if (pmic_plat_data && pmic_plat_data->pre_init) {
> 		ret = pmic_plat_data->pre_init(tps65910);
> 		if (ret != 0) {
> 			dev_err(tps65910->dev, "pre_init() failed: %d\n", ret);
> 			goto err;
> 		}
> 	}
> 
176a294,302
> 	if (pmic_plat_data && pmic_plat_data->post_init) {
> 		ret = pmic_plat_data->post_init(tps65910);
> 		if (ret != 0) {
> 			dev_err(tps65910->dev, "post_init() failed: %d\n", ret);
> 			goto err;
> 		}
> 	}
> 
> 	printk("%s:irq=%d,irq_base=%d,gpio_base=%d\n",__func__,init_data->irq,init_data->irq_base,pmic_plat_data->gpio_base);
184a311,340
> 
> int tps65910_device_shutdown(void)
> {
> 	int val = 0;
> 	int err = -1;
> 	struct tps65910 *tps65910 = g_tps65910;
> 	
> 	printk("%s\n",__func__);
> 
> 	val = tps65910_reg_read(tps65910, TPS65910_DEVCTRL);
>         if (val<0) {
>                 printk(KERN_ERR "Unable to read TPS65910_REG_DCDCCTRL reg\n");
>                 return -EIO;
>         }
> 	
> 	val |= DEVCTRL_DEV_OFF_MASK;
> 	val &= ~DEVCTRL_CK32K_CTRL_MASK;	//keep rtc
> 	err = tps65910_reg_write(tps65910, TPS65910_DEVCTRL, val);
> 	if (err) {
> 		printk(KERN_ERR "Unable to read TPS65910 Reg at offset 0x%x= \
> 				\n", TPS65910_REG_VDIG1);
> 		return err;
> 	}
> 	
> 	return 0;	
> }
> EXPORT_SYMBOL_GPL(tps65910_device_shutdown);
> 
> 
> 
218c374
< subsys_initcall(tps65910_i2c_init);
---
> subsys_initcall_sync(tps65910_i2c_init);




diff -r linux-3.0.36/drivers/mfd/tps65910-irq.c linux-3.0.36-lenovo/drivers/mfd/tps65910-irq.c
24a25,26
> #include <linux/wakelock.h>
> #include <linux/kthread.h>
48c50,51
< 
---
> 	
> 	wake_lock(&tps65910->irq_wake);	
71a75,76
> 	{
> 		wake_unlock(&tps65910->irq_wake);
72a78
> 	}
93c99
< 
---
> 	wake_unlock(&tps65910->irq_wake);
147a154,163
> #ifdef CONFIG_PM_SLEEP
> static int tps65910_irq_set_wake(struct irq_data *data, unsigned int enable)
> {
> 	struct tps65910 *tps65910 = irq_data_get_irq_chip_data(data);
> 	return irq_set_irq_wake(tps65910->chip_irq, enable);
> }
> #else
> #define tps65910_irq_set_wake NULL
> #endif
> 
153a170
> 	.irq_set_wake = tps65910_irq_set_wake,
160a178
> 	u8 reg;
164c182
< 		return -EINVAL;
---
> 		return 0;
169c187
< 		return -EINVAL;
---
> 		return 0;
171a190,200
> 	/* Clear unattended interrupts */
> 	tps65910->read(tps65910, TPS65910_INT_STS, 1, &reg);
> 	tps65910->write(tps65910, TPS65910_INT_STS, 1, &reg);
> 	tps65910->read(tps65910, TPS65910_INT_STS2, 1, &reg);
> 	tps65910->write(tps65910, TPS65910_INT_STS2, 1, &reg);
> 	tps65910->read(tps65910, TPS65910_INT_STS3, 1, &reg);
> 	tps65910->write(tps65910, TPS65910_INT_STS3, 1, &reg);
> 	tps65910->read(tps65910, TPS65910_RTC_STATUS, 1, &reg);	
> 	tps65910->write(tps65910, TPS65910_RTC_STATUS, 1, &reg);//clear alarm and timer interrupt
> 
> 	/* Mask top level interrupts */
174c203,204
< 	mutex_init(&tps65910->irq_lock);
---
> 	mutex_init(&tps65910->irq_lock);	
> 	wake_lock_init(&tps65910->irq_wake, WAKE_LOCK_SUSPEND, "tps65910_irq_wake");
177c207
< 
---
> 	
218c248,249
< 	free_irq(tps65910->chip_irq, tps65910);
---
> 	if (tps65910->chip_irq)
> 		free_irq(tps65910->chip_irq, tps65910);
Only in linux-3.0.36-lenovo/drivers/mfd: twl6030-gpadc.c




diff -r linux-3.0.36/drivers/mfd/twl6030-irq.c linux-3.0.36-lenovo/drivers/mfd/twl6030-irq.c
39a40,41
> #include <linux/suspend.h>
> #include <linux/reboot.h>
42a45
> #include <mach/board.h>
55c58
< static int twl6030_interrupt_mapping[24] = {
---
> static int twl6030_interrupt_mapping_table[24] = {
58c61
< 	PWR_INTR_OFFSET,	/* Bit 2	BAT_VLOW		*/
---
> 	TWL_VLOW_INTR_OFFSET,	/* Bit 2	BAT_VLOW		*/
71c74
< 	MADC_INTR_OFFSET,	/* Bit 14	GPADC_SW_EOC		*/
---
> 	GPADCSW_INTR_OFFSET,	/* Bit 14	GPADC_SW_EOC		*/
82a86,116
> 
> static int twl6032_interrupt_mapping_table[24] = {
> 	PWR_INTR_OFFSET,	/* Bit 0	PWRON			*/
> 	PWR_INTR_OFFSET,	/* Bit 1	RPWRON			*/
> 	TWL_VLOW_INTR_OFFSET,	/* Bit 2	SYS_VLOW		*/
> 	RTC_INTR_OFFSET,	/* Bit 3	RTC_ALARM		*/
> 	RTC_INTR_OFFSET,	/* Bit 4	RTC_PERIOD		*/
> 	HOTDIE_INTR_OFFSET,	/* Bit 5	HOT_DIE			*/
> 	SMPSLDO_INTR_OFFSET,	/* Bit 6	VXXX_SHORT		*/
> 	PWR_INTR_OFFSET,	/* Bit 7	SPDURATION		*/
> 
> 	PWR_INTR_OFFSET,	/* Bit 8	WATCHDOG		*/
> 	BATDETECT_INTR_OFFSET,	/* Bit 9	BAT			*/
> 	SIMDETECT_INTR_OFFSET,	/* Bit 10	SIM			*/
> 	MMCDETECT_INTR_OFFSET,	/* Bit 11	MMC			*/
> 	MADC_INTR_OFFSET,	/* Bit 12	GPADC_RT_EOC		*/
> 	GPADCSW_INTR_OFFSET,	/* Bit 13	GPADC_SW_EOC		*/
> 	GASGAUGE_INTR_OFFSET,	/* Bit 14	CC_EOC		*/
> 	GASGAUGE_INTR_OFFSET,	/* Bit 15	CC_AUTOCAL		*/
> 
> 	USBOTG_INTR_OFFSET,	/* Bit 16	ID_WKUP			*/
> 	USBOTG_INTR_OFFSET,	/* Bit 17	VBUS_WKUP		*/
> 	USBOTG_INTR_OFFSET,	/* Bit 18	ID			*/
> 	USB_PRES_INTR_OFFSET,	/* Bit 19	VBUS			*/
> 	CHARGER_INTR_OFFSET,	/* Bit 20	CHRG_CTRL		*/
> 	CHARGERFAULT_INTR_OFFSET,	/* Bit 21	EXT_CHRG	*/
> 	CHARGERFAULT_INTR_OFFSET,	/* Bit 22	INT_CHRG	*/
> 	RSV_INTR_OFFSET,	/* Bit 23	Reserved		*/
> };
> 
> static int *twl6030_interrupt_mapping = twl6030_interrupt_mapping_table;
85c119,121
< static unsigned twl6030_irq_base;
---
> static unsigned twl6030_irq_base, twl6030_irq_end;
> static int twl_irq;
> static bool twl_irq_wake_enabled;
86a123
> static struct task_struct *task;
87a125,164
> static atomic_t twl6030_wakeirqs = ATOMIC_INIT(0);
> 
> static u8 vbatmin_hi_threshold;
> 
> static int twl6030_irq_pm_notifier(struct notifier_block *notifier,
> 				   unsigned long pm_event, void *unused)
> {
> 	int chained_wakeups;
> 
> 	switch (pm_event) {
> 	case PM_SUSPEND_PREPARE:
> 		chained_wakeups = atomic_read(&twl6030_wakeirqs);
> 
> 		if (chained_wakeups && !twl_irq_wake_enabled) {
> 			if (enable_irq_wake(twl_irq))
> 				pr_err("twl6030 IRQ wake enable failed\n");
> 			else
> 				twl_irq_wake_enabled = true;
> 		} else if (!chained_wakeups && twl_irq_wake_enabled) {
> 			disable_irq_wake(twl_irq);
> 			twl_irq_wake_enabled = false;
> 		}
> 
> 		disable_irq(twl_irq);
> 		break;
> 
> 	case PM_POST_SUSPEND:
> 		enable_irq(twl_irq);
> 		break;
> 
> 	default:
> 		break;
> 	}
> 
> 	return NOTIFY_DONE;
> }
> 
> static struct notifier_block twl6030_irq_pm_notifier_block = {
> 	.notifier_call = twl6030_irq_pm_notifier,
> };
106a184
> 		u32 int_sts; /* sts.int_sts converted to CPU endianness */
138c216,217
< 		for (i = 0; sts.int_sts; sts.int_sts >>= 1, i++) {
---
> 		int_sts = le32_to_cpu(sts.int_sts);
> 		for (i = 0; int_sts; int_sts >>= 1, i++) {
140c219
< 			if (sts.int_sts & 0x1) {
---
> 			if (int_sts & 0x1) {
183a263,285
> /*
>  * handle_twl6030_vlow() is a threaded BAT_VLOW interrupt handler. BAT_VLOW
>  * is a secondary interrupt generated in twl6030_irq_thread().
>  */
> static irqreturn_t handle_twl6030_vlow(int irq, void *unused)
> {
> #ifdef CONFIG_TWL60xx_VBAT_LOW_DETECTION
> 	rk28_send_wakeup_key();
> #else
> 	pr_err("twl6030: BAT_VLOW interrupt; threshold=%dmV\n",
> 	       2300 + (vbatmin_hi_threshold - 0b110) * 50);
> #if 1 /* temporary */
> 	pr_err("%s: disabling BAT_VLOW interrupt\n", __func__);
> 	disable_irq_nosync(twl6030_irq_base + TWL_VLOW_INTR_OFFSET);
> //	WARN_ON(1);
> #else
> 	pr_emerg("handle_twl6030_vlow: kernel_power_off()\n");
> 	kernel_power_off();
> #endif
> #endif
> 	return IRQ_HANDLED;
> }
> 
198a301,310
> int twl6030_irq_set_wake(struct irq_data *d, unsigned int on)
> {
> 	if (on)
> 		atomic_inc(&twl6030_wakeirqs);
> 	else
> 		atomic_dec(&twl6030_wakeirqs);
> 
> 	return 0;
> }
> 
272a385,394
> 
> 	ret = twl_i2c_write_u8(TWL6030_MODULE_ID0,
> 			(MMC_MINS_DEB_MASK | MMC_MEXT_DEB_MASK),
> 			TWL6030_MMCDEBOUNCING);
> 	if (ret < 0){
> 		pr_err("twl6030: Failed to write MMC_MEXT_DEB_MASK %d\n",
> 									ret);
> 		return ret;
> 	}
> 
302c424,492
< int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end)
---
> int twl6030_vlow_init(int vlow_irq)
> {
> 	int status;
> 	u8 val;
> 
> 	status = twl_i2c_read_u8(TWL_MODULE_PM_SLAVE_RES, &val,
> 			REG_VBATMIN_HI_CFG_STATE);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err reading REG_VBATMIN_HI_CFG_STATE: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	status = twl_i2c_write_u8(TWL_MODULE_PM_SLAVE_RES,
> 			val | VBATMIN_VLOW_EN, REG_VBATMIN_HI_CFG_STATE);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err writing REG_VBATMIN_HI_CFG_STATE: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	status = twl_i2c_read_u8(TWL_MODULE_PIH, &val, REG_INT_MSK_LINE_A);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err reading REG_INT_MSK_LINE_A: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	status = twl_i2c_write_u8(TWL_MODULE_PIH, val & ~VLOW_INT_MASK,
> 			REG_INT_MSK_LINE_A);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err writing REG_INT_MSK_LINE_A: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	status = twl_i2c_read_u8(TWL_MODULE_PIH, &val, REG_INT_MSK_STS_A);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err reading REG_INT_MSK_STS_A: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	status = twl_i2c_write_u8(TWL_MODULE_PIH, val & ~VLOW_INT_MASK,
> 		REG_INT_MSK_STS_A);
> 	if (status < 0) {
> 		pr_err("twl6030: I2C err writing REG_INT_MSK_STS_A: %d\n",
> 				status);
> 		return status;
> 	}
> 
> 	twl_i2c_read_u8(TWL_MODULE_PM_MASTER, &vbatmin_hi_threshold,
> 			TWL6030_VBATMIN_HI_THRESHOLD);
> 
> 	/* install an irq handler for vlow */
> 	status = request_threaded_irq(vlow_irq, NULL, handle_twl6030_vlow,
> 			IRQF_ONESHOT,
> 			"TWL6030-VLOW", handle_twl6030_vlow);
> 	if (status < 0) {
> 		pr_err("twl6030: could not claim vlow irq %d: %d\n", vlow_irq,
> 				status);
> 		return status;
> 	}
> 
> 	return 0;
> }
> 
> int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
> 			unsigned long features)
307d496
< 	struct task_struct	*task;
309a499
> 	u8 reg;
311a502,505
> 
> 	if (features & TWL6032_SUBCLASS)
> 		twl6030_interrupt_mapping = twl6032_interrupt_mapping_table;
> 
322a517
> 	twl6030_irq_end = irq_end;
329a525
> 	twl6030_irq_chip.irq_set_wake = twl6030_irq_set_wake;
333a530
> 		irq_set_chip_data(i, (void *)irq_num);
355a553,563
> 
> 	twl_irq = irq_num;
> 	register_pm_notifier(&twl6030_irq_pm_notifier_block);
> 
> 	status = twl6030_vlow_init(twl6030_irq_base + TWL_VLOW_INTR_OFFSET);
> 	if (status < 0)
> 		goto fail_vlow;
> 	
> 	twl_i2c_write_u8(TWL_MODULE_PIH, &reg,REG_INT_MSK_STS_A);
> 	twl_i2c_write_u8(TWL_MODULE_PIH, reg | (1 << 2),REG_INT_MSK_STS_A);   //close vlow interrupt
> 
357c565,566
< fail_irq:
---
> 
> fail_vlow:
359a569,571
> fail_irq:
> 	kthread_stop(task);
> 
367a580,581
> 	int i;
> 	unregister_pm_notifier(&twl6030_irq_pm_notifier_block);
369c583,586
< 	if (twl6030_irq_base) {
---
> 	if (task)
> 		kthread_stop(task);
> 
> 	if (!twl6030_irq_base || !twl6030_irq_end) {
372a590,598
> 
> 	free_irq(twl6030_irq_base + TWL_VLOW_INTR_OFFSET,
> 		handle_twl6030_vlow);
> 
> 	free_irq(twl_irq, &irq_event);
> 
> 	for (i = twl6030_irq_base; i < twl6030_irq_end; i++)
> 		irq_set_chip_and_handler(i, NULL, NULL);
> 
Only in linux-3.0.36-lenovo/drivers/mfd: twl6030-madc.c
Only in linux-3.0.36-lenovo/drivers/mfd: twl6030-power.c
Only in linux-3.0.36-lenovo/drivers/mfd: twl6030-poweroff.c




diff -r linux-3.0.36/drivers/mfd/twl-core.c linux-3.0.36-lenovo/drivers/mfd/twl-core.c
35a36
> #include <linux/interrupt.h>
40a42,47
> #include "twl-core.h"
> 
> #include <linux/earlysuspend.h>
> #ifdef CONFIG_HAS_EARLYSUSPEND
> static struct early_suspend twl60xx_early_suspend;
> #endif
86c93,99
< #ifdef CONFIG_TWL4030_POWER
---
> #if defined(CONFIG_TWL6030_GPADC) || defined(CONFIG_TWL6030_GPADC_MODULE)
> #define twl_has_gpadc()	true
> #else
> #define twl_has_gpadc()	false
> #endif
> 
> #if defined(CONFIG_TWL4030_POWER) || defined(CONFIG_TWL6030_POWER)
119c132,135
< #if defined(CONFIG_CHARGER_TWL4030) || defined(CONFIG_CHARGER_TWL4030_MODULE)
---
> #if defined(CONFIG_CHARGER_TWL4030) || \
> 	defined(CONFIG_CHARGER_TWL4030_MODULE) || \
> 	defined(CONFIG_TWL6030_BCI_BATTERY) || \
> 	defined(CONFIG_TWL6030_BCI_BATTERY_MODULE)
129c145,146
< 
---
> //#define TWL6030_MODULE_LAST		TWL6030_MODULE_SLAVE_RES  //xsf
> #define TWL6030_MODULE_LAST		TWL_MODULE_PM_DVS //add
138a156,162
> #if defined(CONFIG_INPUT_TWL6030_PWRBUTTON) \
> 	|| defined(CONFIG_INPUT_TWL6030_PWRBUTTON_MODULE)
> #define twl6030_has_pwrbutton()        true
> #else
> #define twl6030_has_pwrbutton()        false
> #endif
> 
143,144c167,168
< 
< #define TWL_MODULE_LAST TWL4030_MODULE_LAST
---
> #define SUB_DVS_ID     3            //add
> #define TWL_MODULE_LAST TWL6030_MODULE_LAST
189a214
> #define TWL6030_BASEADD_PM_SLAVE_RES	0x00AD
201c226
< #define TWL6025_BASEADD_CHARGER		0x00DA
---
> #define TWL6032_BASEADD_CHARGER		0x00DA
227a253,259
> /* need to access USB_PRODUCT_ID_LSB to identify which 6030 varient we are */
> #define USB_PRODUCT_ID_LSB	0x02
> 
> /* need to check eeprom revision and jtagver number */
> #define TWL6030_REG_EPROM_REV	0xdf
> #define TWL6030_REG_JTAGVERNUM	0x87
> 
335c367,371
< 	{ SUB_CHIP_ID1, TWL6025_BASEADD_CHARGER },
---
> 	{ SUB_CHIP_ID1, TWL6032_BASEADD_CHARGER },
> 	{ SUB_CHIP_ID0, TWL6030_BASEADD_PM_SLAVE_RES },
> 	{ SUB_DVS_ID, TWL6030_BASEADD_PM_SLAVE_MISC }, //add
> 	
> 
377a414,421
> 	#if 1    
> 	//add
> 	if(mod_no== TWL_MODULE_PM_DVS)
> 		{
> 		msg->addr = 0x12;
> 	}
> 	else
> 		{
378a423,428
> 
> 		}
> 	#else
> 	msg->addr = twl->address;
> 	#endif
> 
381a432
> 	msg->scl_rate = 100*1000;  //add
389,390c440,442
< 		pr_err("%s: i2c_write failed to transfer all messages\n",
< 			DRIVER_NAME);
---
> 		pr_err("%s: i2c_write failed to transfer all messages "
> 			"(addr 0x%04x, reg %d, len %d)\n",
> 			DRIVER_NAME, twl->address, reg, msg->len);
417d468
< 
431a483,489
> 	#if 1    
> 	if(mod_no== 0x1a)
> 		{
> 		msg->addr = 0x12;
> 	}
> 	else
> 		{
432a491,495
> 
> 		}
> 	#else
> 	msg->addr = twl->address;
> 	#endif
436a500
> 	msg->scl_rate = 100*1000;  //add
448,449c512,514
< 		pr_err("%s: i2c_read failed to transfer all messages\n",
< 			DRIVER_NAME);
---
> 		pr_err("%s: i2c_read failed to transfer all messages "
> 			"(addr 0x%04x, reg %d, len %d)\n",
> 			DRIVER_NAME, twl->address, reg, msg->len);
472a538,551
> 	
> 	#if 0               //add
> 	if(mod_no == 0x1a)
> 	{
> 		temp_buffer[1] = 0x43;
> 		 twl_i2c_write(mod_no, temp_buffer, 0x25, 1);
> 
> 	 	temp_buffer[1] = 0x07;
> 		twl_i2c_write(mod_no, temp_buffer, reg, 1);	
> 
> 	}
> 	
> 	#endif
> 
555d633
< 
635a714,716
> #define SET_LDO_STATE_MEM(ldo, state) \
> 	ldo->constraints.state_mem.disabled = state
> 
646a728,729
> 	u8 eepromrev = 0;
> 	u8 twlrev = 0;
662a746,754
> 	if (twl_has_bci() && pdata->bci) {
> 		pdata->bci->features = features;
> 		child = add_child(1, "twl6030_bci",
> 				pdata->bci, sizeof(*pdata->bci),
> 				false,
> 				pdata->irq_base + CHARGER_INTR_OFFSET,
> 				pdata->irq_base + CHARGERFAULT_INTR_OFFSET);
> 	}
> 
671a764,773
> 	if (twl_has_gpadc() && pdata->madc) {
> 		pdata->madc->features = features;
> 		child = add_child(1, "twl6030_gpadc",
> 				pdata->madc, sizeof(*pdata->madc),
> 				true, pdata->irq_base + MADC_INTR_OFFSET,
> 				pdata->irq_base + GPADCSW_INTR_OFFSET);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 	}
> 
753d854
< 
755,765c856
< 			/* this is a template that gets copied */
< 			struct regulator_init_data usb_fixed = {
< 				.constraints.valid_modes_mask =
< 					REGULATOR_MODE_NORMAL
< 					| REGULATOR_MODE_STANDBY,
< 				.constraints.valid_ops_mask =
< 					REGULATOR_CHANGE_MODE
< 					| REGULATOR_CHANGE_STATUS,
< 			};
< 
< 			if (features & TWL6025_SUBCLASS) {
---
> 			if (features & TWL6032_SUBCLASS) {
767c858,862
< 				regulator = TWL6025_REG_LDOUSB;
---
> 				regulator = TWL6032_REG_LDOUSB;
> 				child = add_regulator_linked(regulator,
> 							     pdata->ldousb,
> 							     &usb3v3, 1,
> 							     features);
770a866,869
> 				child = add_regulator_linked(regulator,
> 							     pdata->vusb,
> 							     &usb3v3, 1,
> 							     features);
772,774c871
< 			child = add_regulator_linked(regulator, &usb_fixed,
< 							&usb3v3, 1,
< 							features);
---
> 
794,795c891,892
< 		if (features & TWL6025_SUBCLASS)
< 			child = add_regulator(TWL6025_REG_LDOUSB,
---
> 		if (features & TWL6032_SUBCLASS)
> 			child = add_regulator(TWL6032_REG_LDOUSB,
817a915,921
> 	if (twl6030_has_pwrbutton()) {
> 		child = add_child(1, "twl6030_pwrbutton",
> 				NULL, 0, true, pdata->irq_base, 0);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 	}
> 
830c934
< 		child = add_child(sub_chip_id, "twl6040-codec",
---
> 		child = add_child(sub_chip_id, "twl6040-audio",
925a1030,1055
> 	if (twl_has_regulator() && twl_class_is_6030()) {
> 		/*
> 		 * For TWL6032 revision < ES1.1 with EEPROM revision < rev56.0
> 		 * LDO6 and LDOLN must be always ON
> 		 * if LDO6 or LDOLN is always on then SYSEN must be always on
> 		 * for TWL6030 or TWL6032 revision >= ES1.1 with EEPROM
> 		 * revision >= rev56.0 those LDOs can be off in sleep-mode
> 		 */
> 		if (features & TWL6032_SUBCLASS) {
> 			twl_i2c_read_u8(TWL6030_MODULE_ID2, &eepromrev,
> 					TWL6030_REG_EPROM_REV);
> 
> 			twl_i2c_read_u8(TWL6030_MODULE_ID2, &twlrev,
> 					TWL6030_REG_JTAGVERNUM);
> 
> 			if ((eepromrev < 56) && (twlrev < 1)) {
> 				SET_LDO_STATE_MEM(pdata->ldo6, false);
> 				SET_LDO_STATE_MEM(pdata->ldoln, false);
> 				SET_LDO_STATE_MEM(pdata->sysen, false);
> 				WARN(1, "This TWL6032 is an older revision that "
> 						"does not support low power "
> 						"measurements\n");
> 			}
> 		}
> 	}
> 
928c1058,1059
< 			!(features & TWL6025_SUBCLASS)) {
---
> 			!(features & TWL6032_SUBCLASS)) {
> 			
969c1100,1115
< 		child = add_regulator(TWL6030_REG_CLK32KG, pdata->clk32kg,
---
> 		child = add_regulator(TWL6030_REG_VDD1, pdata->vdd1,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_VDD2, pdata->vdd2,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_VDD3, pdata->vdd3,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_VMEM, pdata->vmem,
972a1119,1123
> 
> 		child = add_regulator(TWL6030_REG_V2V1, pdata->v2v1,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);	
975c1126
< 	/* 6030 and 6025 share this regulator */
---
> 	/* 6030 and 6032 share this regulator */
980a1132,1151
> 		child = add_regulator(TWL6030_REG_CLK32KG, pdata->clk32kg,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_CLK32KAUDIO,
> 				pdata->clk32kaudio, features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_SYSEN,
> 				pdata->sysen, features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 
> 		child = add_regulator(TWL6030_REG_REGEN1,
> 				pdata->sysen, features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 			
983c1154
< 	/* twl6025 regulators */
---
> 	/* twl6032 regulators */
985,986c1156,1157
< 			(features & TWL6025_SUBCLASS)) {
< 		child = add_regulator(TWL6025_REG_LDO5, pdata->ldo5,
---
> 			(features & TWL6032_SUBCLASS)) {
> 		child = add_regulator(TWL6032_REG_LDO5, pdata->ldo5,
990,991c1161,1167
< 
< 		child = add_regulator(TWL6025_REG_LDO1, pdata->ldo1,
---
> 	
> 		child = add_regulator(TWL6032_REG_LDO1, pdata->ldo1,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 	
> 		child = add_regulator(TWL6032_REG_LDO7, pdata->ldo7,
996c1172
< 		child = add_regulator(TWL6025_REG_LDO7, pdata->ldo7,
---
> 		child = add_regulator(TWL6032_REG_LDO6, pdata->ldo6,
1001c1177
< 		child = add_regulator(TWL6025_REG_LDO6, pdata->ldo6,
---
> 		child = add_regulator(TWL6032_REG_LDOLN, pdata->ldoln,
1006c1182
< 		child = add_regulator(TWL6025_REG_LDOLN, pdata->ldoln,
---
> 		child = add_regulator(TWL6032_REG_LDO2, pdata->ldo2,
1011c1187
< 		child = add_regulator(TWL6025_REG_LDO2, pdata->ldo2,
---
> 		child = add_regulator(TWL6032_REG_LDO4, pdata->ldo4,
1016c1192
< 		child = add_regulator(TWL6025_REG_LDO4, pdata->ldo4,
---
> 		child = add_regulator(TWL6032_REG_LDO3, pdata->ldo3,
1021c1197
< 		child = add_regulator(TWL6025_REG_LDO3, pdata->ldo3,
---
> 		child = add_regulator(TWL6032_REG_SMPS3, pdata->smps3,
1026c1202
< 		child = add_regulator(TWL6025_REG_SMPS3, pdata->smps3,
---
> 		child = add_regulator(TWL6032_REG_SMPS4, pdata->smps4,
1031c1207
< 		child = add_regulator(TWL6025_REG_SMPS4, pdata->smps4,
---
> 		child = add_regulator(TWL6032_REG_SMPS1, pdata->smps1,
1036c1212,1217
< 		child = add_regulator(TWL6025_REG_VIO, pdata->vio6025,
---
> 		child = add_regulator(TWL6032_REG_SMPS2, pdata->smps2,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
> 		
> 		child = add_regulator(TWL6032_REG_SMPS5, pdata->smps5,
1040a1222,1226
> 
> 		child = add_regulator(TWL6032_REG_VIO, pdata->vio6032,
> 					features);
> 		if (IS_ERR(child))
> 			return PTR_ERR(child);
1044c1230
< 			!(features & (TPS_SUBSET | TWL5031))) {
---
> 			!(features & (TPS_SUBSET | TWL5031)) && (features & TWL6030_CLASS)) {
1149,1153c1335,1362
< int twl4030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
< int twl4030_exit_irq(void);
< int twl4030_init_chip_irq(const char *chip);
< int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
< int twl6030_exit_irq(void);
---
> #ifdef CONFIG_PM
> static int twl_suspend(struct i2c_client *client, pm_message_t mesg)
> {		
> 	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x1a,SMPS4_CFG_VOLTAGE);//dc4 vcc_io is 2.8v in sleep mode
> 	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x01,LDO4_CFG_VOLTAGE);//ld4 vdd_11 is 1v in sleep mode
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x20,SMPS1_CFG_VOLTAGE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe0,SMPS1_CFG_FORCE);//dc1 vdd_arm is 1v in sleep mode
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x20,SMPS2_CFG_VOLTAGE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe0,SMPS2_CFG_FORCE);//dc2 vdd_logic is 1v in sleep mode
> 	return irq_set_irq_wake(client->irq, 1);
> }
> 
> static int twl_resume(struct i2c_client *client)
> {
> 	//	return irq_set_irq_wake(client->irq, 0);
> 	irq_set_irq_wake(client->irq, 0);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x28,SMPS1_CFG_VOLTAGE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe8,SMPS1_CFG_FORCE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0x28,SMPS2_CFG_VOLTAGE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_DVS,0xe8,SMPS2_CFG_FORCE);
> 	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x02,LDO4_CFG_VOLTAGE);  
> 	twl_i2c_write_u8(TWL_MODULE_PM_RECEIVER,0x1f,SMPS4_CFG_VOLTAGE);
> 	return 0;
> }
> #else
> #define twl_suspend	NULL
> #define twl_resume	NULL
> #endif
1155c1364
< static int twl_remove(struct i2c_client *client)
---
> static int __devexit twl_remove(struct i2c_client *client)
1179a1389,1391
> __weak void  twl60xx_pmu_early_suspend(struct regulator_dev *rdev) {}
> __weak void  twl60xx_pmu_early_resume(struct regulator_dev *rdev) {}
> 
1187c1399
< 	int ret = 0;
---
> 	int ret = 0, features;
1190c1402
< 		dev_dbg(&client->dev, "no platform data?\n");
---
> 		dev_err(&client->dev, "no platform data?\n");
1195c1407
< 		dev_dbg(&client->dev, "can't talk I2C?\n");
---
> 		dev_err(&client->dev, "can't talk I2C?\n");
1200c1412
< 		dev_dbg(&client->dev, "driver is already in use\n");
---
> 		dev_err(&client->dev, "driver is already in use\n");
1206c1418,1419
< 
---
> 	                     
> #if 0
1207a1421,1427
> #else
> 		if( i <TWL_NUM_SLAVES-1 )
> 			twl->address = client->addr + i;
> 		else
> 			twl->address = 0x12; //DVS i2s address
> #endif
> 		
1239a1460,1466
> 	features = id->driver_data;
> 	if (twl_class_is_6030()) {
> 		twl_i2c_read_u8(TWL_MODULE_USB, &temp, USB_PRODUCT_ID_LSB);
> 		if (temp == 0x32)
> 			features |= TWL6032_SUBCLASS;
> 	}
> 
1241,1242c1468,1473
< 	if (twl_has_power() && pdata->power)
< 		twl4030_power_init(pdata->power);
---
> 	if (twl_has_power()) {
> 		if (twl_class_is_4030() && pdata->power)
> 			twl4030_power_init(pdata->power);
> 		if (twl_class_is_6030())
> 			twl6030_power_init(pdata->power, features);
> 	}
1254c1485
< 			pdata->irq_end);
---
> 			pdata->irq_end, features);
1271a1503,1524
> 	
> 	status = add_children(pdata, features);
> 
> 	if (pdata && pdata->pre_init) {
> 		ret = pdata->pre_init();
> 		if (ret != 0) {
> 			printk(" tps80032 pre_init() failed\n");
> 		}
> 	}
> 	
> 	if (pdata && pdata->set_init) {
> 		ret = pdata->set_init();
> 		if (ret != 0) {
> 			printk(" tps80032 set_init() failed\n");
> 		}
> 	}
> 	#ifdef CONFIG_HAS_EARLYSUSPEND
> 	twl60xx_early_suspend.level = 0xffff;
>     twl60xx_early_suspend.suspend = twl60xx_pmu_early_suspend;
>     twl60xx_early_suspend.resume = twl60xx_pmu_early_resume;
>     register_early_suspend(&twl60xx_early_suspend);
> 	#endif
1273c1526
< 	status = add_children(pdata, id->driver_data);
---
> 	
1276a1530
> 	dev_info(&client->dev, "%s finished, status = %d\n", __func__, status);
1288c1542
< 	{ "twl6025", TWL6030_CLASS | TWL6025_SUBCLASS }, /* "Phoenix lite" */
---
> 	{ "twl6032", TWL6030_CLASS | TWL6032_SUBCLASS }, /* Phoenix lite */
1298c1552,1554
< 	.remove		= twl_remove,
---
> 	.remove		= __devexit_p(twl_remove),
> 	.suspend	= twl_suspend,
> 	.resume		= twl_resume,
1305c1561
< subsys_initcall(twl_init);
---
> subsys_initcall_sync(twl_init);




diff -r linux-3.0.36/drivers/mfd/twl-core.h linux-3.0.36-lenovo/drivers/mfd/twl-core.h
4c4,5
< extern int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end);
---
> extern int twl6030_init_irq(int irq_num, unsigned irq_base, unsigned irq_end,
> 			unsigned long features);




diff -r linux-3.0.36/drivers/mfd/wm831x-core.c linux-3.0.36-lenovo/drivers/mfd/wm831x-core.c
20a21
> #include <linux/irq.h>
27a29,36
> #include <linux/mfd/wm831x/pmu.h>
> 
> #include <mach/board.h>
> #include <linux/earlysuspend.h>
> 
> #ifdef CONFIG_HAS_EARLYSUSPEND
> static struct early_suspend wm831x_early_suspend;
> #endif
31a41
>  extern int reboot_cmd_get(void);
386c396
< 						 msecs_to_jiffies(500))) {
---
> 						 msecs_to_jiffies(2000))) {
419a430,438
> #ifdef CONFIG_WM8326_VBAT_LOW_DETECTION
> static irqreturn_t wm831x_vbatlo_irq(int irq, void *irq_data)
> {
> 	rk28_send_wakeup_key();
> 
> 	return IRQ_HANDLED;
> }
> #endif
> 
999a1019,1032
> #if defined(CONFIG_KEYBOARD_WM831X_GPIO)
> 	{
> 		.name		= "wm831x_gpio-keys",
> 		.num_resources	= 0,
> 	},
> #endif
> #if defined(CONFIG_WM831X_CHARGER_DISPLAY)
> 	{
> 		.name		= "wm831x_charger_display",
> 		.num_resources	= 0,
> 	},
> #endif
> 
> 
1439a1473,1476
> 
> __weak void  wm831x_pmu_early_suspend(struct early_suspend *h) {}
> __weak void  wm831x_pmu_early_resume(struct early_suspend *h) {}
> 
1492c1529
< 		wm831x->num_gpio = 16;
---
> 		wm831x->num_gpio = 12;
1497a1535,1537
> 		//ILIM = 900ma
> 		ret = wm831x_reg_read(wm831x, WM831X_POWER_STATE) & 0xffff;
> 		wm831x_reg_write(wm831x, WM831X_POWER_STATE, (ret&0xfff8) | 0x04);	
1598a1639,1666
> 	switch (parent) {
> 	#ifdef CONFIG_WM8326_VBAT_LOW_DETECTION	
> 	#ifdef CONFIG_BATTERY_RK30_VOL3V8
> 	if (wm831x->irq_base) {
> 		ret = request_threaded_irq(wm831x->irq_base +
> 					   WM831X_IRQ_PPM_SYSLO,
> 					   NULL, wm831x_vbatlo_irq, IRQF_TRIGGER_RISING,
> 					   "syslo", wm831x);
> 			}
> 		if (ret < 0)
> 			dev_err(wm831x->dev, "syslo IRQ request failed: %d\n",
> 				ret);
> 	#else
> 	case WM8326:
> 		if (wm831x->irq_base) {
> 		ret = request_threaded_irq(wm831x->irq_base +
> 					   WM831X_IRQ_AUXADC_DCOMP1,
> 					   NULL, wm831x_vbatlo_irq, IRQF_TRIGGER_RISING,
> 					   "syslo", wm831x);
> 			}
> 		if (ret < 0)
> 			dev_err(wm831x->dev, "syslo IRQ request failed: %d\n",
> 				ret);
> 		break;
> 	#endif
> 	#endif
> 	
> 	default:	
1603a1672
> 		}
1606a1676
> 	
1660a1731,1733
> 		wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x9716); //wm831x_reg_unlock
> 		wm831x_set_bits(wm831x, WM831X_RESET_CONTROL,0x0010,0x0000);
> 		wm831x_set_bits(wm831x, WM831X_LDO_ENABLE,0Xf800,0Xf800);
1661a1735
> 		wm831x_reg_write(wm831x, WM831X_SECURITY_KEY, 0x0000);	 //wm831x_reg_lock
1666a1741,1746
> 	#ifdef CONFIG_HAS_EARLYSUSPEND
> 	wm831x_early_suspend.level = 0xffff;
>     wm831x_early_suspend.suspend = wm831x_pmu_early_suspend;
>     wm831x_early_suspend.resume = wm831x_pmu_early_resume;
>     register_early_suspend(&wm831x_early_suspend);
> 	#endif
1690a1771,1786
> 	int i;
> 	
> 	//mask some intterupt avoid wakeing up system while suspending
> 	for (i = 0; i < ARRAY_SIZE(wm831x->irq_masks_cur); i++) {
> 		/* If there's been a change in the mask write it back
> 		 * to the hardware. */
> 		//printk("irq_masks_cur[%d]=0x%x\n",i,wm831x->irq_masks_cur[i]);
> 
> 		if (wm831x->irq_masks_cur[i] != wm831x->irq_masks_cache[i]) {
> 			wm831x->irq_masks_cache[i] = wm831x->irq_masks_cur[i];
> 			wm831x_reg_write(wm831x,
> 					 WM831X_INTERRUPT_STATUS_1_MASK + i,
> 					 wm831x->irq_masks_cur[i]);
> 		}
> 	
> 	}
1722a1819,1907
> 
> void wm831x_enter_sleep(void){
> 	struct regulator *dcdc = regulator_get(NULL, "dcdc1");
> 	int i;		
> 	struct wm831x_dcdc *dc = regulator_get_drvdata(dcdc);
> 	struct wm831x *wm831x = dc->wm831x;
> 	if(wm831x){
> 		wm831x_set_bits(wm831x, WM831X_POWER_STATE, 0x4000, 0x4000); // SYSTEM SLEEP MODE
> 		for (i=0; i<5; i++)
> 			wm831x_reg_write(wm831x,WM831X_INTERRUPT_STATUS_1+i, 0xffff);  // INTRUPT FLAG CLEAR 
> 			
> 		printk("%s:complete! \n",__func__);
> 		
> 	}else{
> 		printk("%s:error!",__func__);
> 	}
> 	regulator_put(dcdc);
> }
> EXPORT_SYMBOL_GPL(wm831x_enter_sleep);
> 
> void wm831x_exit_sleep(void){
> 	struct regulator *dcdc = regulator_get(NULL, "dcdc1");
> 	struct wm831x_dcdc *dc = regulator_get_drvdata(dcdc);
> 	struct wm831x *wm831x = dc->wm831x;
> 	if(wm831x){
> 		wm831x_set_bits(wm831x, WM831X_POWER_STATE, 0x4000, 0);  // SYSTEM ON MODE
> 		printk("%s:complete! \n",__func__);
> 		
> 	}else{
> 		printk("%s:error!",__func__);
> 	}
> 	regulator_put(dcdc);
> }
> EXPORT_SYMBOL_GPL(wm831x_exit_sleep);
> 
> int wm831x_device_shutdown(struct wm831x *wm831x)
> {
> 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
> 	int ret = 0;
> 	
> 	printk("pre WM831X_POWER_STATE = 0x%x\n", wm831x_reg_read(wm831x, WM831X_POWER_STATE));
> 
> 	if(wm831x_set_bits(wm831x, WM831X_RTC_CONTROL, WM831X_RTC_ALAM_ENA_MASK, 0) < 0)
> 			printk("%s wm831x_set_bits err\n", __FUNCTION__);   //disable rtc alam
> #if 0
> 	if (pdata && pdata->last_deinit) {
> 		ret = pdata->last_deinit(wm831x);
> 		if (ret != 0) {
> 			dev_info(wm831x->dev, "last_deinit() failed: %d\n", ret);
> 		}
> 	}
> #endif
> 	//if(0 == reboot_cmd_get())
> 	
> 		if(wm831x_set_bits(wm831x, WM831X_POWER_STATE, WM831X_CHIP_ON_MASK, 0) < 0)
> 			printk("%s wm831x_set_bits err\n", __FUNCTION__);
> 		//printk("post WM831X_POWER_STATE = 0x%x\n", wm831x_reg_read(wm831x, WM831X_POWER_STATE));
> 
> 	return 0;	
> }
> 
> EXPORT_SYMBOL_GPL(wm831x_device_shutdown);
> 
> 
> int wm831x_read_usb(struct wm831x *wm831x)
> {
> 	int ret, usb_chg = 0, wall_chg = 0;
> 	
> 	ret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);
> 	if (ret < 0)
> 		return ret;
> 
> 	if (ret & WM831X_PWR_USB)
> 		usb_chg = 1;
> 	if (ret & WM831X_PWR_WALL)
> 		wall_chg = 1;
> 
> 	return ((usb_chg | wall_chg) ? 1 : 0);
> 
> }
> 
> 
> int wm831x_device_restart(struct wm831x *wm831x)
> {
> 	wm831x_reg_write(wm831x,WM831X_RESET_ID, 0xffff); 
> 
> 	return 0;
> }
> 




diff -r linux-3.0.36/drivers/mfd/wm831x-i2c.c linux-3.0.36-lenovo/drivers/mfd/wm831x-i2c.c
20a21
> #include <linux/gpio.h>
27a29,58
> #if defined(CONFIG_ARCH_RK30)
> 	const struct i2c_client *client = wm831x->control_data;
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msgs[2];
> 	int ret;
> 	char reg_buf[2];
> 	const short regs = reg;
> 	int scl_rate= 100 * 1000;
> 	short *buf = dest;
> 	int count = bytes/2;
> 
>         reg_buf[0] = (regs & 0xff00) >> 8;
>         reg_buf[1] = regs & 0x00ff;
> 
> 	msgs[0].addr = client->addr;
> 	msgs[0].flags = client->flags;
> 	msgs[0].len = 2;
> 	msgs[0].buf = reg_buf;
> 	msgs[0].scl_rate = scl_rate;
> 
> 	msgs[1].addr = client->addr;
> 	msgs[1].flags = client->flags | I2C_M_RD;
> 	msgs[1].len = count * 2;
> 	msgs[1].buf = (char *)buf;
> 	msgs[1].scl_rate = scl_rate;
> 
> 	ret = i2c_transfer(adap, msgs, 2);
> 
> 	return (ret == 2)? 0 : ret;
> #else
43a75
> #endif
52a85,115
> #if defined(CONFIG_ARCH_RK30)
> 	const struct i2c_client *client = wm831x->control_data;
> 	struct i2c_adapter *adap=client->adapter;
> 	struct i2c_msg msg;
> 	int ret;
> 	const short regs = reg;
> 	const short *buf = src;
> 	int count = bytes/2;
> 	int scl_rate = 100 * 1000;
> 	int i;
> 	
> 	char *tx_buf = (char *)kmalloc(2 * (count + 1), GFP_KERNEL);
> 	if(!tx_buf)
> 		return -ENOMEM;
>         tx_buf[0] = (regs & 0xff00) >> 8;
>         tx_buf[1] = regs & 0x00ff;
>         for(i = 0; i < count; i++){
>                 tx_buf[i*2+3] = (buf[i] & 0xff00) >> 8;
>                 tx_buf[i*2+2] = buf[i] & 0x00ff;
>         }
> 
> 	msg.addr = client->addr;
> 	msg.flags = client->flags;
> 	msg.len = 2 * (count + 1);
> 	msg.buf = (char *)tx_buf;
> 	msg.scl_rate = scl_rate;
> 
> 	ret = i2c_transfer(adap, &msg, 1);
> 	kfree(tx_buf);
> 	return (ret == 1) ? 0 : ret;
> #else
54c117
< 	struct i2c_msg xfer[2];
---
> 	unsigned char msg[bytes + 2];
57a121,122
> 	memcpy(&msg[0], &reg, 2);
> 	memcpy(&msg[2], src, bytes);
59,69c124
< 	xfer[0].addr = i2c->addr;
< 	xfer[0].flags = 0;
< 	xfer[0].len = 2;
< 	xfer[0].buf = (char *)&reg;
< 
< 	xfer[1].addr = i2c->addr;
< 	xfer[1].flags = I2C_M_NOSTART;
< 	xfer[1].len = bytes;
< 	xfer[1].buf = (char *)src;
< 
< 	ret = i2c_transfer(i2c->adapter, xfer, 2);
---
> 	ret = i2c_master_send(i2c, msg, bytes + 2);
72c127
< 	if (ret != 2)
---
> 	if (ret < bytes + 2)
75a131
> #endif 
81a138
> 	int ret,gpio,irq;
87a145,158
> 	
> 	gpio = i2c->irq;
> 	ret = gpio_request(gpio, "wm831x");
> 	if (ret) {
> 		printk( "failed to request rk gpio irq for wm831x \n");
> 		return ret;
> 	}
> 	gpio_pull_updown(gpio, GPIOPullUp);
> 	if (ret) {
> 	    printk("failed to pull up gpio irq for wm831x \n");
> 		return ret;
> 	}	
> 	irq = gpio_to_irq(gpio);
> 	
93c164
< 	return wm831x_device_init(wm831x, id->driver_data, i2c->irq);
---
> 	return wm831x_device_init(wm831x, id->driver_data, irq);
108a180,183
> 	spin_lock(&wm831x->flag_lock);
> 	wm831x->flag_suspend = 1;
> 	spin_unlock(&wm831x->flag_lock);
> 
111a187,213
> static int wm831x_i2c_resume(struct device *dev)
> {
> 	struct wm831x *wm831x = dev_get_drvdata(dev);
> 	int i;
> 	//set some intterupt again while resume 
> 	for (i = 0; i < ARRAY_SIZE(wm831x->irq_masks_cur); i++) {
> 		//printk("irq_masks_cur[%d]=0x%x\n",i,wm831x->irq_masks_cur[i]);
> 
> 		if (wm831x->irq_masks_cur[i] != wm831x->irq_masks_cache[i]) {
> 			wm831x->irq_masks_cache[i] = wm831x->irq_masks_cur[i];
> 			wm831x_reg_write(wm831x,
> 					 WM831X_INTERRUPT_STATUS_1_MASK + i,
> 					 wm831x->irq_masks_cur[i]);
> 		}
> 	
> 	}
> 
> 	return 0;
> }
> 
> void wm831x_i2c_shutdown(struct i2c_client *i2c)
> {
> 	struct wm831x *wm831x = i2c_get_clientdata(i2c);
> //	printk("%s\n", __FUNCTION__);
> //	wm831x_device_shutdown(wm831x);
> }
> 
125a228
> 	.resume = wm831x_i2c_resume,
135a239
> 	.shutdown = wm831x_i2c_shutdown,
142a247
> 	printk("%s\n", __FUNCTION__);
149c254
< subsys_initcall(wm831x_i2c_init);
---
> subsys_initcall_sync(wm831x_i2c_init);




diff -r linux-3.0.36/drivers/mfd/wm831x-irq.c linux-3.0.36-lenovo/drivers/mfd/wm831x-irq.c
21c21
< 
---
> #include <linux/slab.h>
27a28,37
> #include <linux/wakelock.h>
> /*
>  * Since generic IRQs don't currently support interrupt controllers on
>  * interrupt driven buses we don't use genirq but instead provide an
>  * interface that looks very much like the standard ones.  This leads
>  * to some bodges, including storing interrupt handler information in
>  * the static irq_data table we use to look up the data for individual
>  * interrupts, but hopefully won't last too long.
>  */
> #define WM831X_IRQ_TYPE IRQF_TRIGGER_LOW
34a45,50
> struct wm831x_handle_irq
> {	
> 	int irq;
> 	struct list_head	queue;
> };
> 
375a392
> 	//printk("%s:irq=%d\n",__FUNCTION__,irq);
384a402
> 	//printk("%s:irq=%d\n",__FUNCTION__,irq);
390c408
< 	int val, irq;
---
> 	int val, irq = 0;
393,394c411
< 
< 	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_11) {
---
> 	if (irq < WM831X_IRQ_GPIO_1 || irq > WM831X_IRQ_GPIO_12) {
401c418
< 
---
> 	//printk("wm831x_irq_set_type:type=%x,irq=%d\n",type,irq);
416c433
< 	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + irq,
---
> 	return wm831x_set_bits(wm831x, WM831X_GPIO1_CONTROL + irq - 1,
419a437,458
> static int wm831x_irq_set_wake(struct irq_data *data, unsigned state)
> {	
> 	struct wm831x *wm831x = irq_data_get_irq_chip_data(data);
> 	int irq = data->irq;
> 	//only wm831x irq
> 	if ((irq > wm831x->irq_base + WM831X_IRQ_TEMP_THW) &&( irq < wm831x->irq_base + WM831X_NUM_IRQS)) 
> 	{
> 		if(state)
> 		wm831x_irq_enable(data);
> 		else	
> 		wm831x_irq_disable(data);
> 		return 0;
> 	}
> 	else
> 	{
> 		printk("%s:irq number err!irq=%d\n",__FUNCTION__,irq);
> 		return -EINVAL;
> 	}
> 
> 
> }
> 
426a466
> 	.irq_set_wake	= wm831x_irq_set_wake,
429,431c469,470
< /* The processing of the primary interrupt occurs in a thread so that
<  * we can interact with the device over I2C or SPI. */
< static irqreturn_t wm831x_irq_thread(int irq, void *data)
---
> #if WM831X_IRQ_LIST
> static void wm831x_handle_worker(struct work_struct *work)
433c472,504
< 	struct wm831x *wm831x = data;
---
> 	struct wm831x *wm831x = container_of(work, struct wm831x, handle_work);
> 	int irq;
> 
> 	while (1) {
> 		unsigned long flags;
> 		struct wm831x_handle_irq *hd = NULL;
> 
> 		spin_lock_irqsave(&wm831x->work_lock, flags);
> 		if (!list_empty(&wm831x->handle_queue)) {
> 			hd = list_first_entry(&wm831x->handle_queue, struct wm831x_handle_irq, queue);
> 			list_del(&hd->queue);
> 		}
> 		spin_unlock_irqrestore(&wm831x->work_lock, flags);
> 
> 		if (!hd)	// trans_queue empty
> 			break;
> 
> 		irq = hd->irq;	//get wm831x intterupt status
> 		//printk("%s:irq=%d\n",__FUNCTION__,irq);
> 		
> 		/*start to handle wm831x intterupt*/
> 		handle_nested_irq(wm831x->irq_base + irq);
> 	
> 		kfree(hd);
> 
> 	}
> }
> #endif
> /* Main interrupt handling occurs in a workqueue since we need
>  * interrupts enabled to interact with the chip. */
> static void wm831x_irq_worker(struct work_struct *work)
> {
> 	struct wm831x *wm831x = container_of(to_delayed_work(work), struct wm831x, irq_work);
438a510,522
> 	unsigned long flags;
> 	struct wm831x_handle_irq *hd;
> 
> #if (WM831X_IRQ_TYPE != IRQF_TRIGGER_LOW)
> 	/*mask wm831x irq at first*/	
> 	int ret;
> 	ret = wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
> 			      WM831X_IRQ_IM_MASK, WM831X_IRQ_IM_EANBLE);
> 	if (ret < 0) {
> 		dev_err(wm831x->dev, "Failed to mask irq: %d\n", ret);
> 		goto out;
> 	}
> #endif
446,457c530,531
< 
< 	/* The touch interrupts are visible in the primary register as
< 	 * an optimisation; open code this to avoid complicating the
< 	 * main handling loop and so we can also skip iterating the
< 	 * descriptors.
< 	 */
< 	if (primary & WM831X_TCHPD_INT)
< 		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHPD);
< 	if (primary & WM831X_TCHDATA_INT)
< 		handle_nested_irq(wm831x->irq_base + WM831X_IRQ_TCHDATA);
< 	if (primary & (WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT))
< 		goto out;
---
> 	
> 	mutex_lock(&wm831x->irq_lock);
461c535
< 
---
> 		
464c538
< 
---
> 		
476c550
< 				goto out;
---
> 				goto out_lock;
484a559,579
> 		{
> 			#if WM831X_IRQ_LIST
> 			/*add intterupt handle on list*/
> 			hd = kzalloc(sizeof(struct wm831x_handle_irq), GFP_KERNEL);
> 			if (!hd)
> 			{
> 				printk("err:%s:ENOMEM\n",__FUNCTION__);
> 				return ;
> 			}
> 			
> 			if(i == WM831X_IRQ_ON)
> 			wake_lock(&wm831x->handle_wake);		//keep wake while handle WM831X_IRQ_ON
> 			hd->irq = i;
> 			spin_lock_irqsave(&wm831x->work_lock, flags);
> 			list_add_tail(&hd->queue, &wm831x->handle_queue);
> 			spin_unlock_irqrestore(&wm831x->work_lock, flags);
> 			queue_work(wm831x->handle_wq, &wm831x->handle_work);
> 			
> 			#else
> 			if(i == WM831X_IRQ_ON)
> 			wake_lock(&wm831x->handle_wake);		//keep wake while handle WM831X_IRQ_ON
485a581,584
> 			
> 			#endif
> 		}
> 			
489c588,591
< 
---
> 	
> out_lock:	
> 	mutex_unlock(&wm831x->irq_lock);
> 	
491,493d592
< 	/* Touchscreen interrupts are handled specially in the driver */
< 	status_regs[0] &= ~(WM831X_TCHDATA_EINT | WM831X_TCHPD_EINT);
< 
498a598,609
> 	
> #if (WM831X_IRQ_TYPE != IRQF_TRIGGER_LOW)	
> 	ret = wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
> 			      WM831X_IRQ_IM_MASK, 0);
> 	if (ret < 0) {
> 		dev_err(wm831x->dev, "Failed to open irq: %d\n", ret);
> 	}
> #endif
> #if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
> 	enable_irq(wm831x->irq);	
> #endif
> 	wake_unlock(&wm831x->irq_wake);
499a611,636
> }
> /* The processing of the primary interrupt occurs in a thread so that
>  * we can interact with the device over I2C or SPI. */
> static irqreturn_t wm831x_irq_thread(int irq, void *data)
> {
> 	struct wm831x *wm831x = data;
> 	int msdelay = 0;
> 	/* Shut the interrupt to the CPU up and schedule the actual
> 	 * handler; we can't check that the IRQ is asserted. */
> #if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
> 	disable_irq_nosync(irq);
> #endif
> 	wake_lock(&wm831x->irq_wake);
> 	if(wm831x->flag_suspend)
> 	{
> 		spin_lock(&wm831x->flag_lock);
> 		wm831x->flag_suspend = 0;
> 		spin_unlock(&wm831x->flag_lock);
> 		msdelay = 50;	//wait for spi/i2c resume
> 		printk("%s:msdelay=%d\n",__FUNCTION__,msdelay);
> 	}
> 	else
> 		msdelay = 0;
> 		
> 	queue_delayed_work(wm831x->irq_wq, &wm831x->irq_work, msecs_to_jiffies(msdelay));
> 	//printk("%s\n",__FUNCTION__);
507c644
< 
---
> 	printk( "wm831x_irq_init:irq=%d,%d\n",irq,pdata->irq_base);
517a655,660
> 	if (!irq) {
> 		dev_warn(wm831x->dev,
> 			 "No interrupt specified - functionality limited\n");
> 		return 0;
> 	}
> 
524,540c667,670
< 	if (pdata->irq_cmos)
< 		i = 0;
< 	else
< 		i = WM831X_IRQ_OD;
< 
< 	wm831x_set_bits(wm831x, WM831X_IRQ_CONFIG,
< 			WM831X_IRQ_OD, i);
< 
< 	/* Try to flag /IRQ as a wake source; there are a number of
< 	 * unconditional wake sources in the PMIC so this isn't
< 	 * conditional but we don't actually care *too* much if it
< 	 * fails.
< 	 */
< 	ret = enable_irq_wake(irq);
< 	if (ret != 0) {
< 		dev_warn(wm831x->dev, "Can't enable IRQ as wake source: %d\n",
< 			 ret);
---
> 	wm831x->irq_wq = create_singlethread_workqueue("wm831x-irq");
> 	if (!wm831x->irq_wq) {
> 		dev_err(wm831x->dev, "Failed to allocate IRQ worker\n");
> 		return -ESRCH;
542a673
> 	
543a675
> 	wm831x->flag_suspend = 0;
544a677,687
> 	INIT_DELAYED_WORK(&wm831x->irq_work, wm831x_irq_worker);
> 	wake_lock_init(&wm831x->irq_wake, WAKE_LOCK_SUSPEND, "wm831x_irq_wake");
> 	wake_lock_init(&wm831x->handle_wake, WAKE_LOCK_SUSPEND, "wm831x_handle_wake");
> #if WM831X_IRQ_LIST
> 	wm831x->handle_wq = create_workqueue("wm831x_handle_wq");
> 	if (!wm831x->handle_wq) {
> 		printk("cannot create workqueue\n");
> 		return -EBUSY;
> 	}
> 	INIT_WORK(&wm831x->handle_work, wm831x_handle_worker);
> 	INIT_LIST_HEAD(&wm831x->handle_queue);
545a689,690
> #endif
> 	
563,575c708,720
< 
< 	if (irq) {
< 		ret = request_threaded_irq(irq, NULL, wm831x_irq_thread,
< 					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
< 					   "wm831x", wm831x);
< 		if (ret != 0) {
< 			dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
< 				irq, ret);
< 			return ret;
< 		}
< 	} else {
< 		dev_warn(wm831x->dev,
< 			 "No interrupt specified - functionality limited\n");
---
> #if (WM831X_IRQ_TYPE == IRQF_TRIGGER_LOW)
> 	ret = request_threaded_irq(wm831x->irq, wm831x_irq_thread, NULL, 
> 				 IRQF_TRIGGER_LOW| IRQF_ONESHOT,//IRQF_TRIGGER_FALLING, // 
> 				   "wm831x", wm831x);
> #else
> 	ret = request_threaded_irq(wm831x->irq, wm831x_irq_thread, NULL, 
> 				 IRQF_TRIGGER_FALLING, //IRQF_TRIGGER_LOW| IRQF_ONESHOT,// 
> 				   "wm831x", wm831x);
> #endif
> 	if (ret != 0) {
> 		dev_err(wm831x->dev, "Failed to request IRQ %d: %d\n",
> 			wm831x->irq, ret);
> 		return ret;
578,579c723
< 
< 
---
> 	enable_irq_wake(wm831x->irq); // so wm831x irq can wake up system




diff -r linux-3.0.36/drivers/mfd/wm831x-otp.c linux-3.0.36-lenovo/drivers/mfd/wm831x-otp.c
20a21
> #include <linux/random.h>
68a70
> 	char uuid[WM831X_UNIQUE_ID_LEN];
74a77,82
> 
> 	ret = wm831x_unique_id_read(wm831x, uuid);
> 	if (ret == 0)
> 		add_device_randomness(uuid, sizeof(uuid));
> 	else
> 		dev_err(wm831x->dev, "Failed to read UUID: %d\n", ret);
Only in linux-3.0.36-lenovo/drivers/mfd: wm831x-spi-a22.c




diff -r linux-3.0.36/drivers/mfd/wm831x-spi.c linux-3.0.36-lenovo/drivers/mfd/wm831x-spi.c
18a19
> #include <linux/gpio.h>
31,32c32,33
< 		tx_val = r | 0x8000;
< 
---
> 		tx_val = cpu_to_be16(r | 0x8000);
> 		//printk("read:reg=0x%x,",reg);
37,38c38,39
< 
< 		*d = be16_to_cpu(*d);
---
> 		//printk("rec=0x%x\n",be16_to_cpu(*d));
> 		//*d = be16_to_cpu(*d);
56c57
< 		data[0] = r;
---
> 		data[0] = cpu_to_be16(r);
58c59
< 
---
> 		//printk("write:reg=0x%x,send=0x%x\n",reg, data[0]);
70a72
> 	int ret,gpio,irq;
98a101,113
> 	gpio = spi->irq;
> 	ret = gpio_request(gpio, "wm831x");
> 	if (ret) {
> 		printk( "failed to request rk gpio irq for wm831x \n");
> 		return ret;
> 	}
> 	gpio_pull_updown(gpio, GPIOPullUp);
> 	if (ret) {
> 	    printk("failed to pull up gpio irq for wm831x \n");
> 		return ret;
> 	}	
> 	irq = gpio_to_irq(gpio);
> 
105c120
< 	return wm831x_device_init(wm831x, type, spi->irq);
---
> 	return wm831x_device_init(wm831x, type, irq);
120a136,138
> 	spin_lock(&wm831x->flag_lock);
> 	wm831x->flag_suspend = 1;
> 	spin_unlock(&wm831x->flag_lock);




diff -r linux-3.0.36/drivers/mfd/wm8994-core.c linux-3.0.36-lenovo/drivers/mfd/wm8994-core.c
27a28,29
> #include <mach/gpio.h>
> #include <mach/iomux.h>
28a31,39
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
> #include <sound/soc.h>
> #endif
> 
> #if 0
> #define DBG(x...) printk(KERN_DEBUG x)
> #else
> #define DBG(x...) do { } while (0)
> #endif
66c77
< 
---
> 	DBG("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,be16_to_cpu(val));
127c138
< 
---
> 	DBG("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,val);
247,253c258,264
< 	"DBVDD",
< 	"DCVDD",
< 	"AVDD1",
< 	"AVDD2",
< 	"CPVDD",
< 	"SPKVDD1",
< 	"SPKVDD2",
---
> //	"DBVDD",
> //	"DCVDD",
> //	"AVDD1",
> //	"AVDD2",
> //	"CPVDD",
> //	"SPKVDD1",
> //	"SPKVDD2",
271c282
< 	struct wm8994 *wm8994 = dev_get_drvdata(dev);
---
> 	struct wm8994 *wm8994 = dev_get_drvdata(dev);	
273c284,291
< 
---
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
> 	printk("on wm8994-core.c wm8994_suspend\n");
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		DBG("incalling  cannot suspend\n");
> 		return 0;
> 	}
> #endif
318c336
< 	struct wm8994 *wm8994 = dev_get_drvdata(dev);
---
> 	struct wm8994 *wm8994 = dev_get_drvdata(dev);		
320c338,345
< 
---
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
> 	printk("on wm8994-core.c wm8994_resume\n");
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		DBG("incalling cannot resume\n");
> 		return 0;
> 	}
> #endif
587a613
> 
589c615,616
< 	struct i2c_msg xfer[2];
---
> 	struct i2c_msg xfer;	
> 	unsigned char msg[bytes + 2];
593,604c620,631
< 
< 	xfer[0].addr = i2c->addr;
< 	xfer[0].flags = 0;
< 	xfer[0].len = 2;
< 	xfer[0].buf = (char *)&reg;
< 
< 	xfer[1].addr = i2c->addr;
< 	xfer[1].flags = I2C_M_NOSTART;
< 	xfer[1].len = bytes;
< 	xfer[1].buf = (char *)src;
< 
< 	ret = i2c_transfer(i2c->adapter, xfer, 2);
---
> 	memcpy(&msg[0], &reg, 2);
> 	memcpy(&msg[2], src, bytes);
> 	
> 	xfer.addr = i2c->addr;
> 	xfer.flags = i2c->flags;
> 	xfer.len = bytes + 2;
> 	xfer.buf = (char *)msg;
> 	xfer.scl_rate = 100 * 1000;
> 	xfer.udelay = i2c->udelay;
> 	xfer.read_type = 0;
> 	
> 	ret = i2c_transfer(i2c->adapter, &xfer, 1);
607c634
< 	if (ret != 2)
---
> 	if (ret != 1)
617c644
< 
---
> 	
641a669,682
> static void wm8994_i2c_shutdown(struct i2c_client *i2c)
> {
> 	struct wm8994 *wm8994 = i2c_get_clientdata(i2c);
> 	struct wm8994_pdata *pdata = wm8994->dev->platform_data;
> 
> 	DBG("%s----%d\n",__FUNCTION__,__LINE__);
> 	
> 	//disable PA	
> 	gpio_direction_output(pdata->PA_control_pin,GPIO_LOW);
> 	if (gpio_is_valid(pdata->PA_control_pin))
> 		gpio_free(pdata->PA_control_pin);
> 
> }
> 
659a701
> 	.shutdown = wm8994_i2c_shutdown,
Only in linux-3.0.36-lenovo/drivers/misc: 3g_module
Only in linux-3.0.36-lenovo/drivers/misc: akm8963.c
Only in linux-3.0.36-lenovo/drivers/misc: akm8975.c
Only in linux-3.0.36-lenovo/drivers/misc: apanic.c
Only in linux-3.0.36-lenovo/drivers/misc: board-id
Only in linux-3.0.36-lenovo/drivers/misc: bp
Only in linux-3.0.36-lenovo/drivers/misc: ec
Only in linux-3.0.36-lenovo/drivers/misc: fm580x.c
Only in linux-3.0.36-lenovo/drivers/misc: fm580x.h
Only in linux-3.0.36-lenovo/drivers/misc: gps
Only in linux-3.0.36-lenovo/drivers/misc: inv_mpu




diff -r linux-3.0.36/drivers/misc/Kconfig linux-3.0.36-lenovo/drivers/misc/Kconfig
325a326,329
> config USB4604
> 	tristate "smsc usb4604 hub"
> 	depends on I2C
> 
393a398,415
> config SENSORS_AK8975
> 	tristate "AK8975 compass support"
> 	default n
> 	depends on I2C
> 	help
> 	  If you say yes here you get support for Asahi Kasei's
> 	  orientation sensor AK8975.
> 
> 
> config SENSORS_AK8963
>        tristate "AK8963 compass support"
>        default n
>        depends on I2C
>        help
>          If you say yes here you get support for Asahi Kasei's
>          orientation sensor AK8963.
> 
> 
436a459,462
> config UID_STAT
> 	bool "UID based statistics tracking exported to /proc/uid_stat"
> 	default n
> 
492a519,570
> config WL127X_RFKILL
> 	tristate "Bluetooth power control driver for TI wl127x"
> 	depends on RFKILL
> 	default n
> 	---help---
> 	 Creates an rfkill entry in sysfs for power control of Bluetooth
> 	 TI wl127x chips.
> 
> config APANIC
> 	bool "Android kernel panic diagnostics driver"
> 	default n
> 	---help---
> 	 Driver which handles kernel panics and attempts to write
> 	 critical debugging data to flash.
> 
> config APANIC_PLABEL
> 	string "Android panic dump flash partition label"
> 	depends on APANIC
> 	default "kpanic"
> 	---help---
> 	 If your platform uses a different flash partition label for storing
>  	 crashdumps, enter it here.
> 
> config MTK23D
> 	bool "MTK6223D modem control driver"
> 	default n	
> 	
> config FM580X
> 	bool "FM rda580x driver"
> 
> config RK29_SC8800
> 	bool "SC8800 misc driver"
> 	default n
> 
> config TDSC8800
> 	bool "TDSC8800 modem control driver"
> 	default n
> config MODEM_SOUND
> 	bool "modem sound control driver"
> 	default n
> 	
> config TCC_BT_DEV
> 	tristate "TCC Bluetooth dev Control power"
> 	default n
> 	help
> 	  If you say Y here, you can contorl the power of the BT H/W Module
> 
> config RK_NTC
>         bool "rk ntc driver"
> 	depends on ADC_RK30
>         default y
> 
495a574,576
> source "drivers/misc/rk29_modem/Kconfig"
> source "drivers/misc/gps/Kconfig"
> source "drivers/misc/inv_mpu/Kconfig"
499a581,586
> source "drivers/misc/3g_module/Kconfig"
> source "drivers/misc/bp/Kconfig"
> source "drivers/misc/rk2928_callpad_misc/Kconfig"
> source "drivers/misc/ec/Kconfig"
> source "drivers/misc/board-id/Kconfig"
> 
500a588
> source "drivers/misc/3g_module/Kconfig"




diff -r linux-3.0.36/drivers/misc/Makefile linux-3.0.36-lenovo/drivers/misc/Makefile
35a36
> obj-$(CONFIG_UID_STAT)		+= uid_stat.o
48a50,71
> obj-$(CONFIG_WL127X_RFKILL)	+= wl127x-rfkill.o
> obj-$(CONFIG_APANIC)		+= apanic.o
> obj-$(CONFIG_SENSORS_AK8975)	+= akm8975.o
> obj-$(CONFIG_SENSORS_AK8963)   += akm8963.o
> obj-$(CONFIG_MTK23D)		+= mtk23d.o
> obj-$(CONFIG_FM580X)		+= fm580x.o
> obj-$(CONFIG_RK29_SUPPORT_MODEM)	+= rk29_modem/
> obj-$(CONFIG_3G_MODULE)		+= 3g_module/
> obj-$(CONFIG_BP_AUTO)		+= bp/
> obj-$(CONFIG_GPS_DEVICES)	+= gps/
> obj-$(CONFIG_EC_DEV)		+= ec/
> obj-$(CONFIG_BOARD_ID)		+= board-id/
> 
> 
> obj-y += inv_mpu/
> obj-$(CONFIG_TDSC8800) += tdsc8800.o
> obj-$(CONFIG_RK29_SC8800)	+=	sc8800.o
> obj-y += rk2928_callpad_misc/
> obj-$(CONFIG_MODEM_SOUND) += modem_sound.o
> obj-$(CONFIG_USB4604) += usb4604.o
> obj-$(CONFIG_TCC_BT_DEV)       += tcc_bt_dev.o
> obj-$(CONFIG_RK_NTC) += rk-ntc.o
Only in linux-3.0.36-lenovo/drivers/misc: modem_sound.c
Only in linux-3.0.36-lenovo/drivers/misc: modem_sound.h
Only in linux-3.0.36-lenovo/drivers/misc: mtk23d.c
Only in linux-3.0.36-lenovo/drivers/misc: rk2928_callpad_misc
Only in linux-3.0.36-lenovo/drivers/misc: rk29_modem
Only in linux-3.0.36-lenovo/drivers/misc: rk-ntc.c
Only in linux-3.0.36-lenovo/drivers/misc: rk-ntc.h
Only in linux-3.0.36-lenovo/drivers/misc: sc8800.c




diff -r linux-3.0.36/drivers/misc/sgi-xp/xpc_main.c linux-3.0.36-lenovo/drivers/misc/sgi-xp/xpc_main.c
55a56,59
> #ifdef CONFIG_X86_64
> #include <asm/traps.h>
> #endif
> 
1081a1086,1088
> /* Used to only allow one cpu to complete disconnect */
> static unsigned int xpc_die_disconnecting;
> 
1094a1102,1104
> 	if (cmpxchg(&xpc_die_disconnecting, 0, 1))
> 		return;
> 
1162c1172
< xpc_system_die(struct notifier_block *nb, unsigned long event, void *unused)
---
> xpc_system_die(struct notifier_block *nb, unsigned long event, void *_die_args)
1194c1204,1224
< 	xpc_die_deactivate();
---
> 	struct die_args *die_args = _die_args;
> 
> 	switch (event) {
> 	case DIE_TRAP:
> 		if (die_args->trapnr == X86_TRAP_DF)
> 			xpc_die_deactivate();
> 
> 		if (((die_args->trapnr == X86_TRAP_MF) ||
> 		     (die_args->trapnr == X86_TRAP_XF)) &&
> 		    !user_mode_vm(die_args->regs))
> 			xpc_die_deactivate();
> 
> 		break;
> 	case DIE_INT3:
> 	case DIE_DEBUG:
> 		break;
> 	case DIE_OOPS:
> 	case DIE_GPF:
> 	default:
> 		xpc_die_deactivate();
> 	}




diff -r linux-3.0.36/drivers/misc/sgi-xp/xpc_uv.c linux-3.0.36-lenovo/drivers/misc/sgi-xp/xpc_uv.c
20a21,22
> #include <linux/cpu.h>
> #include <linux/module.h>
61a64,65
> static int xpc_mq_node = -1;
> 
112,114c116
< 	if (mq->irq < 0) {
< 		dev_err(xpc_part, "uv_setup_irq() returned error=%d\n",
< 			-mq->irq);
---
> 	if (mq->irq < 0)
116d117
< 	}
241,242c242,244
< 	page = alloc_pages_exact_node(nid, GFP_KERNEL | __GFP_ZERO | GFP_THISNODE,
< 				pg_order);
---
> 	page = alloc_pages_exact_node(nid,
> 				      GFP_KERNEL | __GFP_ZERO | GFP_THISNODE,
> 				      pg_order);
1733a1736,1773
> static int
> xpc_init_mq_node(int nid)
> {
> 	int cpu;
> 
> 	get_online_cpus();
> 
> 	for_each_cpu(cpu, cpumask_of_node(nid)) {
> 		xpc_activate_mq_uv =
> 			xpc_create_gru_mq_uv(XPC_ACTIVATE_MQ_SIZE_UV, nid,
> 					     XPC_ACTIVATE_IRQ_NAME,
> 					     xpc_handle_activate_IRQ_uv);
> 		if (!IS_ERR(xpc_activate_mq_uv))
> 			break;
> 	}
> 	if (IS_ERR(xpc_activate_mq_uv)) {
> 		put_online_cpus();
> 		return PTR_ERR(xpc_activate_mq_uv);
> 	}
> 
> 	for_each_cpu(cpu, cpumask_of_node(nid)) {
> 		xpc_notify_mq_uv =
> 			xpc_create_gru_mq_uv(XPC_NOTIFY_MQ_SIZE_UV, nid,
> 					     XPC_NOTIFY_IRQ_NAME,
> 					     xpc_handle_notify_IRQ_uv);
> 		if (!IS_ERR(xpc_notify_mq_uv))
> 			break;
> 	}
> 	if (IS_ERR(xpc_notify_mq_uv)) {
> 		xpc_destroy_gru_mq_uv(xpc_activate_mq_uv);
> 		put_online_cpus();
> 		return PTR_ERR(xpc_notify_mq_uv);
> 	}
> 
> 	put_online_cpus();
> 	return 0;
> }
> 
1736a1777,1779
> 	int nid;
> 	int ret = 0;
> 
1745,1749c1788,1790
< 	xpc_activate_mq_uv = xpc_create_gru_mq_uv(XPC_ACTIVATE_MQ_SIZE_UV, 0,
< 						  XPC_ACTIVATE_IRQ_NAME,
< 						  xpc_handle_activate_IRQ_uv);
< 	if (IS_ERR(xpc_activate_mq_uv))
< 		return PTR_ERR(xpc_activate_mq_uv);
---
> 	if (xpc_mq_node < 0)
> 		for_each_online_node(nid) {
> 			ret = xpc_init_mq_node(nid);
1751,1757c1792,1796
< 	xpc_notify_mq_uv = xpc_create_gru_mq_uv(XPC_NOTIFY_MQ_SIZE_UV, 0,
< 						XPC_NOTIFY_IRQ_NAME,
< 						xpc_handle_notify_IRQ_uv);
< 	if (IS_ERR(xpc_notify_mq_uv)) {
< 		xpc_destroy_gru_mq_uv(xpc_activate_mq_uv);
< 		return PTR_ERR(xpc_notify_mq_uv);
< 	}
---
> 			if (!ret)
> 				break;
> 		}
> 	else
> 		ret = xpc_init_mq_node(xpc_mq_node);
1759c1798,1802
< 	return 0;
---
> 	if (ret < 0)
> 		dev_err(xpc_part, "xpc_init_mq_node() returned error=%d\n",
> 			-ret);
> 
> 	return ret;
1767a1811,1813
> 
> module_param(xpc_mq_node, int, 0);
> MODULE_PARM_DESC(xpc_mq_node, "Node number on which to allocate message queues.");
Only in linux-3.0.36-lenovo/drivers/misc: tcc_bt_dev.c
Only in linux-3.0.36-lenovo/drivers/misc: tdsc8800.c
Only in linux-3.0.36-lenovo/drivers/misc: uid_stat.c
Only in linux-3.0.36-lenovo/drivers/misc: usb4604.c
Only in linux-3.0.36-lenovo/drivers/misc: wl127x-rfkill.c




diff -r linux-3.0.36/drivers/mmc/card/block.c linux-3.0.36-lenovo/drivers/mmc/card/block.c
129,133c129
< 	int devmaj = MAJOR(disk_devt(disk));
< 	int devidx = MINOR(disk_devt(disk)) / perdev_minors;
< 
< 	if (!devmaj)
< 		devidx = disk->first_minor / perdev_minors;
---
> 	int devidx = disk->first_minor / perdev_minors;
536c532,545
< static u32 get_card_status(struct mmc_card *card, struct request *req)
---
> static int send_stop(struct mmc_card *card, u32 *status)
> {
> 	struct mmc_command cmd = {0};
> 	int err;
> 
> 	cmd.opcode = MMC_STOP_TRANSMISSION;
> 	cmd.flags = MMC_RSP_SPI_R1B | MMC_RSP_R1B | MMC_CMD_AC;
> 	err = mmc_wait_for_cmd(card->host, &cmd, 5);
> 	if (err == 0)
> 		*status = cmd.resp[0];
> 	return err;
> }
> 
> static int get_card_status(struct mmc_card *card, u32 *status, int retries)
545c554,646
< 	err = mmc_wait_for_cmd(card->host, &cmd, 0);
---
> 	err = mmc_wait_for_cmd(card->host, &cmd, retries);
> 	if (err == 0)
> 		*status = cmd.resp[0];
> 	return err;
> }
> 
> #define ERR_RETRY	2
> #define ERR_ABORT	1
> #define ERR_CONTINUE	0
> 
> static int mmc_blk_cmd_error(struct request *req, const char *name, int error,
> 	bool status_valid, u32 status)
> {
> 	switch (error) {
> 	case -EILSEQ:
> 		/* response crc error, retry the r/w cmd */
> 		pr_err("%s: %s sending %s command, card status %#x\n",
> 			req->rq_disk->disk_name, "response CRC error",
> 			name, status);
> 		return ERR_RETRY;
> 
> 	case -ETIMEDOUT:
> 		pr_err("%s: %s sending %s command, card status %#x\n",
> 			req->rq_disk->disk_name, "timed out", name, status);
> 
> 		/* If the status cmd initially failed, retry the r/w cmd */
> 		if (!status_valid) {
> 			pr_err("%s: status not valid, retrying timeout\n", req->rq_disk->disk_name);
> 			return ERR_RETRY;
> 		}
> 		/*
> 		 * If it was a r/w cmd crc error, or illegal command
> 		 * (eg, issued in wrong state) then retry - we should
> 		 * have corrected the state problem above.
> 		 */
> 		if (status & (R1_COM_CRC_ERROR | R1_ILLEGAL_COMMAND)) {
> 			pr_err("%s: command error, retrying timeout\n", req->rq_disk->disk_name);
> 			return ERR_RETRY;
> 		}
> 
> 		/* Otherwise abort the command */
> 		pr_err("%s: not retrying timeout\n", req->rq_disk->disk_name);
> 		return ERR_ABORT;
> 
> 	default:
> 		/* We don't understand the error code the driver gave us */
> 		pr_err("%s: unknown error %d sending read/write command, card status %#x\n",
> 		       req->rq_disk->disk_name, error, status);
> 		return ERR_ABORT;
> 	}
> }
> 
> /*
>  * Initial r/w and stop cmd error recovery.
>  * We don't know whether the card received the r/w cmd or not, so try to
>  * restore things back to a sane state.  Essentially, we do this as follows:
>  * - Obtain card status.  If the first attempt to obtain card status fails,
>  *   the status word will reflect the failed status cmd, not the failed
>  *   r/w cmd.  If we fail to obtain card status, it suggests we can no
>  *   longer communicate with the card.
>  * - Check the card state.  If the card received the cmd but there was a
>  *   transient problem with the response, it might still be in a data transfer
>  *   mode.  Try to send it a stop command.  If this fails, we can't recover.
>  * - If the r/w cmd failed due to a response CRC error, it was probably
>  *   transient, so retry the cmd.
>  * - If the r/w cmd timed out, but we didn't get the r/w cmd status, retry.
>  * - If the r/w cmd timed out, and the r/w cmd failed due to CRC error or
>  *   illegal cmd, retry.
>  * Otherwise we don't understand what happened, so abort.
>  */
> static int mmc_blk_cmd_recovery(struct mmc_card *card, struct request *req,
> 	struct mmc_blk_request *brq)
> {
> 	bool prev_cmd_status_valid = true;
> 	u32 status, stop_status = 0;
> 	int err, retry;
> 
> 	/*
> 	 * Try to get card status which indicates both the card state
> 	 * and why there was no response.  If the first attempt fails,
> 	 * we can't be sure the returned status is for the r/w command.
> 	 */
> 	for (retry = 2; retry >= 0; retry--) {
> 		err = get_card_status(card, &status, 0);
> 		if (!err)
> 			break;
> 
> 		prev_cmd_status_valid = false;
> 		pr_err("%s: error %d sending status command, %sing\n",
> 		       req->rq_disk->disk_name, err, retry ? "retry" : "abort");
> 	}
> 
> 	/* We couldn't get a response from the card.  Give up. */
547,549c648,692
< 		printk(KERN_ERR "%s: error %d sending status command",
< 		       req->rq_disk->disk_name, err);
< 	return cmd.resp[0];
---
> 		return ERR_ABORT;
> 
> 	/*
> 	 * Check the current card state.  If it is in some data transfer
> 	 * mode, tell it to stop (and hopefully transition back to TRAN.)
> 	 */
> 	if (R1_CURRENT_STATE(status) == R1_STATE_DATA ||
> 	    R1_CURRENT_STATE(status) == R1_STATE_RCV) {
> 		err = send_stop(card, &stop_status);
> 		if (err)
> 			pr_err("%s: error %d sending stop command\n",
> 			       req->rq_disk->disk_name, err);
> 
> 		/*
> 		 * If the stop cmd also timed out, the card is probably
> 		 * not present, so abort.  Other errors are bad news too.
> 		 */
> 		if (err)
> 			return ERR_ABORT;
> 	}
> 
> 	/* Check for set block count errors */
> 	if (brq->sbc.error)
> 		return mmc_blk_cmd_error(req, "SET_BLOCK_COUNT", brq->sbc.error,
> 				prev_cmd_status_valid, status);
> 
> 	/* Check for r/w command errors */
> 	if (brq->cmd.error)
> 		return mmc_blk_cmd_error(req, "r/w cmd", brq->cmd.error,
> 				prev_cmd_status_valid, status);
> 
> 	/* Now for stop errors.  These aren't fatal to the transfer. */
> 	pr_err("%s: error %d sending stop command, original cmd response %#x, card status %#x\n",
> 	       req->rq_disk->disk_name, brq->stop.error,
> 	       brq->cmd.resp[0], status);
> 
> 	/*
> 	 * Subsitute in our own stop status as this will give the error
> 	 * state which happened during the execution of the r/w command.
> 	 */
> 	if (stop_status) {
> 		brq->stop.resp[0] = stop_status;
> 		brq->stop.error = 0;
> 	}
> 	return ERR_CONTINUE;
679a823,830
> #define CMD_ERRORS							\
> 	(R1_OUT_OF_RANGE |	/* Command argument out of range */	\
> 	 R1_ADDRESS_ERROR |	/* Misaligned address */		\
> 	 R1_BLOCK_LEN_ERROR |	/* Transferred block length incorrect */\
> 	 R1_WP_VIOLATION |	/* Tried to write to protected block */	\
> 	 R1_CC_ERROR |		/* Card controller error */		\
> 	 R1_ERROR)		/* General/unknown error */
> 
685c836
< 	int ret = 1, disable_multi = 0;
---
> 	int ret = 1, disable_multi = 0, retry = 0;
697,698c848
< 		struct mmc_command cmd = {0};
< 		u32 readcmd, writecmd, status = 0;
---
> 		u32 readcmd, writecmd;
703a854,857
>             #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>                 brq.cmd.retries = 2; //suppot retry read-write; added by xbw@2012-07-14
>             #endif
> 
813a968,970
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>     //delete all retry code. modifyed by xbw at 2011-11-17
> #else
815,817c972,979
< 		 * Check for errors here, but don't jump to cmd_err
< 		 * until later as we need to wait for the card to leave
< 		 * programming mode even when things go wrong.
---
> 		 * sbc.error indicates a problem with the set block count
> 		 * command.  No data will have been transferred.
> 		 *
> 		 * cmd.error indicates a problem with the r/w command.  No
> 		 * data will have been transferred.
> 		 *
> 		 * stop.error indicates a problem with the stop command.  Data
> 		 * may have been transferred, or may still be transferring.
819,826c981,989
< 		if (brq.sbc.error || brq.cmd.error ||
< 		    brq.data.error || brq.stop.error) {
< 			if (brq.data.blocks > 1 && rq_data_dir(req) == READ) {
< 				/* Redo read one sector at a time */
< 				printk(KERN_WARNING "%s: retrying using single "
< 				       "block read\n", req->rq_disk->disk_name);
< 				disable_multi = 1;
< 				continue;
---
> 		if (brq.sbc.error || brq.cmd.error || brq.stop.error) {
> 			switch (mmc_blk_cmd_recovery(card, req, &brq)) {
> 			case ERR_RETRY:
> 				if (retry++ < 5)
> 					continue;
> 			case ERR_ABORT:
> 				goto cmd_abort;
> 			case ERR_CONTINUE:
> 				break;
828,853d990
< 			status = get_card_status(card, req);
< 		}
< 
< 		if (brq.sbc.error) {
< 			printk(KERN_ERR "%s: error %d sending SET_BLOCK_COUNT "
< 			       "command, response %#x, card status %#x\n",
< 			       req->rq_disk->disk_name, brq.sbc.error,
< 			       brq.sbc.resp[0], status);
< 		}
< 
< 		if (brq.cmd.error) {
< 			printk(KERN_ERR "%s: error %d sending read/write "
< 			       "command, response %#x, card status %#x\n",
< 			       req->rq_disk->disk_name, brq.cmd.error,
< 			       brq.cmd.resp[0], status);
< 		}
< 
< 		if (brq.data.error) {
< 			if (brq.data.error == -ETIMEDOUT && brq.mrq.stop)
< 				/* 'Stop' response contains card status */
< 				status = brq.mrq.stop->resp[0];
< 			printk(KERN_ERR "%s: error %d transferring data,"
< 			       " sector %u, nr %u, card status %#x\n",
< 			       req->rq_disk->disk_name, brq.data.error,
< 			       (unsigned)blk_rq_pos(req),
< 			       (unsigned)blk_rq_sectors(req), status);
854a992
> #endif		
856,860c994,1002
< 		if (brq.stop.error) {
< 			printk(KERN_ERR "%s: error %d sending stop command, "
< 			       "response %#x, card status %#x\n",
< 			       req->rq_disk->disk_name, brq.stop.error,
< 			       brq.stop.resp[0], status);
---
> 		/*
> 		 * Check for errors relating to the execution of the
> 		 * initial command - such as address errors.  No data
> 		 * has been transferred.
> 		 */
> 		if (brq.cmd.resp[0] & CMD_ERRORS) {
> 			pr_err("%s: r/w command failed, status = %#x\n",
> 				req->rq_disk->disk_name, brq.cmd.resp[0]);
> 			goto cmd_abort;
862a1005,1012
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>     //delete all retry code. modifyed by xbw at 2011-11-17
> #else    
> 		/*
> 		 * Everything else is either success, or a data error of some
> 		 * kind.  If it was a write, we may have transitioned to
> 		 * program mode, which we have to wait for it to complete.
> 		 */
863a1014
> 			u32 status;
865,870c1016
< 				int err;
< 
< 				cmd.opcode = MMC_SEND_STATUS;
< 				cmd.arg = card->rca << 16;
< 				cmd.flags = MMC_RSP_R1 | MMC_CMD_AC;
< 				err = mmc_wait_for_cmd(card->host, &cmd, 5);
---
> 				int err = get_card_status(card, &status, 5);
881,890c1027,1028
< 			} while (!(cmd.resp[0] & R1_READY_FOR_DATA) ||
< 				(R1_CURRENT_STATE(cmd.resp[0]) == 7));
< 
< #if 0
< 			if (cmd.resp[0] & ~0x00000900)
< 				printk(KERN_ERR "%s: status = %08x\n",
< 				       req->rq_disk->disk_name, cmd.resp[0]);
< 			if (mmc_decode_status(cmd.resp))
< 				goto cmd_err;
< #endif
---
> 			} while (!(status & R1_READY_FOR_DATA) ||
> 				 (R1_CURRENT_STATE(status) == R1_STATE_PRG));
891a1030
> #endif
893c1032,1041
< 		if (brq.cmd.error || brq.stop.error || brq.data.error) {
---
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>         if (brq.sbc.error || brq.cmd.error || brq.stop.error || brq.data.error) {   //modifyed by xbw at 2011-11-17
> #else
> 		if (brq.data.error) {
> 			pr_err("%s: error %d transferring data, sector %u, nr %u, cmd response %#x, card status %#x\n",
> 				req->rq_disk->disk_name, brq.data.error,
> 				(unsigned)blk_rq_pos(req),
> 				(unsigned)blk_rq_sectors(req),
> 				brq.cmd.resp[0], brq.stop.resp[0]);
> #endif
894a1043,1054
> 			  #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 			  //direct to exit when error happen; deleted by xbw at 2011-12-14
> 			  #else
> 				if (brq.data.blocks > 1) {
> 					/* Redo read one sector at a time */
> 					pr_warning("%s: retrying using single block read\n",
> 						req->rq_disk->disk_name);
> 					disable_multi = 1;
> 					continue;
> 				}
> 				#endif
> 
903a1064,1065
> 			} else {
> 				goto cmd_err;
905d1066
< 			goto cmd_err;
941a1103
>  cmd_abort:
949a1112,1114
> static int
> mmc_blk_set_blksize(struct mmc_blk_data *md, struct mmc_card *card);
> 
955a1121,1127
> #ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
> 	if (mmc_bus_needs_resume(card->host)) {
> 		mmc_resume_bus(card->host);
> 		mmc_blk_set_blksize(md, card);
> 	}
> #endif
> 
1048a1221
> 	md->disk->flags = GENHD_FL_EXT_DEVT;
1287a1461,1463
> #ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
> 	mmc_set_bus_resume_policy(card->host, 1);
> #endif
1312a1489,1491
> #ifdef CONFIG_MMC_BLOCK_DEFERRED_RESUME
> 	mmc_set_bus_resume_policy(card->host, 0);
> #endif
1335a1515
> #ifndef CONFIG_MMC_BLOCK_DEFERRED_RESUME
1336a1517
> #endif




diff -r linux-3.0.36/drivers/mmc/card/Kconfig linux-3.0.36-lenovo/drivers/mmc/card/Kconfig
52a53,61
> config MMC_BLOCK_DEFERRED_RESUME
> 	bool "Deferr MMC layer resume until I/O is requested"
> 	depends on MMC_BLOCK
> 	default n
> 	help
> 	  Say Y here to enable deferred MMC resume until I/O
> 	  is requested. This will reduce overall resume latency and
> 	  save power when theres an SD card inserted but not being used.
> 




diff -r linux-3.0.36/drivers/mmc/core/bus.c linux-3.0.36-lenovo/drivers/mmc/core/bus.c
123c123
< static int mmc_bus_suspend(struct device *dev, pm_message_t state)
---
> static int mmc_bus_pm_suspend(struct device *dev)
127a128
> 	pm_message_t state = { PM_EVENT_SUSPEND };
134c135
< static int mmc_bus_resume(struct device *dev)
---
> static int mmc_bus_pm_resume(struct device *dev)
146d146
< 
164a165
> #endif /* CONFIG_PM_RUNTIME */
167,169c168,169
< 	.runtime_suspend	= mmc_runtime_suspend,
< 	.runtime_resume		= mmc_runtime_resume,
< 	.runtime_idle		= mmc_runtime_idle,
---
> 	SET_SYSTEM_SLEEP_PM_OPS(mmc_bus_pm_suspend, mmc_bus_pm_resume)
> 	SET_RUNTIME_PM_OPS(mmc_runtime_suspend, mmc_runtime_resume, mmc_runtime_idle)
172,179d171
< #define MMC_PM_OPS_PTR	(&mmc_bus_pm_ops)
< 
< #else /* !CONFIG_PM_RUNTIME */
< 
< #define MMC_PM_OPS_PTR	NULL
< 
< #endif /* !CONFIG_PM_RUNTIME */
< 
187,189c179
< 	.suspend	= mmc_bus_suspend,
< 	.resume		= mmc_bus_resume,
< 	.pm		= MMC_PM_OPS_PTR,
---
> 	.pm		= &mmc_bus_pm_ops,
335a326,328
> #if defined(CONFIG_SDMMC_RK29) && defined(CONFIG_SDMMC_RK29_OLD)
> 		mmc_card_clr_present(card);
> #endif		




diff -r linux-3.0.36/drivers/mmc/core/core.c linux-3.0.36-lenovo/drivers/mmc/core/core.c
25a26
> #include <linux/wakelock.h>
214a216,220
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	unsigned long datasize, waittime = 0xFFFF;
> 	u32 multi, unit;
> #endif
> 
221a228,270
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>     if( strncmp( mmc_hostname(host) ,"mmc0" , strlen("mmc0")) ) 
>     {
>         multi = (mrq->cmd->retries>0)?mrq->cmd->retries:1;
>         waittime = wait_for_completion_timeout(&complete,HZ*7*multi); //sdio; for cmd dead. Modifyed by xbw at 2011-06-02
>     }
>     else
>     {   
>         //calculate the timeout value for SDMMC; added by xbw at 2011-09-27
>         if(mrq->data)
>         {
>             unit = 2*(1<<20);// unit=2MB
>             datasize = mrq->data->blksz*mrq->data->blocks;
>             multi = datasize/unit;
>             multi += (datasize%unit)?1:0;
>             multi = (multi>0) ? multi : 1;
>             multi += (mrq->cmd->retries>0)?1:0;
>             waittime = wait_for_completion_timeout(&complete,HZ*7*multi); //It should be longer than bottom driver's time,due to the sum of two cmd time.
>                                                                           //modifyed by xbw at 2011-10-08
>                                                                           //
>                                                                           //example:
>                                                                           //rk29_sdmmc_request_end..2336...   CMD12 wait busy timeout!!!!! ====xbw=[sd_mmc]====
>                                                                           //mmc_wait_for_req..236.. !!!!! wait for CMD25 timeout ===xbw[mmc0]===
>         }
>         else
>         {
>             multi = (mrq->cmd->retries>0)?mrq->cmd->retries:1;
>             waittime = wait_for_completion_timeout(&complete,HZ*7*multi);
>         }
>     }
>     
>     if(waittime <= 1)
>     {
>         host->doneflag = 0;
>         mrq->cmd->error = -EIO;
> 
>         if(0 == mrq->cmd->retries)
>         {
>             printk(KERN_WARNING "%s..%d.. !!!!! wait for CMD%d timeout [%s]\n",\
>                 __FUNCTION__, __LINE__, mrq->cmd->opcode, mmc_hostname(host));
>         }
>     }
> #else
222a272
> #endif
1045c1095,1098
< 
---
> 	
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
>     host->ios.clock = host->f_min;
> #else
1046a1100
> #endif
1123a1178,1207
> int mmc_resume_bus(struct mmc_host *host)
> {
> 	unsigned long flags;
> 
> 	if (!mmc_bus_needs_resume(host))
> 		return -EINVAL;
> 
> 	printk("%s: Starting deferred resume\n", mmc_hostname(host));
> 	spin_lock_irqsave(&host->lock, flags);
> 	host->bus_resume_flags &= ~MMC_BUSRESUME_NEEDS_RESUME;
> 	host->rescan_disable = 0;
> 	spin_unlock_irqrestore(&host->lock, flags);
> 
> 	mmc_bus_get(host);
> 	if (host->bus_ops && !host->bus_dead) {
> 		mmc_power_up(host);
> 		BUG_ON(!host->bus_ops->resume);
> 		host->bus_ops->resume(host);
> 	}
> 
> 	if (host->bus_ops->detect && !host->bus_dead)
> 		host->bus_ops->detect(host);
> 
> 	mmc_bus_put(host);
> 	printk("%s: Deferred resume completed\n", mmc_hostname(host));
> 	return 0;
> }
> 
> EXPORT_SYMBOL(mmc_resume_bus);
> 
1188a1273
> 	wake_lock(&host->detect_wake_lock);
1560a1646,1649
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17		
> 	int init_ret=0;
> #endif
> 
1572c1661,1760
< 	sdio_reset(host);
---
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17	
> //the process is default for rockchip SDK. noted by xbw at 2011-11-17
> 
> /* Order's important: probe SDIO, then SD, then MMC */
> 
> #if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
>     if( strncmp( mmc_hostname(host) ,"mmc0" , strlen("mmc0")) )
>     {
>         #if defined(CONFIG_RTL8723AS)
> 	//sdio_reset(host);//make no sense; noteed by xbw at 2011-12-14
>         #endif
>     	mmc_go_idle(host);
> 
>     	if (!(init_ret=mmc_attach_sdio(host)))
>     	{
>     	    printk(KERN_INFO "%s..%d..  ===== Initialize SDIO successfully. [%s]\n",\
>     	        __FUNCTION__,  __LINE__, mmc_hostname(host));
>     		return 0;
>     	}
>     	else
>     	{
>     	    if(0xFF!=init_ret)
>     	    {
>     	         printk(KERN_WARNING "\n=====\n %s..%d..  ===== Initialize SDIO-card unsuccessfully!!! [%s]\n=====\n",\
>     		        __FUNCTION__,  __LINE__, mmc_hostname(host));
> 
>     		     goto freq_out;   
>     	    }
>     	}
>     }
>     else
>     {
>         mmc_go_idle(host);
>     }
> #else
>     //sdio_reset(host); //make no sense; noteed by xbw at 2011-12-14
> 	mmc_go_idle(host);
> 
> 	if (!(init_ret=mmc_attach_sdio(host)))
> 	{
> 	    printk(KERN_INFO "%s..%d..  ===== Initialize SDIO successfully. [%s]\n",\
> 	        __FUNCTION__,  __LINE__, mmc_hostname(host));
> 		return 0;
> 	}
> 	else
> 	{
> 	    if(0xFF!=init_ret)
> 	    {
> 	         printk(KERN_WARNING "\n=====\n %s..%d..  ===== Initialize SDIO-card unsuccessfully!!! [%s]\n=====\n",\
> 		        __FUNCTION__,  __LINE__, mmc_hostname(host));
> 
> 		     goto freq_out;   
> 	    }
> 	}
> #endif // #end--#if !defined(CONFIG_USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD)
> 
>     if (!(init_ret=mmc_attach_sd(host)))
>     {
>         printk(KERN_INFO "%s..%d..  ===== Initialize SD-card successfully. [%s]\n",\
>             __FUNCTION__,  __LINE__, mmc_hostname(host));
>             
> 	    return 0;
> 	}
> 	else
> 	{
> 	    if(0xFF!=init_ret)
> 	    {
> 	          printk(KERN_WARNING "\n=====\n%s..%d..  ===== Initialize SD-card unsuccessfully! [%s]\n====\n",\
> 	                __FUNCTION__,  __LINE__, mmc_hostname(host));
> 
> 		     goto freq_out;   
> 	    }
> 	}
> 
> 
> 	if (!(init_ret=mmc_attach_mmc(host)))
> 	{
> 	    printk(KERN_INFO "%s...%d..  ===== Initialize MMC-card successfully. [%s]\n",\
> 	        __FUNCTION__,  __LINE__, mmc_hostname(host));
> 
> 	    return 0;
> 	}
> 	else
> 	{
> 	    if(0xFF!=init_ret)
> 	    {
> 	         printk(KERN_WARNING "\n =====\n%s..%d..  ===== Initialize MMC-card unsuccessfully!!! [%s]\n======\n",\
> 	            __FUNCTION__,  __LINE__, mmc_hostname(host));
> 	            
> 		     goto freq_out;   
> 	    }
> 	}		
>     	
> freq_out:
> 	mmc_power_off(host);
> 	return -EIO;
> 
> #else  // the default process in ICS.
> 
>     sdio_reset(host);
1586a1775,1776
> #endif 
> 
1594a1785
> 	bool extend_wakelock = false;
1608a1800,1805
> 	/* If the card was removed the bus will be marked
> 	 * as dead - extend the wakelock so userspace
> 	 * can respond */
> 	if (host->bus_dead)
> 		extend_wakelock = 1;
> 
1627a1825,1828
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
>     printk(KERN_INFO "\n%s...%d..  ===== mmc_rescan Begin....[%s]\n",__FILE__, __LINE__, mmc_hostname(host));
> #endif
> 
1628a1830,1835
> 	{
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
>     	 printk(KERN_WARNING "\n=================\n%s..%d..  ====find no SDMMC host. [%s]\n", \
>     	        __FUNCTION__, __LINE__, mmc_hostname(host));
> #endif
> 
1629a1837
> 	}
1631a1840,1845
> 
> #if defined(CONFIG_SDMMC_RK29) || !defined(CONFIG_SDMMC_RK29_OLD)   //Modifyed by xbw at 2011-11-17
>     if (!mmc_rescan_try_freq(host, host->f_min)) 
>         extend_wakelock = true;
> 
> #else	
1633c1847,1848
< 		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min)))
---
> 		if (!mmc_rescan_try_freq(host, max(freqs[i], host->f_min))) {
> 			extend_wakelock = true;
1634a1850
> 		}
1637a1854,1855
> #endif
> 
1641c1859,1864
< 	if (host->caps & MMC_CAP_NEEDS_POLL)
---
> 	if (extend_wakelock)
> 		wake_lock_timeout(&host->detect_wake_lock, HZ / 2);
> 	else
> 		wake_unlock(&host->detect_wake_lock);
> 	if (host->caps & MMC_CAP_NEEDS_POLL) {
> 		wake_lock(&host->detect_wake_lock);
1642a1866
> 	}
1662c1886,1887
< 	cancel_delayed_work_sync(&host->detect);
---
> 	if (cancel_delayed_work_sync(&host->detect))
> 		wake_unlock(&host->detect_wake_lock);
1778a2004,2006
> 	if (mmc_bus_needs_resume(host))
> 		return 0;
> 
1781c2009,2010
< 	cancel_delayed_work(&host->detect);
---
> 	if (cancel_delayed_work(&host->detect))
> 		wake_unlock(&host->detect_wake_lock);
1787a2017,2020
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>                //deleted all detail code. //fix the crash bug when error occur during suspend. Modiefyed by xbw at 2012-08-09
> #else
1801a2035,2036
> #endif
> 		flush_delayed_work(&host->disable);
1821a2057,2062
> 	if (mmc_bus_manual_resume(host)) {
> 		host->bus_resume_flags |= MMC_BUSRESUME_NEEDS_RESUME;
> 		mmc_bus_put(host);
> 		return 0;
> 	}
> 
1839a2081,2085
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>         //panic if the card is being removed during the resume, deleted by xbw at 2011-06-20
> 		host->bus_ops->resume(host);
> 
> #else
1846a2093
> #endif
1871a2119,2122
> 		if (mmc_bus_needs_resume(host)) {
> 			spin_unlock_irqrestore(&host->lock, flags);
> 			break;
> 		}
1874c2125,2126
< 		cancel_delayed_work_sync(&host->detect);
---
> 		if (cancel_delayed_work_sync(&host->detect))
> 			wake_unlock(&host->detect_wake_lock);
1894a2147,2150
> 		if (mmc_bus_manual_resume(host)) {
> 			spin_unlock_irqrestore(&host->lock, flags);
> 			break;
> 		}
1902a2159,2174
> #endif
> 
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> void mmc_set_embedded_sdio_data(struct mmc_host *host,
> 				struct sdio_cis *cis,
> 				struct sdio_cccr *cccr,
> 				struct sdio_embedded_func *funcs,
> 				int num_funcs)
> {
> 	host->embedded_sdio_data.cis = cis;
> 	host->embedded_sdio_data.cccr = cccr;
> 	host->embedded_sdio_data.funcs = funcs;
> 	host->embedded_sdio_data.num_funcs = num_funcs;
> }
> 
> EXPORT_SYMBOL(mmc_set_embedded_sdio_data);




diff -r linux-3.0.36/drivers/mmc/core/host.c linux-3.0.36-lenovo/drivers/mmc/core/host.c
286a287,288
> 	wake_lock_init(&host->detect_wake_lock, WAKE_LOCK_SUSPEND,
> 		kasprintf(GFP_KERNEL, "%s_detect", mmc_hostname(host)));
339c341,342
< 	register_pm_notifier(&host->pm_notify);
---
> 	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
> 		register_pm_notifier(&host->pm_notify);
356c359,361
< 	unregister_pm_notifier(&host->pm_notify);
---
> 	if (!(host->pm_flags & MMC_PM_IGNORE_PM_NOTIFY))
> 		unregister_pm_notifier(&host->pm_notify);
> 
382a388
> 	wake_lock_destroy(&host->detect_wake_lock);




diff -r linux-3.0.36/drivers/mmc/core/Kconfig linux-3.0.36-lenovo/drivers/mmc/core/Kconfig
29a30,46
> 
> config MMC_EMBEDDED_SDIO
> 	boolean "MMC embedded SDIO device support (EXPERIMENTAL)"
> 	depends on EXPERIMENTAL
> 	help
> 	  If you say Y here, support will be added for embedded SDIO
> 	  devices which do not contain the necessary enumeration
> 	  support in hardware to be properly detected.
> 
> config MMC_PARANOID_SD_INIT
> 	bool "Enable paranoid SD card initialization (EXPERIMENTAL)"
> 	depends on EXPERIMENTAL
> 	help
> 	  If you say Y here, the MMC layer will be extra paranoid
> 	  about re-trying SD init requests. This can be a useful
> 	  work-around for buggy controllers and hardware. Enable
> 	  if you are experiencing issues with SD detection.




diff -r linux-3.0.36/drivers/mmc/core/mmc.c linux-3.0.36-lenovo/drivers/mmc/core/mmc.c
445c445,455
< 	err = (!(card->ext_csd.raw_partition_support ==
---
> 	//err = (!(card->ext_csd.raw_partition_support ==  	                                                   
> 	err = !((card->ext_csd.raw_partition_support ==
> 	                                                    /*Modifyed by xbw at 2012-03-05
> 	                                                    
> 	                                                   commit dd13b4ed4650bb3a7d6c86b549ab66a6aa0c00d8
>                                                         Author: Jurgen Heeks <jurgen.heeks@nokia.com>
>                                                         Date:   Wed Feb 1 13:30:55 2012 +0100
> 
>                                                           mmc: core: Fix comparison issue in mmc_compare_ext_csds
> 	                                                   */
> 	
563a574,578
> 	{
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	    printk(KERN_INFO "%s..%d..  ====*Identify the card as MMC , but OCR error, so fail to initialize.[%s]\n",\
> 	        __FUNCTION__, __LINE__, mmc_hostname(host));
> #endif
564a580
> 	}
738a755,758
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>         //in order to expand the compatibility of card. Added by xbw@2011-03-21
> 		card->csd.max_dtr = (card->csd.max_dtr > MMC_FPP_FREQ) ? MMC_FPP_FREQ : (card->csd.max_dtr); 
> #endif
1017a1038,1040
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	int retry_times = 3;
> #endif
1022a1046
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
1024,1025c1048,1056
< 		return err;
< 
---
> 		return 0xFF;//return err; Modifyed by xbw at 2011-11-17
> 		
>     printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as MMC-card [%s]\n", \
>         __FUNCTION__, __LINE__, mmc_hostname(host));
> #else
>     if (err)
>     	return err;
> #endif        
>         
1067a1099,1121
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> //modifyed by xbw at 2011--04-11
> Retry_add:
> 	err = mmc_add_card(host->card);
> 	mmc_claim_host(host);
> 	if (err)
> 	{
> 	    //retry add the card; Added by xbw
>         if((--retry_times >= 0))
>         {        
>             printk(KERN_ERR "\n%s..%s..%d   ****error in add partition, so retry.  [%s]\n",__FUNCTION__,__FILE__,__LINE__, mmc_hostname(host));   
>             /* sleep some time */
>             set_current_state(TASK_INTERRUPTIBLE);
>             schedule_timeout(HZ/2);
>             
>             goto Retry_add;
>         }
> 
> 		goto remove_card;
>     
> 	}
> #else
1071a1126
> #endif




diff -r linux-3.0.36/drivers/mmc/core/sd.c linux-3.0.36-lenovo/drivers/mmc/core/sd.c
309c309,314
< 	if (card->scr.sda_spec3) {
---
> 	if (status[13] & UHS_SDR50_BUS_SPEED)
> 		card->sw_caps.hs_max_dtr = 50000000;
> 
>     //mask the the SD Ver3.0 support,modifyed by xbw at 2012-8-09
> 	//if (card->scr.sda_spec3) {
> 	if(0) {
351,353d355
< 	} else {
< 		if (status[13] & 0x02)
< 			card->sw_caps.hs_max_dtr = 50000000;
721c723,727
< 	if (err)
---
> 	if (err) {
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	    printk(KERN_WARNING "%s..%d..  ====*Identify the card as SD , but OCR error, so fail to initialize.[%s]\n", \
> 	        __FUNCTION__, __LINE__, mmc_hostname(host));
> #endif
722a729
> 	}
766a774,776
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	int retries;
> #endif
792a803,826
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 		for (retries = 1; retries <= 3; retries++) {
> 			err = mmc_read_switch(card);
> 			if (!err) {
> 				if (retries > 1) {
> 					printk(KERN_WARNING
> 					       "%s: recovered\n", 
> 					       mmc_hostname(host));
> 				}
> 				break;
> 			} else {
> 				printk(KERN_WARNING
> 				       "%s: read switch failed (attempt %d)\n",
> 				       mmc_hostname(host), retries);
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 				if(0 == host->re_initialized_flags)
> 				{
> 					 break; //Added by xbw at 2011-06-21
> 				}
> #endif
> 			}
> 		}
> #else
793a828,829
> #endif
> 
839a876,880
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>         //in order to expand the compatibility of card. Added by xbw@2011-03-21
> 	    card->csd.max_dtr = (card->csd.max_dtr > SD_FPP_FREQ) ? SD_FPP_FREQ : (card->csd.max_dtr); 
> #endif
992c1033,1036
< 	int err;
---
> 	int err = 0;
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
>         int retries = 5;
> #endif
996c1040
< 
---
>        
1002c1046,1058
< 	err = mmc_send_status(host->card, NULL);
---
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	while(retries) {
> 		err = mmc_send_status(host->card, NULL);
> 		if (err) {
> 			retries--;
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 		  if(0 == host->re_initialized_flags)
> 			{
> 				 retries = 0;
> 				 break; //Added by xbw at 2011-06-21
> 			}
> #endif
1003a1060,1071
> 			udelay(5);
> 			continue;
> 		}
> 		break;
> 	}
> 	if (!retries) {
> 		printk(KERN_ERR "%s(%s): Unable to re-detect card (%d)\n",
> 		       __func__, mmc_hostname(host), err);
> 	}
> #else
> 	err = mmc_send_status(host->card, NULL);
> #endif
1041a1110,1112
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	int retries;
> #endif
1046a1118,1139
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	retries = 5;
> 	while (retries) {
> 		err = mmc_sd_init_card(host, host->ocr, host->card);
> 
> 		if (err) {
> 			printk(KERN_ERR "%s: Re-init card rc = %d (retries = %d)\n",
> 			       mmc_hostname(host), err, retries);
> 			mdelay(5);
> 			retries--;
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 			if(0 == host->re_initialized_flags)
> 			{
> 				 break; //Added by xbw at 2011-06-21
> 			}
> #endif
> 			continue;
> 		}
> 		break;
> 	}
> #else
1047a1141
> #endif
1098a1193,1199
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	int retry_times = 3;
> #endif
> 
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	int retries;
> #endif
1112a1214,1220
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
> 	if (err)
> 		return 0xFF;//return err; Modifyed by xbw at 2011-11-17
> 		
>     printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as SD-card. [%s]\n",\
>         __FUNCTION__, __LINE__, mmc_hostname(host));
> #else
1115c1223
< 
---
> #endif
1162a1271,1295
> #ifdef CONFIG_MMC_PARANOID_SD_INIT
> 	retries = 5;
> 	while (retries) {
> 		err = mmc_sd_init_card(host, host->ocr, NULL);
> 		if (err) {
> 			retries--;
> 
> 	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 			if(0 == host->re_initialized_flags)
> 			{
> 				 retries = 0;
> 				 break; //Added by xbw at 2011-06-21
> 			}
> 	#endif
> 			continue;
> 		}
> 		break;
> 	}
> 
> 	if (!retries) {
> 		printk(KERN_ERR "%s: mmc_sd_init_card() failure (err = %d)\n",
> 		       mmc_hostname(host), err);
> 		goto err;
> 	}
> #else
1165a1299
> #endif
1167a1302,1324
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> //modifyed by xbw at 2011--04-11
> Retry_add:
> 	err = mmc_add_card(host->card);
> 	mmc_claim_host(host);
> 	if (err)
> 	{
> 	    //retry add the card; Added by xbw
>         if((--retry_times >= 0))
>         {        
>             printk(KERN_WARNING "\n%s..%s..%d   ****error in add partition, so retry.  [%s]\n",__FUNCTION__,__FILE__,__LINE__, mmc_hostname(host));   
>             /* sleep some time */
>             set_current_state(TASK_INTERRUPTIBLE);
>             schedule_timeout(HZ/2);
>             
>             goto Retry_add;
>         }
> 
> 		goto remove_card;
>     
> 	}
> #else
1171a1329
> #endif




diff -r linux-3.0.36/drivers/mmc/core/sdio_bus.c linux-3.0.36-lenovo/drivers/mmc/core/sdio_bus.c
25a26,29
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> #include <linux/mmc/host.h>
> #endif
> 
263c267,274
< 	sdio_free_func_cis(func);
---
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	/*
> 	 * If this device is embedded then we never allocated
> 	 * cis tables for this func
> 	 */
> 	if (!func->card->host->embedded_sdio_data.funcs)
> #endif
> 		sdio_free_func_cis(func);




diff -r linux-3.0.36/drivers/mmc/core/sdio.c linux-3.0.36-lenovo/drivers/mmc/core/sdio.c
29a30,33
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> #include <linux/mmc/sdio_ids.h>
> #endif
> 
350c354,358
< 		if (err)
---
> 		if (err) {
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	    printk(KERN_ERR "%s..%d..  ====*Identify the card as SDIO , but OCR error, so fail to initialize. [%s]\n", \
> 	        __FUNCTION__, __LINE__, mmc_hostname(host));
> #endif
351a360
> 		}
452,457c461,474
< 	/*
< 	 * Read the common registers.
< 	 */
< 	err = sdio_read_cccr(card);
< 	if (err)
< 		goto remove;
---
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	if (host->embedded_sdio_data.cccr)
> 		memcpy(&card->cccr, host->embedded_sdio_data.cccr, sizeof(struct sdio_cccr));
> 	else {
> #endif
> 		/*
> 		 * Read the common registers.
> 		 */
> 		err = sdio_read_cccr(card);
> 		if (err)
> 			goto remove;
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	}
> #endif
459,464c476,489
< 	/*
< 	 * Read the common CIS tuples.
< 	 */
< 	err = sdio_read_common_cis(card);
< 	if (err)
< 		goto remove;
---
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	if (host->embedded_sdio_data.cis)
> 		memcpy(&card->cis, host->embedded_sdio_data.cis, sizeof(struct sdio_cis));
> 	else {
> #endif
> 		/*
> 		 * Read the common CIS tuples.
> 		 */
> 		err = sdio_read_common_cis(card);
> 		if (err)
> 			goto remove;
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	}
> #endif
666a692,697
> #if defined(CONFIG_MTK_COMBO) && defined(CONFIG_MTK_COMBO_DRIVER_VERSION_JB2)
>     /* sdio_funcs are NOT resumed yet! Signal irq only in host driver. */
>     //
>     // do not to  wake up sdio_irq_thread; noted by xbw at 2013-05-08
>     //
> #else
668a700
> #endif
769a802,803
> 	
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)	
770a805,810
> 		return 0xFF;//return err; //Modifyed by xbw at 2011-11-17
> 		
>     printk(KERN_INFO "\n%s..%d..  ===== Begin to identify card as SDIO-card. [%s]\n",\
>         __FUNCTION__, __LINE__, mmc_hostname(host));
> #else
>     if (err)
772c812
< 
---
> #endif        
829a870,874
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	if (host->embedded_sdio_data.funcs)
> 		card->sdio_funcs = funcs = host->embedded_sdio_data.num_funcs;
> #endif
> 
834,837c879,899
< 		err = sdio_init_func(host->card, i + 1);
< 		if (err)
< 			goto remove;
< 
---
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 		if (host->embedded_sdio_data.funcs) {
> 			struct sdio_func *tmp;
> 
> 			tmp = sdio_alloc_func(host->card);
> 			if (IS_ERR(tmp))
> 				goto remove;
> 			tmp->num = (i + 1);
> 			card->sdio_func[i] = tmp;
> 			tmp->class = host->embedded_sdio_data.funcs[i].f_class;
> 			tmp->max_blksize = host->embedded_sdio_data.funcs[i].f_maxblksize;
> 			tmp->vendor = card->cis.vendor;
> 			tmp->device = card->cis.device;
> 		} else {
> #endif
> 			err = sdio_init_func(host->card, i + 1);
> 			if (err)
> 				goto remove;
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 		}
> #endif
884a947,1025
> int sdio_reset_comm(struct mmc_card *card)
> {
> 	struct mmc_host *host = card->host;
> 	u32 ocr;
> 	int err;
> 
> 	printk("%s():\n", __func__);
> 	mmc_claim_host(host);
> 
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	host->sdmmc_host_hw_init(mmc_priv(host));  //added by xbw , at 2011-10-18
> 	host->ios.clock = host->f_min; //for avoid 25MHz once again during init process.noted by xbw at 2011-11-14
> #endif
> 
> 	mmc_go_idle(host);
> 
> 	mmc_set_clock(host, host->f_min);
> 
> 	err = mmc_send_io_op_cond(host, 0, &ocr);
> 	if (err)
> 		goto err;
> 
> 	host->ocr = mmc_select_voltage(host, ocr);
> 	if (!host->ocr) {
> 		err = -EINVAL;
> 		goto err;
> 	}
> 
> 	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
> 	if (err)
> 		goto err;
> 
> 	if (mmc_host_is_spi(host)) {
> 		err = mmc_spi_set_crc(host, use_spi_crc);
> 		if (err)
> 			goto err;
> 	}
> 
> 	if (!mmc_host_is_spi(host)) {
> 		err = mmc_send_relative_addr(host, &card->rca);
> 		if (err)
> 			goto err;
> 		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
> 	}
> 	if (!mmc_host_is_spi(host)) {
> 		err = mmc_select_card(card);
> 		if (err)
> 			goto err;
> 	}
> 
> 	/*
> 	 * Switch to high-speed (if supported).
> 	 */
> 	err = sdio_enable_hs(card);
> 	if (err > 0)
> 		mmc_sd_go_highspeed(card);
> 	else if (err)
> 		goto err;
> 
> 	/*
> 	 * Change to the card's maximum speed.
> 	 */
> 	mmc_set_clock(host, mmc_sdio_get_max_clock(card));
> 
> 	err = sdio_enable_4bit_bus(card);
> 	if (err > 0)
> 		mmc_set_bus_width(host, MMC_BUS_WIDTH_4);
> 	else if (err)
> 		goto err;
> 
> 	mmc_release_host(host);
> 	return 0;
> err:
> 	printk("%s: Error resetting SDIO communications (%d)\n",
> 	       mmc_hostname(host), err);
> 	mmc_release_host(host);
> 	return err;
> }
> EXPORT_SYMBOL(sdio_reset_comm);




diff -r linux-3.0.36/drivers/mmc/core/sdio_cis.c linux-3.0.36-lenovo/drivers/mmc/core/sdio_cis.c
316c316,318
< 				printk(KERN_WARNING "%s: queuing unknown"
---
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
>                 // This is the normal exit procedure,rather than an error.noted by xbw at 2011-12-14
> 				printk(KERN_DEBUG "%s: queuing unknown"
319a322,328
> #else
>                 printk(KERN_WARNING "%s: queuing unknown"
> 				       " CIS tuple 0x%02x (%u bytes)\n",
> 				       mmc_hostname(card->host),
> 				       tpl_code, tpl_link);
> 
> #endif




diff -r linux-3.0.36/drivers/mmc/core/sdio_io.c linux-3.0.36-lenovo/drivers/mmc/core/sdio_io.c
385a386,418
>  *	sdio_readb_ext - read a single byte from a SDIO function
>  *	@func: SDIO function to access
>  *	@addr: address to read
>  *	@err_ret: optional status value from transfer
>  *	@in: value to add to argument
>  *
>  *	Reads a single byte from the address space of a given SDIO
>  *	function. If there is a problem reading the address, 0xff
>  *	is returned and @err_ret will contain the error code.
>  */
> unsigned char sdio_readb_ext(struct sdio_func *func, unsigned int addr,
> 	int *err_ret, unsigned in)
> {
> 	int ret;
> 	unsigned char val;
> 
> 	BUG_ON(!func);
> 
> 	if (err_ret)
> 		*err_ret = 0;
> 
> 	ret = mmc_io_rw_direct(func->card, 0, func->num, addr, (u8)in, &val);
> 	if (ret) {
> 		if (err_ret)
> 			*err_ret = ret;
> 		return 0xFF;
> 	}
> 
> 	return val;
> }
> EXPORT_SYMBOL_GPL(sdio_readb_ext);
> 
> /**




diff -r linux-3.0.36/drivers/mmc/host/Kconfig linux-3.0.36-lenovo/drivers/mmc/host/Kconfig
6a7,86
> config SDMMC_RK29
> 	tristate "RK29 SDMMC controller suppport"
> 	depends on PLAT_RK
> 	help
> 		This selects the RK29 SDMMC controller.
> 		SDMMC0 used for sd/mmc card, and SDMMC1 used for sdio.
> if SDMMC_RK29
>     comment "Now, there are two SDMMC controllers selected, SDMMC0 and SDMMC1."
> 	config SDMMC_RK29_OLD
> 		bool "Old driver (DEPRECATED)"
> 		help
> 			 You will select old,origin driver for your project if you say Yes.
> 			 It is not good to select the driver.
> 
> 	config SDMMC0_RK29
> 		tristate "RK29 SDMMC0 controller support(sdmmc)"
> 		default y
> 		help
> 			This supports the use of the SDMMC0 controller on Rk29 processors.
> 			
> 	config SDMMC0_RK29_WRITE_PROTECT
> 		bool "Write-protect for SDMMC0"
> 		default n
> 		depends on SDMMC0_RK29
> 		help
> 			 You will add the feature of write-protect for sdmmc-card if you say Yes.
> 			 Please note that this feature requires hardware support.
> 	
> 	config SDMMC0_RK29_SDCARD_DET_FROM_GPIO
>         bool "use the gpio-interrupt to detect card"
>         default n
>         depends on SDMMC0_RK29
>             help
> 	           You can detect the presence of card by the gpio-interrupt if you say Yes.
> 			   Of course, you must define the pin-name for the detect-pin.
> 
> 			   If you say No, then detect the card by register interrupt.
> 
> #	config USE_SDMMC0_FOR_WIFI_DEVELOP_BOARD
> #	    depends on SDMMC0_RK29
> #		bool "Switch the driver SDMMC0 for the debug of wifi_develop_board."
> #		default n
> #		help
> #			In order to debug the Wifi development board using SD interface,
> #			we can switch the driver SDMMC0.
> 
> 
> 	config SDMMC1_RK29
> 		tristate "RK29 SDMMC1 controller support(sdio)"
> 		default y
> 		help
> 			This supports the use of the SDMMC1 controller on Rk29 processors.
> 	config SDMMC1_RK29_WRITE_PROTECT
> 		bool "Write-protect for SDMMC1"
> 		default n
> 		depends on SDMMC1_RK29
> 		help
> 			 You will add the feature of write-protect for sdio-card if you say Yes.
> 			 Please note that this feature requires hardware support.
> 			
>        config  RK29_SDIO_IRQ_FROM_GPIO
>          bool "sdio-irq from gpio"
>          default n
>          depends on SDMMC1_RK29
>          help
>             You will generate sdio interrupt from gpio if you say Yes.
>             Please note that this feature requires hardware support.
> 
> 
> 
> #	config USE_SDMMC1_FOR_WIFI_DEVELOP_BOARD
> #	  depends on SDMMC1_RK29
> #		bool "Switch the driver SDMMC1 for the debug of wifi_develop_board."
> #		default n
> #		help
> #			In order to debug the Wifi development board using SD interface,
> #			we can switch the driver SDMMC1.
> 
> endif
> 




diff -r linux-3.0.36/drivers/mmc/host/Makefile linux-3.0.36-lenovo/drivers/mmc/host/Makefile
4a5,10
> ifeq ($(CONFIG_SDMMC_RK29_OLD),y)
> obj-$(CONFIG_SDMMC_RK29)	+= rk29_sdmmc_old.o
> else
> obj-$(CONFIG_SDMMC_RK29)	+= rk29_sdmmc.o
> endif
> 




diff -r linux-3.0.36/drivers/mmc/host/mxs-mmc.c linux-3.0.36-lenovo/drivers/mmc/host/mxs-mmc.c
280a281,282
> 	spin_unlock(&host->lock);
> 
283,284d284
< 
< 	spin_unlock(&host->lock);
Only in linux-3.0.36-lenovo/drivers/mmc/host: rk2818-sdmmc.h
Only in linux-3.0.36-lenovo/drivers/mmc/host: rk29_sdmmc.c
Only in linux-3.0.36-lenovo/drivers/mmc/host: rk29_sdmmc.h
Only in linux-3.0.36-lenovo/drivers/mmc/host: rk29_sdmmc_old.c




diff -r linux-3.0.36/drivers/mmc/host/sdhci.c linux-3.0.36-lenovo/drivers/mmc/host/sdhci.c
1047c1047
< 	if (clock == host->clock)
---
> 	if (clock && clock == host->clock)
2518,2519c2518,2520
< 	/* UHS-I mode(s) supported by the host controller. */
< 	if (host->version >= SDHCI_SPEC_300)
---
> 	/* Any UHS-I mode in caps implies SDR12 and SDR25 support. */
> 	if (caps[1] & (SDHCI_SUPPORT_SDR104 | SDHCI_SUPPORT_SDR50 |
> 		       SDHCI_SUPPORT_DDR50))




diff -r linux-3.0.36/drivers/mmc/host/sdhci-esdhc.h linux-3.0.36-lenovo/drivers/mmc/host/sdhci-esdhc.h
50a51,53
> 	if (clock == 0)
> 		goto out;
> 
55,57d57
< 
< 	if (clock == 0)
< 		goto out;




diff -r linux-3.0.36/drivers/mmc/host/sdhci-pci.c linux-3.0.36-lenovo/drivers/mmc/host/sdhci-pci.c
142a143
> 			  SDHCI_QUIRK_BROKEN_CARD_DETECTION |




diff -r linux-3.0.36/drivers/mmc/host/sdhci-s3c.c linux-3.0.36-lenovo/drivers/mmc/host/sdhci-s3c.c
592c592
< 	for (ptr = 0; ptr < 3; ptr++) {
---
> 	for (ptr = 0; ptr < MAX_BUS_CLK; ptr++) {




diff -r linux-3.0.36/drivers/mtd/devices/slram.c linux-3.0.36-lenovo/drivers/mtd/devices/slram.c
269c269
< 		devlength = handle_unit(devlength, buffer) - devstart;
---
> 		devlength = handle_unit(devlength, buffer);




diff -r linux-3.0.36/drivers/mtd/Kconfig linux-3.0.36-lenovo/drivers/mtd/Kconfig
328a329,330
> source "drivers/mtd/rknand/Kconfig"
> 




diff -r linux-3.0.36/drivers/mtd/Makefile linux-3.0.36-lenovo/drivers/mtd/Makefile
32c32
< obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/
---
> obj-y		+= chips/ lpddr/ maps/ devices/ nand/ onenand/ tests/  rknand/




diff -r linux-3.0.36/drivers/mtd/maps/autcpu12-nvram.c linux-3.0.36-lenovo/drivers/mtd/maps/autcpu12-nvram.c
46c46,47
< 	int err, save0, save1;
---
> 	map_word tmp, save0, save1;
> 	int err;
54c55
< 	simple_map_init(&autcpu_sram_map);
---
> 	simple_map_init(&autcpu12_sram_map);
64,66c65,68
< 	save0 = map_read32(&autcpu12_sram_map,0);
< 	save1 = map_read32(&autcpu12_sram_map,0x10000);
< 	map_write32(&autcpu12_sram_map,~save0,0x10000);
---
> 	save0 = map_read(&autcpu12_sram_map, 0);
> 	save1 = map_read(&autcpu12_sram_map, 0x10000);
> 	tmp.x[0] = ~save0.x[0];
> 	map_write(&autcpu12_sram_map, tmp, 0x10000);
70,71c72,74
< 	if ( map_read32(&autcpu12_sram_map,0) != save0) {
< 		map_write32(&autcpu12_sram_map,save0,0x0);
---
> 	tmp = map_read(&autcpu12_sram_map, 0);
> 	if (!map_word_equal(&autcpu12_sram_map, tmp, save0)) {
> 		map_write(&autcpu12_sram_map, save0, 0x0);
77c80
< 	map_write32(&autcpu12_sram_map,save1,0x10000);
---
> 	map_write(&autcpu12_sram_map, save1, 0x10000);




diff -r linux-3.0.36/drivers/mtd/mtd_blkdevs.c linux-3.0.36-lenovo/drivers/mtd/mtd_blkdevs.c
42a43,45
> #define MTD_MERGE                       1
> 
> 
77c80
< 
---
> #if(MTD_MERGE == 0)
84c87
< 
---
> #if 0
86a90,104
> #else  //modify by zyf for cap>=4GB 20110120
> 	block = blk_rq_pos(req);
> 	nsect = blk_rq_cur_bytes(req) >> tr->blkshift;
>     if(tr->blkshift != 9)
>     {
>         if(tr->blkshift > 9)
>         {
>     	    block = blk_rq_pos(req) >> (tr->blkshift - 9);
>         }
>         else
>         {
> 	        block = blk_rq_pos(req) << (9 - tr->blkshift);
>         }
>     }
> #endif
102,103c120,121
< 		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
< 			if (tr->readsect(dev, block, buf))
---
> 		//for (; nsect > 0; nsect--, block++, buf += tr->blksize)
> 			if (tr->readsect(dev, block,nsect, buf))
112,113c130,131
< 		for (; nsect > 0; nsect--, block++, buf += tr->blksize)
< 			if (tr->writesect(dev, block, buf))
---
> 		//for (; nsect > 0; nsect--, block++, buf += tr->blksize)
> 			if (tr->writesect(dev, block,nsect, buf))
138c156
< 
---
> 	
190a209,291
> #else
> 
> #define MTD_RW_SECTORS  (2048)     // 2048 (BLK_SAFE_MAX_SECTORS+1)
> static char * mtd_rw_buffer;       //[MTD_RW_SECTORS*512]   __attribute__((aligned(4096)));
> struct mutex  mtd_rw_buffer_lock;
> static int req_check_buffer_align(struct request *req,char **pbuf)
> {
>     int    nr_vec = 0;
>     struct bio_vec *bv;
>     struct req_iterator iter;
>     char *buffer;
>     void *firstbuf = 0;
>     char *nextbuffer = 0;
> 	unsigned long block, nsect;
> 	block = blk_rq_pos(req);
> 	nsect = blk_rq_cur_bytes(req) >> 9;
> 	rq_for_each_segment(bv, req, iter)
> 	{
> 	    buffer = page_address(bv->bv_page) + bv->bv_offset;
> 	    if( firstbuf == 0 )
> 	    {
>             firstbuf = buffer;
> 	    }
>         nr_vec++;
>         if(nextbuffer!=0)
>         {
>             if(nextbuffer!=buffer)
>             {
>                 return 0;
>             }    
>         }
>         nextbuffer = buffer+bv->bv_len;
> 	}
> 	*pbuf = firstbuf;
> 	return 1;
> }
> 
> 
> int mtd_blktrans_cease_background(struct mtd_blktrans_dev *dev)
> {
> 	if (kthread_should_stop())
> 		return 1;
> 
> 	return dev->bg_stop;
> }
> EXPORT_SYMBOL_GPL(mtd_blktrans_cease_background);
> 
> static int mtd_blktrans_thread(void *arg)
> {
> 	struct mtd_blktrans_dev *dev = arg;
> 	struct mtd_blktrans_ops *tr = dev->tr;
> 	struct request_queue *rq = dev->rq;
> 	struct request *req = NULL;
> 	int background_done = 0;
> 	
> 	unsigned long block, data_len;
> 	char *buf = NULL;
> 	struct req_iterator rq_iter;
> 	struct bio_vec *bvec;
> 	int cmd_flag;
> 	
>     set_user_nice(current,-20);
> 	spin_lock_irq(rq->queue_lock);
> 
> 	while (!kthread_should_stop()) {
> 		int res;
> 
> 		dev->bg_stop = false;
> 		if (!req && !(req = blk_fetch_request(rq))) {
> 			if (tr->background && !background_done) {
> 				spin_unlock_irq(rq->queue_lock);
> 				mutex_lock(&dev->lock);
> 				tr->background(dev);
> 				mutex_unlock(&dev->lock);
> 				spin_lock_irq(rq->queue_lock);
> 				/*
> 				 * Do background processing just once per idle
> 				 * period.
> 				 */
> 				background_done = !dev->bg_stop;
> 				continue;
> 			}
> 			set_current_state(TASK_INTERRUPTIBLE);
191a293,427
> 			if (kthread_should_stop())
> 				set_current_state(TASK_RUNNING);
> 
> 			spin_unlock_irq(rq->queue_lock);
> 			schedule();
> 			spin_lock_irq(rq->queue_lock);
> 			continue;
> 		}
>     	if ((req->cmd_type != REQ_TYPE_FS) || (blk_rq_pos(req) + blk_rq_sectors(req) > get_capacity(req->rq_disk)))
>     	{
>             __blk_end_request_all(req, -EIO);
> 	        req = NULL;
> 		    background_done = 0;
> 	        continue;
>     	}
> 		spin_unlock_irq(rq->queue_lock);
>         mutex_lock(&dev->lock);
>         
> 	    block = blk_rq_pos(req);
> 	    data_len = 0;
> 		buf = 0;
> 		res = 0;
> 	    cmd_flag = rq_data_dir(req);
> 	    //i = 0;
>         if(cmd_flag == READ && mtd_rw_buffer)
>         {
> 	        unsigned long nsect;
>             buf = mtd_rw_buffer;
>             req_check_buffer_align(req,&buf);
>             nsect = req->__data_len >> 9;
>             if( nsect > MTD_RW_SECTORS ) {
>                 //printk("%s..%d::nsect=%d,too large , may be error!\n",__FILE__,__LINE__, nsect );
>                 nsect = MTD_RW_SECTORS;
> 				BUG_ON(1);
>                 //while(1);
>             }
> 			if(buf == mtd_rw_buffer )
>             	mutex_lock(&mtd_rw_buffer_lock);
>     		if (tr->readsect(dev, block,nsect, buf))
>     		    res = -EIO;
>             if( buf == mtd_rw_buffer ) 
>             {
>                 char *p = buf;
>         	    rq_for_each_segment(bvec, req, rq_iter) 
>             	{ 
>                     memcpy( page_address(bvec->bv_page) + bvec->bv_offset , p , bvec->bv_len );
>                     flush_dcache_page(bvec->bv_page); //zyf rq_flush_dcache_pages(req);
>                     p += bvec->bv_len;
>             	}
>             	mutex_unlock(&mtd_rw_buffer_lock);
>             }
>             //rq_flush_dcache_pages(req);
>         }
>         else
>         {    
>         	rq_for_each_segment(bvec, req, rq_iter) 
>         	{
>             	//printk("%d buf = %x, lba = %llx , nsec=%x ,offset = %x\n",i,page_address(bvec->bv_page) + bvec->bv_offset,((rq_iter.bio)->bi_sector),(bvec->bv_len),(bvec->bv_offset));
>                 //i++;
>                 flush_dcache_page(bvec->bv_page); //zyf rq_flush_dcache_pages(req);
>                 if((page_address(bvec->bv_page) + bvec->bv_offset) == (buf + data_len))
>                 {
>                     data_len += bvec->bv_len;
>                 }
>                 else
>                 {
>                     if(data_len)
>                     {
>             	        //printk("buf = %x, lba = %lx , nsec=%x \n",buf,block,data_len);
>                     	switch(cmd_flag)
>                     	{
>                     	case READ:
>                 			if (tr->readsect(dev, block,data_len>>9, buf))
>                 				res = -EIO;
>                     		//rq_flush_dcache_pages(req);
>                     		break;
>                     	case WRITE:
>                     		//if (!tr->writesect)
>                     		//	res = -EIO;
>                     		//rq_flush_dcache_pages(req);
>                 			if (tr->writesect(dev, block,data_len>>9, buf))
>                 				res = -EIO;
>                     		break;
>                     	default:
>                     		//printk(KERN_NOTICE "Unknown request %u\n", rq_data_dir(req));
>                 			res = -EIO;
>                     		break;
>                     	}
>                     }
>      				block += data_len>>9;
>     				buf = (page_address(bvec->bv_page) + bvec->bv_offset);
>     				data_len = bvec->bv_len;
>                 }
>         	}
>     
>             if(data_len)
>             {
>             	//printk("buf = %x, lba = %lx , nsec=%x \n",buf,block,data_len);
>             	switch(cmd_flag)
>             	{
>             	case READ:
>         			if (tr->readsect(dev, block,data_len>>9, buf))
>         				res = -EIO;
>             		//rq_flush_dcache_pages(req);
>             		break;
>             	case WRITE:
>             		//if (!tr->writesect)
>             		//	res = -EIO;
>             		//rq_flush_dcache_pages(req);
>         			if (tr->writesect(dev, block,data_len>>9, buf))
>         				res = -EIO;
>             		break;
>             	default:
>             		//printk(KERN_NOTICE "Unknown request %u\n", rq_data_dir(req));
>         			res = -EIO;
>             		break;
>             	}
>             }
>         }
>         mutex_unlock(&dev->lock);
> 		spin_lock_irq(rq->queue_lock);
> 		//printk("__blk_end_request_all %d\n",res);
> 		__blk_end_request_all(req, res);
> 		req = NULL;
> 		background_done = 0;
> 	}
> 
> 	if (req)
> 		__blk_end_request_all(req, -EIO);
> 
> 	spin_unlock_irq(rq->queue_lock);
> 
> 	return 0;
> }
> #endif
418c654,657
< 	set_capacity(gd, (new->size * tr->blksize) >> 9);
---
> 	/* 2.5 has capacity in units of 512 bytes while still
> 	   having BLOCK_SIZE_BITS set to 10. Just to keep us amused. */
> 	//set_capacity(gd, (new->size * tr->blksize) >> 9);
> 	set_capacity(gd, (new->size >> 9) * tr->blksize);   //modify by zyf for cap>=4GB 20110120
428a668,673
> 	
> #if (MTD_MERGE == 1)
>     blk_queue_max_hw_sectors(new->rq,MTD_RW_SECTORS);
> 	//blk_queue_max_segment_size(new->rq,MTD_RW_SECTORS);
> 	blk_queue_max_segments(new->rq, MTD_RW_SECTORS);// /PAGE_CACHE_SIZE
> #endif
541c786,789
< 
---
> #if(MTD_MERGE != 0)
> 	mutex_init(&mtd_rw_buffer_lock);
>     mtd_rw_buffer = kmalloc(MTD_RW_SECTORS*512, GFP_KERNEL | GFP_DMA);
> #endif




diff -r linux-3.0.36/drivers/mtd/mtdblock.c linux-3.0.36-lenovo/drivers/mtd/mtdblock.c
30a31
> #include <linux/version.h>
142,143c143,144
< 
< static int do_cached_write (struct mtdblk_dev *mtdblk, unsigned long pos,
---
> #if 0
> static int do_cached_write (struct mtdblk_dev *mtdblk, loff_t pos,
213c214
< static int do_cached_read (struct mtdblk_dev *mtdblk, unsigned long pos,
---
> static int do_cached_read (struct mtdblk_dev *mtdblk, loff_t pos,
260c261
< 			      unsigned long block, char *buf)
---
> 			      loff_t block,unsigned long nsect, char *buf)
263c264
< 	return do_cached_read(mtdblk, block<<9, 512, buf);
---
> 	return do_cached_read(mtdblk, (loff_t)block<<9, 512*nsect, buf);
267c268
< 			      unsigned long block, char *buf)
---
> 			      unsigned long block,unsigned long nsect, char *buf)
279c280,298
< 	return do_cached_write(mtdblk, block<<9, 512, buf);
---
> 	return do_cached_write(mtdblk, (loff_t)block<<9, 512*nsect, buf);
> }
> #else
> static int mtdblock_readsect(struct mtd_blktrans_dev *dev,
> 			      unsigned long block,unsigned long nsect, char *buf)
> {
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
> 	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
> 	struct mtd_info *mtd = mtdblk->mbd.mtd;
> #else
> 	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
> 	struct mtd_info *mtd = mtdblk->mtd;
> #endif
> 	size_t retlen,len;
> 	loff_t pos = (loff_t)block*512;
>     len = 512*nsect;
> 
> 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: read on \"%s\" at 0x%llx, size 0x%x\n",mtd->name, pos, len);
> 	return mtd->read(mtd, pos, len, &retlen, buf);
281a301,318
> static int mtdblock_writesect(struct mtd_blktrans_dev *dev,
> 			      unsigned long block,unsigned long nsect, char *buf)
> {
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 35))
> 	struct mtdblk_dev *mtdblk = container_of(dev, struct mtdblk_dev, mbd);
> 	struct mtd_info *mtd = mtdblk->mbd.mtd;
> #else
> 	struct mtdblk_dev *mtdblk = mtdblks[dev->devnum];
> 	struct mtd_info *mtd = mtdblk->mtd;
> #endif
> 	size_t retlen,len;
> 	loff_t pos = (loff_t)block*512;
>     len = 512*nsect;
>     
> 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%llx, size 0x%x\n",mtd->name, pos, len);
>     return mtd->write(mtd, pos, len, &retlen, buf);
> }
> #endif




diff -r linux-3.0.36/drivers/mtd/mtdblock_ro.c linux-3.0.36-lenovo/drivers/mtd/mtdblock_ro.c
28c28
< 			      unsigned long block, char *buf)
---
> 			      unsigned long block, unsigned long nsect, char *buf)
32c32
< 	if (dev->mtd->read(dev->mtd, (block * 512), 512, &retlen, buf))
---
> 	if (dev->mtd->read(dev->mtd, (block * 512), 512*nsect, &retlen, buf))
38c38
< 			      unsigned long block, char *buf)
---
> 			      unsigned long block, unsigned long nsect, char *buf)
42c42
< 	if (dev->mtd->write(dev->mtd, (block * 512), 512, &retlen, buf))
---
> 	if (dev->mtd->write(dev->mtd, (block * 512), 512*nsect, &retlen, buf))




diff -r linux-3.0.36/drivers/mtd/nand/cafe_nand.c linux-3.0.36-lenovo/drivers/mtd/nand/cafe_nand.c
105c105
< 	int result = !!(cafe_readl(cafe, NAND_STATUS) | 0x40000000);
---
> 	int result = !!(cafe_readl(cafe, NAND_STATUS) & 0x40000000);




diff -r linux-3.0.36/drivers/mtd/nand/Kconfig linux-3.0.36-lenovo/drivers/mtd/nand/Kconfig
0a1,7
> config MTD_NAND_IDS
> 	tristate "Include chip ids for known NAND devices."
> 	depends on MTD
> 	help
> 	  Useful for NAND drivers that do not use the NAND subsystem but
> 	  still like to take advantage of the known chip information.
> 
123a131,147
> config MTD_NAND_OMAP_PREFETCH
> 	bool "GPMC prefetch support for NAND Flash device"
> 	depends on MTD_NAND_OMAP2
> 	default y
> 	help
> 	 The NAND device can be accessed for Read/Write using GPMC PREFETCH engine
> 	 to improve the performance.
> 
> config MTD_NAND_OMAP_PREFETCH_DMA
> 	depends on MTD_NAND_OMAP_PREFETCH
> 	bool "DMA mode"
> 	default n
> 	help
> 	 The GPMC PREFETCH engine can be configured eigther in MPU interrupt mode
> 	 or in DMA interrupt mode.
> 	 Say y for DMA mode or MPU mode will be used
> 
394a419,424
> config MTD_NAND_RK29
>         tristate "NAND Flash support for RK29sdk"
>         depends on ARCH_RK29
>         help
>           This enables the NAND flash controller on the RK29 SoC
>           




diff -r linux-3.0.36/drivers/mtd/nand/Makefile linux-3.0.36-lenovo/drivers/mtd/nand/Makefile
47a48
> obj-$(CONFIG_MTD_NAND_RK29)		+= rk29_nand.o




diff -r linux-3.0.36/drivers/mtd/nand/nand_base.c linux-3.0.36-lenovo/drivers/mtd/nand/nand_base.c
1494a1495,1499
> #ifdef CONFIG_MTD_NAND_RK29
>             extern int rk29_nand_refresh(struct mtd_info *mtd, int srcAddr);
> 		    if(ret == -1)
> 		        ret=rk29_nand_refresh(mtd, page<<chip->page_shift);
> #endif              
1495a1501
> 			{
1496a1503
> 			}
3082a3090,3091
> 	chip->options |= busw;
> 	
3224a3234,3271
> static void nand_panic_wait(struct mtd_info *mtd)
> {
> 	struct nand_chip *chip = mtd->priv;
> 	int i;
> 
> 	if (chip->state != FL_READY)
> 		for (i = 0; i < 40; i++) {
> 			if (chip->dev_ready(mtd))
> 				break;
> 			mdelay(10);
> 		}
> 	chip->state = FL_READY;
> }
> 
> static int nand_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
> 			    size_t *retlen, const u_char *buf)
> {
> 	struct nand_chip *chip = mtd->priv;
> 	int ret;
> 
> 	/* Do not allow reads past end of device */
> 	if ((to + len) > mtd->size)
> 		return -EINVAL;
> 	if (!len)
> 		return 0;
> 
> 	nand_panic_wait(mtd);
> 
> 	chip->ops.len = len;
> 	chip->ops.datbuf = (uint8_t *)buf;
> 	chip->ops.oobbuf = NULL;
> 
> 	ret = nand_do_write_ops(mtd, to, &chip->ops);
> 
> 	*retlen = chip->ops.retlen;
> 	return ret;
> }
> 
3467a3515
> 	mtd->panic_write = nand_panic_write;




diff -r linux-3.0.36/drivers/mtd/nand/nand_bbt.c linux-3.0.36-lenovo/drivers/mtd/nand/nand_bbt.c
432c432
< 			      mtd->writesize, td);
---
> 			      mtd->writesize, md);
1212a1213,1216
> #ifdef CONFIG_MTD_NAND_RK29
>     extern void mark_reserve_region(struct mtd_info *mtd,struct nand_bbt_descr *td,struct nand_bbt_descr *md);
>     mark_reserve_region(mtd, td, md);
> #endif    
1296,1297c1300,1301
< 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
< 	.offs =	8,
---
> 		| NAND_BBT_2BIT /*| NAND_BBT_VERSION */| NAND_BBT_PERCHIP,
> 	.offs =0,  //8,  // meet to rk2818 nandc spare
1306,1307c1310,1311
< 		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
< 	.offs =	8,
---
> 		| NAND_BBT_2BIT /*| NAND_BBT_VERSION */| NAND_BBT_PERCHIP,
> 	.offs =0,   //8,  // meet to rk2818 nandc spare




diff -r linux-3.0.36/drivers/mtd/nand/nandsim.c linux-3.0.36-lenovo/drivers/mtd/nand/nandsim.c
31c31
< #include <asm/div64.h>
---
> #include <linux/math64.h>
550,555d549
< static uint64_t divide(uint64_t n, uint32_t d)
< {
< 	do_div(n, d);
< 	return n;
< }
< 
584c578
< 	ns->geom.pgnum    = divide(ns->geom.totsz, ns->geom.pgsz);
---
> 	ns->geom.pgnum    = div_u64(ns->geom.totsz, ns->geom.pgsz);
927c921
< 	wear_eb_count = divide(mtd->size, mtd->erasesize);
---
> 	wear_eb_count = div_u64(mtd->size, mtd->erasesize);
2363a2358
> 			retval = -EINVAL;




diff -r linux-3.0.36/drivers/mtd/nand/omap2.c linux-3.0.36-lenovo/drivers/mtd/nand/omap2.c
1142c1142,1143
< 	kfree(&info->mtd);
---
> 	release_mem_region(info->phys_base, NAND_IO_SIZE);
> 	kfree(info);
Only in linux-3.0.36-lenovo/drivers/mtd/nand: rk29_nand.c
Only in linux-3.0.36-lenovo/drivers/mtd: rknand




diff -r linux-3.0.36/drivers/mtd/ubi/build.c linux-3.0.36-lenovo/drivers/mtd/ubi/build.c
818a819,823
> 	if (ubi->ro_mode) {
> 		ubi_warn("skip auto-resize because of R/O mode");
> 		return 0;
> 	}
> 




diff -r linux-3.0.36/drivers/mtd/ubi/vtbl.c linux-3.0.36-lenovo/drivers/mtd/ubi/vtbl.c
359c359
< 	kfree(new_seb);
---
> 	kmem_cache_free(si->scan_leb_slab, new_seb);
372c372
< 	kfree(new_seb);
---
> 	kmem_cache_free(si->scan_leb_slab, new_seb);
Only in linux-3.0.36-lenovo/drivers: mtk_wcn_bt
Only in linux-3.0.36-lenovo/drivers: mtk_wcn_combo




diff -r linux-3.0.36/drivers/net/benet/be_main.c linux-3.0.36-lenovo/drivers/net/benet/be_main.c
765a766,767
> 		int gso_segs = skb_shinfo(skb)->gso_segs;
> 
783,784c785
< 		be_tx_stats_update(adapter, wrb_cnt, copied,
< 				skb_shinfo(skb)->gso_segs, stopped);
---
> 		be_tx_stats_update(adapter, wrb_cnt, copied, gso_segs, stopped);




diff -r linux-3.0.36/drivers/net/bnx2.c linux-3.0.36-lenovo/drivers/net/bnx2.c
5313c5313
< 				j++;
---
> 				j = NEXT_TX_BD(j);
5325,5326c5325,5326
< 			j++;
< 			for (k = 0; k < last; k++, j++) {
---
> 			j = NEXT_TX_BD(j);
> 			for (k = 0; k < last; k++, j = NEXT_TX_BD(j)) {




diff -r linux-3.0.36/drivers/net/bonding/bond_main.c linux-3.0.36-lenovo/drivers/net/bonding/bond_main.c
79a80
> #include <net/pkt_sched.h>
391,392d391
< #define bond_queue_mapping(skb) (*(u16 *)((skb)->cb))
< 
406c405,407
< 	skb->queue_mapping = bond_queue_mapping(skb);
---
> 	BUILD_BUG_ON(sizeof(skb->queue_mapping) !=
> 		     sizeof(qdisc_skb_cb(skb)->bond_queue_mapping));
> 	skb->queue_mapping = qdisc_skb_cb(skb)->bond_queue_mapping;
1440a1442,1443
> 	unsigned int gso_max_size = GSO_MAX_SIZE;
> 	u16 gso_max_segs = GSO_MAX_SEGS;
1453a1457,1459
> 
> 		gso_max_size = min(gso_max_size, slave->dev->gso_max_size);
> 		gso_max_segs = min(gso_max_segs, slave->dev->gso_max_segs);
1458a1465,1466
> 	bond_dev->gso_max_segs = gso_max_segs;
> 	netif_set_gso_max_size(bond_dev, gso_max_size);
4243c4251
< 	bond_queue_mapping(skb) = skb->queue_mapping;
---
> 	qdisc_skb_cb(skb)->bond_queue_mapping = skb->queue_mapping;




diff -r linux-3.0.36/drivers/net/bonding/bond_sysfs.c linux-3.0.36-lenovo/drivers/net/bonding/bond_sysfs.c
1526a1527
> 	read_lock(&bond->lock);
1534a1536
> 	read_unlock(&bond->lock);




diff -r linux-3.0.36/drivers/net/caif/caif_serial.c linux-3.0.36-lenovo/drivers/net/caif/caif_serial.c
327a328,330
> 	if (!dev)
> 		return -ENOMEM;
> 




diff -r linux-3.0.36/drivers/net/can/c_can/c_can.c linux-3.0.36-lenovo/drivers/net/can/c_can/c_can.c
595,596c595,596
< 	if (priv->can.ctrlmode & (CAN_CTRLMODE_LISTENONLY &
< 					CAN_CTRLMODE_LOOPBACK)) {
---
> 	if ((priv->can.ctrlmode & CAN_CTRLMODE_LISTENONLY) &&
> 	    (priv->can.ctrlmode & CAN_CTRLMODE_LOOPBACK)) {
919c919
< 		cf->data[2] |= (CAN_ERR_PROT_LOC_ACK |
---
> 		cf->data[3] |= (CAN_ERR_PROT_LOC_ACK |
932c932
< 		cf->data[2] |= (CAN_ERR_PROT_LOC_CRC_SEQ |
---
> 		cf->data[3] |= (CAN_ERR_PROT_LOC_CRC_SEQ |




diff -r linux-3.0.36/drivers/net/can/dev.c linux-3.0.36-lenovo/drivers/net/can/dev.c
560,561c560
< 	if (del_timer_sync(&priv->restart_timer))
< 		dev_put(dev);
---
> 	del_timer_sync(&priv->restart_timer);




diff -r linux-3.0.36/drivers/net/can/janz-ican3.c linux-3.0.36-lenovo/drivers/net/can/janz-ican3.c
1252d1251
< 	u8 val = 1 << mod->num;
1266,1267c1265
< 	iowrite8(val, &mod->ctrl->reset_assert);
< 	iowrite8(val, &mod->ctrl->reset_deassert);
---
> 	iowrite8(0x00, &mod->dpmctrl->hwreset);




diff -r linux-3.0.36/drivers/net/can/mcp251x.c linux-3.0.36-lenovo/drivers/net/can/mcp251x.c
85a86,90
> #define RTS_TXB0		0x01
> #define RTS_TXB1		0x02
> #define RTS_TXB2		0x04
> #define INSTRUCTION_RTS(n)	(0x80 | ((n) & 0x07))
> 
399a405
> 	struct mcp251x_priv *priv = dev_get_drvdata(&spi->dev);
421c427,430
< 	mcp251x_write_reg(spi, TXBCTRL(tx_buf_idx), TXBCTRL_TXREQ);
---
> 
> 	/* use INSTRUCTION_RTS, to avoid "repeated frame problem" */
> 	priv->spi_tx_buf[0] = INSTRUCTION_RTS(1 << tx_buf_idx);
> 	mcp251x_spi_trans(priv->spi, 1);




diff -r linux-3.0.36/drivers/net/can/mscan/mpc5xxx_can.c linux-3.0.36-lenovo/drivers/net/can/mscan/mpc5xxx_can.c
184c184
< 			if (!sys_clk) {
---
> 			if (IS_ERR(sys_clk)) {
207c207
< 			if (!ref_clk) {
---
> 			if (IS_ERR(ref_clk)) {




diff -r linux-3.0.36/drivers/net/can/pch_can.c linux-3.0.36-lenovo/drivers/net/can/pch_can.c
562c562
< 		cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
---
> 		cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |




diff -r linux-3.0.36/drivers/net/can/ti_hecc.c linux-3.0.36-lenovo/drivers/net/can/ti_hecc.c
737c737
< 			cf->data[2] |= CAN_ERR_PROT_LOC_CRC_SEQ |
---
> 			cf->data[3] |= CAN_ERR_PROT_LOC_CRC_SEQ |
742c742
< 			cf->data[2] |= CAN_ERR_PROT_LOC_ACK |
---
> 			cf->data[3] |= CAN_ERR_PROT_LOC_ACK |
971a972
> 	unregister_candev(ndev);
977d977
< 	unregister_candev(ndev);




diff -r linux-3.0.36/drivers/net/davinci_cpdma.c linux-3.0.36-lenovo/drivers/net/davinci_cpdma.c
851a852
> 		chan->count--;




diff -r linux-3.0.36/drivers/net/dm9000.c linux-3.0.36-lenovo/drivers/net/dm9000.c
40a41
> #include <mach/gpio.h>
138d138
< 
313c313
< 	spin_lock_irqsave(&db->lock, flags);
---
> 	spin_lock_irqsave(&db->lock, flags);	
368c368
< 
---
> 	
370c370
< 
---
> 		
380c380
< 
---
> 	
382c382
< 
---
> 	
405,406c405,406
< 
< 	spin_lock_irqsave(&db->lock, flags);
---
> 	
> 	spin_lock_irqsave(&db->lock, flags);	
416c416
< 
---
> 	
875c875
< 
---
> 	
894c894
< 
---
> 	
949,950c949
< 		/* Get most updated data */
< 		rxbyte = readb(db->io_data);
---
> 		udelay(1);//add by lyx@20100713,or dm9000_rx will be error in high frequence
951a951,957
> 		#if 1
> 		/* Get most updated data */		
> 		rxbyte = ior(db, DM9000_MRCMDX);	/* Dummy read */
> 		#else
> 		rxbyte = readb(db->io_data);
> 		#endif
> 		
954a961
> 			#if 0
956a964,966
> 			#else
> 			dm9000_reset(db);
> 			#endif			
962c972
< 
---
> 		
1050c1060
< 	/* holders of db->lock must always block IRQs */
---
> 	/* holders of db->lock must always block IRQs */	
1088c1098
< 
---
> 	
1158c1168
< 	irqflags |= IRQF_SHARED;
---
> 	//irqflags |= IRQF_SHARED;
1208c1218
< 
---
> 	
1255c1265
< 
---
> 	
1273c1283
< 	spin_lock_irqsave(&db->lock,flags);
---
> 	spin_lock_irqsave(&db->lock,flags);	
1447d1456
< 	ndev->irq	= db->irq_res->start;
1448a1458,1479
> 	//io init for dm9000 , modify by lyx@20100809
> 	if (pdata && pdata->io_init) {
> 		if (pdata->io_init()) {
> 			ret = -EINVAL;
> 			goto out;
> 		}
> 	}
> 
> 	if (gpio_request(pdata->irq_pin, "dm9000 interrupt")) {
> 		gpio_free(pdata->irq_pin);
> 		if (pdata->io_deinit)
> 			pdata->io_deinit();
> 		printk("[fun:%s line:%d], request gpio for net interrupt fail\n", __func__,__LINE__);
> 		ret = -EINVAL;
> 		goto out;
> 	}	
> 	gpio_pull_updown(pdata->irq_pin, pdata->irq_pin_value);
> 	gpio_direction_input(pdata->irq_pin);
> 
> 	ndev->irq = gpio_to_irq(pdata->irq_pin);
> 	//ndev->irq = db->irq_res->start;
> 	
1581a1613,1615
> 
> 	dm9000_shutdown(ndev);//add by lyx@20100713, reduce power consume
> 
1648a1683,1688
> 	struct dm9000_plat_data *pdata = pdev->dev.platform_data;
> 
> 	//deinit io for dm9000
> 	gpio_free(pdata->irq_pin);
> 	if (pdata && pdata->io_deinit)
> 		pdata->io_deinit();




diff -r linux-3.0.36/drivers/net/dummy.c linux-3.0.36-lenovo/drivers/net/dummy.c
39a40
> #include <linux/sched.h>
189c190
< 	for (i = 0; i < numdummies && !err; i++)
---
> 	for (i = 0; i < numdummies && !err; i++) {
190a192,193
> 		cond_resched();
> 	}




diff -r linux-3.0.36/drivers/net/e1000e/82571.c linux-3.0.36-lenovo/drivers/net/e1000e/82571.c
1575a1576,1578
> 	/* SYNCH bit and IV bit are sticky */
> 	udelay(10);
> 	rxcw = er32(RXCW);
1602,1603d1604
< 			 * If the partner code word is null, stop forcing
< 			 * and restart auto negotiation.
1605c1606
< 			if ((rxcw & E1000_RXCW_C) || !(rxcw & E1000_RXCW_CW))  {
---
> 			if (rxcw & E1000_RXCW_C) {
2090c2091,2092
< 				  | FLAG2_DISABLE_ASPM_L0S,
---
> 				  | FLAG2_DISABLE_ASPM_L0S
> 				  | FLAG2_DISABLE_ASPM_L1,




diff -r linux-3.0.36/drivers/net/enc28j60.c linux-3.0.36-lenovo/drivers/net/enc28j60.c
30a31
> #include <mach/gpio.h>
33a35
> #define MAC_INT_PORT	RK2818_PIN_PE2
1549c1551,1554
< 
---
> 	unsigned long req_flags = IRQF_TRIGGER_FALLING;
> 	int gpioToIrq = gpio_to_irq (MAC_INT_PORT);
> 	
> 	gpio_request(MAC_INT_PORT, "DRV_NAME");
1588c1593,1599
< 	ret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);
---
> 	gpio_pull_updown(MAC_INT_PORT, GPIOPullUp);	
> 	if(gpioToIrq != -1)
> 		ret = request_irq(gpioToIrq, enc28j60_irq,req_flags, "DRV_NAME", priv);
> 	else
> 		ret = -1;
> 		
> 	///ret = request_irq(spi->irq, enc28j60_irq, 0, DRV_NAME, priv);




diff -r linux-3.0.36/drivers/net/igb/igb_main.c linux-3.0.36-lenovo/drivers/net/igb/igb_main.c
4524c4524
< 		u32 rqdpc_tmp = rd32(E1000_RQDPC(i)) & 0x0FFF;
---
> 		u32 rqdpc = rd32(E1000_RQDPC(i));
4527,4528c4527,4530
< 		ring->rx_stats.drops += rqdpc_tmp;
< 		net_stats->rx_fifo_errors += rqdpc_tmp;
---
> 		if (rqdpc) {
> 			ring->rx_stats.drops += rqdpc;
> 			net_stats->rx_fifo_errors += rqdpc;
> 		}
Only in linux-3.0.36-lenovo/drivers/net/irda: bu92725guw.c
Only in linux-3.0.36-lenovo/drivers/net/irda: bu92725guw.h
Only in linux-3.0.36-lenovo/drivers/net/irda: ir_serial.c
Only in linux-3.0.36-lenovo/drivers/net/irda: ir_serial.h




diff -r linux-3.0.36/drivers/net/irda/Kconfig linux-3.0.36-lenovo/drivers/net/irda/Kconfig
399a400,422
> config RK_IRDA
> 	tristate "rockchip rk29 IrDA"
> 	depends on IRDA && RK29_SMC
> 	help
> 	  Say Y or M here if you want to build support for the rk29
> 	  built-in IRDA interface which can support both SIR, MIR and FIR.
> 
> choice
> 	depends on RK_IRDA
> 	prompt "irda device driver"
> config RK_IRDA_UART
> 	bool "uses irda as a serial device"
> config RK_IRDA_NET
> 	bool "uses irda as a network device"
> endchoice
> 
> choice
> 	depends on RK_IRDA
> 	prompt "irda module select"
> config BU92725GUW
> 	bool "bu92725guw"
> endchoice
> 




diff -r linux-3.0.36/drivers/net/irda/Makefile linux-3.0.36-lenovo/drivers/net/irda/Makefile
41a42,44
> obj-$(CONFIG_RK_IRDA_UART)           += ir_serial.o
> obj-$(CONFIG_RK_IRDA_NET)           += rk29_ir.o
> obj-$(CONFIG_BU92725GUW)        += bu92725guw.o
Only in linux-3.0.36-lenovo/drivers/net/irda: rk29_ir.c
Only in linux-3.0.36-lenovo/drivers/net/irda: rk29_ir.h




diff -r linux-3.0.36/drivers/net/irda/sir_dev.c linux-3.0.36-lenovo/drivers/net/irda/sir_dev.c
224c224
< 			if (dev->dongle_drv->reset) {
---
> 			if (dev->dongle_drv->set_speed) {




diff -r linux-3.0.36/drivers/net/ixgbe/ixgbe_82599.c linux-3.0.36-lenovo/drivers/net/ixgbe/ixgbe_82599.c
362a363,364
> 	case IXGBE_DEV_ID_82599EN_SFP:
> 	case IXGBE_DEV_ID_82599_SFP_SF_QP:




diff -r linux-3.0.36/drivers/net/ixgbe/ixgbe_common.c linux-3.0.36-lenovo/drivers/net/ixgbe/ixgbe_common.c
3183a3184
> 	case IXGBE_DEV_ID_X540T1:




diff -r linux-3.0.36/drivers/net/ixgbe/ixgbe_main.c linux-3.0.36-lenovo/drivers/net/ixgbe/ixgbe_main.c
131a132,137
> 	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599EN_SFP),
> 	 board_82599 },
> 	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_82599_SFP_SF_QP),
> 	 board_82599 },
> 	{PCI_VDEVICE(INTEL, IXGBE_DEV_ID_X540T1),
> 	 board_X540 },




diff -r linux-3.0.36/drivers/net/ixgbe/ixgbe_type.h linux-3.0.36-lenovo/drivers/net/ixgbe/ixgbe_type.h
61a62
> #define IXGBE_DEV_ID_82599EN_SFP         0x1557
65a67
> #define IXGBE_DEV_ID_82599_SFP_SF_QP     0x154A
66a69
> #define IXGBE_DEV_ID_X540T1              0x1560




diff -r linux-3.0.36/drivers/net/Kconfig linux-3.0.36-lenovo/drivers/net/Kconfig
253a254,263
> config RK29_VMAC
> 	tristate "RK29 VMAC ethernet support"
> 	depends on HAS_DMA
> 	select MII
> 	select PHYLIB
> 	select CRC32
> 	help
> 	  MAC device present on rockchip rk29xx 
> 
> 
995a1006,1016
> if DM9000
> choice
>   prompt "choose control"
> 	config DM9000_USE_NAND_CONTROL
> 		tristate "DM9000 with NANDC Interface"
> 
> 	config DM9000_USE_NOR_CONTROL
> 		tristate  "DM9000 with NOR Interface"
> endchoice
> endif
> 	  
3325a3347,3363
> 
> config PPPOLAC
> 	tristate "PPP on L2TP Access Concentrator"
> 	depends on PPP && INET
> 	help
> 	  L2TP (RFC 2661) is a tunneling protocol widely used in virtual private
> 	  networks. This driver handles L2TP data packets between a UDP socket
> 	  and a PPP channel, but only permits one session per socket. Thus it is
> 	  fairly simple and suited for clients.
> 
> config PPPOPNS
> 	tristate "PPP on PPTP Network Server"
> 	depends on PPP && INET
> 	help
> 	  PPTP (RFC 2637) is a tunneling protocol widely used in virtual private
> 	  networks. This driver handles PPTP data packets between a RAW socket
> 	  and a PPP channel. It is fairly simple and easy to use.




diff -r linux-3.0.36/drivers/net/loopback.c linux-3.0.36-lenovo/drivers/net/loopback.c
80a81,85
> 	/* Before queueing this packet to netif_rx(),
> 	 * make sure dst is refcounted.
> 	 */
> 	skb_dst_force(skb);
> 




diff -r linux-3.0.36/drivers/net/Makefile linux-3.0.36-lenovo/drivers/net/Makefile
141a142
> obj-$(CONFIG_RK29_VMAC) += rk29_vmac.o
170a172,173
> obj-$(CONFIG_PPPOLAC) += pppox.o pppolac.o
> obj-$(CONFIG_PPPOPNS) += pppox.o pppopns.o




diff -r linux-3.0.36/drivers/net/ne.c linux-3.0.36-lenovo/drivers/net/ne.c
816a817
> 	SET_NETDEV_DEV(dev, &pdev->dev);




diff -r linux-3.0.36/drivers/net/netconsole.c linux-3.0.36-lenovo/drivers/net/netconsole.c
655d654
< 					netconsole_target_put(nt);




diff -r linux-3.0.36/drivers/net/netxen/netxen_nic_main.c linux-3.0.36-lenovo/drivers/net/netxen/netxen_nic_main.c
1290a1291,1294
> 	/* root bus? */
> 	if (!root)
> 		return;
> 




diff -r linux-3.0.36/drivers/net/pppoe.c linux-3.0.36-lenovo/drivers/net/pppoe.c
579c579
< 	if (sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND)) {
---
> 	if (sk->sk_state & (PPPOX_CONNECTED | PPPOX_BOUND | PPPOX_ZOMBIE)) {
Only in linux-3.0.36-lenovo/drivers/net: pppolac.c
Only in linux-3.0.36-lenovo/drivers/net: pppopns.c




diff -r linux-3.0.36/drivers/net/r8169.c linux-3.0.36-lenovo/drivers/net/r8169.c
61,62c61,66
< #define TX_BUFFS_AVAIL(tp) \
< 	(tp->dirty_tx + NUM_TX_DESC - tp->cur_tx - 1)
---
> #define TX_SLOTS_AVAIL(tp) \
> 	(tp->dirty_tx + NUM_TX_DESC - tp->cur_tx)
> 
> /* A skbuff with nr_frags needs nr_frags+1 entries in the tx queue */
> #define TX_FRAGS_READY_FOR(tp,nr_frags) \
> 	(TX_SLOTS_AVAIL(tp) >= (nr_frags + 1))
74c78
< #define TX_DMA_BURST	6	/* Maximum PCI burst, '6' is 1024 */
---
> #define TX_DMA_BURST	7	/* Maximum PCI burst, '7' is unlimited */
143,144c147,159
< #define _R(NAME,TD,FW) \
< 	{ .name = NAME, .txd_version = TD, .fw_name = FW }
---
> #define JUMBO_1K	ETH_DATA_LEN
> #define JUMBO_4K	(4*1024 - ETH_HLEN - 2)
> #define JUMBO_6K	(6*1024 - ETH_HLEN - 2)
> #define JUMBO_7K	(7*1024 - ETH_HLEN - 2)
> #define JUMBO_9K	(9*1024 - ETH_HLEN - 2)
> 
> #define _R(NAME,TD,FW,SZ,B) {	\
> 	.name = NAME,		\
> 	.txd_version = TD,	\
> 	.fw_name = FW,		\
> 	.jumbo_max = SZ,	\
> 	.jumbo_tx_csum = B	\
> }
149a165,166
> 	u16 jumbo_max;
> 	bool jumbo_tx_csum;
153c170
< 		_R("RTL8169",		RTL_TD_0, NULL),
---
> 		_R("RTL8169",		RTL_TD_0, NULL, JUMBO_7K, true),
155c172
< 		_R("RTL8169s",		RTL_TD_0, NULL),
---
> 		_R("RTL8169s",		RTL_TD_0, NULL, JUMBO_7K, true),
157c174
< 		_R("RTL8110s",		RTL_TD_0, NULL),
---
> 		_R("RTL8110s",		RTL_TD_0, NULL, JUMBO_7K, true),
159c176
< 		_R("RTL8169sb/8110sb",	RTL_TD_0, NULL),
---
> 		_R("RTL8169sb/8110sb",	RTL_TD_0, NULL, JUMBO_7K, true),
161c178
< 		_R("RTL8169sc/8110sc",	RTL_TD_0, NULL),
---
> 		_R("RTL8169sc/8110sc",	RTL_TD_0, NULL, JUMBO_7K, true),
163c180
< 		_R("RTL8169sc/8110sc",	RTL_TD_0, NULL),
---
> 		_R("RTL8169sc/8110sc",	RTL_TD_0, NULL, JUMBO_7K, true),
166c183
< 		_R("RTL8102e",		RTL_TD_1, NULL),
---
> 		_R("RTL8102e",		RTL_TD_1, NULL, JUMBO_1K, true),
168c185
< 		_R("RTL8102e",		RTL_TD_1, NULL),
---
> 		_R("RTL8102e",		RTL_TD_1, NULL, JUMBO_1K, true),
170c187
< 		_R("RTL8102e",		RTL_TD_1, NULL),
---
> 		_R("RTL8102e",		RTL_TD_1, NULL, JUMBO_1K, true),
172c189
< 		_R("RTL8101e",		RTL_TD_0, NULL),
---
> 		_R("RTL8101e",		RTL_TD_0, NULL, JUMBO_1K, true),
174c191
< 		_R("RTL8168b/8111b",	RTL_TD_0, NULL),
---
> 		_R("RTL8168b/8111b",	RTL_TD_0, NULL, JUMBO_4K, false),
176c193
< 		_R("RTL8168b/8111b",	RTL_TD_0, NULL),
---
> 		_R("RTL8168b/8111b",	RTL_TD_0, NULL, JUMBO_4K, false),
178c195
< 		_R("RTL8101e",		RTL_TD_0, NULL),
---
> 		_R("RTL8101e",		RTL_TD_0, NULL, JUMBO_1K, true),
180c197
< 		_R("RTL8100e",		RTL_TD_0, NULL),
---
> 		_R("RTL8100e",		RTL_TD_0, NULL, JUMBO_1K, true),
182c199
< 		_R("RTL8100e",		RTL_TD_0, NULL),
---
> 		_R("RTL8100e",		RTL_TD_0, NULL, JUMBO_1K, true),
184c201
< 		_R("RTL8101e",		RTL_TD_0, NULL),
---
> 		_R("RTL8101e",		RTL_TD_0, NULL, JUMBO_1K, true),
186c203
< 		_R("RTL8168b/8111b",	RTL_TD_0, NULL),
---
> 		_R("RTL8168b/8111b",	RTL_TD_1, NULL, JUMBO_4K, false),
188c205
< 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL, JUMBO_6K, false),
190c207
< 		_R("RTL8168c/8111c",	RTL_TD_1, NULL),
---
> 		_R("RTL8168c/8111c",	RTL_TD_1, NULL, JUMBO_6K, false),
192c209
< 		_R("RTL8168c/8111c",	RTL_TD_1, NULL),
---
> 		_R("RTL8168c/8111c",	RTL_TD_1, NULL, JUMBO_6K, false),
194c211
< 		_R("RTL8168c/8111c",	RTL_TD_1, NULL),
---
> 		_R("RTL8168c/8111c",	RTL_TD_1, NULL, JUMBO_6K, false),
196c213
< 		_R("RTL8168c/8111c",	RTL_TD_1, NULL),
---
> 		_R("RTL8168c/8111c",	RTL_TD_1, NULL, JUMBO_6K, false),
198c215
< 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL, JUMBO_6K, false),
200c217
< 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168cp/8111cp",	RTL_TD_1, NULL, JUMBO_6K, false),
202c219,220
< 		_R("RTL8168d/8111d",	RTL_TD_1, FIRMWARE_8168D_1),
---
> 		_R("RTL8168d/8111d",	RTL_TD_1, FIRMWARE_8168D_1,
> 							JUMBO_9K, false),
204c222,223
< 		_R("RTL8168d/8111d",	RTL_TD_1, FIRMWARE_8168D_2),
---
> 		_R("RTL8168d/8111d",	RTL_TD_1, FIRMWARE_8168D_2,
> 							JUMBO_9K, false),
206c225
< 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL, JUMBO_9K, false),
208c227
< 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL, JUMBO_9K, false),
210c229,230
< 		_R("RTL8105e",		RTL_TD_1, FIRMWARE_8105E_1),
---
> 		_R("RTL8105e",		RTL_TD_1, FIRMWARE_8105E_1,
> 							JUMBO_1K, true),
212c232,233
< 		_R("RTL8105e",		RTL_TD_1, FIRMWARE_8105E_1),
---
> 		_R("RTL8105e",		RTL_TD_1, FIRMWARE_8105E_1,
> 							JUMBO_1K, true),
214c235
< 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL),
---
> 		_R("RTL8168dp/8111dp",	RTL_TD_1, NULL, JUMBO_9K, false),
216c237,238
< 		_R("RTL8168e/8111e",	RTL_TD_1, FIRMWARE_8168E_1),
---
> 		_R("RTL8168e/8111e",	RTL_TD_1, FIRMWARE_8168E_1,
> 							JUMBO_9K, false),
218c240,241
< 		_R("RTL8168e/8111e",	RTL_TD_1, FIRMWARE_8168E_2)
---
> 		_R("RTL8168e/8111e",	RTL_TD_1, FIRMWARE_8168E_2,
> 							JUMBO_9K, false)
282a306,307
> #define PME_SIGNAL			(1 << 5)	/* 8168c and later */
> 
390a416
> 	RxBOVF	= (1 << 24),
431d456
< 	MSIEnable	= (1 << 5),	/* Enable Message Signaled Interrupt */
438a464
> 	MSIEnable	= (1 << 5),	/* 8169 only. Reserved in the 8168. */
444a471
> 	Jumbo_En0	= (1 << 2),	/* 8168 only. Reserved in the 8168b */
446a474,476
> 	/* Config4 register */
> 	Jumbo_En1	= (1 << 1),	/* 8168 only. Reserved in the 8168b */
> 
654a685,689
> 	struct jumbo_ops {
> 		void (*enable)(struct rtl8169_private *);
> 		void (*disable)(struct rtl8169_private *);
> 	} jumbo_ops;
> 
668a704
> 	u32 opts1_mask;
707a744,758
> static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
> {
> 	struct net_device *dev = pci_get_drvdata(pdev);
> 	struct rtl8169_private *tp = netdev_priv(dev);
> 	int cap = tp->pcie_cap;
> 
> 	if (cap) {
> 		u16 ctl;
> 
> 		pci_read_config_word(pdev, cap + PCI_EXP_DEVCTL, &ctl);
> 		ctl = (ctl & ~PCI_EXP_DEVCTL_READRQ) | force;
> 		pci_write_config_word(pdev, cap + PCI_EXP_DEVCTL, ctl);
> 	}
> }
> 
1046c1097
< static void rtl8169_irq_mask_and_ack(void __iomem *ioaddr)
---
> static void rtl8169_irq_mask_and_ack(struct rtl8169_private *tp)
1048c1099
< 	RTL_W16(IntrMask, 0x0000);
---
> 	void __iomem *ioaddr = tp->mmio_addr;
1050c1101,1103
< 	RTL_W16(IntrStatus, 0xffff);
---
> 	RTL_W16(IntrMask, 0x0000);
> 	RTL_W16(IntrStatus, tp->intr_event);
> 	RTL_R8(ChipCmd);
1053c1106
< static void rtl8169_asic_down(void __iomem *ioaddr)
---
> static void rtl8169_asic_down(struct rtl8169_private *tp)
1054a1108,1109
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
1056c1111
< 	rtl8169_irq_mask_and_ack(ioaddr);
---
> 	rtl8169_irq_mask_and_ack(tp);
1115c1170
< 			pm_schedule_suspend(&tp->pci_dev->dev, 100);
---
> 			pm_schedule_suspend(&tp->pci_dev->dev, 5000);
1177d1231
< 		{ WAKE_ANY,   Config1, PMEnable },
1184a1239
> 	u8 options;
1189c1244
< 		u8 options = RTL_R8(cfg[i].reg) & ~cfg[i].mask;
---
> 		options = RTL_R8(cfg[i].reg) & ~cfg[i].mask;
1194a1250,1264
> 	switch (tp->mac_version) {
> 	case RTL_GIGA_MAC_VER_01 ... RTL_GIGA_MAC_VER_17:
> 		options = RTL_R8(Config1) & ~PMEnable;
> 		if (wolopts)
> 			options |= PMEnable;
> 		RTL_W8(Config1, options);
> 		break;
> 	default:
> 		options = RTL_R8(Config2) & ~PME_SIGNAL;
> 		if (wolopts)
> 			options |= PME_SIGNAL;
> 		RTL_W8(Config2, options);
> 		break;
> 	}
> 
1375a1446,1447
> 	struct rtl8169_private *tp = netdev_priv(dev);
> 
1378a1451,1454
> 	if (dev->mtu > JUMBO_1K &&
> 	    !rtl_chip_infos[tp->mac_version].jumbo_tx_csum)
> 		features &= ~NETIF_F_IP_CSUM;
> 
2951c3027
< static unsigned rtl_try_msi(struct pci_dev *pdev, void __iomem *ioaddr,
---
> static unsigned rtl_try_msi(struct rtl8169_private *tp,
2953a3030
> 	void __iomem *ioaddr = tp->mmio_addr;
2959,2960c3036,3037
< 		if (pci_enable_msi(pdev)) {
< 			dev_info(&pdev->dev, "no MSI. Back to INTx.\n");
---
> 		if (pci_enable_msi(tp->pci_dev)) {
> 			netif_info(tp, hw, tp->dev, "no MSI. Back to INTx.\n");
2966c3043,3044
< 	RTL_W8(Config2, cfg2);
---
> 	if (tp->mac_version <= RTL_GIGA_MAC_VER_06)
> 		RTL_W8(Config2, cfg2);
3129,3130c3207,3210
< 		RTL_W32(RxConfig, RTL_R32(RxConfig) |
< 			AcceptBroadcast | AcceptMulticast | AcceptMyPhys);
---
> 		if (tp->mac_version == RTL_GIGA_MAC_VER_32 ||
> 		    tp->mac_version == RTL_GIGA_MAC_VER_33)
> 			RTL_W32(RxConfig, RTL_R32(RxConfig) | AcceptBroadcast |
> 				AcceptMulticast | AcceptMyPhys);
3175,3176c3255,3256
< static void rtl_pll_power_op(struct rtl8169_private *tp,
< 			     void (*op)(struct rtl8169_private *))
---
> static void rtl_generic_op(struct rtl8169_private *tp,
> 			   void (*op)(struct rtl8169_private *))
3184c3264
< 	rtl_pll_power_op(tp, tp->pll_power_ops.down);
---
> 	rtl_generic_op(tp, tp->pll_power_ops.down);
3189c3269
< 	rtl_pll_power_op(tp, tp->pll_power_ops.up);
---
> 	rtl_generic_op(tp, tp->pll_power_ops.up);
3235a3316,3458
> static void rtl_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	rtl_generic_op(tp, tp->jumbo_ops.enable);
> }
> 
> static void rtl_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	rtl_generic_op(tp, tp->jumbo_ops.disable);
> }
> 
> static void r8168c_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	RTL_W8(Config3, RTL_R8(Config3) | Jumbo_En0);
> 	RTL_W8(Config4, RTL_R8(Config4) | Jumbo_En1);
> 	rtl_tx_performance_tweak(tp->pci_dev, 0x2 << MAX_READ_REQUEST_SHIFT);
> }
> 
> static void r8168c_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	RTL_W8(Config3, RTL_R8(Config3) & ~Jumbo_En0);
> 	RTL_W8(Config4, RTL_R8(Config4) & ~Jumbo_En1);
> 	rtl_tx_performance_tweak(tp->pci_dev, 0x5 << MAX_READ_REQUEST_SHIFT);
> }
> 
> static void r8168dp_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	RTL_W8(Config3, RTL_R8(Config3) | Jumbo_En0);
> }
> 
> static void r8168dp_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	RTL_W8(Config3, RTL_R8(Config3) & ~Jumbo_En0);
> }
> 
> static void r8168e_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 	struct pci_dev *pdev = tp->pci_dev;
> 
> 	RTL_W8(MaxTxPacketSize, 0x3f);
> 	RTL_W8(Config3, RTL_R8(Config3) | Jumbo_En0);
> 	RTL_W8(Config4, RTL_R8(Config4) | 0x01);
> 	pci_write_config_byte(pdev, 0x79, 0x20);
> }
> 
> static void r8168e_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 	struct pci_dev *pdev = tp->pci_dev;
> 
> 	RTL_W8(MaxTxPacketSize, 0x0c);
> 	RTL_W8(Config3, RTL_R8(Config3) & ~Jumbo_En0);
> 	RTL_W8(Config4, RTL_R8(Config4) & ~0x01);
> 	pci_write_config_byte(pdev, 0x79, 0x50);
> }
> 
> static void r8168b_0_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	rtl_tx_performance_tweak(tp->pci_dev,
> 		(0x2 << MAX_READ_REQUEST_SHIFT) | PCI_EXP_DEVCTL_NOSNOOP_EN);
> }
> 
> static void r8168b_0_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	rtl_tx_performance_tweak(tp->pci_dev,
> 		(0x5 << MAX_READ_REQUEST_SHIFT) | PCI_EXP_DEVCTL_NOSNOOP_EN);
> }
> 
> static void r8168b_1_hw_jumbo_enable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	r8168b_0_hw_jumbo_enable(tp);
> 
> 	RTL_W8(Config4, RTL_R8(Config4) | (1 << 0));
> }
> 
> static void r8168b_1_hw_jumbo_disable(struct rtl8169_private *tp)
> {
> 	void __iomem *ioaddr = tp->mmio_addr;
> 
> 	r8168b_0_hw_jumbo_disable(tp);
> 
> 	RTL_W8(Config4, RTL_R8(Config4) & ~(1 << 0));
> }
> 
> static void __devinit rtl_init_jumbo_ops(struct rtl8169_private *tp)
> {
> 	struct jumbo_ops *ops = &tp->jumbo_ops;
> 
> 	switch (tp->mac_version) {
> 	case RTL_GIGA_MAC_VER_11:
> 		ops->disable	= r8168b_0_hw_jumbo_disable;
> 		ops->enable	= r8168b_0_hw_jumbo_enable;
> 		break;
> 	case RTL_GIGA_MAC_VER_12:
> 	case RTL_GIGA_MAC_VER_17:
> 		ops->disable	= r8168b_1_hw_jumbo_disable;
> 		ops->enable	= r8168b_1_hw_jumbo_enable;
> 		break;
> 	case RTL_GIGA_MAC_VER_18: /* Wild guess. Needs info from Realtek. */
> 	case RTL_GIGA_MAC_VER_19:
> 	case RTL_GIGA_MAC_VER_20:
> 	case RTL_GIGA_MAC_VER_21: /* Wild guess. Needs info from Realtek. */
> 	case RTL_GIGA_MAC_VER_22:
> 	case RTL_GIGA_MAC_VER_23:
> 	case RTL_GIGA_MAC_VER_24:
> 	case RTL_GIGA_MAC_VER_25:
> 	case RTL_GIGA_MAC_VER_26:
> 		ops->disable	= r8168c_hw_jumbo_disable;
> 		ops->enable	= r8168c_hw_jumbo_enable;
> 		break;
> 	case RTL_GIGA_MAC_VER_27:
> 	case RTL_GIGA_MAC_VER_28:
> 		ops->disable	= r8168dp_hw_jumbo_disable;
> 		ops->enable	= r8168dp_hw_jumbo_enable;
> 		break;
> 	case RTL_GIGA_MAC_VER_31: /* Wild guess. Needs info from Realtek. */
> 	case RTL_GIGA_MAC_VER_32:
> 	case RTL_GIGA_MAC_VER_33:
> 		ops->disable	= r8168e_hw_jumbo_disable;
> 		ops->enable	= r8168e_hw_jumbo_enable;
> 		break;
> 
> 	/*
> 	 * No action needed for jumbo frames with 8169.
> 	 * No jumbo for 810x at all.
> 	 */
> 	default:
> 		ops->disable	= NULL;
> 		ops->enable	= NULL;
> 		break;
> 	}
> }
> 
3376a3600
> 	rtl_init_jumbo_ops(tp);
3390c3614
< 	tp->features |= rtl_try_msi(pdev, ioaddr, cfg);
---
> 	tp->features |= rtl_try_msi(tp, cfg);
3442a3667,3669
> 	tp->opts1_mask = (tp->mac_version != RTL_GIGA_MAC_VER_01) ?
> 		~(RxBOVF | RxFOVF) : ~0;
> 
3457a3685,3690
> 	if (rtl_chip_infos[chipset].jumbo_max != JUMBO_1K) {
> 		netif_info(tp, probe, dev, "jumbo features [frames: %d bytes, "
> 			   "tx checksumming: %s]\n",
> 			   rtl_chip_infos[chipset].jumbo_max,
> 			   rtl_chip_infos[chipset].jumbo_tx_csum ? "ok" : "ko");
> 	}
3475a3709
> 	netif_napi_del(&tp->napi);
3500a3735,3736
> 	netif_napi_del(&tp->napi);
> 
3614c3850
< 	rtl8169_irq_mask_and_ack(ioaddr);
---
> 	rtl8169_irq_mask_and_ack(tp);
3782,3796d4017
< static void rtl_tx_performance_tweak(struct pci_dev *pdev, u16 force)
< {
< 	struct net_device *dev = pci_get_drvdata(pdev);
< 	struct rtl8169_private *tp = netdev_priv(dev);
< 	int cap = tp->pcie_cap;
< 
< 	if (cap) {
< 		u16 ctl;
< 
< 		pci_read_config_word(pdev, cap + PCI_EXP_DEVCTL, &ctl);
< 		ctl = (ctl & ~PCI_EXP_DEVCTL_READRQ) | force;
< 		pci_write_config_word(pdev, cap + PCI_EXP_DEVCTL, ctl);
< 	}
< }
< 
4096,4097c4317
< 	if (tp->mac_version == RTL_GIGA_MAC_VER_11 ||
< 	    tp->mac_version == RTL_GIGA_MAC_VER_22) {
---
> 	if (tp->mac_version == RTL_GIGA_MAC_VER_11) {
4278a4499,4503
> 	if (tp->mac_version >= RTL_GIGA_MAC_VER_30) {
> 		tp->intr_event &= ~RxFIFOOver;
> 		tp->napi_event &= ~RxFIFOOver;
> 	}
> 
4339c4564,4567
< 	if (new_mtu < ETH_ZLEN || new_mtu > SafeMtu)
---
> 	struct rtl8169_private *tp = netdev_priv(dev);
> 
> 	if (new_mtu < ETH_ZLEN ||
> 	    new_mtu > rtl_chip_infos[tp->mac_version].jumbo_max)
4341a4570,4574
> 	if (new_mtu > ETH_DATA_LEN)
> 		rtl_hw_jumbo_enable(tp);
> 	else
> 		rtl_hw_jumbo_disable(tp);
> 
4542c4775
< 	rtl8169_irq_mask_and_ack(ioaddr);
---
> 	rtl8169_irq_mask_and_ack(tp);
4701c4934
< 	if (unlikely(TX_BUFFS_AVAIL(tp) < skb_shinfo(skb)->nr_frags)) {
---
> 	if (unlikely(!TX_FRAGS_READY_FOR(tp, skb_shinfo(skb)->nr_frags))) {
4749c4982
< 	if (TX_BUFFS_AVAIL(tp) < MAX_SKB_FRAGS) {
---
> 	if (!TX_FRAGS_READY_FOR(tp, MAX_SKB_FRAGS)) {
4751,4752c4984,4985
< 		smp_rmb();
< 		if (TX_BUFFS_AVAIL(tp) >= MAX_SKB_FRAGS)
---
> 		smp_mb();
> 		if (TX_FRAGS_READY_FOR(tp, MAX_SKB_FRAGS))
4852c5085
< 		smp_wmb();
---
> 		smp_mb();
4854c5087
< 		    (TX_BUFFS_AVAIL(tp) >= MAX_SKB_FRAGS)) {
---
> 		    TX_FRAGS_READY_FOR(tp, MAX_SKB_FRAGS)) {
4863d5095
< 		smp_rmb();
4921c5153
< 		status = le32_to_cpu(desc->opts1);
---
> 		status = le32_to_cpu(desc->opts1) & tp->opts1_mask;
4941c5173
< 			int pkt_size = (status & 0x00001FFF) - 4;
---
> 			int pkt_size = (status & 0x00003fff) - 4;
4974,4980d5205
< 
< 		/* Work around for AMD plateform. */
< 		if ((desc->opts2 & cpu_to_le32(0xfffe000)) &&
< 		    (tp->mac_version == RTL_GIGA_MAC_VER_05)) {
< 			desc->opts2 = 0;
< 			cur_rx++;
< 		}
5003a5229,5232
> 		status &= tp->intr_event;
> 		if (!status)
> 			break;
> 
5010c5239
< 			rtl8169_asic_down(ioaddr);
---
> 			rtl8169_asic_down(tp);
5018,5019d5246
< 			case RTL_GIGA_MAC_VER_22:
< 			case RTL_GIGA_MAC_VER_26:
5023,5038d5249
< 			/* Testers needed. */
< 			case RTL_GIGA_MAC_VER_17:
< 			case RTL_GIGA_MAC_VER_19:
< 			case RTL_GIGA_MAC_VER_20:
< 			case RTL_GIGA_MAC_VER_21:
< 			case RTL_GIGA_MAC_VER_23:
< 			case RTL_GIGA_MAC_VER_24:
< 			case RTL_GIGA_MAC_VER_27:
< 			case RTL_GIGA_MAC_VER_28:
< 			case RTL_GIGA_MAC_VER_31:
< 			/* Experimental science. Pktgen proof. */
< 			case RTL_GIGA_MAC_VER_12:
< 			case RTL_GIGA_MAC_VER_25:
< 				if (status == RxFIFOOver)
< 					goto done;
< 				break;
5133c5344
< 	rtl8169_asic_down(ioaddr);
---
> 	rtl8169_asic_down(tp);
5378a5590,5592
> 	struct device *d = &pdev->dev;
> 
> 	pm_runtime_get_sync(d);
5387c5601
< 	rtl8169_asic_down(ioaddr);
---
> 	rtl8169_asic_down(tp);
5392,5393c5606,5610
< 		/* WoL fails with some 8168 when the receiver is disabled. */
< 		if (tp->features & RTL_FEATURE_WOL) {
---
> 		/* WoL fails with 8168b when the receiver is disabled. */
> 		if ((tp->mac_version == RTL_GIGA_MAC_VER_11 ||
> 		     tp->mac_version == RTL_GIGA_MAC_VER_12 ||
> 		     tp->mac_version == RTL_GIGA_MAC_VER_17) &&
> 		    (tp->features & RTL_FEATURE_WOL)) {
5403a5621,5622
> 
> 	pm_runtime_put_noidle(d);
Only in linux-3.0.36-lenovo/drivers/net: rk29_vmac.c
Only in linux-3.0.36-lenovo/drivers/net: rk29_vmac.h




diff -r linux-3.0.36/drivers/net/sfc/efx.c linux-3.0.36-lenovo/drivers/net/sfc/efx.c
1385a1386,1390
> 	BUILD_BUG_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_RXQ_MIN_ENT);
> 	if (WARN_ON(EFX_DEFAULT_DMAQ_SIZE < EFX_TXQ_MIN_ENT(efx))) {
> 		rc = -EINVAL;
> 		goto fail3;
> 	}
1944a1950
> 	net_dev->gso_max_segs = EFX_TSO_MAX_SEGS;




diff -r linux-3.0.36/drivers/net/sfc/efx.h linux-3.0.36-lenovo/drivers/net/sfc/efx.h
40a41
> extern unsigned int efx_tx_max_skb_descs(struct efx_nic *efx);
63,66c64,72
< /* The smallest [rt]xq_entries that the driver supports. Callers of
<  * efx_wake_queue() assume that they can subsequently send at least one
<  * skb. Falcon/A1 may require up to three descriptors per skb_frag. */
< #define EFX_MIN_RING_SIZE (roundup_pow_of_two(2 * 3 * MAX_SKB_FRAGS))
---
> /* Maximum number of TCP segments we support for soft-TSO */
> #define EFX_TSO_MAX_SEGS	100
> 
> /* The smallest [rt]xq_entries that the driver supports.  RX minimum
>  * is a bit arbitrary.  For TX, we must have space for at least 2
>  * TSO skbs.
>  */
> #define EFX_RXQ_MIN_ENT		128U
> #define EFX_TXQ_MIN_ENT(efx)	(2 * efx_tx_max_skb_descs(efx))




diff -r linux-3.0.36/drivers/net/sfc/ethtool.c linux-3.0.36-lenovo/drivers/net/sfc/ethtool.c
679a680
> 	u32 txq_entries;
686,687c687
< 	if (ring->rx_pending < EFX_MIN_RING_SIZE ||
< 	    ring->tx_pending < EFX_MIN_RING_SIZE) {
---
> 	if (ring->rx_pending < EFX_RXQ_MIN_ENT) {
689,690c689,690
< 			  "TX and RX queues cannot be smaller than %ld\n",
< 			  EFX_MIN_RING_SIZE);
---
> 			  "RX queues cannot be smaller than %u\n",
> 			  EFX_RXQ_MIN_ENT);
694c694,700
< 	return efx_realloc_channels(efx, ring->rx_pending, ring->tx_pending);
---
> 	txq_entries = max(ring->tx_pending, EFX_TXQ_MIN_ENT(efx));
> 	if (txq_entries != ring->tx_pending)
> 		netif_warn(efx, drv, efx->net_dev,
> 			   "increasing TX queue size to minimum of %u\n",
> 			   txq_entries);
> 
> 	return efx_realloc_channels(efx, ring->rx_pending, txq_entries);




diff -r linux-3.0.36/drivers/net/sfc/nic.h linux-3.0.36-lenovo/drivers/net/sfc/nic.h
67a68,72
> /* Alignment of PCIe DMA boundaries (4KB) */
> #define EFX_PAGE_SIZE	4096
> /* Size and alignment of buffer table entries (same) */
> #define EFX_BUF_SIZE	EFX_PAGE_SIZE
> 




diff -r linux-3.0.36/drivers/net/sfc/tx.c linux-3.0.36-lenovo/drivers/net/sfc/tx.c
117a118,136
> unsigned int efx_tx_max_skb_descs(struct efx_nic *efx)
> {
> 	/* Header and payload descriptor for each output segment, plus
> 	 * one for every input fragment boundary within a segment
> 	 */
> 	unsigned int max_descs = EFX_TSO_MAX_SEGS * 2 + MAX_SKB_FRAGS;
> 
> 	/* Possibly one more per segment for the alignment workaround */
> 	if (EFX_WORKAROUND_5391(efx))
> 		max_descs += EFX_TSO_MAX_SEGS;
> 
> 	/* Possibly more for PCIe page boundaries within input fragments */
> 	if (PAGE_SIZE > EFX_PAGE_SIZE)
> 		max_descs += max_t(unsigned int, MAX_SKB_FRAGS,
> 				   DIV_ROUND_UP(GSO_MAX_SIZE, EFX_PAGE_SIZE));
> 
> 	return max_descs;
> }
> 




diff -r linux-3.0.36/drivers/net/skge.c linux-3.0.36-lenovo/drivers/net/skge.c
4099a4100,4106
> 	{
> 		.ident = "ASUS P5NSLI",
> 		.matches = {
> 			DMI_MATCH(DMI_BOARD_VENDOR, "ASUSTeK Computer INC."),
> 			DMI_MATCH(DMI_BOARD_NAME, "P5NSLI")
> 		},
> 	},




diff -r linux-3.0.36/drivers/net/sky2.c linux-3.0.36-lenovo/drivers/net/sky2.c
2932c2932,2933
< 	if (status == 0 || status == ~0)
---
> 	if (status == 0 || status == ~0) {
> 		sky2_write32(hw, B0_Y2_SP_ICR, 2);
2933a2935
> 	}
4209,4212c4211,4216
< 	if (changed & NETIF_F_RXCSUM) {
< 		u32 on = features & NETIF_F_RXCSUM;
< 		sky2_write32(sky2->hw, Q_ADDR(rxqaddr[sky2->port], Q_CSR),
< 			     on ? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);
---
> 	if ((changed & NETIF_F_RXCSUM) &&
> 	    !(sky2->hw->flags & SKY2_HW_NEW_LE)) {
> 		sky2_write32(sky2->hw,
> 			     Q_ADDR(rxqaddr[sky2->port], Q_CSR),
> 			     (features & NETIF_F_RXCSUM)
> 			     ? BMU_ENA_RX_CHKSUM : BMU_DIS_RX_CHKSUM);




diff -r linux-3.0.36/drivers/net/tg3.c linux-3.0.36-lenovo/drivers/net/tg3.c
999,1006c999,1018
< #define TG3_PHY_AUXCTL_SMDSP_ENABLE(tp) \
< 	tg3_phy_auxctl_write((tp), MII_TG3_AUXCTL_SHDWSEL_AUXCTL, \
< 			     MII_TG3_AUXCTL_ACTL_SMDSP_ENA | \
< 			     MII_TG3_AUXCTL_ACTL_TX_6DB)
< 
< #define TG3_PHY_AUXCTL_SMDSP_DISABLE(tp) \
< 	tg3_phy_auxctl_write((tp), MII_TG3_AUXCTL_SHDWSEL_AUXCTL, \
< 			     MII_TG3_AUXCTL_ACTL_TX_6DB);
---
> static int tg3_phy_toggle_auxctl_smdsp(struct tg3 *tp, bool enable)
> {
> 	u32 val;
> 	int err;
> 
> 	err = tg3_phy_auxctl_read(tp, MII_TG3_AUXCTL_SHDWSEL_AUXCTL, &val);
> 
> 	if (err)
> 		return err;
> 	if (enable)
> 
> 		val |= MII_TG3_AUXCTL_ACTL_SMDSP_ENA;
> 	else
> 		val &= ~MII_TG3_AUXCTL_ACTL_SMDSP_ENA;
> 
> 	err = tg3_phy_auxctl_write((tp), MII_TG3_AUXCTL_SHDWSEL_AUXCTL,
> 				   val | MII_TG3_AUXCTL_ACTL_TX_6DB);
> 
> 	return err;
> }
1778c1790
< 	if (TG3_PHY_AUXCTL_SMDSP_ENABLE(tp))
---
> 	if (tg3_phy_toggle_auxctl_smdsp(tp, true))
1803c1815
< 	TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 	tg3_phy_toggle_auxctl_smdsp(tp, false);
1851c1863
< 	    !TG3_PHY_AUXCTL_SMDSP_ENABLE(tp)) {
---
> 	    !tg3_phy_toggle_auxctl_smdsp(tp, true)) {
1853c1865
< 		TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 		tg3_phy_toggle_auxctl_smdsp(tp, false);
1998c2010
< 		err = TG3_PHY_AUXCTL_SMDSP_ENABLE(tp);
---
> 		err = tg3_phy_toggle_auxctl_smdsp(tp, true);
2019c2031
< 	TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 	tg3_phy_toggle_auxctl_smdsp(tp, false);
2108c2120
< 	    !TG3_PHY_AUXCTL_SMDSP_ENABLE(tp)) {
---
> 	    !tg3_phy_toggle_auxctl_smdsp(tp, true)) {
2111c2123
< 		TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 		tg3_phy_toggle_auxctl_smdsp(tp, false);
2120c2132
< 		if (!TG3_PHY_AUXCTL_SMDSP_ENABLE(tp)) {
---
> 		if (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {
2124c2136
< 			TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 			tg3_phy_toggle_auxctl_smdsp(tp, false);
2127c2139
< 		if (!TG3_PHY_AUXCTL_SMDSP_ENABLE(tp)) {
---
> 		if (!tg3_phy_toggle_auxctl_smdsp(tp, true)) {
2136c2148
< 			TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 			tg3_phy_toggle_auxctl_smdsp(tp, false);
2984c2996
< 	err = TG3_PHY_AUXCTL_SMDSP_ENABLE(tp);
---
> 	err = tg3_phy_toggle_auxctl_smdsp(tp, true);
3011c3023
< 		err2 = TG3_PHY_AUXCTL_SMDSP_DISABLE(tp);
---
> 		err2 = tg3_phy_toggle_auxctl_smdsp(tp, false);
5664a5677,5679
> 	if (tg3_irq_sync(tp))
> 		return;
> 
13650c13665,13669
< 	    (tp->fw_needed && !tg3_flag(tp, ENABLE_ASF)))
---
> 	    tp->fw_needed) {
> 		/* For firmware TSO, assume ASF is disabled.
> 		 * We'll disable TSO later if we discover ASF
> 		 * is enabled in tg3_get_eeprom_hw_cfg().
> 		 */
13652c13671
< 	else {
---
> 	} else {
13688,13689c13707,13709
< 	if (tg3_flag(tp, 5755_PLUS))
< 		tg3_flag_set(tp, SHORT_DMA_BUG);
---
> 	if (tg3_flag(tp, 5755_PLUS) ||
> 		GET_ASIC_REV(tp->pci_chip_rev_id) == ASIC_REV_5906)
> 			tg3_flag_set(tp, SHORT_DMA_BUG);
13889a13910,13915
> 	if (tp->fw_needed && tg3_flag(tp, ENABLE_ASF)) {
> 		tg3_flag_clear(tp, TSO_CAPABLE);
> 		tg3_flag_clear(tp, TSO_BUG);
> 		tp->fw_needed = NULL;
> 	}
> 
14972a14999
> 	tp->irq_sync = 1;




diff -r linux-3.0.36/drivers/net/tun.c linux-3.0.36-lenovo/drivers/net/tun.c
1242c1242,1248
< 	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89)
---
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> 	if (cmd != TUNGETIFF && !capable(CAP_NET_ADMIN)) {
> 		return -EPERM;
> 	}
> #endif
> 
> 	if (cmd == TUNSETIFF || _IOC_TYPE(cmd) == 0x89) {
1245c1251,1253
< 
---
> 	} else {
> 		memset(&ifr, 0, sizeof(ifr));
> 	}




diff -r linux-3.0.36/drivers/net/usb/asix.c linux-3.0.36-lenovo/drivers/net/usb/asix.c
3c3
<  * Copyright (C) 2003-2006 David Hollis <dhollis@davehollis.com>
---
>  * Copyright (C) 2003-2005 David Hollis <dhollis@davehollis.com>
5d4
<  * Copyright (C) 2006 James Painter <jamie.painter@iname.com>
23,24c22
< // #define	DEBUG			// error path messages, extra info
< // #define	VERBOSE			// more; success messages
---
> //#define	DEBUG			// debug messages, extra info
25a24,28
> #include <linux/version.h>
> //#include <linux/config.h>
> #ifdef	CONFIG_USB_DEBUG
> #   define DEBUG
> #endif
27a31
> #include <linux/sched.h>
36,37d39
< #include <linux/usb/usbnet.h>
< #include <linux/slab.h>
39,40c41,42
< #define DRIVER_VERSION "14-Jun-2006"
< static const char driver_name [] = "asix";
---
> #include "axusbnet.c"
> #include "asix.h"
42c44
< /* ASIX AX8817X based USB 2.0 Ethernet Devices */
---
> #define DRV_VERSION	"4.1.1"
44,174c46,66
< #define AX_CMD_SET_SW_MII		0x06
< #define AX_CMD_READ_MII_REG		0x07
< #define AX_CMD_WRITE_MII_REG		0x08
< #define AX_CMD_SET_HW_MII		0x0a
< #define AX_CMD_READ_EEPROM		0x0b
< #define AX_CMD_WRITE_EEPROM		0x0c
< #define AX_CMD_WRITE_ENABLE		0x0d
< #define AX_CMD_WRITE_DISABLE		0x0e
< #define AX_CMD_READ_RX_CTL		0x0f
< #define AX_CMD_WRITE_RX_CTL		0x10
< #define AX_CMD_READ_IPG012		0x11
< #define AX_CMD_WRITE_IPG0		0x12
< #define AX_CMD_WRITE_IPG1		0x13
< #define AX_CMD_READ_NODE_ID		0x13
< #define AX_CMD_WRITE_NODE_ID		0x14
< #define AX_CMD_WRITE_IPG2		0x14
< #define AX_CMD_WRITE_MULTI_FILTER	0x16
< #define AX88172_CMD_READ_NODE_ID	0x17
< #define AX_CMD_READ_PHY_ID		0x19
< #define AX_CMD_READ_MEDIUM_STATUS	0x1a
< #define AX_CMD_WRITE_MEDIUM_MODE	0x1b
< #define AX_CMD_READ_MONITOR_MODE	0x1c
< #define AX_CMD_WRITE_MONITOR_MODE	0x1d
< #define AX_CMD_READ_GPIOS		0x1e
< #define AX_CMD_WRITE_GPIOS		0x1f
< #define AX_CMD_SW_RESET			0x20
< #define AX_CMD_SW_PHY_STATUS		0x21
< #define AX_CMD_SW_PHY_SELECT		0x22
< 
< #define AX_MONITOR_MODE			0x01
< #define AX_MONITOR_LINK			0x02
< #define AX_MONITOR_MAGIC		0x04
< #define AX_MONITOR_HSFS			0x10
< 
< /* AX88172 Medium Status Register values */
< #define AX88172_MEDIUM_FD		0x02
< #define AX88172_MEDIUM_TX		0x04
< #define AX88172_MEDIUM_FC		0x10
< #define AX88172_MEDIUM_DEFAULT \
< 		( AX88172_MEDIUM_FD | AX88172_MEDIUM_TX | AX88172_MEDIUM_FC )
< 
< #define AX_MCAST_FILTER_SIZE		8
< #define AX_MAX_MCAST			64
< 
< #define AX_SWRESET_CLEAR		0x00
< #define AX_SWRESET_RR			0x01
< #define AX_SWRESET_RT			0x02
< #define AX_SWRESET_PRTE			0x04
< #define AX_SWRESET_PRL			0x08
< #define AX_SWRESET_BZ			0x10
< #define AX_SWRESET_IPRL			0x20
< #define AX_SWRESET_IPPD			0x40
< 
< #define AX88772_IPG0_DEFAULT		0x15
< #define AX88772_IPG1_DEFAULT		0x0c
< #define AX88772_IPG2_DEFAULT		0x12
< 
< /* AX88772 & AX88178 Medium Mode Register */
< #define AX_MEDIUM_PF		0x0080
< #define AX_MEDIUM_JFE		0x0040
< #define AX_MEDIUM_TFC		0x0020
< #define AX_MEDIUM_RFC		0x0010
< #define AX_MEDIUM_ENCK		0x0008
< #define AX_MEDIUM_AC		0x0004
< #define AX_MEDIUM_FD		0x0002
< #define AX_MEDIUM_GM		0x0001
< #define AX_MEDIUM_SM		0x1000
< #define AX_MEDIUM_SBP		0x0800
< #define AX_MEDIUM_PS		0x0200
< #define AX_MEDIUM_RE		0x0100
< 
< #define AX88178_MEDIUM_DEFAULT	\
< 	(AX_MEDIUM_PS | AX_MEDIUM_FD | AX_MEDIUM_AC | \
< 	 AX_MEDIUM_RFC | AX_MEDIUM_TFC | AX_MEDIUM_JFE | \
< 	 AX_MEDIUM_RE )
< 
< #define AX88772_MEDIUM_DEFAULT	\
< 	(AX_MEDIUM_FD | AX_MEDIUM_RFC | \
< 	 AX_MEDIUM_TFC | AX_MEDIUM_PS | \
< 	 AX_MEDIUM_AC | AX_MEDIUM_RE )
< 
< /* AX88772 & AX88178 RX_CTL values */
< #define AX_RX_CTL_SO			0x0080
< #define AX_RX_CTL_AP			0x0020
< #define AX_RX_CTL_AM			0x0010
< #define AX_RX_CTL_AB			0x0008
< #define AX_RX_CTL_SEP			0x0004
< #define AX_RX_CTL_AMALL			0x0002
< #define AX_RX_CTL_PRO			0x0001
< #define AX_RX_CTL_MFB_2048		0x0000
< #define AX_RX_CTL_MFB_4096		0x0100
< #define AX_RX_CTL_MFB_8192		0x0200
< #define AX_RX_CTL_MFB_16384		0x0300
< 
< #define AX_DEFAULT_RX_CTL	\
< 	(AX_RX_CTL_SO | AX_RX_CTL_AB )
< 
< /* GPIO 0 .. 2 toggles */
< #define AX_GPIO_GPO0EN		0x01	/* GPIO0 Output enable */
< #define AX_GPIO_GPO_0		0x02	/* GPIO0 Output value */
< #define AX_GPIO_GPO1EN		0x04	/* GPIO1 Output enable */
< #define AX_GPIO_GPO_1		0x08	/* GPIO1 Output value */
< #define AX_GPIO_GPO2EN		0x10	/* GPIO2 Output enable */
< #define AX_GPIO_GPO_2		0x20	/* GPIO2 Output value */
< #define AX_GPIO_RESERVED	0x40	/* Reserved */
< #define AX_GPIO_RSE		0x80	/* Reload serial EEPROM */
< 
< #define AX_EEPROM_MAGIC		0xdeadbeef
< #define AX88172_EEPROM_LEN	0x40
< #define AX88772_EEPROM_LEN	0xff
< 
< #define PHY_MODE_MARVELL	0x0000
< #define MII_MARVELL_LED_CTRL	0x0018
< #define MII_MARVELL_STATUS	0x001b
< #define MII_MARVELL_CTRL	0x0014
< 
< #define MARVELL_LED_MANUAL	0x0019
< 
< #define MARVELL_STATUS_HWCFG	0x0004
< 
< #define MARVELL_CTRL_TXDELAY	0x0002
< #define MARVELL_CTRL_RXDELAY	0x0080
< 
< /* This structure cannot exceed sizeof(unsigned long [5]) AKA 20 bytes */
< struct asix_data {
< 	u8 multi_filter[AX_MCAST_FILTER_SIZE];
< 	u8 mac_addr[ETH_ALEN];
< 	u8 phymode;
< 	u8 ledmode;
< 	u8 eeprom_len;
< };
---
> static char version[] =
> KERN_INFO "ASIX USB Ethernet Adapter:v" DRV_VERSION 
> 	" " __TIME__ " " __DATE__ "\n"
> KERN_INFO "    http://www.asix.com.tw\n";
> 
> /* configuration of maximum bulk in size */
> static int bsize = AX88772B_MAX_BULKIN_2K;
> module_param (bsize, int, 0);
> MODULE_PARM_DESC (bsize, "Maximum transfer size per bulk");
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> static void ax88772b_link_reset (void *data);
> static void ax88772a_link_reset (void *data);
> static void ax88772_link_reset (void *data);
> #else
> static void ax88772b_link_reset (struct work_struct *work);
> static void ax88772a_link_reset (struct work_struct *work);
> static void ax88772_link_reset (struct work_struct *work);
> #endif
> static int ax88772a_phy_powerup (struct usbnet *dev);
> #define  TAG "AX88xx------>"
176,182c68
< struct ax88172_int_data {
< 	__le16 res1;
< 	u8 link;
< 	__le16 res2;
< 	u8 status;
< 	__le16 res3;
< } __packed;
---
> /* ASIX AX8817X based USB 2.0 Ethernet Devices */
184c70
< static int asix_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
---
> static int ax8817x_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
187,197c73
< 	void *buf;
< 	int err = -ENOMEM;
< 
< 	netdev_dbg(dev->net, "asix_read_cmd() cmd=0x%02x value=0x%04x index=0x%04x size=%d\n",
< 		   cmd, value, index, size);
< 
< 	buf = kmalloc(size, GFP_KERNEL);
< 	if (!buf)
< 		goto out;
< 
< 	err = usb_control_msg(
---
> 	return usb_control_msg(
204c80
< 		buf,
---
> 		data,
207,214d82
< 	if (err == size)
< 		memcpy(data, buf, size);
< 	else if (err >= 0)
< 		err = -EINVAL;
< 	kfree(buf);
< 
< out:
< 	return err;
217c85
< static int asix_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
---
> static int ax8817x_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
220,232c88
< 	void *buf = NULL;
< 	int err = -ENOMEM;
< 
< 	netdev_dbg(dev->net, "asix_write_cmd() cmd=0x%02x value=0x%04x index=0x%04x size=%d\n",
< 		   cmd, value, index, size);
< 
< 	if (data) {
< 		buf = kmemdup(data, size, GFP_KERNEL);
< 		if (!buf)
< 			goto out;
< 	}
< 
< 	err = usb_control_msg(
---
> 	return usb_control_msg(
239c95
< 		buf,
---
> 		data,
242,245d97
< 	kfree(buf);
< 
< out:
< 	return err;
248c100,104
< static void asix_async_cmd_callback(struct urb *urb)
---
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> static void ax8817x_async_cmd_callback(struct urb *urb, struct pt_regs *regs)
> #else
> static void ax8817x_async_cmd_callback(struct urb *urb)
> #endif
251d106
< 	int status = urb->status;
253,255c108,110
< 	if (status < 0)
< 		printk(KERN_DEBUG "asix_async_cmd_callback() failed with %d",
< 			status);
---
> 	if (urb->status < 0)
> 		printk(KERN_DEBUG "ax8817x_async_cmd_callback() failed with %d",
> 			urb->status);
261,263c116
< static void
< asix_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
< 				    u16 size, void *data)
---
> static int ax8817x_set_mac_addr (struct net_device *net, void *p)
265,280c118,119
< 	struct usb_ctrlrequest *req;
< 	int status;
< 	struct urb *urb;
< 
< 	netdev_dbg(dev->net, "asix_write_cmd_async() cmd=0x%02x value=0x%04x index=0x%04x size=%d\n",
< 		   cmd, value, index, size);
< 	if ((urb = usb_alloc_urb(0, GFP_ATOMIC)) == NULL) {
< 		netdev_err(dev->net, "Error allocating URB in write_cmd_async!\n");
< 		return;
< 	}
< 
< 	if ((req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC)) == NULL) {
< 		netdev_err(dev->net, "Failed to allocate memory for control request\n");
< 		usb_free_urb(urb);
< 		return;
< 	}
---
> 	struct usbnet *dev = netdev_priv(net);
> 	struct sockaddr *addr = p;
282,286c121
< 	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
< 	req->bRequest = cmd;
< 	req->wValue = cpu_to_le16(value);
< 	req->wIndex = cpu_to_le16(index);
< 	req->wLength = cpu_to_le16(size);
---
> 	memcpy (net->dev_addr, addr->sa_data, ETH_ALEN);
288,291c123,125
< 	usb_fill_control_urb(urb, dev->udev,
< 			     usb_sndctrlpipe(dev->udev, 0),
< 			     (void *)req, data, size,
< 			     asix_async_cmd_callback, req);
---
> 	/* Set the MAC address */
> 	return ax8817x_write_cmd (dev, AX88772_CMD_WRITE_NODE_ID,
> 			   0, 0, ETH_ALEN, net->dev_addr);
293,298d126
< 	if((status = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
< 		netdev_err(dev->net, "Error submitting the control message: status=%d\n",
< 			   status);
< 		kfree(req);
< 		usb_free_urb(urb);
< 	}
301c129
< static int asix_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
---
> static void ax88178_status(struct usbnet *dev, struct urb *urb)
303,344c131,133
< 	u8  *head;
< 	u32  header;
< 	char *packet;
< 	struct sk_buff *ax_skb;
< 	u16 size;
< 
< 	head = (u8 *) skb->data;
< 	memcpy(&header, head, sizeof(header));
< 	le32_to_cpus(&header);
< 	packet = head + sizeof(header);
< 
< 	skb_pull(skb, 4);
< 
< 	while (skb->len > 0) {
< 		if ((header & 0x07ff) != ((~header >> 16) & 0x07ff))
< 			netdev_err(dev->net, "asix_rx_fixup() Bad Header Length\n");
< 
< 		/* get the packet length */
< 		size = (u16) (header & 0x000007ff);
< 
< 		if ((skb->len) - ((size + 1) & 0xfffe) == 0) {
< 			u8 alignment = (unsigned long)skb->data & 0x3;
< 			if (alignment != 0x2) {
< 				/*
< 				 * not 16bit aligned so use the room provided by
< 				 * the 32 bit header to align the data
< 				 *
< 				 * note we want 16bit alignment as MAC header is
< 				 * 14bytes thus ip header will be aligned on
< 				 * 32bit boundary so accessing ipheader elements
< 				 * using a cast to struct ip header wont cause
< 				 * an unaligned accesses.
< 				 */
< 				u8 realignment = (alignment + 2) & 0x3;
< 				memmove(skb->data - realignment,
< 					skb->data,
< 					size);
< 				skb->data -= realignment;
< 				skb_set_tail_pointer(skb, size);
< 			}
< 			return 2;
< 		}
---
> 	struct ax88172_int_data *event;
> 	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
> 	int link;
346,354c135,136
< 		if (size > dev->net->mtu + ETH_HLEN) {
< 			netdev_err(dev->net, "asix_rx_fixup() Bad RX Length %d\n",
< 				   size);
< 			return 0;
< 		}
< 		ax_skb = skb_clone(skb, GFP_ATOMIC);
< 		if (ax_skb) {
< 			u8 alignment = (unsigned long)packet & 0x3;
< 			ax_skb->len = size;
---
> 	if (urb->actual_length < 8)
> 		return;
356,370c138,139
< 			if (alignment != 0x2) {
< 				/*
< 				 * not 16bit aligned use the room provided by
< 				 * the 32 bit header to align the data
< 				 */
< 				u8 realignment = (alignment + 2) & 0x3;
< 				memmove(packet - realignment, packet, size);
< 				packet -= realignment;
< 			}
< 			ax_skb->data = packet;
< 			skb_set_tail_pointer(ax_skb, size);
< 			usbnet_skb_return(dev, ax_skb);
< 		} else {
< 			return 0;
< 		}
---
> 	if (ax178dataptr->EepromData == PHY_MODE_MAC_TO_MAC_GMII)
> 		return;
372c141,151
< 		skb_pull(skb, (size + 1) & 0xfffe);
---
> 	event = urb->transfer_buffer;
> 	link = event->link & 0x01;
> 	if (netif_carrier_ok(dev->net) != link) {
> 		if (link) {
> 			netif_carrier_on(dev->net);
> 			axusbnet_defer_kevent (dev, EVENT_LINK_RESET);
> 		} else
> 			netif_carrier_off(dev->net);
> 		devwarn(dev, "ax88178 - Link status is: %d", link);
> 	}
> }
374,375c153,156
< 		if (skb->len < sizeof(header))
< 			break;
---
> static void ax8817x_status(struct usbnet *dev, struct urb *urb)
> {
> 	struct ax88172_int_data *event;
> 	int link;
377,382c158,159
< 		head = (u8 *) skb->data;
< 		memcpy(&header, head, sizeof(header));
< 		le32_to_cpus(&header);
< 		packet = head + sizeof(header);
< 		skb_pull(skb, 4);
< 	}
---
> 	if (urb->actual_length < 8)
> 		return;
384,387c161,169
< 	if (skb->len < 0) {
< 		netdev_err(dev->net, "asix_rx_fixup() Bad SKB Length %d\n",
< 			   skb->len);
< 		return 0;
---
> 	event = urb->transfer_buffer;
> 	link = event->link & 0x01;
> 	if (netif_carrier_ok(dev->net) != link) {
> 		if (link) {
> 			netif_carrier_on(dev->net);
> 			axusbnet_defer_kevent (dev, EVENT_LINK_RESET );
> 		} else
> 			netif_carrier_off(dev->net);
> 		devwarn(dev, "ax8817x - Link status is: %d", link);
389d170
< 	return 1;
392,393c173
< static struct sk_buff *asix_tx_fixup(struct usbnet *dev, struct sk_buff *skb,
< 					gfp_t flags)
---
> static void ax88772_status(struct usbnet *dev, struct urb *urb)
395,401c175,180
< 	int padlen;
< 	int headroom = skb_headroom(skb);
< 	int tailroom = skb_tailroom(skb);
< 	u32 packet_len;
< 	u32 padbytes = 0xffff0000;
< 
< 	padlen = ((skb->len + 4) & (dev->maxpacket - 1)) ? 0 : 4;
---
> 	struct ax88172_int_data *event;
> 	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
> 	int link;
> 	
> 	if (urb->actual_length < 8)
> 		return;
403,407c182,194
< 	if ((!skb_cloned(skb)) &&
< 	    ((headroom + tailroom) >= (4 + padlen))) {
< 		if ((headroom < 4) || (tailroom < padlen)) {
< 			skb->data = memmove(skb->head + 4, skb->data, skb->len);
< 			skb_set_tail_pointer(skb, skb->len);
---
> 	event = urb->transfer_buffer;
> 	link = event->link & 0x01;
> 	
> 	if (netif_carrier_ok(dev->net) != link) {
> 		if (link) {
> 			netif_carrier_on(dev->net);
> 			ax772_data->Event = AX_SET_RX_CFG;
> 		} else {
> 			netif_carrier_off(dev->net);
> 			if (ax772_data->Event == AX_NOP) {
> 				ax772_data->Event = PHY_POWER_DOWN;
> 				ax772_data->TickToExpire = 25;
> 			}
409,421d195
< 	} else {
< 		struct sk_buff *skb2;
< 		skb2 = skb_copy_expand(skb, 4, padlen, flags);
< 		dev_kfree_skb_any(skb);
< 		skb = skb2;
< 		if (!skb)
< 			return NULL;
< 	}
< 
< 	skb_push(skb, 4);
< 	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
< 	cpu_to_le32s(&packet_len);
< 	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
423,426c197
< 	if (padlen) {
< 		cpu_to_le32s(&padbytes);
< 		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
< 		skb_put(skb, sizeof(padbytes));
---
> 		devwarn(dev, "ax88772 - Link status is: %d", link);
428c199,201
< 	return skb;
---
> 	
> 	if (ax772_data->Event)
> 		queue_work (ax772_data->ax_work, &ax772_data->check_link);
431c204
< static void asix_status(struct usbnet *dev, struct urb *urb)
---
> static void ax88772a_status(struct usbnet *dev, struct urb *urb)
433a207
> 	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
434a209
> 	int PowSave = (ax772a_data->EepromData >> 14);
440a216
> 
441a218
> 
444,445c221,222
< 			usbnet_defer_kevent (dev, EVENT_LINK_RESET );
< 		} else
---
> 			ax772a_data->Event = AX_SET_RX_CFG;
> 		} else if ((PowSave == 0x3) || (PowSave == 0x1)) {
447,458c224,231
< 		netdev_dbg(dev->net, "Link Status is: %d\n", link);
< 	}
< }
< 
< static inline int asix_set_sw_mii(struct usbnet *dev)
< {
< 	int ret;
< 	ret = asix_write_cmd(dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to enable software MII access\n");
< 	return ret;
< }
---
> 			if (ax772a_data->Event == AX_NOP) {
> 				ax772a_data->Event = CHK_CABLE_EXIST;
> 				ax772a_data->TickToExpire = 31;//14;
> 			}
> 		} else {
> 			netif_carrier_off(dev->net);
> 			ax772a_data->Event = AX_NOP;
> 		}
460,466c233,237
< static inline int asix_set_hw_mii(struct usbnet *dev)
< {
< 	int ret;
< 	ret = asix_write_cmd(dev, AX_CMD_SET_HW_MII, 0x0000, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to enable hardware MII access\n");
< 	return ret;
---
> 		devwarn(dev, "ax88772a - Link status is: %d", link);
> 	}
> 	
> 	if (ax772a_data->Event)
> 		queue_work (ax772a_data->ax_work, &ax772a_data->check_link);
469c240
< static inline int asix_get_phy_addr(struct usbnet *dev)
---
> static void ax88772b_status(struct usbnet *dev, struct urb *urb)
471,472c242,244
< 	u8 buf[2];
< 	int ret = asix_read_cmd(dev, AX_CMD_READ_PHY_ID, 0, 0, 2, buf);
---
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 	struct ax88172_int_data *event;
> 	int link;
474c246,247
< 	netdev_dbg(dev->net, "asix_get_phy_addr()\n");
---
> 	if (urb->actual_length < 8)
> 		return;
476,478c249,259
< 	if (ret < 0) {
< 		netdev_err(dev->net, "Error reading PHYID register: %02x\n", ret);
< 		goto out;
---
> 	event = urb->transfer_buffer;
> 	link = event->link & AX_INT_PPLS_LINK;
> 	if (netif_carrier_ok(dev->net) != link) {
> 		if (link) {
> 			netif_carrier_on(dev->net);
> 			ax772b_data->Event = AX_SET_RX_CFG;
> 		} else {
> 			netif_carrier_off(dev->net);
> 			ax772b_data->time_to_chk = jiffies;
> 		}
> 		devwarn(dev, "ax88772b - Link status is: %d", link);
480,482d260
< 	netdev_dbg(dev->net, "asix_get_phy_addr() returning 0x%04x\n",
< 		   *((__le16 *)buf));
< 	ret = buf[1];
484,486c262
< out:
< 	return ret;
< }
---
> 	if (!link) {
488,490c264
< static int asix_sw_reset(struct usbnet *dev, u8 flags)
< {
< 	int ret;
---
> 		int no_cable = (event->link & AX_INT_CABOFF_UNPLUG) ? 1 : 0;
492,494c266,274
<         ret = asix_write_cmd(dev, AX_CMD_SW_RESET, flags, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to send software reset: %02x\n", ret);
---
> 		if (no_cable) {
> 			if ((ax772b_data->psc & 
> 			    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) &&
> 			     !ax772b_data->pw_enabled) {
> 				/* 
> 				 * AX88772B already entered power saving state
> 				 */
> 				ax772b_data->pw_enabled = 1;
> 			}
496c276,290
< 	return ret;
---
> 		} else {
> 			/* AX88772B resumed from power saving state */
> 			if (ax772b_data->pw_enabled || 
> 				(jiffies > (ax772b_data->time_to_chk + 
> 				 AX88772B_WATCHDOG))) {
> 				if (ax772b_data->pw_enabled)
> 					ax772b_data->pw_enabled = 0;
> 				ax772b_data->Event = PHY_POWER_UP;
> 				ax772b_data->time_to_chk = jiffies;
> 			}
> 		}
> 	}
> 
> 	if (ax772b_data->Event)
> 		queue_work (ax772b_data->ax_work, &ax772b_data->check_link);
499c293,295
< static u16 asix_read_rx_ctl(struct usbnet *dev)
---
> static void
> ax8817x_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value, u16 index,
> 				    u16 size, void *data)
501,502c297,299
< 	__le16 v;
< 	int ret = asix_read_cmd(dev, AX_CMD_READ_RX_CTL, 0, 0, 2, &v);
---
> 	struct usb_ctrlrequest *req;
> 	int status;
> 	struct urb *urb;
504,506c301,303
< 	if (ret < 0) {
< 		netdev_err(dev->net, "Error reading RX_CTL register: %02x\n", ret);
< 		goto out;
---
> 	if ((urb = usb_alloc_urb(0, GFP_ATOMIC)) == NULL) {
> 		deverr(dev, "Error allocating URB in write_cmd_async!");
> 		return;
508,515d304
< 	ret = le16_to_cpu(v);
< out:
< 	return ret;
< }
< 
< static int asix_write_rx_ctl(struct usbnet *dev, u16 mode)
< {
< 	int ret;
517,521c306,311
< 	netdev_dbg(dev->net, "asix_write_rx_ctl() - mode = 0x%04x\n", mode);
< 	ret = asix_write_cmd(dev, AX_CMD_WRITE_RX_CTL, mode, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to write RX_CTL mode to 0x%04x: %02x\n",
< 			   mode, ret);
---
> 	if ((req = kmalloc (sizeof (struct usb_ctrlrequest),
> 			    GFP_ATOMIC)) == NULL) {
> 		deverr(dev, "Failed to allocate memory for control request");
> 		usb_free_urb(urb);
> 		return;
> 	}
523,524c313,317
< 	return ret;
< }
---
> 	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
> 	req->bRequest = cmd;
> 	req->wValue = cpu_to_le16(value);
> 	req->wIndex = cpu_to_le16(index);
> 	req->wLength = cpu_to_le16(size);
526,529c319,322
< static u16 asix_read_medium_status(struct usbnet *dev)
< {
< 	__le16 v;
< 	int ret = asix_read_cmd(dev, AX_CMD_READ_MEDIUM_STATUS, 0, 0, 2, &v);
---
> 	usb_fill_control_urb(urb, dev->udev,
> 			     usb_sndctrlpipe(dev->udev, 0),
> 			     (void *)req, data, size,
> 			     ax8817x_async_cmd_callback, req);
531,534c324,328
< 	if (ret < 0) {
< 		netdev_err(dev->net, "Error reading Medium Status register: %02x\n",
< 			   ret);
< 		goto out;
---
> 	if((status = usb_submit_urb(urb, GFP_ATOMIC)) < 0) {
> 		deverr(dev, "Error submitting the control message: status=%d",
> 				status);
> 		kfree(req);
> 		usb_free_urb(urb);
536,538d329
< 	ret = le16_to_cpu(v);
< out:
< 	return ret;
541c332
< static int asix_write_medium_mode(struct usbnet *dev, u16 mode)
---
> static void ax8817x_set_multicast(struct net_device *net)
543,549c334,343
< 	int ret;
< 
< 	netdev_dbg(dev->net, "asix_write_medium_mode() - mode = 0x%04x\n", mode);
< 	ret = asix_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to write Medium Mode mode to 0x%04x: %02x\n",
< 			   mode, ret);
---
> 	struct usbnet *dev = netdev_priv(net);
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	u8 rx_ctl = AX_RX_CTL_START | AX_RX_CTL_AB;
> 	int mc_count;
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
> 	mc_count = net->mc_count;
> #else
> 	mc_count = netdev_mc_count (net);
> #endif
551,552c345,360
< 	return ret;
< }
---
> 	if (net->flags & IFF_PROMISC) {
> 		rx_ctl |= AX_RX_CTL_PRO;
> 	} else if (net->flags & IFF_ALLMULTI
> 		   || mc_count > AX_MAX_MCAST) {
> 		rx_ctl |= AX_RX_CTL_AMALL;
> 	} else if (mc_count == 0) {
> 		/* just broadcast and directed */
> 	} else {
> 		/* We use the 20 byte dev->data
> 		 * for our 8 byte filter buffer
> 		 * to avoid allocating memory that
> 		 * is tricky to free later */
> 		u32 crc_bits;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
> 		struct dev_mc_list *mc_list = net->mc_list;
> 		int i;
554,556c362
< static int asix_write_gpio(struct usbnet *dev, u16 value, int sleep)
< {
< 	int ret;
---
> 		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
558,562c364,383
< 	netdev_dbg(dev->net, "asix_write_gpio() - value = 0x%04x\n", value);
< 	ret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS, value, 0, 0, NULL);
< 	if (ret < 0)
< 		netdev_err(dev->net, "Failed to write GPIO value 0x%04x: %02x\n",
< 			   value, ret);
---
> 		/* Build the multicast hash filter. */
> 		for (i = 0; i < net->mc_count; i++) {
> 			crc_bits =
> 			    ether_crc(ETH_ALEN,
> 				      mc_list->dmi_addr) >> 26;
> 			data->multi_filter[crc_bits >> 3] |=
> 			    1 << (crc_bits & 7);
> 			mc_list = mc_list->next;
> 		}
> #else
> 		struct netdev_hw_addr *ha;
> 		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
> 		netdev_for_each_mc_addr (ha, net) {
> 			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
> 			data->multi_filter[crc_bits >> 3] |=
> 				1 << (crc_bits & 7);
> 		}
> #endif
> 		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
> 				   AX_MCAST_FILTER_SIZE, data->multi_filter);
564,565c385,386
< 	if (sleep)
< 		msleep(sleep);
---
> 		rx_ctl |= AX_RX_CTL_AM;
> 	}
567c388
< 	return ret;
---
> 	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
570,573c391
< /*
<  * AX88772 & AX88178 have a 16-bit RX_CTL value
<  */
< static void asix_set_multicast(struct net_device *net)
---
> static void ax88772b_set_multicast(struct net_device *net)
576,577c394,402
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	u16 rx_ctl = AX_DEFAULT_RX_CTL;
---
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	u16 rx_ctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT);
> 	int mc_count;
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
> 	mc_count = net->mc_count;
> #else
> 	mc_count = netdev_mc_count (net);
> #endif
581,582c406,407
< 	} else if (net->flags & IFF_ALLMULTI ||
< 		   netdev_mc_count(net) > AX_MAX_MCAST) {
---
> 	} else if (net->flags & IFF_ALLMULTI
> 		   || mc_count > AX_MAX_MCAST) {
584c409
< 	} else if (netdev_mc_empty(net)) {
---
> 	} else if (mc_count == 0) {
591d415
< 		struct netdev_hw_addr *ha;
593a418,421
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
> 		struct dev_mc_list *mc_list = net->mc_list;
> 		int i;
> 
597,598c425,428
< 		netdev_for_each_mc_addr(ha, net) {
< 			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
---
> 		for (i = 0; i < net->mc_count; i++) {
> 			crc_bits =
> 			    ether_crc(ETH_ALEN,
> 				      mc_list->dmi_addr) >> 26;
600a431
> 			mc_list = mc_list->next;
602,603c433,442
< 
< 		asix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
---
> #else
> 		struct netdev_hw_addr *ha;
> 		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
> 		netdev_for_each_mc_addr (ha, net) {
> 			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
> 			data->multi_filter[crc_bits >> 3] |=
> 				1 << (crc_bits & 7);
> 		}
> #endif
> 		ax8817x_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
609c448,468
< 	asix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
---
> 	ax8817x_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
> }
> 
> static int ax8817x_mdio_read(struct net_device *netdev, int phy_id, int loc)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	u16 *res;
> 	u16 ret;
> 
> 	res = kmalloc (2, GFP_ATOMIC);
> 	if (!res)
> 		return 0;
> 
> 	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
> 	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id, (__u16)loc, 2, res);
> 	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
> 
> 	ret = *res & 0xffff;
> 	kfree (res);
> 
> 	return ret;
612c471,472
< static int asix_mdio_read(struct net_device *netdev, int phy_id, int loc)
---
> static int 
> ax8817x_swmii_mdio_read(struct net_device *netdev, int phy_id, int loc)
615c475,476
< 	__le16 res;
---
> 	u16 *res;
> 	u16 ret;
617,622c478,489
< 	mutex_lock(&dev->phy_mutex);
< 	asix_set_sw_mii(dev);
< 	asix_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
< 				(__u16)loc, 2, &res);
< 	asix_set_hw_mii(dev);
< 	mutex_unlock(&dev->phy_mutex);
---
> 	res = kmalloc (2, GFP_ATOMIC);
> 	if (!res)
> 		return 0;
> 
> 	ax8817x_read_cmd(dev, AX_CMD_READ_MII_REG, phy_id,
> 				(__u16)loc, 2, res);
> 
> 	ret = *res & 0xffff;
> 	kfree (res);
> 
> 	return ret;
> }
624,625c491,495
< 	netdev_dbg(dev->net, "asix_mdio_read() phy_id=0x%02x, loc=0x%02x, returns=0x%04x\n",
< 		   phy_id, loc, le16_to_cpu(res));
---
> /* same as above, but converts resulting value to cpu byte order */
> static int ax8817x_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
> {
> 	return le16_to_cpu(ax8817x_mdio_read(netdev,phy_id, loc));
> }
627c497,500
< 	return le16_to_cpu(res);
---
> static int 
> ax8817x_swmii_mdio_read_le(struct net_device *netdev, int phy_id, int loc)
> {
> 	return le16_to_cpu(ax8817x_swmii_mdio_read(netdev,phy_id, loc));
631c504
< asix_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
---
> ax8817x_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
634c507,517
< 	__le16 res = cpu_to_le16(val);
---
> 	u16 *res;
> 
> 	res = kmalloc (2, GFP_ATOMIC);
> 	if (!res)
> 		return;
> 	*res = val;
> 
> 	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
> 	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
> 				(__u16)loc, 2, res);
> 	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
636,642c519
< 	netdev_dbg(dev->net, "asix_mdio_write() phy_id=0x%02x, loc=0x%02x, val=0x%04x\n",
< 		   phy_id, loc, val);
< 	mutex_lock(&dev->phy_mutex);
< 	asix_set_sw_mii(dev);
< 	asix_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id, (__u16)loc, 2, &res);
< 	asix_set_hw_mii(dev);
< 	mutex_unlock(&dev->phy_mutex);
---
> 	kfree (res);
645,646c522,523
< /* Get the PHY Identifier from the PHYSID1 & PHYSID2 MII registers */
< static u32 asix_get_phyid(struct usbnet *dev)
---
> static void ax8817x_swmii_mdio_write(struct net_device *netdev, 
> 			int phy_id, int loc, int val)
648,649c525,526
< 	int phy_reg;
< 	u32 phy_id;
---
> 	struct usbnet *dev = netdev_priv(netdev);
> 	u16 *res;
651,653c528,531
< 	phy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID1);
< 	if (phy_reg < 0)
< 		return 0;
---
> 	res = kmalloc (2, GFP_ATOMIC);
> 	if (!res)
> 		return;
> 	*res = val;
655c533,534
< 	phy_id = (phy_reg & 0xffff) << 16;
---
> 	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
> 				(__u16)loc, 2, res);
657,659c536,552
< 	phy_reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_PHYSID2);
< 	if (phy_reg < 0)
< 		return 0;
---
> 	kfree (res);
> }
> 
> static void
> ax88772b_mdio_write(struct net_device *netdev, int phy_id, int loc, int val)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	u16 *res;
> 
> 	res = kmalloc (2, GFP_ATOMIC);
> 	if (!res)
> 		return;
> 	*res = val;
> 
> 	ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII, 0, 0, 0, NULL);
> 	ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
> 				(__u16)loc, 2, res);
661c554,570
< 	phy_id |= (phy_reg & 0xffff);
---
> 	if (loc == MII_ADVERTISE) {
> 		*res = cpu_to_le16(BMCR_ANENABLE | BMCR_ANRESTART);
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_MII_REG, phy_id,
> 				(__u16)MII_BMCR, 2, res);
> 	}
> 
> 	ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
> 
> 	kfree (res);
> }
> 
> /* same as above, but converts new value to le16 byte order before writing */
> static void
> ax8817x_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
> {
> 	ax8817x_mdio_write( netdev, phy_id, loc, cpu_to_le16(val) );
> }
663c572,575
< 	return phy_id;
---
> static void ax8817x_swmii_mdio_write_le(struct net_device *netdev,
> 			int phy_id, int loc, int val)
> {
> 	ax8817x_swmii_mdio_write( netdev, phy_id, loc, cpu_to_le16(val) );
667c579,768
< asix_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
---
> ax88772b_mdio_write_le(struct net_device *netdev, int phy_id, int loc, int val)
> {
> 	ax88772b_mdio_write( netdev, phy_id, loc, cpu_to_le16(val) );
> }
> 
> static int ax88772_suspend (struct usb_interface *intf,
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
> 			pm_message_t message)
> #else
> 			u32 message)
> #endif
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 	u16 *medium;
> 
> 	medium = kmalloc (2, GFP_ATOMIC);
> 	if (!medium)
> 		return axusbnet_suspend (intf, message);
> /*
> 	ax8817x_read_cmd (dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, medium);
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_MEDIUM_MODE,
> 			(*medium & ~AX88772_MEDIUM_RX_ENABLE), 0, 0, NULL);*/
> 
> 	kfree (medium);
> 	return axusbnet_suspend (intf, message);
> }
> 
> static int ax88772b_suspend (struct usb_interface *intf,
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
> 			pm_message_t message)
> #else
> 			u32 message)
> #endif
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 	u16 *tmp16;
> 	u8 *opt;
> 
> 	tmp16 = kmalloc (2, GFP_ATOMIC);
> 	if (!tmp16)
> 		return axusbnet_suspend (intf, message);
> 	opt = (u8 *)tmp16;
>        #if 0
> 	ax8817x_read_cmd (dev, AX_CMD_READ_MEDIUM_MODE, 0, 0, 2, tmp16);
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_MEDIUM_MODE,
> 			(*tmp16 & ~AX88772_MEDIUM_RX_ENABLE), 0, 0, NULL);
> 
> 	ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt);
> 	if (!(*opt & AX_MONITOR_LINK) && !(*opt & AX_MONITOR_MAGIC)) {
> 		ax8817x_write_cmd (dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_IPRL | AX_SWRESET_IPPD, 0, 0, NULL);
> 	} else {
> 
> 		if (ax772b_data->psc & AX_SWRESET_WOLLP) {
> 			*tmp16 = ax8817x_mdio_read_le (dev->net,
> 					dev->mii.phy_id, MII_BMCR);
> 			ax8817x_mdio_write_le (dev->net, dev->mii.phy_id,
> 					MII_BMCR, *tmp16 | BMCR_ANENABLE);
> 
> 			ax8817x_write_cmd (dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPRL | ax772b_data->psc, 0, 0, NULL);
> 		}
> 
> 		if (ax772b_data->psc &
> 		    (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) {
> 			*opt |= AX_MONITOR_LINK;
> 			ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,
> 					*opt, 0, 0, NULL);
> 		}
> 	}
> #endif
> 	kfree (tmp16);
> 	return axusbnet_suspend (intf, message);
> }
> 
> static int ax88772_resume (struct usb_interface *intf)
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 
> 	netif_carrier_off (dev->net);
> 
> 	return axusbnet_resume (intf);
> }
> 
> static int ax88772b_resume (struct usb_interface *intf)
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 	int ret;
> 	void *buf;
> 
> 	buf = kmalloc (6, GFP_KERNEL);
> 
> 	/* Initialize MII structure */
> 	dev->mii.dev = dev->net;
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax88772b_mdio_write_le;
> 	dev->mii.phy_id_mask = 0xff;
> 	dev->mii.reg_num_mask = 0xff;
>        #if 0
> 	/* Get the PHY id */
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,
> 			0, 0, 2, buf)) < 0) {
> 		deverr(dev, "Error reading PHY ID: %02x", ret);
> 		goto err_out;
> 	} else if (ret < 2) {
> 		/* this should always return 2 bytes */
> 		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
> 		    ret);
> 		ret = -EIO;
> 		goto err_out;
> 	}
> 	dev->mii.phy_id = *((u8 *)buf + 1);
> 
> 	if(dev->mii.phy_id != 0x10) {
> 		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
> 		ret = -EIO;
> 		goto err_out;
> 	}
>        #endif
> 	/* select the embedded 10/100 Ethernet PHY */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
> 			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
> 			0, 0, NULL)) < 0) {
> 		deverr(dev, "Select PHY #1 failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	if ((ret = ax88772a_phy_powerup (dev)) < 0)
> 		goto err_out;
>       #if 0
> 	/* stop MAC operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			AX_RX_CTL_STOP, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	/* make sure the driver can enable sw mii operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII,
> 			0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Enabling software MII failed: %d", ret);
> 		goto err_out;
> 	}
> 	#endif
> 	/* Get the PHY id */
> /*	ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,0, 0, 2, buf);
> 	devwarn(dev, "reading PHY ID: %02x", ret);
> 	devwarn(dev, "PHY ID: %02x", *((u8 *)buf + 1));
> 
> 
> 	if (ax772b_data->psc & AX_SWRESET_WOLLP) {
> 		ax8817x_write_cmd (dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPRL | (ax772b_data->psc & 0x7FFF),
> 				0, 0, NULL);
> 	}
> 
> 	if (ax772b_data->psc & (AX_SWRESET_IPPSL_0 | AX_SWRESET_IPPSL_1)) {
> 		ax88772a_phy_powerup (dev);
> 	}
> */
> 	kfree (buf);
> 	netif_carrier_off (dev->net);
> 	return axusbnet_resume (intf);
> 
> err_out:
> 	return axusbnet_resume (intf);
> }
> 
> static int ax88172_link_reset(struct usbnet *dev)
> {
> 	u16 lpa;
> 	u16 adv;
> 	u16 res;
> 	u8 mode;
> 
> 	mode = AX_MEDIUM_TX_ABORT_ALLOW | AX_MEDIUM_FLOW_CONTROL_EN;
> 	lpa = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_LPA);
> 	adv = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, MII_ADVERTISE);
> 	res = mii_nway_result(lpa|adv);
> 	if (res & LPA_DUPLEX)
> 		mode |= AX_MEDIUM_FULL_DUPLEX;
> 	ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, mode, 0, 0, NULL);
> 
> 	return 0;
> }
> 
> static void
> ax8817x_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
670c771,774
< 	u8 opt;
---
> 	u8 *opt;
> 
> 	wolinfo->supported = 0;
> 	wolinfo->wolopts = 0;
672,674c776,777
< 	if (asix_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, &opt) < 0) {
< 		wolinfo->supported = 0;
< 		wolinfo->wolopts = 0;
---
> 	opt = kmalloc (1, GFP_KERNEL);
> 	if (!opt)
676c779,782
< 	}
---
> 
> 	if (ax8817x_read_cmd(dev, AX_CMD_READ_MONITOR_MODE, 0, 0, 1, opt) < 0)
> 		return;
> 
678,684c784,790
< 	wolinfo->wolopts = 0;
< 	if (opt & AX_MONITOR_MODE) {
< 		if (opt & AX_MONITOR_LINK)
< 			wolinfo->wolopts |= WAKE_PHY;
< 		if (opt & AX_MONITOR_MAGIC)
< 			wolinfo->wolopts |= WAKE_MAGIC;
< 	}
---
> 
> 	if (*opt & AX_MONITOR_LINK)
> 		wolinfo->wolopts |= WAKE_PHY;
> 	if (*opt & AX_MONITOR_MAGIC)
> 		wolinfo->wolopts |= WAKE_MAGIC;
> 
> 	kfree (opt);
688c794
< asix_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
---
> ax8817x_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
691c797,801
< 	u8 opt = 0;
---
> 	u8 *opt;
> 
> 	opt = kmalloc (1, GFP_KERNEL);
> 	if (!opt)
> 		return -ENOMEM;
692a803
> 	*opt = 0;
694c805
< 		opt |= AX_MONITOR_LINK;
---
> 		*opt |= AX_MONITOR_LINK;
696,698c807
< 		opt |= AX_MONITOR_MAGIC;
< 	if (opt != 0)
< 		opt |= AX_MONITOR_MODE;
---
> 		*opt |= AX_MONITOR_MAGIC;
700,702c809
< 	if (asix_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE,
< 			      opt, 0, 0, NULL) < 0)
< 		return -EINVAL;
---
> 	ax8817x_write_cmd(dev, AX_CMD_WRITE_MONITOR_MODE, *opt, 0, 0, NULL);
703a811
> 	kfree (opt);
707c815
< static int asix_get_eeprom_len(struct net_device *net)
---
> static int ax8817x_get_eeprom_len(struct net_device *net)
709,712c817
< 	struct usbnet *dev = netdev_priv(net);
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 
< 	return data->eeprom_len;
---
> 	return AX_EEPROM_LEN;
715c820
< static int asix_get_eeprom(struct net_device *net,
---
> static int ax8817x_get_eeprom(struct net_device *net,
719c824
< 	__le16 *ebuf = (__le16 *)data;
---
> 	u16 *ebuf = (u16 *)data;
732c837
< 		if (asix_read_cmd(dev, AX_CMD_READ_EEPROM,
---
> 		if (ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM,
739c844
< static void asix_get_drvinfo (struct net_device *net,
---
> static void ax8817x_get_drvinfo (struct net_device *net,
742,744d846
< 	struct usbnet *dev = netdev_priv(net);
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 
746,749c848,849
< 	usbnet_get_drvinfo(net, info);
< 	strncpy (info->driver, driver_name, sizeof info->driver);
< 	strncpy (info->version, DRIVER_VERSION, sizeof info->version);
< 	info->eedump_len = data->eeprom_len;
---
> 	axusbnet_get_drvinfo(net, info);
> 	info->eedump_len = 0x3e;
752c852
< static u32 asix_get_link(struct net_device *net)
---
> static int ax8817x_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
755,756c855
< 
< 	return mii_link_ok(&dev->mii);
---
> 	return mii_ethtool_gset(&dev->mii,cmd);
759c858
< static int asix_ioctl (struct net_device *net, struct ifreq *rq, int cmd)
---
> static int ax8817x_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
762,787c861
< 
< 	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
< }
< 
< static int asix_set_mac_address(struct net_device *net, void *p)
< {
< 	struct usbnet *dev = netdev_priv(net);
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	struct sockaddr *addr = p;
< 
< 	if (netif_running(net))
< 		return -EBUSY;
< 	if (!is_valid_ether_addr(addr->sa_data))
< 		return -EADDRNOTAVAIL;
< 
< 	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
< 
< 	/* We use the 20 byte dev->data
< 	 * for our 6 byte mac buffer
< 	 * to avoid allocating memory that
< 	 * is tricky to free later */
< 	memcpy(data->mac_addr, addr->sa_data, ETH_ALEN);
< 	asix_write_cmd_async(dev, AX_CMD_WRITE_NODE_ID, 0, 0, ETH_ALEN,
< 							data->mac_addr);
< 
< 	return 0;
---
> 	return mii_ethtool_sset(&dev->mii,cmd);
793,804c867,877
< static const struct ethtool_ops ax88172_ethtool_ops = {
< 	.get_drvinfo		= asix_get_drvinfo,
< 	.get_link		= asix_get_link,
< 	.get_msglevel		= usbnet_get_msglevel,
< 	.set_msglevel		= usbnet_set_msglevel,
< 	.get_wol		= asix_get_wol,
< 	.set_wol		= asix_set_wol,
< 	.get_eeprom_len		= asix_get_eeprom_len,
< 	.get_eeprom		= asix_get_eeprom,
< 	.get_settings		= usbnet_get_settings,
< 	.set_settings		= usbnet_set_settings,
< 	.nway_reset		= usbnet_nway_reset,
---
> static struct ethtool_ops ax8817x_ethtool_ops = {
> 	.get_drvinfo		= ax8817x_get_drvinfo,
> 	.get_link		= ethtool_op_get_link,
> 	.get_msglevel		= axusbnet_get_msglevel,
> 	.set_msglevel		= axusbnet_set_msglevel,
> 	.get_wol		= ax8817x_get_wol,
> 	.set_wol		= ax8817x_set_wol,
> 	.get_eeprom_len	= ax8817x_get_eeprom_len,
> 	.get_eeprom		= ax8817x_get_eeprom,
> 	.get_settings		= ax8817x_get_settings,
> 	.set_settings		= ax8817x_set_settings,
807c880
< static void ax88172_set_multicast(struct net_device *net)
---
> static int ax8817x_ioctl (struct net_device *net, struct ifreq *rq, int cmd)
810,859d882
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	u8 rx_ctl = 0x8c;
< 
< 	if (net->flags & IFF_PROMISC) {
< 		rx_ctl |= 0x01;
< 	} else if (net->flags & IFF_ALLMULTI ||
< 		   netdev_mc_count(net) > AX_MAX_MCAST) {
< 		rx_ctl |= 0x02;
< 	} else if (netdev_mc_empty(net)) {
< 		/* just broadcast and directed */
< 	} else {
< 		/* We use the 20 byte dev->data
< 		 * for our 8 byte filter buffer
< 		 * to avoid allocating memory that
< 		 * is tricky to free later */
< 		struct netdev_hw_addr *ha;
< 		u32 crc_bits;
< 
< 		memset(data->multi_filter, 0, AX_MCAST_FILTER_SIZE);
< 
< 		/* Build the multicast hash filter. */
< 		netdev_for_each_mc_addr(ha, net) {
< 			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
< 			data->multi_filter[crc_bits >> 3] |=
< 			    1 << (crc_bits & 7);
< 		}
< 
< 		asix_write_cmd_async(dev, AX_CMD_WRITE_MULTI_FILTER, 0, 0,
< 				   AX_MCAST_FILTER_SIZE, data->multi_filter);
< 
< 		rx_ctl |= 0x10;
< 	}
< 
< 	asix_write_cmd_async(dev, AX_CMD_WRITE_RX_CTL, rx_ctl, 0, 0, NULL);
< }
< 
< static int ax88172_link_reset(struct usbnet *dev)
< {
< 	u8 mode;
< 	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
< 
< 	mii_check_media(&dev->mii, 1, 1);
< 	mii_ethtool_gset(&dev->mii, &ecmd);
< 	mode = AX88172_MEDIUM_DEFAULT;
< 
< 	if (ecmd.duplex != DUPLEX_FULL)
< 		mode |= ~AX88172_MEDIUM_FD;
< 
< 	netdev_dbg(dev->net, "ax88172_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
< 		   ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);
861,863c884
< 	asix_write_medium_mode(dev, mode);
< 
< 	return 0;
---
> 	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
866,875c887,898
< static const struct net_device_ops ax88172_netdev_ops = {
< 	.ndo_open		= usbnet_open,
< 	.ndo_stop		= usbnet_stop,
< 	.ndo_start_xmit		= usbnet_start_xmit,
< 	.ndo_tx_timeout		= usbnet_tx_timeout,
< 	.ndo_change_mtu		= usbnet_change_mtu,
< 	.ndo_set_mac_address 	= eth_mac_addr,
< 	.ndo_validate_addr	= eth_validate_addr,
< 	.ndo_do_ioctl		= asix_ioctl,
< 	.ndo_set_multicast_list = ax88172_set_multicast,
---
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
> static const struct net_device_ops ax88x72_netdev_ops = {
> 	.ndo_open			= axusbnet_open,
> 	.ndo_stop			= axusbnet_stop,
> 	.ndo_start_xmit	= axusbnet_start_xmit,
> 	.ndo_tx_timeout	= axusbnet_tx_timeout,
> 	.ndo_change_mtu	= axusbnet_change_mtu,
> 	.ndo_get_stats		= axusbnet_get_stats,
> 	.ndo_do_ioctl		= ax8817x_ioctl,
> 	.ndo_set_mac_address		= ax8817x_set_mac_addr,
> 	.ndo_validate_addr		= eth_validate_addr,
> 	.ndo_set_multicast_list	= ax8817x_set_multicast,
876a900
> #endif
878c902
< static int ax88172_bind(struct usbnet *dev, struct usb_interface *intf)
---
> static int ax8817x_bind(struct usbnet *dev, struct usb_interface *intf)
881c905
< 	u8 buf[ETH_ALEN];
---
> 	void *buf;
884c908
< 	struct asix_data *data = (struct asix_data *)&dev->data;
---
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
886c910
< 	data->eeprom_len = AX88172_EEPROM_LEN;
---
> 	axusbnet_get_endpoints(dev,intf);
888c912,916
< 	usbnet_get_endpoints(dev,intf);
---
> 	buf = kmalloc(ETH_ALEN, GFP_KERNEL);
> 	if(!buf) {
> 		ret = -ENOMEM;
> 		goto out1;
> 	}
892c920
< 		if ((ret = asix_write_cmd(dev, AX_CMD_WRITE_GPIOS,
---
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
895c923
< 			goto out;
---
> 			goto out2;
899,900c927,931
< 	if ((ret = asix_write_rx_ctl(dev, 0x80)) < 0)
< 		goto out;
---
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 				0x80, 0, 0, NULL)) < 0) {
> 		deverr(dev, "send AX_CMD_WRITE_RX_CTL failed: %d", ret);
> 		goto out2;
> 	}
903,906c934,938
< 	if ((ret = asix_read_cmd(dev, AX88172_CMD_READ_NODE_ID,
< 				0, 0, ETH_ALEN, buf)) < 0) {
< 		dbg("read AX_CMD_READ_NODE_ID failed: %d", ret);
< 		goto out;
---
> 	memset(buf, 0, ETH_ALEN);
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_NODE_ID,
> 				0, 0, 6, buf)) < 0) {
> 		deverr(dev, "read AX_CMD_READ_NODE_ID failed: %d", ret);
> 		goto out2;
909a942,954
> 	/* Get the PHY id */
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,
> 				0, 0, 2, buf)) < 0) {
> 		deverr(dev, "error on read AX_CMD_READ_PHY_ID: %02x", ret);
> 		goto out2;
> 	} else if (ret < 2) {
> 		/* this should always return 2 bytes */
> 		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
> 				ret);
> 		ret = -EIO;
> 		goto out2;
> 	}
> 
912,913c957,958
< 	dev->mii.mdio_read = asix_mdio_read;
< 	dev->mii.mdio_write = asix_mdio_write;
---
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax8817x_mdio_write_le;
916c961
< 	dev->mii.phy_id = asix_get_phy_addr(dev);
---
> 	dev->mii.phy_id = *((u8 *)buf + 1);
918,919c963,975
< 	dev->net->netdev_ops = &ax88172_netdev_ops;
< 	dev->net->ethtool_ops = &ax88172_ethtool_ops;
---
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
> 	dev->net->do_ioctl = ax8817x_ioctl;
> 	dev->net->set_multicast_list = ax8817x_set_multicast;
> 	dev->net->set_mac_address = ax8817x_set_mac_addr;
> #else
> 	dev->net->netdev_ops = &ax88x72_netdev_ops;
> #endif
> 
> 	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
> 
> 	/* Register suspend and resume functions */
> 	data->suspend = axusbnet_suspend;
> 	data->resume = axusbnet_resume;
921,922c977,978
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
---
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
926c982
< 	return 0;
---
> 	printk (version);
928c984,987
< out:
---
> 	return 0;
> out2:
> 	kfree(buf);
> out1:
932,943c991,1001
< static const struct ethtool_ops ax88772_ethtool_ops = {
< 	.get_drvinfo		= asix_get_drvinfo,
< 	.get_link		= asix_get_link,
< 	.get_msglevel		= usbnet_get_msglevel,
< 	.set_msglevel		= usbnet_set_msglevel,
< 	.get_wol		= asix_get_wol,
< 	.set_wol		= asix_set_wol,
< 	.get_eeprom_len		= asix_get_eeprom_len,
< 	.get_eeprom		= asix_get_eeprom,
< 	.get_settings		= usbnet_get_settings,
< 	.set_settings		= usbnet_set_settings,
< 	.nway_reset		= usbnet_nway_reset,
---
> static struct ethtool_ops ax88772_ethtool_ops = {
> 	.get_drvinfo		= ax8817x_get_drvinfo,
> 	.get_link		= ethtool_op_get_link,
> 	.get_msglevel		= axusbnet_get_msglevel,
> 	.set_msglevel		= axusbnet_set_msglevel,
> 	.get_wol		= ax8817x_get_wol,
> 	.set_wol		= ax8817x_set_wol,
> 	.get_eeprom_len		= ax8817x_get_eeprom_len,
> 	.get_eeprom		= ax8817x_get_eeprom,
> 	.get_settings		= ax8817x_get_settings,
> 	.set_settings		= ax8817x_set_settings,
946c1004
< static int ax88772_link_reset(struct usbnet *dev)
---
> static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
948,949c1006,1009
< 	u16 mode;
< 	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
---
> 	int ret;
> 	void *buf;
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	struct ax88772_data *ax772_data = NULL;
951,953c1011
< 	mii_check_media(&dev->mii, 1, 1);
< 	mii_ethtool_gset(&dev->mii, &ecmd);
< 	mode = AX88772_MEDIUM_DEFAULT;
---
> 	axusbnet_get_endpoints(dev,intf);
955,956c1013,1046
< 	if (ethtool_cmd_speed(&ecmd) != SPEED_100)
< 		mode &= ~AX_MEDIUM_PS;
---
> 	buf = kmalloc(6, GFP_KERNEL);
> 	if(!buf) {
> 		deverr(dev, "Cannot allocate memory for buffer");
> 		ret = -ENOMEM;
> 		goto out1;
> 	}
> 
>         ax772_data = kmalloc (sizeof(*ax772_data), GFP_KERNEL);
>         if (!ax772_data) {
>                 deverr(dev, "Cannot allocate memory for AX88772 data");
>                 kfree (buf);
>                 return -ENOMEM;
>         }
>         memset (ax772_data, 0, sizeof(*ax772_data));
>         dev->priv = ax772_data;
> 
>         ax772_data->ax_work = create_singlethread_workqueue ("ax88772");
>         if (!ax772_data->ax_work) {
>                 kfree (ax772_data);
>                 kfree (buf);
>                 return -ENOMEM;
>         }
> 
>         ax772_data->dev = dev;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
>         INIT_WORK (&ax772_data->check_link, ax88772_link_reset, dev);
> #else
>         INIT_WORK (&ax772_data->check_link, ax88772_link_reset);
> #endif
> 
> 	/* reload eeprom data */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
> 				     0x00B0, 0, 0, NULL)) < 0)
> 		goto out2;
958,959c1048
< 	if (ecmd.duplex != DUPLEX_FULL)
< 		mode &= ~AX_MEDIUM_FD;
---
> 	msleep(5);
961,962c1050,1055
< 	netdev_dbg(dev->net, "ax88772_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
< 		   ethtool_cmd_speed(&ecmd), ecmd.duplex, mode);
---
> 	/* Initialize MII structure */
> 	dev->mii.dev = dev->net;
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax8817x_mdio_write_le;
> 	dev->mii.phy_id_mask = 0xff;
> 	dev->mii.reg_num_mask = 0xff;
964c1057,1077
< 	asix_write_medium_mode(dev, mode);
---
> 	/* Get the PHY id */
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,
> 			0, 0, 2, buf)) < 0) {
> 		deverr(dev, "Error reading PHY ID: %02x", ret);
> 		goto out2;
> 	} else if (ret < 2) {
> 		/* this should always return 2 bytes */
> 		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
> 		    ret);
> 		ret = -EIO;
> 		goto out2;
> 	}
> 	dev->mii.phy_id = *((u8 *)buf + 1);
> 
> 	if (dev->mii.phy_id == 0x10)
> 	{
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
> 					0x0001, 0, 0, NULL)) < 0) {
> 			deverr(dev, "Select PHY #1 failed: %d", ret);
> 			goto out2;
> 		}
966,967c1079,1084
< 	return 0;
< }
---
> 		if ((ret = ax8817x_write_cmd (dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_IPPD,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev, "Failed to power down PHY: %d", ret);
> 			goto out2;
> 		}
969,979c1086,1093
< static const struct net_device_ops ax88772_netdev_ops = {
< 	.ndo_open		= usbnet_open,
< 	.ndo_stop		= usbnet_stop,
< 	.ndo_start_xmit		= usbnet_start_xmit,
< 	.ndo_tx_timeout		= usbnet_tx_timeout,
< 	.ndo_change_mtu		= usbnet_change_mtu,
< 	.ndo_set_mac_address 	= asix_set_mac_address,
< 	.ndo_validate_addr	= eth_validate_addr,
< 	.ndo_do_ioctl		= asix_ioctl,
< 	.ndo_set_multicast_list = asix_set_multicast,
< };
---
> 		msleep(150);
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_CLEAR,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev, 
> 			      "Failed to perform software reset: %d", ret);
> 			goto out2;
> 		}
981,1002c1095,1102
< static int ax88772_bind(struct usbnet *dev, struct usb_interface *intf)
< {
< 	int ret, embd_phy;
< 	u16 rx_ctl;
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	u8 buf[ETH_ALEN];
< 	u32 phyid;
< 
< 	data->eeprom_len = AX88772_EEPROM_LEN;
< 
< 	usbnet_get_endpoints(dev,intf);
< 
< 	if ((ret = asix_write_gpio(dev,
< 			AX_GPIO_RSE | AX_GPIO_GPO_2 | AX_GPIO_GPO2EN, 5)) < 0)
< 		goto out;
< 
< 	/* 0x10 is the phy id of the embedded 10/100 ethernet phy */
< 	embd_phy = ((asix_get_phy_addr(dev) & 0x1f) == 0x10 ? 1 : 0);
< 	if ((ret = asix_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
< 				embd_phy, 0, 0, NULL)) < 0) {
< 		dbg("Select PHY #1 failed: %d", ret);
< 		goto out;
---
> 		msleep(150);
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 		     			AX_SWRESET_IPRL | AX_SWRESET_PRL,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev,
> 			      "Failed to set PHY reset control: %d", ret);
> 			goto out2;
> 		}
1003a1104,1110
> 	else
> 	{
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
> 					0x0000, 0, 0, NULL)) < 0) {
> 			deverr(dev, "Select PHY #1 failed: %d", ret);
> 			goto out2;
> 		}
1005,1019c1112,1118
< 	if ((ret = asix_sw_reset(dev, AX_SWRESET_IPPD | AX_SWRESET_PRL)) < 0)
< 		goto out;
< 
< 	msleep(150);
< 	if ((ret = asix_sw_reset(dev, AX_SWRESET_CLEAR)) < 0)
< 		goto out;
< 
< 	msleep(150);
< 	if (embd_phy) {
< 		if ((ret = asix_sw_reset(dev, AX_SWRESET_IPRL)) < 0)
< 			goto out;
< 	}
< 	else {
< 		if ((ret = asix_sw_reset(dev, AX_SWRESET_PRTE)) < 0)
< 			goto out;
---
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_IPPD | AX_SWRESET_PRL,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev,
> 			      "Failed to power down internal PHY: %d", ret);
> 			goto out2;
> 		}
1023,1029c1122,1126
< 	rx_ctl = asix_read_rx_ctl(dev);
< 	dbg("RX_CTL is 0x%04x after software reset", rx_ctl);
< 	if ((ret = asix_write_rx_ctl(dev, 0x0000)) < 0)
< 		goto out;
< 
< 	rx_ctl = asix_read_rx_ctl(dev);
< 	dbg("RX_CTL is 0x%04x setting to 0x0000", rx_ctl);
---
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 				0x0000, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to reset RX_CTL: %d", ret);
> 		goto out2;
> 	}
1032c1129,1130
< 	if ((ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,
---
> 	memset(buf, 0, ETH_ALEN);
> 	if ((ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID,
1034,1035c1132,1133
< 		dbg("Failed to read MAC address: %d", ret);
< 		goto out;
---
> 		deverr(dev, "Failed to read MAC address: %d", ret);
> 		goto out2;
1039,1053c1137,1141
< 	/* Initialize MII structure */
< 	dev->mii.dev = dev->net;
< 	dev->mii.mdio_read = asix_mdio_read;
< 	dev->mii.mdio_write = asix_mdio_write;
< 	dev->mii.phy_id_mask = 0x1f;
< 	dev->mii.reg_num_mask = 0x1f;
< 	dev->mii.phy_id = asix_get_phy_addr(dev);
< 
< 	phyid = asix_get_phyid(dev);
< 	dbg("PHYID=0x%08x", phyid);
< 
< 	if ((ret = asix_sw_reset(dev, AX_SWRESET_PRL)) < 0)
< 		goto out;
< 
< 	msleep(150);
---
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII,
> 				0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Enabling software MII failed: %d", ret);
> 		goto out2;
> 	}
1055,1056c1143,1168
< 	if ((ret = asix_sw_reset(dev, AX_SWRESET_IPRL | AX_SWRESET_PRL)) < 0)
< 		goto out;
---
> 	if (dev->mii.phy_id == 0x10)
> 	{
> 		if ((ret = ax8817x_mdio_read_le(dev->net,
> 				dev->mii.phy_id, 2)) != 0x003b) {
> 			deverr(dev, "Read PHY register 2 must be 0x3b00: %d",
> 				ret);
> 			goto out2;
> 		}
> 		
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_PRL,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev, "Set external PHY reset pin level: %d", ret);
> 			goto out2;
> 		}
> 		msleep(150);
> 		if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			 		AX_SWRESET_IPRL | AX_SWRESET_PRL,
> 					0, 0, NULL)) < 0) {
> 			deverr(dev, 
> 				"Set Internal/External PHY reset control: %d",
> 				ret);
> 			goto out2;
> 		}
> 		msleep(150);
> 	}
1058c1170,1176
< 	msleep(150);
---
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
> 	dev->net->do_ioctl = ax8817x_ioctl;
> 	dev->net->set_multicast_list = ax8817x_set_multicast;
> 	dev->net->set_mac_address = ax8817x_set_mac_addr;
> #else
> 	dev->net->netdev_ops = &ax88x72_netdev_ops;
> #endif
1060d1177
< 	dev->net->netdev_ops = &ax88772_netdev_ops;
1063,1064c1180,1185
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
---
> 	/* Register suspend and resume functions */
> 	data->suspend = ax88772_suspend;
> 	data->resume = ax88772_resume;
> 
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
1066d1186
< 	mii_nway_restart(&dev->mii);
1068,1069c1188,1190
< 	if ((ret = asix_write_medium_mode(dev, AX88772_MEDIUM_DEFAULT)) < 0)
< 		goto out;
---
> 	mii_nway_restart(&dev->mii);
>         ax772_data->autoneg_start = jiffies;
>         ax772_data->Event = WAIT_AUTONEG_COMPLETE;
1071,1075c1192,1207
< 	if ((ret = asix_write_cmd(dev, AX_CMD_WRITE_IPG0,
< 				AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT,
< 				AX88772_IPG2_DEFAULT, 0, NULL)) < 0) {
< 		dbg("Write IPG,IPG1,IPG2 failed: %d", ret);
< 		goto out;
---
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
> 				AX88772_MEDIUM_DEFAULT, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Write medium mode register: %d", ret);
> 		goto out2;
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
> 			AX88772_IPG0_DEFAULT | AX88772_IPG1_DEFAULT << 8,
> 			AX88772_IPG2_DEFAULT, 0, NULL)) < 0) {
> 		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
> 		goto out2;
> 	}
> 	if ((ret =
> 	     ax8817x_write_cmd(dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to set hardware MII: %02x", ret);
> 		goto out2;
1079,1086c1211,1216
< 	if ((ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL)) < 0)
< 		goto out;
< 
< 	rx_ctl = asix_read_rx_ctl(dev);
< 	dbg("RX_CTL is 0x%04x after all initializations", rx_ctl);
< 
< 	rx_ctl = asix_read_medium_status(dev);
< 	dbg("Medium Status is 0x%04x after all initializations", rx_ctl);
---
> 	if ((ret =
> 	     ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL, 0x0088, 0, 0,
> 			       NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto out2;
> 	}
1093a1224,1226
> 
> 	kfree (buf);
> 	printk (version);
1096c1229,1233
< out:
---
> out2:
> 	destroy_workqueue (ax772_data->ax_work);
>         kfree (ax772_data);
> 	kfree(buf);
> out1:
1100,1112c1237,1241
< static struct ethtool_ops ax88178_ethtool_ops = {
< 	.get_drvinfo		= asix_get_drvinfo,
< 	.get_link		= asix_get_link,
< 	.get_msglevel		= usbnet_get_msglevel,
< 	.set_msglevel		= usbnet_set_msglevel,
< 	.get_wol		= asix_get_wol,
< 	.set_wol		= asix_set_wol,
< 	.get_eeprom_len		= asix_get_eeprom_len,
< 	.get_eeprom		= asix_get_eeprom,
< 	.get_settings		= usbnet_get_settings,
< 	.set_settings		= usbnet_set_settings,
< 	.nway_reset		= usbnet_nway_reset,
< };
---
> static void ax88772_unbind(struct usbnet *dev, struct usb_interface *intf)
> {
> 	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
> 
> 	if (ax772_data) {
1114c1243,1258
< static int marvell_phy_init(struct usbnet *dev)
---
> 		flush_workqueue (ax772_data->ax_work);
> 		destroy_workqueue (ax772_data->ax_work);
> 
> 		/* stop MAC operation */
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 					AX_RX_CTL_STOP, 0, 0, NULL);
> 
> 		/* Power down PHY */
> 		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_IPPD, 0, 0, NULL);
> 
> 		kfree (ax772_data);
> 	}
> }
> 
> static int ax88772a_phy_powerup (struct usbnet *dev)
1116,1117c1260,1268
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	u16 reg;
---
> 	int ret;
> 	/* set the embedded Ethernet PHY in power-down state */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to power down PHY: %d", ret);
> 		return ret;
> 	}
> 
> 	msleep(10);
1119c1270,1276
< 	netdev_dbg(dev->net, "marvell_phy_init()\n");
---
> 	
> 	/* set the embedded Ethernet PHY in power-up state */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_IPRL, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to reset PHY: %d", ret);
> 		return ret;
> 	}
1121,1122c1278
< 	reg = asix_mdio_read(dev->net, dev->mii.phy_id, MII_MARVELL_STATUS);
< 	netdev_dbg(dev->net, "MII_MARVELL_STATUS = 0x%04x\n", reg);
---
> 	msleep(600);
1124,1125c1280,1285
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_MARVELL_CTRL,
< 			MARVELL_CTRL_RXDELAY | MARVELL_CTRL_TXDELAY);
---
> 	/* set the embedded Ethernet PHY in reset state */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_CLEAR, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to power up PHY: %d", ret);
> 		return ret;
> 	}
1127,1140c1287,1291
< 	if (data->ledmode) {
< 		reg = asix_mdio_read(dev->net, dev->mii.phy_id,
< 			MII_MARVELL_LED_CTRL);
< 		netdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (1) = 0x%04x\n", reg);
< 
< 		reg &= 0xf8ff;
< 		reg |= (1 + 0x0100);
< 		asix_mdio_write(dev->net, dev->mii.phy_id,
< 			MII_MARVELL_LED_CTRL, reg);
< 
< 		reg = asix_mdio_read(dev->net, dev->mii.phy_id,
< 			MII_MARVELL_LED_CTRL);
< 		netdev_dbg(dev->net, "MII_MARVELL_LED_CTRL (2) = 0x%04x\n", reg);
< 		reg &= 0xfc0f;
---
> 	/* set the embedded Ethernet PHY in power-up state */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_IPRL, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to reset PHY: %d", ret);
> 		return ret;
1146c1297
< static int marvell_led_status(struct usbnet *dev, u16 speed)
---
> static int ax88772a_bind(struct usbnet *dev, struct usb_interface *intf)
1148c1299,1302
< 	u16 reg = asix_mdio_read(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL);
---
> 	int ret = -EIO;
> 	void *buf;
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	struct ax88772a_data *ax772a_data = NULL;
1150c1304
< 	netdev_dbg(dev->net, "marvell_led_status() read 0x%04x\n", reg);
---
> 	axusbnet_get_endpoints(dev,intf);
1152,1153c1306,1348
< 	/* Clear out the center LED bits - 0x03F0 */
< 	reg &= 0xfc0f;
---
> 	buf = kmalloc(6, GFP_KERNEL);
> 	if(!buf) {
> 		deverr(dev, "Cannot allocate memory for buffer");
> 		ret = -ENOMEM;
> 		goto out1;
> 	}
> 
> 	ax772a_data = kmalloc (sizeof(*ax772a_data), GFP_KERNEL);
> 	if (!ax772a_data) {
> 		deverr(dev, "Cannot allocate memory for AX88772A data");
> 		kfree (buf);
> 		return -ENOMEM;
> 	}
> 	memset (ax772a_data, 0, sizeof(*ax772a_data));
> 	dev->priv = ax772a_data;
> 
> 	ax772a_data->ax_work = create_singlethread_workqueue ("ax88772a");
> 	if (!ax772a_data->ax_work) {
> 		kfree (ax772a_data);
> 		kfree (buf);
> 		return -ENOMEM;
> 	}
> 
> 	ax772a_data->dev = dev;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> 	INIT_WORK (&ax772a_data->check_link, ax88772a_link_reset, dev);
> #else
> 	INIT_WORK (&ax772a_data->check_link, ax88772a_link_reset);
> #endif
> 
> 	/* Get the EEPROM data*/
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_EEPROM, 
> 			0x0017, 0, 2, (void *)&ax772a_data->EepromData)) < 0) {
> 		deverr(dev, "read SROM address 17h failed: %d", ret);
> 		goto out2;
> 	}
> 	le16_to_cpus (&ax772a_data->EepromData);
> 	/* End of get EEPROM data */
> 
> 	/* reload eeprom data */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
> 			AXGPIOS_RSE, 0, 0, NULL)) < 0)
> 		goto out2;
1155,1163c1350,1408
< 	switch (speed) {
< 		case SPEED_1000:
< 			reg |= 0x03e0;
< 			break;
< 		case SPEED_100:
< 			reg |= 0x03b0;
< 			break;
< 		default:
< 			reg |= 0x02f0;
---
> 	msleep(5);
> 
> 	/* Initialize MII structure */
> 	dev->mii.dev = dev->net;
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax8817x_mdio_write_le;
> 	dev->mii.phy_id_mask = 0xff;
> 	dev->mii.reg_num_mask = 0xff;
> 
> 	/* Get the PHY id */
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,
> 			0, 0, 2, buf)) < 0) {
> 		deverr(dev, "Error reading PHY ID: %02x", ret);
> 		goto out2;
> 	} else if (ret < 2) {
> 		/* this should always return 2 bytes */
> 		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
> 			ret);
> 		goto out2;
> 	}
> 	dev->mii.phy_id = *((u8 *)buf + 1);
> 
> 	if(dev->mii.phy_id != 0x10) {
> 		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
> 		goto out2;
> 	}
> 
> 	/* select the embedded 10/100 Ethernet PHY */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
> 			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
> 			0, 0, NULL)) < 0) {
> 		deverr(dev, "Select PHY #1 failed: %d", ret);
> 		goto out2;
> 	}
> 
> 	if ((ret = ax88772a_phy_powerup (dev)) < 0)
> 		goto out2;
> 
> 	/* stop MAC operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			AX_RX_CTL_STOP, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto out2;
> 	}
> 
> 	/* Get the MAC address */
> 	memset(buf, 0, ETH_ALEN);
> 	if ((ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID,
> 				0, 0, ETH_ALEN, buf)) < 0) {
> 		deverr(dev, "Failed to read MAC address: %d", ret);
> 		goto out2;
> 	}
> 	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
> 
> 	/* make sure the driver can enable sw mii operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII,
> 			0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Enabling software MII failed: %d", ret);
> 		goto out2;
1166,1167c1411,1417
< 	netdev_dbg(dev->net, "marvell_led_status() writing 0x%04x\n", reg);
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MARVELL_LED_MANUAL, reg);
---
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
> 	dev->net->do_ioctl = ax8817x_ioctl;
> 	dev->net->set_multicast_list = ax8817x_set_multicast;
> 	dev->net->set_mac_address = ax8817x_set_mac_addr;
> #else
> 	dev->net->netdev_ops = &ax88x72_netdev_ops;
> #endif
1169c1419,1471
< 	return 0;
---
> 	dev->net->ethtool_ops = &ax88772_ethtool_ops;
> 
> 	/* Register suspend and resume functions */
> 	data->suspend = ax88772_suspend;
> 	data->resume = ax88772_resume;
> 
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_BMCR, BMCR_RESET);
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
> 			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
> 
> 	mii_nway_restart(&dev->mii);
> 	ax772a_data->autoneg_start = jiffies;
> 	ax772a_data->Event = WAIT_AUTONEG_COMPLETE;
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
> 				AX88772_MEDIUM_DEFAULT, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Write medium mode register: %d", ret);
> 		goto out2;
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
> 			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
> 			AX88772A_IPG2_DEFAULT, 0, NULL)) < 0) {
> 		deverr(dev, "Write IPG,IPG1,IPG2 failed: %d", ret);
> 		goto out2;
> 	}
> 
> 	/* Set RX_CTL to default values with 2k buffer, and enable cactus */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			(AX_RX_CTL_START | AX_RX_CTL_AB),
> 			0, 0, NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto out2;
> 	}
> 
> 	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
> 	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
> 		/* hard_mtu  is still the default - the device does not support
> 		   jumbo eth frames */
> 		dev->rx_urb_size = 2048;
> 	}
> 
> 	kfree (buf);
> 
> 	printk (version);
> 
> 	return ret;
> out2:
> 	destroy_workqueue (ax772a_data->ax_work);
> 	kfree (ax772a_data);
> 	kfree (buf);
> out1:
> 	return ret;
1172c1474
< static int ax88178_link_reset(struct usbnet *dev)
---
> static void ax88772a_unbind(struct usbnet *dev, struct usb_interface *intf)
1174,1191c1476
< 	u16 mode;
< 	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
< 	struct asix_data *data = (struct asix_data *)&dev->data;
< 	u32 speed;
< 
< 	netdev_dbg(dev->net, "ax88178_link_reset()\n");
< 
< 	mii_check_media(&dev->mii, 1, 1);
< 	mii_ethtool_gset(&dev->mii, &ecmd);
< 	mode = AX88178_MEDIUM_DEFAULT;
< 	speed = ethtool_cmd_speed(&ecmd);
< 
< 	if (speed == SPEED_1000)
< 		mode |= AX_MEDIUM_GM;
< 	else if (speed == SPEED_100)
< 		mode |= AX_MEDIUM_PS;
< 	else
< 		mode &= ~(AX_MEDIUM_PS | AX_MEDIUM_GM);
---
> 	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
1193c1478,1498
< 	mode |= AX_MEDIUM_ENCK;
---
> 	if (ax772a_data) {
> 
> 		flush_workqueue (ax772a_data->ax_work);
> 		destroy_workqueue (ax772a_data->ax_work);
> 
> 		/* stop MAC operation */
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 					AX_RX_CTL_STOP, 0, 0, NULL);
> 
> 		/* Power down PHY */
> 		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_IPPD, 0, 0, NULL);
> 
> 		kfree (ax772a_data);
> 	}
> }
> 
> static int ax88772b_set_csums(struct usbnet *dev)
> {
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 	u16 checksum;
1195,1196c1500,1501
< 	if (ecmd.duplex == DUPLEX_FULL)
< 		mode |= AX_MEDIUM_FD;
---
> 	if (ax772b_data->checksum & AX_RX_CHECKSUM)
> 		checksum = AX_RXCOE_DEF_CSUM;
1198c1503
< 		mode &= ~AX_MEDIUM_FD;
---
> 		checksum = 0;
1200,1201c1505,1506
< 	netdev_dbg(dev->net, "ax88178_link_reset() speed: %u duplex: %d setting mode to 0x%04x\n",
< 		   speed, ecmd.duplex, mode);
---
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_RXCOE_CTL,
> 				 checksum, 0, 0, NULL);
1203c1508,1511
< 	asix_write_medium_mode(dev, mode);
---
> 	if (ax772b_data->checksum & AX_TX_CHECKSUM)
> 		checksum = AX_TXCOE_DEF_CSUM;
> 	else
> 		checksum = 0;
1205,1206c1513,1514
< 	if (data->phymode == PHY_MODE_MARVELL && data->ledmode)
< 		marvell_led_status(dev, speed);
---
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_TXCOE_CTL,
> 				 checksum, 0, 0, NULL);
1211c1519,1595
< static void ax88178_set_mfb(struct usbnet *dev)
---
> static u32 ax88772b_get_tx_csum(struct net_device *netdev)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 
> 	return (ax772b_data->checksum & AX_TX_CHECKSUM);
> }
> 
> static u32 ax88772b_get_rx_csum(struct net_device *netdev)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 
> 	return (ax772b_data->checksum & AX_RX_CHECKSUM);
> }
> 
> static int ax88772b_set_rx_csum(struct net_device *netdev, u32 val)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 
> 	if (val)
> 		ax772b_data->checksum |= AX_RX_CHECKSUM;
> 	else
> 		ax772b_data->checksum &= ~AX_RX_CHECKSUM;
> 
> 	return ax88772b_set_csums(dev);
> }
> 
> static int ax88772b_set_tx_csum(struct net_device *netdev, u32 val)
> {
> 	struct usbnet *dev = netdev_priv(netdev);
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 
> 	if (val)
> 		ax772b_data->checksum |= AX_TX_CHECKSUM;
> 	else
> 		ax772b_data->checksum &= ~AX_TX_CHECKSUM;
> 
> 	ethtool_op_set_tx_csum(netdev, val);
> 
> 	return ax88772b_set_csums(dev);
> }
> 
> static struct ethtool_ops ax88772b_ethtool_ops = {
> 	.get_drvinfo		= ax8817x_get_drvinfo,
> 	.get_link		= ethtool_op_get_link,
> 	.get_msglevel		= axusbnet_get_msglevel,
> 	.set_msglevel		= axusbnet_set_msglevel,
> 	.get_wol		= ax8817x_get_wol,
> 	.set_wol		= ax8817x_set_wol,
> 	.get_eeprom_len		= ax8817x_get_eeprom_len,
> 	.get_eeprom		= ax8817x_get_eeprom,
> 	.get_settings		= ax8817x_get_settings,
> 	.set_settings		= ax8817x_set_settings,
> 	.set_tx_csum		= ax88772b_set_tx_csum,
> 	.get_tx_csum		= ax88772b_get_tx_csum,
> 	.get_rx_csum		= ax88772b_get_rx_csum,
> 	.set_rx_csum		= ax88772b_set_rx_csum,
> };
> 
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,29)
> static const struct net_device_ops ax88772b_netdev_ops = {
> 	.ndo_open			= axusbnet_open,
> 	.ndo_stop			= axusbnet_stop,
> 	.ndo_start_xmit	= axusbnet_start_xmit,
> 	.ndo_tx_timeout	= axusbnet_tx_timeout,
> 	.ndo_change_mtu	= axusbnet_change_mtu,
> 	.ndo_do_ioctl		= ax8817x_ioctl,
> 	.ndo_get_stats		= axusbnet_get_stats,
> 	.ndo_set_mac_address 	= ax8817x_set_mac_addr,
> 	.ndo_validate_addr		= eth_validate_addr,
> 	.ndo_set_multicast_list = ax88772b_set_multicast,
> };
> #endif
> 
> static int ax88772b_bind(struct usbnet *dev, struct usb_interface *intf)
1213,1216c1597,1798
< 	u16 mfb = AX_RX_CTL_MFB_16384;
< 	u16 rxctl;
< 	u16 medium;
< 	int old_rx_urb_size = dev->rx_urb_size;
---
> 	int ret;
> 	void *buf;
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	struct ax88772b_data *ax772b_data;
> 	u16 *tmp16;
> 	u8 i;
> 
> 	axusbnet_get_endpoints(dev,intf);
> 
> 	buf = kmalloc (6, GFP_KERNEL);
> 	if (!buf) {
> 		deverr(dev, "Cannot allocate memory for buffer");
> 		return -ENOMEM;
> 	}
> 	tmp16 = (u16 *)buf;
> 
> 	ax772b_data = kmalloc (sizeof(*ax772b_data), GFP_KERNEL);
> 	if (!ax772b_data) {
> 		deverr(dev, "Cannot allocate memory for AX88772B data");
> 		kfree (buf);
> 		return -ENOMEM;
> 	}
> 	memset (ax772b_data, 0, sizeof(*ax772b_data));
> 	dev->priv = ax772b_data;
> 
> 	ax772b_data->ax_work = create_singlethread_workqueue ("ax88772b");
> 	if (!ax772b_data->ax_work) {
> 		kfree (buf);
> 		kfree (ax772b_data);
> 		return -ENOMEM;
> 	}
> 
> 	ax772b_data->dev = dev;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> 	INIT_WORK (&ax772b_data->check_link, ax88772b_link_reset, dev);
> #else
> 	INIT_WORK (&ax772b_data->check_link, ax88772b_link_reset);
> #endif
> 
> 	/* reload eeprom data */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_GPIOS,
> 			AXGPIOS_RSE, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to enable GPIO finction: %d", ret);
> 		goto err_out;
> 	}
> 	msleep(5);
> 
> 	/* Get the EEPROM data*/
> 	if ((ret = ax8817x_read_cmd (dev, AX_CMD_READ_EEPROM,
> 				     0x18, 0, 2, (void *)tmp16)) < 0) {
> 		deverr(dev, "read SROM address 18h failed: %d", ret);
> 		goto err_out;
> 	}
> 	le16_to_cpus(tmp16);
> 	ax772b_data->psc = *tmp16 & 0xFF00;
> 	/* End of get EEPROM data */
> 
> 	/* Get the MAC address from EEPROM */
> 	#if 0
> 	memset(buf, 0, ETH_ALEN);
> 	for (i = 0; i < (ETH_ALEN >> 1); i++) {
> 		if ((ret = ax8817x_read_cmd (dev, AX_CMD_READ_EEPROM,
> 					0x04 + i, 0, 2, (buf + i * 2))) < 0) {
> 			deverr(dev, "read SROM address 04h failed: %d", ret);
> 			goto err_out;
> 		}
> 	}
> 	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
> 		for(i=0;i<ETH_ALEN;i++){
>            deverr(dev, "yyz________________read mac addr0: 0x%x", *((char *)buf+i));
> 	}
>        #endif
> 		/* Get the MAC address */
> 	memset(buf, 0, ETH_ALEN);
> 	if ((ret = ax8817x_read_cmd(dev, AX88772_CMD_READ_NODE_ID,
> 				0, 0, ETH_ALEN, buf)) < 0) {
> 		deverr(dev, "Failed to read MAC address: %d", ret);
> 		goto err_out;
> 	}
> 	memcpy(dev->net->dev_addr, buf, ETH_ALEN);
> 
> 	//for(i=0;i<ETH_ALEN;i++){
>            //deverr(dev, "yyz________________read mac addr1: 0x%x", *((char *)buf+i));
> 	//}
> 	
> 	#if 0
> 	/* Set the MAC address */
> 	if ((ret = ax8817x_write_cmd (dev, AX88772_CMD_WRITE_NODE_ID,
> 			0, 0, ETH_ALEN, buf)) < 0) {
> 		deverr(dev, "set MAC address failed: %d", ret);
> 		goto err_out;
> 	}
> 	#endif
> 	/* Initialize MII structure */
> 	dev->mii.dev = dev->net;
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax88772b_mdio_write_le;
> 	dev->mii.phy_id_mask = 0xff;
> 	dev->mii.reg_num_mask = 0xff;
> 
> 	/* Get the PHY id */
> 	if ((ret = ax8817x_read_cmd(dev, AX_CMD_READ_PHY_ID,
> 			0, 0, 2, buf)) < 0) {
> 		deverr(dev, "Error reading PHY ID: %02x", ret);
> 		goto err_out;
> 	} else if (ret < 2) {
> 		/* this should always return 2 bytes */
> 		deverr(dev, "Read PHYID returned less than 2 bytes: ret=%02x",
> 		    ret);
> 		ret = -EIO;
> 		goto err_out;
> 	}
> 	dev->mii.phy_id = *((u8 *)buf + 1);
> 
> 	if(dev->mii.phy_id != 0x10) {
> 		deverr(dev, "Got wrong PHY ID: %02x", dev->mii.phy_id);
> 		ret = -EIO;
> 		goto err_out;
> 	}
> 
> 	/* select the embedded 10/100 Ethernet PHY */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_PHY_SELECT,
> 			AX_PHYSEL_SSEN | AX_PHYSEL_PSEL | AX_PHYSEL_SSMII,
> 			0, 0, NULL)) < 0) {
> 		deverr(dev, "Select PHY #1 failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	if ((ret = ax88772a_phy_powerup (dev)) < 0)
> 		goto err_out;
> 
> 	/* stop MAC operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			AX_RX_CTL_STOP, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	/* make sure the driver can enable sw mii operation */
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SET_SW_MII,
> 			0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Enabling software MII failed: %d", ret);
> 		goto err_out;
> 	}
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
> 	dev->net->do_ioctl = ax8817x_ioctl;
> 	dev->net->set_multicast_list = ax88772b_set_multicast;
> 	dev->net->set_mac_address = ax8817x_set_mac_addr;
> #else
> 	dev->net->netdev_ops = &ax88772b_netdev_ops;
> #endif
> 
> 	dev->net->ethtool_ops = &ax88772b_ethtool_ops;
> 
> 	/* Register suspend and resume functions */
> 	data->suspend = ax88772b_suspend;
> 	data->resume = ax88772b_resume;
> 
> 	*tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
> 			((*tmp16 & 0xFF9F) | 0x0040));
> 
> 	ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
> 			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
> 
> 	mii_nway_restart(&dev->mii);
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE,
> 				AX88772_MEDIUM_DEFAULT, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to write medium mode: %d", ret);
> 		goto err_out;
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_IPG0,
> 			AX88772A_IPG0_DEFAULT | AX88772A_IPG1_DEFAULT << 8,
> 			AX88772A_IPG2_DEFAULT, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to write interframe gap: %d", ret);
> 		goto err_out;
> 	}
> 
> 	dev->net->features |= NETIF_F_IP_CSUM;
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,22)
> 	dev->net->features |= NETIF_F_IPV6_CSUM;
> #endif
> 
> 	ax772b_data->checksum = AX_RX_CHECKSUM | AX_TX_CHECKSUM;
> 	if ((ret = ax88772b_set_csums(dev)) < 0) {
> 		deverr(dev, "Write RX_COE/TX_COE failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	dev->rx_size = bsize & 0x07;
> 	if (dev->udev->speed == USB_SPEED_HIGH) {
> 
> 		if ((ret = ax8817x_write_cmd (dev, 0x2A,
> 				AX88772B_BULKIN_SIZE[dev->rx_size].byte_cnt,
> 				AX88772B_BULKIN_SIZE[dev->rx_size].threshold,
> 				0, NULL)) < 0) {
> 			deverr(dev, "Reset RX_CTL failed: %d", ret);
> 			goto err_out;
> 		}
1218c1800,1806
< 	if (dev->hard_mtu < 2048) {
---
> 		dev->rx_urb_size = AX88772B_BULKIN_SIZE[dev->rx_size].size;
> 	} else {
> 		if ((ret = ax8817x_write_cmd (dev, 0x2A,
> 				0x8000, 0x8001, 0, NULL)) < 0) {
> 			deverr(dev, "Reset RX_CTL failed: %d", ret);
> 			goto err_out;
> 		}
1220,1229d1807
< 		mfb = AX_RX_CTL_MFB_2048;
< 	} else if (dev->hard_mtu < 4096) {
< 		dev->rx_urb_size = 4096;
< 		mfb = AX_RX_CTL_MFB_4096;
< 	} else if (dev->hard_mtu < 8192) {
< 		dev->rx_urb_size = 8192;
< 		mfb = AX_RX_CTL_MFB_8192;
< 	} else if (dev->hard_mtu < 16384) {
< 		dev->rx_urb_size = 16384;
< 		mfb = AX_RX_CTL_MFB_16384;
1232,1233c1810,1823
< 	rxctl = asix_read_rx_ctl(dev);
< 	asix_write_rx_ctl(dev, (rxctl & ~AX_RX_CTL_MFB_16384) | mfb);
---
> 	/* Configure RX header type */
> 	if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_RX_CTL,
> 		      (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_HEADER_DEFAULT),
> 		      0, 0, NULL)) < 0) {
> 		deverr(dev, "Reset RX_CTL failed: %d", ret);
> 		goto err_out;
> 	}
> 
> 	/* Overwrite power saving configuration from eeprom */
> 	if ((ret = ax8817x_write_cmd (dev, AX_CMD_SW_RESET,
> 	    AX_SWRESET_IPRL | (ax772b_data->psc & 0x7FFF), 0, 0, NULL)) < 0) {
> 		deverr(dev, "Failed to configure PHY power saving: %d", ret);
> 		goto err_out;
> 	}
1235,1240c1825,1826
< 	medium = asix_read_medium_status(dev);
< 	if (dev->net->mtu > 1500)
< 		medium |= AX_MEDIUM_JFE;
< 	else
< 		medium &= ~AX_MEDIUM_JFE;
< 	asix_write_medium_mode(dev, medium);
---
> 	kfree (buf);
> 	printk (version);
1242,1243c1828,1833
< 	if (dev->rx_urb_size > old_rx_urb_size)
< 		usbnet_unlink_rx_urbs(dev);
---
> 	return ret;
> err_out:
> 	destroy_workqueue (ax772b_data->ax_work);
> 	kfree (buf);
> 	kfree (ax772b_data);
> 	return ret;
1246c1836
< static int ax88178_change_mtu(struct net_device *net, int new_mtu)
---
> static void ax88772b_unbind(struct usbnet *dev, struct usb_interface *intf)
1248,1249c1838
< 	struct usbnet *dev = netdev_priv(net);
< 	int ll_mtu = new_mtu + net->hard_header_len + 4;
---
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
1251c1840
< 	netdev_dbg(dev->net, "ax88178_change_mtu() new_mtu=%d\n", new_mtu);
---
> 	if (ax772b_data) {
1253,1254c1842,1843
< 	if (new_mtu <= 0 || ll_mtu > 16384)
< 		return -EINVAL;
---
> 		flush_workqueue (ax772b_data->ax_work);
> 		destroy_workqueue (ax772b_data->ax_work);
1256,1257c1845,1909
< 	if ((ll_mtu % dev->maxpacket) == 0)
< 		return -EDOM;
---
> 		/* stop MAC operation */
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 					AX_RX_CTL_STOP, 0, 0, NULL);
> 
> 		/* Power down PHY */
> 		ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					AX_SWRESET_IPPD, 0, 0, NULL);
> 
> 		kfree (ax772b_data);
> 	}
> }
> 
> static int 
> ax88178_media_check (struct usbnet *dev, struct ax88178_data *ax178dataptr)
> {
> 	int fullduplex;
> 	u16 tempshort = 0;
> 	u16 media;
> 	u16 advertise, lpa, result, stat1000;
> 
> 	advertise = ax8817x_mdio_read_le (dev->net,
> 				dev->mii.phy_id, MII_ADVERTISE);
> 	lpa = ax8817x_mdio_read_le (dev->net, dev->mii.phy_id, MII_LPA);
> 	result = advertise & lpa;
> 
> 	stat1000 = ax8817x_mdio_read_le (dev->net,
> 				dev->mii.phy_id, MII_STAT1000);
> 
> 	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 	    (ax178dataptr->LedMode == 1)) { 
> 		tempshort = ax8817x_mdio_read_le (dev->net,
> 				dev->mii.phy_id, MARVELL_MANUAL_LED) & 0xfc0f;
> 	}
> 
> 	fullduplex=1;
> 	if (stat1000 & LPA_1000FULL) {
> 		media = MEDIUM_GIGA_MODE | MEDIUM_FULL_DUPLEX_MODE |
> 			MEDIUM_ENABLE_125MHZ | MEDIUM_ENABLE_RECEIVE;
> 		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 		    (ax178dataptr->LedMode == 1))
> 			tempshort|= 0x3e0;
> 	} else if (result & LPA_100FULL) {
> 		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE |
> 			MEDIUM_MII_100M_MODE;
> 		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 		    (ax178dataptr->LedMode == 1))
> 			tempshort|= 0x3b0;
> 	} else if (result & LPA_100HALF) {
> 		fullduplex = 0;
> 		media = MEDIUM_ENABLE_RECEIVE | MEDIUM_MII_100M_MODE;
> 		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 		    (ax178dataptr->LedMode == 1))
> 			tempshort |= 0x3b0;
> 	} else if (result & LPA_10FULL) {
> 		media = MEDIUM_FULL_DUPLEX_MODE | MEDIUM_ENABLE_RECEIVE;
> 		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 		    (ax178dataptr->LedMode == 1))
> 			tempshort |= 0x2f0;
> 	} else {
> 		media = MEDIUM_ENABLE_RECEIVE;
> 		fullduplex=0;
> 		if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 		    (ax178dataptr->LedMode == 1))
> 				tempshort |= 0x02f0;
> 	}
1259,1261c1911,1915
< 	net->mtu = new_mtu;
< 	dev->hard_mtu = net->mtu + net->hard_header_len;
< 	ax88178_set_mfb(dev);
---
> 	if ((ax178dataptr->PhyMode == PHY_MODE_MARVELL) &&
> 	    (ax178dataptr->LedMode == 1)) {
> 		ax8817x_mdio_write_le (dev->net, 
> 			dev->mii.phy_id, MARVELL_MANUAL_LED, tempshort);
> 	}
1263c1917,1925
< 	return 0;
---
> 	media |= 0x0004;
> 	if(ax178dataptr->UseRgmii)
> 		media |= 0x0008;
> 	if(fullduplex) {
> 		media |= 0x0020;  //ebable tx flow control as default;
> 		media |= 0x0010;  //ebable rx flow control as default;
> 	}
> 
> 	return media;
1266,1276c1928,2415
< static const struct net_device_ops ax88178_netdev_ops = {
< 	.ndo_open		= usbnet_open,
< 	.ndo_stop		= usbnet_stop,
< 	.ndo_start_xmit		= usbnet_start_xmit,
< 	.ndo_tx_timeout		= usbnet_tx_timeout,
< 	.ndo_set_mac_address 	= asix_set_mac_address,
< 	.ndo_validate_addr	= eth_validate_addr,
< 	.ndo_set_multicast_list = asix_set_multicast,
< 	.ndo_do_ioctl 		= asix_ioctl,
< 	.ndo_change_mtu 	= ax88178_change_mtu,
< };
---
> static void Vitess_8601_Init (struct usbnet *dev, int State)
> {
> 	u16 reg;
> 
> 	switch (State) {
> 	case 0:	// tx, rx clock skew
> 		ax8817x_swmii_mdio_write_le (dev->net, dev->mii.phy_id, 31, 1);
> 		ax8817x_swmii_mdio_write_le (dev->net, dev->mii.phy_id, 28, 0);
> 		ax8817x_swmii_mdio_write_le (dev->net, dev->mii.phy_id, 31, 0);
> 		break;
> 
> 	case 1:
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 31, 0x52B5);
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 18, 0x009E);
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 17, 0xDD39);
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 16, 0x87AA);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 16, 0xA7B4);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 18,
> 				ax8817x_swmii_mdio_read_le (dev->net,
> 						dev->mii.phy_id, 18));
> 
> 		reg = (ax8817x_swmii_mdio_read_le (dev->net,
> 				dev->mii.phy_id, 17) & ~0x003f) | 0x003c;
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 17, reg);
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 16, 0x87B4);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 16, 0xa794);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 18,
> 				ax8817x_swmii_mdio_read_le (dev->net,
> 					dev->mii.phy_id, 18));
> 
> 		reg = (ax8817x_swmii_mdio_read_le (dev->net,
> 				dev->mii.phy_id, 17) & ~0x003f) | 0x003e;
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 17, reg);
> 		ax8817x_swmii_mdio_write_le (dev->net,
> 				dev->mii.phy_id, 16, 0x8794);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 0x00f7);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, 0xbe36);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x879e);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0xa7a0);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 
> 				ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, 18));
> 
> 		reg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 				dev->mii.phy_id, 17) & ~0x003f) | 0x0034;
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, reg);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87a0);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 0x003c);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, 0xf3cf);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87a2);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 0x003c);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, 0xf3cf);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87a4);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 0x003c);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, 0xd287);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87a6);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0xa7a8);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 
> 				ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, 18));
> 
> 		reg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 				dev->mii.phy_id, 17) & ~0x0fff) | 0x0125;
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, reg);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87a8);
> 
> 		// Enable Smart Pre-emphasis
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0xa7fa);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, 
> 				ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, 18));
> 
> 		reg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 				dev->mii.phy_id, 17) & ~0x0008) | 0x0008;
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 17, reg);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87fa);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 31, 0);
> 
> 		break;
> 	}
> }
> 
> static int 
> ax88178_phy_init (struct usbnet *dev, struct ax88178_data *ax178dataptr)
> {
> 	int i;
> 	u16 PhyAnar, PhyAuxCtrl, PhyCtrl, TempShort, PhyID1;
> 	u16 PhyReg = 0;
> 
> 	//Disable MII operation of AX88178 Hardware
> 	ax8817x_write_cmd (dev, AX_CMD_SET_SW_MII, 0x0000, 0, 0, NULL);
> 
> 
> 	//Read SROM - MiiPhy Address (ID)
> 	ax8817x_read_cmd (dev, AX_CMD_READ_PHY_ID, 0, 0, 2, &dev->mii.phy_id);
> 	le16_to_cpus (&dev->mii.phy_id);
> 
> 	/* Initialize MII structure */
> 	dev->mii.phy_id >>= 8;
> 	dev->mii.phy_id &= PHY_ID_MASK;
> 	dev->mii.dev = dev->net;
> 	dev->mii.mdio_read = ax8817x_mdio_read_le;
> 	dev->mii.mdio_write = ax8817x_mdio_write_le;
> 	dev->mii.phy_id_mask = 0x3f;
> 	dev->mii.reg_num_mask = 0x1f;
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,11)
> 	dev->mii.supports_gmii = 1;
> #endif
> 
> 	if (ax178dataptr->PhyMode == PHY_MODE_MAC_TO_MAC_GMII)
> 	{
> 		ax178dataptr->UseRgmii = 0;
> 		ax178dataptr->MediaLink = MEDIUM_GIGA_MODE |
> 					  MEDIUM_FULL_DUPLEX_MODE |
> 					  MEDIUM_ENABLE_125MHZ |
> 					  MEDIUM_ENABLE_RECEIVE |
> 					  MEDIUM_ENABLE_RX_FLOWCTRL |
> 					  MEDIUM_ENABLE_TX_FLOWCTRL;
> 
> 		goto SkipPhySetting;
> 	}
> 
> 	// test read phy register 2
> 	if (!ax178dataptr->UseGpio0) {
> 		i = 1000;
> 		while (i--) {
> 			PhyID1 = ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, GMII_PHY_OUI);
> 			if ((PhyID1 == 0x000f) || (PhyID1 == 0x0141) ||
> 			    (PhyID1 == 0x0282) || (PhyID1 == 0x004d) ||
> 			    (PhyID1 == 0x0243) || (PhyID1 == 0x001C) ||
> 			    (PhyID1 == 0x0007))
> 				break;
> 			msleep(5);
> 		}
> 		if (i < 0)
> 			return -EIO;
> 	}
> 
> 	ax178dataptr->UseRgmii = 0;
> 	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
> 		PhyReg = ax8817x_swmii_mdio_read_le(dev->net, 
> 					dev->mii.phy_id, 27);
> 		if (!(PhyReg & 4)) {
> 			ax178dataptr->UseRgmii = 1;
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 20, 0x82);
> 			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 		}
> 	} else if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
> 		 (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
> 		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) {
> 			ax178dataptr->UseRgmii = 1;
> 			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 		}
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) {
> 		// not Cameo
> 		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode) {
> 			ax178dataptr->UseRgmii = 1;
> 			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 		}
> 
> 		for (i = 0; i < (sizeof(CICADA_FAMILY_HWINIT) / 
> 			 	 sizeof(CICADA_FAMILY_HWINIT[0])); i++) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id,
> 					CICADA_FAMILY_HWINIT[i].offset,
> 					CICADA_FAMILY_HWINIT[i].value);
> 		}
> 
> 	}
> 	else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2)
> 	{
> 		// not Cameo
> 		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode)
> 		{
> 			ax178dataptr->UseRgmii = 1;
> 			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 		}
> 
> 		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) / 
> 				 sizeof(CICADA_V2_HWINIT[0])); i++) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset,
> 				CICADA_V2_HWINIT[i].value);
> 		}
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX) {
> 		// not Cameo
> 		if (!ax178dataptr->UseGpio0 || ax178dataptr->LedMode)
> 		{
> 			ax178dataptr->UseRgmii = 1;
> 			ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 		}
> 
> 		for (i = 0; i < (sizeof(CICADA_V2_HWINIT) / 
> 				 sizeof(CICADA_V2_HWINIT[0])); i++) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, CICADA_V2_HWINIT[i].offset, 
> 				CICADA_V2_HWINIT[i].value);
> 		}
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
> 		ax178dataptr->UseRgmii = 1;
> 		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211BN) {
> 		ax178dataptr->UseRgmii = 1;
> 		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8251CL) {
> 		ax178dataptr->UseRgmii = 1;
> 		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
> 		ax178dataptr->UseRgmii = 1;
> 		ax178dataptr->MediaLink |= MEDIUM_ENABLE_125MHZ;
> //		Vitess_8601_Init (dev, 0);
> 	}
> 
> 	if (ax178dataptr->PhyMode != PHY_MODE_ATTANSIC_V0) {
> 		// software reset
> 		ax8817x_swmii_mdio_write_le (
> 			dev->net, dev->mii.phy_id, GMII_PHY_CONTROL,
> 			ax8817x_swmii_mdio_read_le (
> 				dev->net, dev->mii.phy_id, GMII_PHY_CONTROL)
> 				| GMII_CONTROL_RESET);
> 		msleep (1);
> 	}
> 
> 	if ((ax178dataptr->PhyMode == PHY_MODE_AGERE_V0) ||
> 	    (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0_GMII)) {
> 		if (ax178dataptr->PhyMode == PHY_MODE_AGERE_V0)
> 		{
> 			i = 1000;
> 			while (i--)
> 			{
> 				ax8817x_swmii_mdio_write_le (dev->net, 
> 						dev->mii.phy_id, 21, 0x1001);
> 
> 				PhyReg = ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, 21);
> 				if ((PhyReg & 0xf00f) == 0x1001)
> 					break;
> 			}
> 			if (i < 0)
> 				return -EIO;
> 		}
> 
> 		if (ax178dataptr->LedMode == 4) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 28, 0x7417);
> 		} else if (ax178dataptr->LedMode == 9) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 28, 0x7a10);
> 		} else if (ax178dataptr->LedMode == 10) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 28, 0x7a13);
> 		}
> 
> 		for (i = 0; i < (sizeof(AGERE_FAMILY_HWINIT) /
> 				 sizeof(AGERE_FAMILY_HWINIT[0])); i++) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, AGERE_FAMILY_HWINIT[i].offset,
> 				AGERE_FAMILY_HWINIT[i].value);
> 		}
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_RTL8211CL) {
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 0x1f, 0x0005);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 0x0c, 0);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 0x01, 
> 				(ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 0x01) | 0x0080));
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 0x1f, 0);
> 
> 		if (ax178dataptr->LedMode == 12) {
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 0x1f, 0x0002);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 0x1a, 0x00cb);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 0x1f, 0);
> 		}
> 	} else if (ax178dataptr->PhyMode == PHY_MODE_VSC8601) {
> 		Vitess_8601_Init (dev, 1);
> 	}
> 
> 	// read phy register 0
> 	PhyCtrl = ax8817x_swmii_mdio_read_le (dev->net, 
> 				dev->mii.phy_id, GMII_PHY_CONTROL);
> 	TempShort = PhyCtrl;
> 	PhyCtrl &= ~(GMII_CONTROL_POWER_DOWN | GMII_CONTROL_ISOLATE);
> 	if (PhyCtrl != TempShort) {
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, GMII_PHY_CONTROL, PhyCtrl);
> 	}
> 
> 	// led
> 	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
> 		if (ax178dataptr->LedMode == 1)	{
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 				dev->mii.phy_id, 24) & 0xf8ff) | (1 + 0x100);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 			PhyReg = ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 25) & 0xfc0f;
> 
> 		} else if (ax178dataptr->LedMode == 2) {
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 24) & 0xf886) | 
> 					(1 + 0x10 + 0x300);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 
> 		} else if (ax178dataptr->LedMode == 5) {
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 24) & 0xf8be) | 
> 					(1 + 0x40 + 0x300);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 
> 		} else if (ax178dataptr->LedMode == 7) {
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 						dev->mii.phy_id, 24) & 0xf8ff) |
> 						(1 + 0x100);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 
> 		} else if (ax178dataptr->LedMode == 8) {
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 24) & 0xf8be) | 
> 					(1 + 0x40 + 0x100);
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 
> 		} else if (ax178dataptr->LedMode == 11) {
> 
> 			PhyReg = ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 24) & 0x4106;
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 24, PhyReg);
> 
> 		}
> 	} else if ((ax178dataptr->PhyMode == PHY_MODE_CICADA_V1) ||
> 		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2) ||
> 		   (ax178dataptr->PhyMode == PHY_MODE_CICADA_V2_ASIX)) {
> 
> 		if (ax178dataptr->LedMode == 3) {
> 
> 			PhyReg = (ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 27) & 0xFCFF) | 0x0100;
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 27, PhyReg);
> 		}
> 
> 	}
> 
> 	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL)
> 	{
> 		if (ax178dataptr->LedMode == 1)
> 			PhyReg |= 0x3f0;
> 	}
> 
> 	PhyAnar = 1 | (GMII_ANAR_PAUSE | GMII_ANAR_100TXFD | GMII_ANAR_100TX |
> 		       GMII_ANAR_10TFD | GMII_ANAR_10T | GMII_ANAR_ASYM_PAUSE);
> 
> 	PhyAuxCtrl = GMII_1000_AUX_CTRL_FD_CAPABLE;
> 
> 	ax8817x_swmii_mdio_write_le (dev->net, 
> 			dev->mii.phy_id, GMII_PHY_ANAR, PhyAnar);
> 	ax8817x_swmii_mdio_write_le (dev->net, 
> 			dev->mii.phy_id, GMII_PHY_1000BT_CONTROL, PhyAuxCtrl);
> 
> 	if (ax178dataptr->PhyMode == PHY_MODE_VSC8601)
> 	{
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 31, 0x52B5);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0xA7F8);
> 
> 		TempShort = ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 17) & (~0x0018);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 17, TempShort);
> 
> 		TempShort = ax8817x_swmii_mdio_read_le (dev->net, 
> 					dev->mii.phy_id, 18);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 18, TempShort);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 16, 0x87F8);
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, 31, 0);
> 	}
> 
> 	if (ax178dataptr->PhyMode == PHY_MODE_ATTANSIC_V0) {
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, GMII_PHY_CONTROL, 0x9000);
> 
> 	} else {
> 		PhyCtrl &= ~GMII_CONTROL_LOOPBACK;
> 		PhyCtrl |= (GMII_CONTROL_ENABLE_AUTO | GMII_CONTROL_START_AUTO);
> 
> 		ax8817x_swmii_mdio_write_le (dev->net, 
> 				dev->mii.phy_id, GMII_PHY_CONTROL, PhyCtrl);
> 	}
> 
> 	if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
> 		if (ax178dataptr->LedMode == 1)
> 			ax8817x_swmii_mdio_write_le (dev->net, 
> 					dev->mii.phy_id, 25, PhyReg);
> 	}
> 
> SkipPhySetting:
> 
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_MEDIUM_MODE, 
> 			ax178dataptr->MediaLink, 0, 0, NULL);
> 
> 	ax8817x_write_cmd (dev, AX_CMD_WRITE_IPG0, 
> 			AX88772_IPG0_DEFAULT | (AX88772_IPG1_DEFAULT << 8), 
> 			AX88772_IPG2_DEFAULT, 0, NULL);
> 
> 	msleep (1);
> 
> 	ax8817x_write_cmd (dev, AX_CMD_SET_HW_MII, 0, 0, 0, NULL);
> 
> 	return 0;
> }
1280d2418
< 	struct asix_data *data = (struct asix_data *)&dev->data;
1282,1314c2420,2455
< 	u8 buf[ETH_ALEN];
< 	__le16 eeprom;
< 	u8 status;
< 	int gpio0 = 0;
< 	u32 phyid;
< 
< 	usbnet_get_endpoints(dev,intf);
< 
< 	asix_read_cmd(dev, AX_CMD_READ_GPIOS, 0, 0, 1, &status);
< 	dbg("GPIO Status: 0x%04x", status);
< 
< 	asix_write_cmd(dev, AX_CMD_WRITE_ENABLE, 0, 0, 0, NULL);
< 	asix_read_cmd(dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2, &eeprom);
< 	asix_write_cmd(dev, AX_CMD_WRITE_DISABLE, 0, 0, 0, NULL);
< 
< 	dbg("EEPROM index 0x17 is 0x%04x", eeprom);
< 
< 	if (eeprom == cpu_to_le16(0xffff)) {
< 		data->phymode = PHY_MODE_MARVELL;
< 		data->ledmode = 0;
< 		gpio0 = 1;
< 	} else {
< 		data->phymode = le16_to_cpu(eeprom) & 7;
< 		data->ledmode = le16_to_cpu(eeprom) >> 8;
< 		gpio0 = (le16_to_cpu(eeprom) & 0x80) ? 0 : 1;
< 	}
< 	dbg("GPIO0: %d, PhyMode: %d", gpio0, data->phymode);
< 
< 	asix_write_gpio(dev, AX_GPIO_RSE | AX_GPIO_GPO_1 | AX_GPIO_GPO1EN, 40);
< 	if ((le16_to_cpu(eeprom) >> 8) != 1) {
< 		asix_write_gpio(dev, 0x003c, 30);
< 		asix_write_gpio(dev, 0x001c, 300);
< 		asix_write_gpio(dev, 0x003c, 30);
---
> 	void *buf;
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 	struct ax88178_data *ax178dataptr = NULL;
> 
> 	axusbnet_get_endpoints(dev,intf);
> 
> 	buf = kmalloc(6, GFP_KERNEL);
> 	if(!buf) {
> 		deverr(dev, "Cannot allocate memory for buffer");
> 		return -ENOMEM;
> 	}
> 
> 	/* allocate 178 data */
> 	ax178dataptr = kmalloc (sizeof (*ax178dataptr), GFP_KERNEL);
> 	if (!ax178dataptr) {
> 		deverr(dev, "Cannot allocate memory for AX88178 data");
> 		ret = -ENOMEM;
> 		goto error_out;
> 	}
> 	memset (ax178dataptr, 0, sizeof (struct ax88178_data));
> 	dev->priv = ax178dataptr;
> 	/* end of allocate 178 data */
> 
> 	/* Get the EEPROM data*/
> 	if ((ret = ax8817x_read_cmd (dev, AX_CMD_READ_EEPROM, 0x0017, 0, 2,
> 				(void *)(&ax178dataptr->EepromData))) < 0) {
> 		deverr(dev, "read SROM address 17h failed: %d", ret);
> 		goto error_out;
> 	}
> 	le16_to_cpus (&ax178dataptr->EepromData);
> 	/* End of get EEPROM data */
> 
> 	if (ax178dataptr->EepromData == 0xffff) {
> 		ax178dataptr->PhyMode  = PHY_MODE_MARVELL;
> 		ax178dataptr->LedMode  = 0;
> 		ax178dataptr->UseGpio0 = 1; //True
1316,1318c2457,2470
< 		dbg("gpio phymode == 1 path");
< 		asix_write_gpio(dev, AX_GPIO_GPO1EN, 30);
< 		asix_write_gpio(dev, AX_GPIO_GPO1EN | AX_GPIO_GPO_1, 30);
---
> 		ax178dataptr->PhyMode = (u8)(ax178dataptr->EepromData & 
> 						EEPROMMASK);
> 		ax178dataptr->LedMode = (u8)(ax178dataptr->EepromData >> 8);
> 		if (ax178dataptr->LedMode == 6)	// for buffalo new (use gpio2)
> 			ax178dataptr->LedMode = 1;
> 		else if (ax178dataptr->LedMode == 1)
> 			ax178dataptr->BuffaloOld = 1;
> 
> 
> 		if(ax178dataptr->EepromData & 0x80) {
> 			ax178dataptr->UseGpio0=0; //MARVEL se and other
> 		} else {
> 			ax178dataptr->UseGpio0=1; //cameo
> 		}
1321,1322c2473
< 	asix_sw_reset(dev, 0);
< 	msleep(150);
---
> 	if (ax178dataptr->UseGpio0) {
1324,1325c2475,2491
< 	asix_sw_reset(dev, AX_SWRESET_PRL | AX_SWRESET_IPPD);
< 	msleep(150);
---
> 		if (ax178dataptr->PhyMode == PHY_MODE_MARVELL) {
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					AXGPIOS_GPO0EN | AXGPIOS_RSE,
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (25);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
> 					 AXGPIOS_GPO0EN), 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
1327c2493,2626
< 	asix_write_rx_ctl(dev, 0);
---
> 			msleep (15);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					AXGPIOS_GPO2EN | AXGPIOS_GPO0EN,
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (245);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO2 | AXGPIOS_GPO2EN |
> 					 AXGPIOS_GPO0EN), 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 		} else { // vitesse
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_RSE | AXGPIOS_GPO0EN |
> 					 AXGPIOS_GPO0), 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (25);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
> 					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (25);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
> 					 AXGPIOS_GPO2EN), 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (245);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO0EN | AXGPIOS_GPO0 |
> 					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 		}
> 	} else {	// use gpio1
> 
> 		if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 				(AXGPIOS_GPO1 |AXGPIOS_GPO1EN | AXGPIOS_RSE),
> 				0, 0, NULL)) < 0) {
> 			deverr(dev, "write GPIO failed: %d", ret);
> 			goto error_out;
> 		}
> 
> 		if (ax178dataptr->BuffaloOld) {
> 
> 			msleep (350);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					AXGPIOS_GPO1EN, 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (350);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					AXGPIOS_GPO1EN | AXGPIOS_GPO1,
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 		}
> 		else
> 		{
> 			msleep (25);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
> 					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (25);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
> 					 AXGPIOS_GPO2EN), 0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 
> 			msleep (245);
> 
> 			if ((ret = ax8817x_write_cmd (dev, AX_CMD_WRITE_GPIOS,
> 					(AXGPIOS_GPO1EN | AXGPIOS_GPO1 |
> 					 AXGPIOS_GPO2EN | AXGPIOS_GPO2),
> 					0, 0, NULL)) < 0) {
> 				deverr(dev, "write GPIO failed: %d", ret);
> 				goto error_out;
> 			}
> 		}
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev,
> 			AX_CMD_SW_PHY_SELECT, 0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Select PHY failed: %d", ret);
> 		goto error_out;
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 			AX_SWRESET_IPPD | AX_SWRESET_PRL, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Issue sw reset failed: %d", ret);
> 		goto error_out;
> 	}
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			0, 0, 0, NULL)) < 0) {
> 		deverr(dev, "Issue rx ctrl failed: %d", ret);
> 		goto error_out;
> 	}
1330,1333c2629,2633
< 	if ((ret = asix_read_cmd(dev, AX_CMD_READ_NODE_ID,
< 				0, 0, ETH_ALEN, buf)) < 0) {
< 		dbg("Failed to read MAC address: %d", ret);
< 		goto out;
---
> 	memset(buf, 0, ETH_ALEN);
> 	if ((ret = ax8817x_read_cmd (dev, AX88772_CMD_READ_NODE_ID,
> 				     0, 0, ETH_ALEN, buf)) < 0) {
> 		deverr(dev, "read AX_CMD_READ_NODE_ID failed: %d", ret);
> 		goto error_out;
1335a2636
> 	/* End of get MAC address */
1337,1344c2638,2639
< 	/* Initialize MII structure */
< 	dev->mii.dev = dev->net;
< 	dev->mii.mdio_read = asix_mdio_read;
< 	dev->mii.mdio_write = asix_mdio_write;
< 	dev->mii.phy_id_mask = 0x1f;
< 	dev->mii.reg_num_mask = 0xff;
< 	dev->mii.supports_gmii = 1;
< 	dev->mii.phy_id = asix_get_phy_addr(dev);
---
> 	if ((ret = ax88178_phy_init (dev, ax178dataptr)) < 0)
> 		goto error_out;
1346,1347c2641,2652
< 	dev->net->netdev_ops = &ax88178_netdev_ops;
< 	dev->net->ethtool_ops = &ax88178_ethtool_ops;
---
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,30)
> 	dev->net->do_ioctl = ax8817x_ioctl;
> 	dev->net->set_multicast_list = ax8817x_set_multicast;
> 	dev->net->set_mac_address = ax8817x_set_mac_addr;
> #else
> 	dev->net->netdev_ops = &ax88x72_netdev_ops;
> #endif
> 	dev->net->ethtool_ops = &ax8817x_ethtool_ops;
> 
> 	/* Register suspend and resume functions */
> 	data->suspend = ax88772_suspend;
> 	data->resume = ax88772_resume;
1349,1350c2654,2656
< 	phyid = asix_get_phyid(dev);
< 	dbg("PHYID=0x%08x", phyid);
---
> 	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
> 		dev->rx_urb_size = 16384;
> 	}
1352,1354c2658,2662
< 	if (data->phymode == PHY_MODE_MARVELL) {
< 		marvell_phy_init(dev);
< 		msleep(60);
---
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 			(AX_RX_CTL_MFB | AX_RX_CTL_START | AX_RX_CTL_AB),
> 			0, 0, NULL)) < 0) {
> 		deverr(dev, "write RX ctrl reg failed: %d", ret);
> 		goto error_out;
1357,1359c2665,3173
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_BMCR,
< 			BMCR_RESET | BMCR_ANENABLE);
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_ADVERTISE,
---
> 	kfree (buf);
> 	printk (version);
> 	return ret;
> 
> error_out:
> 	if (ax178dataptr)
> 		kfree (ax178dataptr);
> 	kfree (buf);
> 	return ret;
> }
> 
> static void ax88178_unbind(struct usbnet *dev, struct usb_interface *intf)
> {
> 	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
> 
> 	if (ax178dataptr) {
> 
> 		/* stop MAC operation */
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_RX_CTL,
> 					AX_RX_CTL_STOP, 0, 0, NULL);
> 
> 		kfree (ax178dataptr);
> 	}
> }
> 
> static int ax88772_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
> {
> 	u8  *head;
> 	u32  header;
> 	char *packet;
> 	struct sk_buff *ax_skb;
> 	u16 size;
> 
> 	head = (u8 *) skb->data;
> 	memcpy(&header, head, sizeof(header));
> 	le32_to_cpus(&header);
> 	packet = head + sizeof(header);
> 
> 	skb_pull(skb, 4);
> 
> 	while (skb->len > 0) {
> 		if ((short)(header & 0x0000ffff) !=
> 		    ~((short)((header & 0xffff0000) >> 16))) {
> 			deverr(dev, "header length data is error 0x%08x, %d\n",
> 				header, skb->len);
> 		}
> 		/* get the packet length */
> 		size = (u16) (header & 0x0000ffff);
> 
> 		if ((skb->len) - ((size + 1) & 0xfffe) == 0) {
> 
> 			/* Make sure ip header is aligned on 32-bit boundary */
> 			if (!((unsigned long)skb->data & 0x02)) {
> 				memmove (skb->data - 2, skb->data, size);
> 				skb->data -= 2;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 				skb->tail = skb->data + size;
> #else
> 				skb_set_tail_pointer (skb, size);
> #endif
> 			}
> 			skb->truesize = size + sizeof(struct sk_buff);
> 			return 2;
> 		}
> 
> 		if (size > ETH_FRAME_LEN) {
> 			deverr(dev, "invalid rx length %d", size);
> 			return 0;
> 		}
> 		ax_skb = skb_clone(skb, GFP_ATOMIC);
> 		if (ax_skb) {
> 
> 			/* Make sure ip header is aligned on 32-bit boundary */
> 			if (!((unsigned long)packet & 0x02)) {
> 				memmove (packet - 2, packet, size);
> 				packet -= 2;
> 			}
> 			ax_skb->data = packet;
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 			ax_skb->tail = packet + size;
> #else
> 			skb_set_tail_pointer (ax_skb, size);
> #endif
> 			ax_skb->truesize = size + sizeof(struct sk_buff);
> 			axusbnet_skb_return(dev, ax_skb);
> 
> 		} else {
> 			return 0;
> 		}
> 
> 		skb_pull(skb, (size + 1) & 0xfffe);
> 
> 		if (skb->len == 0)
> 			break;
> 
> 		head = (u8 *) skb->data;
> 		memcpy(&header, head, sizeof(header));
> 		le32_to_cpus(&header);
> 		packet = head + sizeof(header);
> 		skb_pull(skb, 4);
> 	}
> 
> 	if (skb->len < 0) {
> 		deverr(dev, "invalid rx length %d", skb->len);
> 		return 0;
> 	}
> 	return 1;
> }
> 
> static struct sk_buff *ax88772_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
> {
> 	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
> 	u32 packet_len;
> 	u32 padbytes = 0xffff0000;
> 
> #if (!AX_FORCE_BUFF_ALIGN)
> 	int headroom = skb_headroom(skb);
> 	int tailroom = skb_tailroom(skb);
> 
> 	if ((!skb_cloned(skb))
> 	    && ((headroom + tailroom) >= (4 + padlen))) {
> 		if ((headroom < 4) || (tailroom < padlen)) {
> 			skb->data = memmove(skb->head + 4, skb->data, skb->len);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 		skb->tail = skb->data + skb->len;
> #else
> 		skb_set_tail_pointer (skb, skb->len);
> #endif
> 		}
> 	} else
> #endif
> 	{
> 		struct sk_buff *skb2;
> 		skb2 = skb_copy_expand(skb, 4, padlen, flags);
> 		dev_kfree_skb_any(skb);
> 		skb = skb2;
> 		if (!skb)
> 			return NULL;
> 	}
> 
> 	skb_push(skb, 4);
> 	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
> 	cpu_to_le32s(&packet_len);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 	memcpy(skb->data, &packet_len, sizeof(packet_len));
> #else
> 	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
> #endif
> 
> 	if ((skb->len % 512) == 0) {
> 		cpu_to_le32s(&padbytes);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 		memcpy(skb->tail, &padbytes, sizeof(padbytes));
> #else
> 		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
> #endif
> 		skb_put(skb, sizeof(padbytes));
> 	}
> 	return skb;
> }
> 
> static void
> ax88772b_rx_checksum (struct sk_buff *skb, struct ax88772b_rx_header *rx_hdr)
> {
> 	skb->ip_summed = CHECKSUM_NONE;
> 
> 	/* checksum error bit is set */
> 	if (rx_hdr->l3_csum_err || rx_hdr->l4_csum_err) {
> 		return;
> 	}
> 
> 	/* It must be a TCP or UDP packet with a valid checksum */
> 	if ((rx_hdr->l4_type == AX_RXHDR_L4_TYPE_TCP) ||
> 	    (rx_hdr->l4_type == AX_RXHDR_L4_TYPE_UDP)) {
> 		skb->ip_summed = CHECKSUM_UNNECESSARY;
> 	}
> }
> 
> static int ax88772b_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
> {
> 	struct ax88772b_rx_header rx_hdr;
> 	struct sk_buff *ax_skb;
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> 
> 	while (skb->len > 0) {
> 
> 		memcpy (&rx_hdr, skb->data, sizeof (struct ax88772b_rx_header));
> 
> 		if ((short)rx_hdr.len != (~((short)rx_hdr.len_bar) & 0x7FF)) {
> 			return 0;
> 		}
> 
> 		if (rx_hdr.len > (ETH_FRAME_LEN + 4)) {
> 			deverr(dev, "invalid rx length %d", rx_hdr.len);
> 			return 0;
> 		}
> 
> 		if (skb->len - ((rx_hdr.len + 
> 				 sizeof (struct ax88772b_rx_header) + 3) & 
> 				 0xfffc) == 0) {
> 			skb_pull(skb, sizeof (struct ax88772b_rx_header));
> 			skb->len = rx_hdr.len;
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 			skb->tail = skb->data + rx_hdr.len;
> #else
> 			skb_set_tail_pointer(skb, rx_hdr.len);
> #endif
> 			skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
> 
> 			if (ax772b_data->checksum & AX_RX_CHECKSUM)
> 				ax88772b_rx_checksum (skb, &rx_hdr);
> 
> 			return 2;
> 		}
> 
> 		ax_skb = skb_clone(skb, GFP_ATOMIC);
> 		if (ax_skb) {
> 			ax_skb->len = rx_hdr.len;
> 			ax_skb->data = skb->data + 
> 				       sizeof (struct ax88772b_rx_header);
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 			ax_skb->tail = ax_skb->data + rx_hdr.len;
> #else
> 			skb_set_tail_pointer(ax_skb, rx_hdr.len);
> #endif
> 			ax_skb->truesize = rx_hdr.len + sizeof(struct sk_buff);
> 
> 			if (ax772b_data->checksum & AX_RX_CHECKSUM) {
> 				ax88772b_rx_checksum (ax_skb, &rx_hdr);
> 			}
> 
> 			axusbnet_skb_return(dev, ax_skb);
> 
> 		} else {
> 			return 0;
> 		}
> 
> 		skb_pull(skb, ((rx_hdr.len + 
> 				sizeof (struct ax88772b_rx_header) + 3)
> 				& 0xfffc));
> 	}
> 
> 	if (skb->len < 0) {
> 		deverr(dev, "invalid rx length %d", skb->len);
> 		return 0;
> 	}
> 	return 1;
> }
> 
> static struct sk_buff *
> ax88772b_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
> {
> 	int padlen = ((skb->len + 4) % 512) ? 0 : 4;
> 	u32 packet_len;
> 	u32 padbytes = 0xffff0000;
> 
> #if (!AX_FORCE_BUFF_ALIGN)
> 	int headroom = skb_headroom(skb);
> 	int tailroom = skb_tailroom(skb);
> 
> 	if ((!skb_cloned(skb))
> 	    && ((headroom + tailroom) >= (4 + padlen))) {
> 		if ((headroom < 4) || (tailroom < padlen)) {
> 			skb->data = memmove(skb->head + 4, skb->data, skb->len);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 			skb->tail = skb->data + skb->len;
> #else
> 			skb_set_tail_pointer(skb, skb->len);
> #endif
> 		}
> 	} else
> #endif
> 	{
> 		struct sk_buff *skb2;
> 		skb2 = skb_copy_expand(skb, 4, padlen, flags);
> 		dev_kfree_skb_any(skb);
> 		skb = skb2;
> 		if (!skb)
> 			return NULL;
> 	}
> 
> 	skb_push(skb, 4);
> 	packet_len = (((skb->len - 4) ^ 0x0000ffff) << 16) + (skb->len - 4);
> 
> 	cpu_to_le32s (&packet_len);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 	memcpy(skb->data, &packet_len, sizeof(packet_len));
> #else
> 	skb_copy_to_linear_data(skb, &packet_len, sizeof(packet_len));
> #endif
> 
> 	if ((skb->len % 512) == 0) {
> 		cpu_to_le32s (&padbytes);
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)
> 		memcpy(skb->tail, &padbytes, sizeof(padbytes));
> #else
> 		memcpy(skb_tail_pointer(skb), &padbytes, sizeof(padbytes));
> #endif
> 		skb_put(skb, sizeof(padbytes));
> 	}
> 
> 	return skb;
> }
> 
> static const u8 ChkCntSel [6][3] = 
> {
> 	{12, 23, 31},
> 	{12, 31, 23},
> 	{23, 31, 12},
> 	{23, 12, 31},
> 	{31, 12, 23},
> 	{31, 23, 12}
> };
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> static void ax88772_link_reset (void *data)
> {
> 	struct usbnet *dev = (struct usbnet *)data;
> 	struct ax88772_data *ax772_data = (struct ax88772_data *)dev->priv;
> #else
> static void ax88772_link_reset (struct work_struct *work)
> {
> 	struct ax88772_data *ax772_data = container_of (work, 
> 					struct ax88772_data, check_link);
> 	struct usbnet *dev = ax772_data->dev;
> #endif
> 	
> 	if (ax772_data->Event == AX_SET_RX_CFG) {
> 		u16 bmcr;
> 		u16 mode;
> 		
> 		ax772_data->Event = AX_NOP;
> 	
> 		mode = AX88772_MEDIUM_DEFAULT;
> 
> 		bmcr = ax8817x_mdio_read_le(dev->net, 
> 				dev->mii.phy_id, MII_BMCR);
> 		if (!(bmcr & BMCR_FULLDPLX))
> 			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
> 		if (!(bmcr & BMCR_SPEED100))
> 			mode &= ~AX88772_MEDIUM_100MB;
> 
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 
> 			mode, 0, 0, NULL);
> 		return;
> 	}
> 	
> 	switch (ax772_data->Event) {
> 	  case WAIT_AUTONEG_COMPLETE:
> 		if (jiffies > (ax772_data->autoneg_start + 5 * HZ)) {
> 			ax772_data->Event = PHY_POWER_DOWN;
> 			ax772_data->TickToExpire = 23;
> 		}
> 		break;
> 	  case PHY_POWER_DOWN:
> 		if (ax772_data->TickToExpire == 23) {
> 			/* Set Phy Power Down */
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					  AX_SWRESET_IPPD,
> 					  0, 0, NULL);
> 			--ax772_data->TickToExpire;
> 		} else if (--ax772_data->TickToExpire == 0) {
> 			/* Set Phy Power Up */
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPRL, 0, 0, NULL);
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPPD | AX_SWRESET_IPRL, 0, 0, NULL);
> 			msleep(10);
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPRL, 0, 0, NULL);
> 			msleep(60);
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_CLEAR, 0, 0, NULL);
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 				AX_SWRESET_IPRL, 0, 0, NULL);
> 
> 			ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 
> 				MII_ADVERTISE,
> 				ADVERTISE_ALL | ADVERTISE_CSMA | 
> 				ADVERTISE_PAUSE_CAP);
> 			mii_nway_restart(&dev->mii);
> 			
> 			ax772_data->Event = PHY_POWER_UP;
> 			ax772_data->TickToExpire = 47;
> 		}
> 		break;
> 	  case PHY_POWER_UP:
> 		if (--ax772_data->TickToExpire == 0) {
> 			ax772_data->Event = PHY_POWER_DOWN;
> 			ax772_data->TickToExpire = 23;
> 		}
> 		break;
> 	  default:
> 		break;
> 	}
> 	return;
> }
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> static void ax88772a_link_reset (void *data)
> {
> 	struct usbnet *dev = (struct usbnet *)data;
> 	struct ax88772a_data *ax772a_data = (struct ax88772a_data *)dev->priv;
> #else
> static void ax88772a_link_reset (struct work_struct *work)
> {
> 	struct ax88772a_data *ax772a_data = container_of (work, 
> 					struct ax88772a_data, check_link);
> 	struct usbnet *dev = ax772a_data->dev;
> #endif
> 	int PowSave = (ax772a_data->EepromData >> 14);
> 	u16 phy_reg;
> 	
> 	if (ax772a_data->Event == AX_SET_RX_CFG) {
> 		u16 bmcr;
> 		u16 mode;
> 
> 		ax772a_data->Event = AX_NOP;
> 	
> 		mode = AX88772_MEDIUM_DEFAULT;
> 
> 		bmcr = ax8817x_mdio_read_le(dev->net, 
> 				dev->mii.phy_id, MII_BMCR);
> 		if (!(bmcr & BMCR_FULLDPLX))
> 			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
> 		if (!(bmcr & BMCR_SPEED100))
> 			mode &= ~AX88772_MEDIUM_100MB;
> 
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 
> 			mode, 0, 0, NULL);
> 		return;
> 	}
> 
> 	switch (ax772a_data->Event) {
> 	case WAIT_AUTONEG_COMPLETE:
> 		if (jiffies > (ax772a_data->autoneg_start + 5 * HZ)) {
> 			ax772a_data->Event = CHK_CABLE_EXIST;
> 			ax772a_data->TickToExpire = 14;
> 		}
> 		break;
> 	case CHK_CABLE_EXIST:
> 		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
> 		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
> 			ax8817x_mdio_write_le(dev->net,
> 				dev->mii.phy_id, 0x16, 0x4040);
> 			mii_nway_restart(&dev->mii);
> 			ax772a_data->Event = CHK_CABLE_STATUS;
> 			ax772a_data->TickToExpire = 31;
> 		} else if (--ax772a_data->TickToExpire == 0) {
> 			mii_nway_restart(&dev->mii);
> 			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
> 			if (PowSave == 0x03){
> 			  ax772a_data->TickToExpire = 47;
> 			} else if (PowSave == 0x01) {
> 			  ax772a_data->DlyIndex = (u8)(jiffies % 6);
> 			  ax772a_data->DlySel = 0;
> 			  ax772a_data->TickToExpire = 
> 			  ChkCntSel[ax772a_data->DlyIndex][ax772a_data->DlySel];
> 			}
> 		}
> 		break;
> 	case CHK_CABLE_EXIST_AGAIN:
> 		/* if cable disconnected */
> 		phy_reg = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
> 		if ((phy_reg != 0x8012) && (phy_reg != 0x8013)) {
> 			mii_nway_restart(&dev->mii);
> 			ax772a_data->Event = CHK_CABLE_STATUS;
> 			ax772a_data->TickToExpire = 31;
> 		} else if (--ax772a_data->TickToExpire == 0) {
> 			/* Power down PHY */
> 			ax8817x_write_cmd(dev, AX_CMD_SW_RESET,
> 					  AX_SWRESET_IPPD,
> 					  0, 0, NULL);
> 			ax772a_data->Event = PHY_POWER_DOWN;
> 			if (PowSave == 0x03){
> 			  ax772a_data->TickToExpire = 23;
> 			} else if (PowSave == 0x01) {
> 			  ax772a_data->TickToExpire = 31;
> 			}
> 		}
> 		break;
> 	case PHY_POWER_DOWN:
> 		if (--ax772a_data->TickToExpire == 0) {
> 			ax772a_data->Event = PHY_POWER_UP;
> 		}
> 		break;
> 	case CHK_CABLE_STATUS:
> 		if (--ax772a_data->TickToExpire == 0) {
> 			ax8817x_mdio_write_le(dev->net,
> 					dev->mii.phy_id, 0x16, 0x4040);
> 			mii_nway_restart(&dev->mii);
> 			ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
> 			if (PowSave == 0x03){
> 			  ax772a_data->TickToExpire = 47;
> 			} else if (PowSave == 0x01) {
> 			  ax772a_data->DlyIndex = (u8)(jiffies % 6);
> 			  ax772a_data->DlySel = 0;
> 			  ax772a_data->TickToExpire = 
> 			  ChkCntSel[ax772a_data->DlyIndex][ax772a_data->DlySel];
> 			}
> 		}
> 		break;
> 	case PHY_POWER_UP:
> 
> 		ax88772a_phy_powerup (dev);
> 
> 		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
1361,1362d3174
< 	asix_mdio_write(dev->net, dev->mii.phy_id, MII_CTRL1000,
< 			ADVERTISE_1000FULL);
1364c3176
< 	mii_nway_restart(&dev->mii);
---
> 		mii_nway_restart(&dev->mii);
1366,1367c3178
< 	if ((ret = asix_write_medium_mode(dev, AX88178_MEDIUM_DEFAULT)) < 0)
< 		goto out;
---
> 		ax772a_data->Event = CHK_CABLE_EXIST_AGAIN;
1369,1370c3180,3195
< 	if ((ret = asix_write_rx_ctl(dev, AX_DEFAULT_RX_CTL)) < 0)
< 		goto out;
---
> 		if (PowSave == 0x03){
> 			  ax772a_data->TickToExpire = 47;
> 			  
> 		} else if (PowSave == 0x01) {
> 		  
> 		  if (++ax772a_data->DlySel >= 3) {
> 		    ax772a_data->DlyIndex = (u8)(jiffies % 6);
> 		    ax772a_data->DlySel = 0;
> 		  }  
> 		  ax772a_data->TickToExpire = 
> 			ChkCntSel[ax772a_data->DlyIndex][ax772a_data->DlySel];
> 		}
> 		break;
> 	default:
> 		break;
> 	}
1372,1376c3197,3265
< 	/* Asix framing packs multiple eth frames into a 2K usb bulk transfer */
< 	if (dev->driver_info->flags & FLAG_FRAMING_AX) {
< 		/* hard_mtu  is still the default - the device does not support
< 		   jumbo eth frames */
< 		dev->rx_urb_size = 2048;
---
> 	return;
> }
> 
> #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
> static void ax88772b_link_reset (void *data)
> {
> 	struct usbnet *dev = (struct usbnet *)data;
> 	struct ax88772b_data *ax772b_data = (struct ax88772b_data *)dev->priv;
> #else
> static void ax88772b_link_reset (struct work_struct *work)
> {
> 	struct ax88772b_data *ax772b_data = container_of (work, 
> 					struct ax88772b_data, check_link);
> 	struct usbnet *dev = ax772b_data->dev;
> #endif
> 
> 	switch (ax772b_data->Event) {
> 
> 	case AX_SET_RX_CFG:
> 	{
> 		u16 bmcr = ax8817x_mdio_read_le(dev->net,
> 					dev->mii.phy_id, MII_BMCR);
> 		u16 mode = AX88772_MEDIUM_DEFAULT;
> 
> 		if (!(bmcr & BMCR_FULLDPLX))
> 			mode &= ~AX88772_MEDIUM_FULL_DUPLEX;
> 		if (!(bmcr & BMCR_SPEED100))
> 			mode &= ~AX88772_MEDIUM_100MB;
> 
> 		ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 
> 					mode, 0, 0, NULL);
> 		break;
> 	}
> 	case PHY_POWER_UP:
> 	{
> 		u16 tmp16;
> 
> 		ax88772a_phy_powerup (dev);
> 		tmp16 = ax8817x_mdio_read_le(dev->net, dev->mii.phy_id, 0x12);
> 		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, 0x12,
> 				((tmp16 & 0xFF9F) | 0x0040));
> 
> 		ax8817x_mdio_write_le(dev->net, dev->mii.phy_id, MII_ADVERTISE,
> 			ADVERTISE_ALL | ADVERTISE_CSMA | ADVERTISE_PAUSE_CAP);
> 		break;
> 	}
> 	default:
> 		break;
> 	}
> 
> 	ax772b_data->Event = AX_NOP;
> 
> 	return;
> }
> 
> static int ax88178_set_media(struct usbnet *dev)
> {
> 	int	ret;
> 	struct ax88178_data *ax178dataptr = (struct ax88178_data *)dev->priv;
> 	int media;
> 
> 	media = ax88178_media_check (dev, ax178dataptr);
> 	if (media < 0)
> 		return media;
> 
> 	if ((ret = ax8817x_write_cmd(dev, AX_CMD_WRITE_MEDIUM_MODE, 
> 			media, 0, 0, NULL)) < 0) {
> 		deverr(dev, "write mode medium reg failed: %d", ret);
> 		return ret;
1377a3267
> 
1378a3269
> }
1380,1381c3271,3294
< out:
< 	return ret;
---
> static int ax88178_link_reset(struct usbnet *dev)
> {
> 	return ax88178_set_media (dev);
> }
> 
> static int ax_suspend (struct usb_interface *intf,
> #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)
> 			pm_message_t message)
> #else
> 			u32 message)
> #endif
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 
> 	return data->suspend (intf, message);
> }
> 
> static int ax_resume (struct usb_interface *intf)
> {
> 	struct usbnet *dev = usb_get_intfdata(intf);
> 	struct ax8817x_data *data = (struct ax8817x_data *)&dev->data;
> 
> 	return data->resume (intf);
1383a3297,3320
> static const struct driver_info ax88178_info = {
> 	.description = "ASIX AX88178 USB 2.0 Ethernet",
> 	.bind = ax88178_bind,
> 	.unbind = ax88178_unbind,
> 	.status = ax88178_status,
> 	.link_reset = ax88178_link_reset,
> 	.reset = ax88178_link_reset,
> 	.flags =  FLAG_ETHER | FLAG_FRAMING_AX,
> 	.rx_fixup = ax88772_rx_fixup,
> 	.tx_fixup = ax88772_tx_fixup,
> };
> 
> static const struct driver_info belkin178_info = {
> 	.description = "Belkin Gigabit USB 2.0 Network Adapter",
> 	.bind = ax88178_bind,
> 	.unbind = ax88178_unbind,
> 	.status = ax8817x_status,
> 	.link_reset = ax88178_link_reset,
> 	.reset = ax88178_link_reset,
> 	.flags =  FLAG_ETHER | FLAG_FRAMING_AX,
> 	.rx_fixup = ax88772_rx_fixup,
> 	.tx_fixup = ax88772_tx_fixup,
> };
> 
1386,1387c3323,3324
< 	.bind = ax88172_bind,
< 	.status = asix_status,
---
> 	.bind = ax8817x_bind,
> 	.status = ax8817x_status,
1390,1391c3327
< 	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
< 	.data = 0x00130103,
---
> 	.flags =  FLAG_ETHER,
1396,1397c3332,3333
< 	.bind = ax88172_bind,
< 	.status = asix_status,
---
> 	.bind = ax8817x_bind,
> 	.status = ax8817x_status,
1400,1401c3336
< 	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
< 	.data = 0x009f9d9f,
---
> 	.flags =  FLAG_ETHER,
1406,1407c3341,3342
< 	.bind = ax88172_bind,
< 	.status = asix_status,
---
> 	.bind = ax8817x_bind,
> 	.status = ax8817x_status,
1410,1411c3345
< 	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
< 	.data = 0x00130103,
---
> 	.flags =  FLAG_ETHER,
1416,1417c3350,3351
< 	.bind = ax88172_bind,
< 	.status = asix_status,
---
> 	.bind = ax8817x_bind,
> 	.status = ax8817x_status,
1420,1421c3354
< 	.flags =  FLAG_ETHER | FLAG_LINK_INTR,
< 	.data = 0x001f1d1f,
---
> 	.flags =  FLAG_ETHER,
1427,1432c3360,3364
< 	.status = asix_status,
< 	.link_reset = ax88772_link_reset,
< 	.reset = ax88772_link_reset,
< 	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR,
< 	.rx_fixup = asix_rx_fixup,
< 	.tx_fixup = asix_tx_fixup,
---
> 	.unbind = ax88772_unbind,
> 	.status = ax88772_status,
> 	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
> 	.rx_fixup = ax88772_rx_fixup,
> 	.tx_fixup = ax88772_tx_fixup,
1435,1443c3367,3394
< static const struct driver_info ax88178_info = {
< 	.description = "ASIX AX88178 USB 2.0 Ethernet",
< 	.bind = ax88178_bind,
< 	.status = asix_status,
< 	.link_reset = ax88178_link_reset,
< 	.reset = ax88178_link_reset,
< 	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_LINK_INTR,
< 	.rx_fixup = asix_rx_fixup,
< 	.tx_fixup = asix_tx_fixup,
---
> static const struct driver_info dlink_dub_e100b_info = {
> 	.description = "D-Link DUB-E100 USB 2.0 Fast Ethernet Adapter",
> 	.bind = ax88772_bind,
> 	.unbind = ax88772_unbind,
> 	.status = ax88772_status,
> 	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
> 	.rx_fixup = ax88772_rx_fixup,
> 	.tx_fixup = ax88772_tx_fixup,
> };
> 
> static const struct driver_info ax88772a_info = {
> 	.description = "ASIX AX88772A USB 2.0 Ethernet",
> 	.bind = ax88772a_bind,
> 	.unbind = ax88772a_unbind,
> 	.status = ax88772a_status,
> 	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
> 	.rx_fixup = ax88772_rx_fixup,
> 	.tx_fixup = ax88772_tx_fixup,
> };
> 
> static const struct driver_info ax88772b_info = {
> 	.description = "ASIX AX88772B USB 2.0 Ethernet",
> 	.bind = ax88772b_bind,
> 	.unbind = ax88772b_unbind,
> 	.status = ax88772b_status,
> 	.flags = FLAG_ETHER | FLAG_FRAMING_AX | FLAG_HW_IP_ALIGNMENT,
> 	.rx_fixup = ax88772b_rx_fixup,
> 	.tx_fixup = ax88772b_tx_fixup,
1447a3399,3418
> 	// 88178
> 	USB_DEVICE (0x0b95, 0x1780),
> 	.driver_info =	(unsigned long) &ax88178_info,
> }, {
> 	// 88178 for billianton linksys
> 	USB_DEVICE (0x077b, 0x2226),
> 	.driver_info =	(unsigned long) &ax88178_info,
> }, {
> 	// ABOCOM for linksys
> 	USB_DEVICE (0x1737, 0x0039),
> 	.driver_info =	(unsigned long) &ax88178_info,
> }, {
> 	// ABOCOM  for pci
> 	USB_DEVICE (0x14ea, 0xab11),
> 	.driver_info =	(unsigned long) &ax88178_info,
> }, {
> 	// Belkin
> 	USB_DEVICE (0x050d, 0x5055),
> 	.driver_info =	(unsigned long) &belkin178_info,
> }, {
1459a3431,3438
> 	// DLink DUB-E100B
> 	USB_DEVICE (0x2001, 0x3c05),
> 	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
> }, {
> 	// DLink DUB-E100B
> 	USB_DEVICE (0x07d1, 0x3c05),
> 	.driver_info =  (unsigned long) &dlink_dub_e100b_info,
> }, {
1468,1470c3447,3449
< 	// Billionton Systems, USB2AR
< 	USB_DEVICE (0x08dd, 0x90ff),
< 	.driver_info =  (unsigned long) &ax8817x_info,
---
>         // Billionton Systems, USB2AR
>         USB_DEVICE (0x08dd, 0x90ff),
>         .driver_info =  (unsigned long) &ax8817x_info,
1480,1483d3458
< 	// Buffalo LUA-U2-GT 10/100/1000
< 	USB_DEVICE (0x0411, 0x006e),
< 	.driver_info =  (unsigned long) &ax88178_info,
< }, {
1488,1491d3462
< 	// Sitecom LN-031 "USB 2.0 10/100/1000 Ethernet adapter"
< 	USB_DEVICE (0x0df6, 0x0056),
< 	.driver_info =  (unsigned long) &ax88178_info,
< }, {
1504,1511d3474
< 	// JVC MP-PRX1 Port Replicator
< 	USB_DEVICE (0x04f1, 0x3008),
< 	.driver_info = (unsigned long) &ax8817x_info,
< }, {
< 	// ASIX AX88772B 10/100
< 	USB_DEVICE (0x0b95, 0x772b),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
1513,1522c3476,3477
< 	USB_DEVICE (0x0b95, 0x7720),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
< 	// ASIX AX88178 10/100/1000
< 	USB_DEVICE (0x0b95, 0x1780),
< 	.driver_info = (unsigned long) &ax88178_info,
< }, {
< 	// Logitec LAN-GTJ/U2A
< 	USB_DEVICE (0x0789, 0x0160),
< 	.driver_info = (unsigned long) &ax88178_info,
---
>         USB_DEVICE (0x0b95, 0x7720),
>         .driver_info = (unsigned long) &ax88772_info,
1524,1530c3479,3481
< 	// Linksys USB200M Rev 2
< 	USB_DEVICE (0x13b1, 0x0018),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
< 	// 0Q0 cable ethernet
< 	USB_DEVICE (0x1557, 0x7720),
< 	.driver_info = (unsigned long) &ax88772_info,
---
> 	// ASIX AX88772 10/100
>         USB_DEVICE (0x125E, 0x180D),
>         .driver_info = (unsigned long) &ax88772_info,
1532,1534c3483,3497
< 	// DLink DUB-E100 H/W Ver B1
< 	USB_DEVICE (0x07d1, 0x3c05),
< 	.driver_info = (unsigned long) &ax88772_info,
---
> 	// ASIX AX88772A 10/100
>         USB_DEVICE (0x0b95, 0x772A),
>         .driver_info = (unsigned long) &ax88772a_info,
> }, {
> 	// ASIX AX88772A 10/100
>         USB_DEVICE (0x0db0, 0xA877),
>         .driver_info = (unsigned long) &ax88772a_info,
> }, {
> 	// ASIX AX88772A 10/100
>         USB_DEVICE (0x0421, 0x772A),
>         .driver_info = (unsigned long) &ax88772a_info,
> }, {
> 	// Linksys 200M
>         USB_DEVICE (0x13B1, 0x0018),
>         .driver_info = (unsigned long) &ax88772a_info,
1536,1538c3499,3500
< 	// DLink DUB-E100 H/W Ver B1 Alternate
< 	USB_DEVICE (0x2001, 0x3c05),
< 	.driver_info = (unsigned long) &ax88772_info,
---
>         USB_DEVICE (0x05ac, 0x1402),
>         .driver_info = (unsigned long) &ax88772a_info,
1540,1542c3502,3504
< 	// Linksys USB1000
< 	USB_DEVICE (0x1737, 0x0039),
< 	.driver_info = (unsigned long) &ax88178_info,
---
> 	// ASIX AX88772B 10/100
>         USB_DEVICE (0x0b95, 0x772B),
>         .driver_info = (unsigned long) &ax88772b_info,
1544,1570c3506,3508
< 	// IO-DATA ETG-US2
< 	USB_DEVICE (0x04bb, 0x0930),
< 	.driver_info = (unsigned long) &ax88178_info,
< }, {
< 	// Belkin F5D5055
< 	USB_DEVICE(0x050d, 0x5055),
< 	.driver_info = (unsigned long) &ax88178_info,
< }, {
< 	// Apple USB Ethernet Adapter
< 	USB_DEVICE(0x05ac, 0x1402),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
< 	// Cables-to-Go USB Ethernet Adapter
< 	USB_DEVICE(0x0b95, 0x772a),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
< 	// ABOCOM for pci
< 	USB_DEVICE(0x14ea, 0xab11),
< 	.driver_info = (unsigned long) &ax88178_info,
< }, {
< 	// ASIX 88772a
< 	USB_DEVICE(0x0db0, 0xa877),
< 	.driver_info = (unsigned long) &ax88772_info,
< }, {
< 	// Asus USB Ethernet Adapter
< 	USB_DEVICE (0x0b95, 0x7e2b),
< 	.driver_info = (unsigned long) &ax88772_info,
---
> 	// ASIX AX88772B 10/100
>         USB_DEVICE (0x0b95, 0x7E2B),
>         .driver_info = (unsigned long) &ax88772b_info,
1576a3515
> //	.owner =	THIS_MODULE,
1579,1583c3518,3521
< 	.probe =	usbnet_probe,
< 	.suspend =	usbnet_suspend,
< 	.resume =	usbnet_resume,
< 	.disconnect =	usbnet_disconnect,
< 	.supports_autosuspend = 1,
---
> 	.probe =	axusbnet_probe,
> 	.suspend =	ax_suspend,
>        .resume =	ax_resume,
> 	.disconnect =	axusbnet_disconnect,
Only in linux-3.0.36-lenovo/drivers/net/usb: asix.h
Only in linux-3.0.36-lenovo/drivers/net/usb: axusbnet.c
Only in linux-3.0.36-lenovo/drivers/net/usb: axusbnet.h
Only in linux-3.0.36-lenovo/drivers/net/usb: dm9620.c




diff -r linux-3.0.36/drivers/net/usb/ipheth.c linux-3.0.36-lenovo/drivers/net/usb/ipheth.c
61a62
> #define USB_PRODUCT_IPAD 0x129a
63a65
> #define USB_PRODUCT_IPHONE_5	0x12a8
103a106,109
> 		USB_VENDOR_APPLE, USB_PRODUCT_IPAD,
> 		IPHETH_USBINTF_CLASS, IPHETH_USBINTF_SUBCLASS,
> 		IPHETH_USBINTF_PROTO) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(
108a115,118
> 		IPHETH_USBINTF_CLASS, IPHETH_USBINTF_SUBCLASS,
> 		IPHETH_USBINTF_PROTO) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(
> 		USB_VENDOR_APPLE, USB_PRODUCT_IPHONE_5,




diff -r linux-3.0.36/drivers/net/usb/kaweth.c linux-3.0.36-lenovo/drivers/net/usb/kaweth.c
1311c1311
<         urb = usb_alloc_urb(0, GFP_NOIO);
---
> 	urb = usb_alloc_urb(0, GFP_ATOMIC);




diff -r linux-3.0.36/drivers/net/usb/Kconfig linux-3.0.36-lenovo/drivers/net/usb/Kconfig
225a226,243
> config USB_NET_DM9620
> 	tristate "Davicom DM9620 based USB 1.1 10/100 ethernet devices"
> 	depends on USB_USBNET
> 	select CRC32
> 	default y
> 	help
> 	  This option adds support for Davicom DM9620 based USB 1.1
> 	  10/100 Ethernet adapters.
> 
> config USB_NET_SR9700
> 	tristate "WilLing Electrnic SR9700 based USB 2.0"
> 	depends on USB_USBNET
> 	select CRC32
> 	default y
> 	help
> 	  This option adds support for Davicom SR9700 based USB 2.0
> 	  10/100 Ethernet adapters.
> 




diff -r linux-3.0.36/drivers/net/usb/Makefile linux-3.0.36-lenovo/drivers/net/usb/Makefile
13a14,15
> obj-$(CONFIG_USB_NET_DM9620)	+= dm9620.o
> obj-$(CONFIG_USB_NET_SR9700)	+= sr9700.o




diff -r linux-3.0.36/drivers/net/usb/sierra_net.c linux-3.0.36-lenovo/drivers/net/usb/sierra_net.c
681c681
< 	*datap = *attrdata;
---
> 	*datap = le16_to_cpu(*attrdata);
Only in linux-3.0.36-lenovo/drivers/net/usb: sr9700.c
Only in linux-3.0.36-lenovo/drivers/net/usb: sr9700.h




diff -r linux-3.0.36/drivers/net/usb/usbnet.c linux-3.0.36-lenovo/drivers/net/usb/usbnet.c
51a52,54
> static char version[] =
> KERN_INFO "USBNET Framwork for ASIX USB Ethernet Adapter:3.2.101 Beta6"
> 	" " __TIME__ " " __DATE__ "\n";
248c251
< 
---
> 
349c352
< 	skb_reserve (skb, NET_IP_ALIGN);
---
> 	//skb_reserve (skb, NET_IP_ALIGN);  //ylz++
1102a1106,1129
> 	
> //$_rbox_$_modify_$_chenzhi
> //$_rbox_$_modify_$_begin
> /* data must be 4-byte aligned */
>         length = ((unsigned long)skb->data) & 0x3;
>         if (length) {
>                 if (skb_cloned(skb) ||
>                     ((skb_headroom(skb) < length) &&
>                      (skb_tailroom(skb) < (4-length)))) {
>                         struct sk_buff *skb2;
>                         /* copy skb with proper alignment */
>                         skb2 = skb_copy_expand(skb, 0, 4, GFP_ATOMIC);
>                         dev_kfree_skb_any(skb);
>                         skb = skb2;
>                         if (!skb)
>                                 goto drop;
>                 } else {
>                         /* move data inside buffer */
>                         length = ((skb_headroom(skb) >= length) ? 0 : 4)-length;
>                         memmove(skb->data+length, skb->data, skb->len);
>                         skb_reserve(skb, length);
>                 }
>         }
> //$_rbox_$_modify_$_end	
1151a1179
> 		usb_put_urb(urb);
1292a1321,1322
> 	usb_scuttle_anchored_urbs(&dev->deferred);
> 
1407a1438,1439
> 
> 	info->flags |= FLAG_AVOID_UNLINK_URBS;




diff -r linux-3.0.36/drivers/net/wan/ixp4xx_hss.c linux-3.0.36-lenovo/drivers/net/wan/ixp4xx_hss.c
10a11
> #include <linux/module.h>




diff -r linux-3.0.36/drivers/net/wimax/i2400m/i2400m-usb.h linux-3.0.36-lenovo/drivers/net/wimax/i2400m/i2400m-usb.h
154a155,157
> 	USB_DEVICE_ID_I6150 = 0x07d6,
> 	USB_DEVICE_ID_I6150_2 = 0x07d7,
> 	USB_DEVICE_ID_I6150_3 = 0x07d9,




diff -r linux-3.0.36/drivers/net/wimax/i2400m/usb.c linux-3.0.36-lenovo/drivers/net/wimax/i2400m/usb.c
493a494,496
> 	case USB_DEVICE_ID_I6150:
> 	case USB_DEVICE_ID_I6150_2:
> 	case USB_DEVICE_ID_I6150_3:
742a746,748
> 	{ USB_DEVICE(0x8087, USB_DEVICE_ID_I6150) },
> 	{ USB_DEVICE(0x8087, USB_DEVICE_ID_I6150_2) },
> 	{ USB_DEVICE(0x8087, USB_DEVICE_ID_I6150_3) },
Only in linux-3.0.36/drivers/net/wireless: adm8211.c
Only in linux-3.0.36/drivers/net/wireless: adm8211.h
Only in linux-3.0.36/drivers/net/wireless: airo.c
Only in linux-3.0.36/drivers/net/wireless: airo_cs.c
Only in linux-3.0.36/drivers/net/wireless: airo.h
Only in linux-3.0.36-lenovo/drivers/net/wireless: ar6003
Only in linux-3.0.36/drivers/net/wireless: at76c50x-usb.c
Only in linux-3.0.36/drivers/net/wireless: at76c50x-usb.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: ani.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: ani.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: ath5k.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: attach.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: base.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: base.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: caps.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: debug.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: debug.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: desc.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: desc.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: dma.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: eeprom.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: eeprom.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: gpio.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: initvals.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: Kconfig
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: led.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: Makefile
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: pcu.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: phy.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: qcu.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: reg.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: reset.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: rfbuffer.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: rfgain.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: rfkill.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath5k: sysfs.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ahb.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ani.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ani.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar5008_initvals.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar5008_phy.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9001_initvals.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_calib.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_hw.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_initvals.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_mac.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_phy.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9002_phy.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_2p2_initvals.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_calib.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_eeprom.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_eeprom.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_hw.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_mac.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_mac.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_paprd.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_phy.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ar9003_phy.h




diff -r linux-3.0.36/drivers/net/wireless/ath/ath9k/ar9485_initvals.h linux-3.0.36-lenovo/drivers/net/wireless/ath/ath9k/ar9485_initvals.h
524c524
< 	{0x00016140, 0x50804008},
---
> 	{0x00016140, 0x10804008},
606c606
< 	{0x00018c00, 0x18052e5e},
---
> 	{0x00018c00, 0x10052e5e},
779c779
< 	{0x00018c00, 0x18013e5e},
---
> 	{0x00018c00, 0x10013e5e},
885c885
< 	{0x00018c00, 0x18012e5e},
---
> 	{0x00018c00, 0x10012e5e},
1024c1024
< 	{0x00018c00, 0x18053e5e},
---
> 	{0x00018c00, 0x10053e5e},
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: ath9k.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: beacon.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: btcoex.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: btcoex.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: calib.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: calib.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: common.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: common.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: debug.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: debug.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: eeprom_4k.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: eeprom_9287.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: eeprom.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: eeprom_def.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: eeprom.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: gpio.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: hif_usb.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: hif_usb.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_drv_beacon.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_drv_init.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_drv_main.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_drv_txrx.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_hst.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: htc_hst.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: hw.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: hw.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: hw-ops.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: init.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: Kconfig
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: mac.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: mac.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: main.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: Makefile
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: pci.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: phy.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: rc.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: rc.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: recv.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: reg.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: wmi.c
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: wmi.h
Only in linux-3.0.36/drivers/net/wireless/ath/ath9k: xmit.c
Only in linux-3.0.36/drivers/net/wireless/ath: ath.h




diff -r linux-3.0.36/drivers/net/wireless/ath/carl9170/tx.c linux-3.0.36-lenovo/drivers/net/wireless/ath/carl9170/tx.c
1248d1247
< 		carl9170_release_dev_space(ar, skb);
Only in linux-3.0.36/drivers/net/wireless/ath: debug.c
Only in linux-3.0.36/drivers/net/wireless/ath: hw.c
Only in linux-3.0.36/drivers/net/wireless/ath: Kconfig
Only in linux-3.0.36/drivers/net/wireless/ath: main.c
Only in linux-3.0.36/drivers/net/wireless/ath: Makefile
Only in linux-3.0.36/drivers/net/wireless/ath: regd.c
Only in linux-3.0.36/drivers/net/wireless/ath: regd_common.h
Only in linux-3.0.36/drivers/net/wireless/ath: regd.h
Only in linux-3.0.36/drivers/net/wireless/ath: reg.h
Only in linux-3.0.36/drivers/net/wireless: atmel.c
Only in linux-3.0.36/drivers/net/wireless: atmel_cs.c
Only in linux-3.0.36/drivers/net/wireless: atmel.h
Only in linux-3.0.36/drivers/net/wireless: atmel_pci.c
Only in linux-3.0.36/drivers/net/wireless/b43: b43.h
Only in linux-3.0.36/drivers/net/wireless/b43: debugfs.c
Only in linux-3.0.36/drivers/net/wireless/b43: debugfs.h
Only in linux-3.0.36/drivers/net/wireless/b43: dma.c
Only in linux-3.0.36/drivers/net/wireless/b43: dma.h
Only in linux-3.0.36/drivers/net/wireless/b43: Kconfig
Only in linux-3.0.36/drivers/net/wireless/b43: leds.c
Only in linux-3.0.36/drivers/net/wireless/b43: leds.h
Only in linux-3.0.36/drivers/net/wireless/b43: lo.c
Only in linux-3.0.36/drivers/net/wireless/b43: lo.h
Only in linux-3.0.36/drivers/net/wireless/b43: main.c
Only in linux-3.0.36/drivers/net/wireless/b43: main.h
Only in linux-3.0.36/drivers/net/wireless/b43: Makefile
Only in linux-3.0.36/drivers/net/wireless/b43: pcmcia.c
Only in linux-3.0.36/drivers/net/wireless/b43: pcmcia.h
Only in linux-3.0.36/drivers/net/wireless/b43: phy_a.c
Only in linux-3.0.36/drivers/net/wireless/b43: phy_a.h
Only in linux-3.0.36/drivers/net/wireless/b43: phy_common.c
Only in linux-3.0.36/drivers/net/wireless/b43: phy_common.h
Only in linux-3.0.36/drivers/net/wireless/b43: phy_g.c
Only in linux-3.0.36/drivers/net/wireless/b43: phy_g.h
Only in linux-3.0.36/drivers/net/wireless/b43: phy_lp.c
Only in linux-3.0.36/drivers/net/wireless/b43: phy_lp.h
Only in linux-3.0.36/drivers/net/wireless/b43: phy_n.c
Only in linux-3.0.36/drivers/net/wireless/b43: phy_n.h
Only in linux-3.0.36/drivers/net/wireless/b43: pio.c
Only in linux-3.0.36/drivers/net/wireless/b43: pio.h
Only in linux-3.0.36/drivers/net/wireless/b43: rfkill.c
Only in linux-3.0.36/drivers/net/wireless/b43: rfkill.h
Only in linux-3.0.36/drivers/net/wireless/b43: sdio.c
Only in linux-3.0.36/drivers/net/wireless/b43: sdio.h
Only in linux-3.0.36/drivers/net/wireless/b43: sysfs.c
Only in linux-3.0.36/drivers/net/wireless/b43: sysfs.h
Only in linux-3.0.36/drivers/net/wireless/b43: tables.c
Only in linux-3.0.36/drivers/net/wireless/b43: tables.h
Only in linux-3.0.36/drivers/net/wireless/b43: tables_lpphy.c
Only in linux-3.0.36/drivers/net/wireless/b43: tables_lpphy.h
Only in linux-3.0.36/drivers/net/wireless/b43: tables_nphy.c
Only in linux-3.0.36/drivers/net/wireless/b43: tables_nphy.h
Only in linux-3.0.36/drivers/net/wireless/b43: wa.c
Only in linux-3.0.36/drivers/net/wireless/b43: wa.h
Only in linux-3.0.36/drivers/net/wireless/b43: xmit.c
Only in linux-3.0.36/drivers/net/wireless/b43: xmit.h
Only in linux-3.0.36/drivers/net/wireless: b43legacy
Only in linux-3.0.36-lenovo/drivers/net/wireless: bcm4319
Only in linux-3.0.36-lenovo/drivers/net/wireless: bcm4329
Only in linux-3.0.36/drivers/net/wireless: hostap
Only in linux-3.0.36/drivers/net/wireless: ipw2x00




diff -r linux-3.0.36/drivers/net/wireless/iwlegacy/iwl3945-base.c linux-3.0.36-lenovo/drivers/net/wireless/iwlegacy/iwl3945-base.c
2766c2766
< 	if (test_bit(STATUS_EXIT_PENDING, &priv->status) || priv->txq == NULL)
---
> 	if (test_bit(STATUS_EXIT_PENDING, &priv->status))
2912a2913
> 
2914,2916c2915,2917
< 	 * If active scaning is requested but a certain channel is marked
< 	 * passive, we can do active scanning if we detect transmissions. For
< 	 * passive only scanning disable switching to active on any channel.
---
> 	 * If active scaning is requested but a certain channel
> 	 * is marked passive, we can do active scanning if we
> 	 * detect transmissions.
2919c2920
< 					IWL_GOOD_CRC_TH_NEVER;
---
> 					IWL_GOOD_CRC_TH_DISABLED;




diff -r linux-3.0.36/drivers/net/wireless/iwlegacy/iwl-3945.c linux-3.0.36-lenovo/drivers/net/wireless/iwlegacy/iwl-3945.c
1875,1877c1875,1876
< 	mutex_lock(&priv->mutex);
< 	if (test_bit(STATUS_EXIT_PENDING, &priv->status) || priv->txq == NULL)
< 		goto out;
---
> 	if (test_bit(STATUS_EXIT_PENDING, &priv->status))
> 		return;
1878a1878
> 	mutex_lock(&priv->mutex);
1880d1879
< out:
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-1000.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-5000.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-5000-hw.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-6000.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-6000-hw.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-calib.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-hcmd.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-hw.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-ict.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-lib.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-rs.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-rs.h




diff -r linux-3.0.36/drivers/net/wireless/iwlwifi/iwl-agn-rxon.c linux-3.0.36-lenovo/drivers/net/wireless/iwlwifi/iwl-agn-rxon.c
414,431d413
< void iwlagn_config_ht40(struct ieee80211_conf *conf,
< 	struct iwl_rxon_context *ctx)
< {
< 	if (conf_is_ht40_minus(conf)) {
< 		ctx->ht.extension_chan_offset =
< 			IEEE80211_HT_PARAM_CHA_SEC_BELOW;
< 		ctx->ht.is_40mhz = true;
< 	} else if (conf_is_ht40_plus(conf)) {
< 		ctx->ht.extension_chan_offset =
< 			IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
< 		ctx->ht.is_40mhz = true;
< 	} else {
< 		ctx->ht.extension_chan_offset =
< 			IEEE80211_HT_PARAM_CHA_SEC_NONE;
< 		ctx->ht.is_40mhz = false;
< 	}
< }
< 
445,447d426
< 	if (test_bit(STATUS_EXIT_PENDING, &priv->status))
< 		goto out;
< 
494,498c473,485
< 				/* if HT40 is used, it should not change
< 				 * after associated except channel switch */
< 				if (!ctx->ht.is_40mhz ||
< 						!iwl_is_associated_ctx(ctx))
< 					iwlagn_config_ht40(conf, ctx);
---
> 				if (conf_is_ht40_minus(conf)) {
> 					ctx->ht.extension_chan_offset =
> 						IEEE80211_HT_PARAM_CHA_SEC_BELOW;
> 					ctx->ht.is_40mhz = true;
> 				} else if (conf_is_ht40_plus(conf)) {
> 					ctx->ht.extension_chan_offset =
> 						IEEE80211_HT_PARAM_CHA_SEC_ABOVE;
> 					ctx->ht.is_40mhz = true;
> 				} else {
> 					ctx->ht.extension_chan_offset =
> 						IEEE80211_HT_PARAM_CHA_SEC_NONE;
> 					ctx->ht.is_40mhz = false;
> 				}




diff -r linux-3.0.36/drivers/net/wireless/iwlwifi/iwl-agn-sta.c linux-3.0.36-lenovo/drivers/net/wireless/iwlwifi/iwl-agn-sta.c
480c480
< 	priv->stations[sta_id].sta.key.key_offset = keyconf->hw_key_idx;
---
> 	priv->stations[sta_id].sta.key.key_offset = WEP_INVALID_OFFSET;
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-tx.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-agn-ucode.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-commands.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-core.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-core.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-csr.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-debugfs.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-debug.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-dev.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-devtrace.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-devtrace.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-eeprom.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-eeprom.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-fh.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-hcmd.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-helpers.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-io.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-led.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-led.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-power.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-power.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-prph.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-rx.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-scan.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-sta.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-sta.h
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: iwl-tx.c
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: Kconfig
Only in linux-3.0.36/drivers/net/wireless/iwlwifi: Makefile
Only in linux-3.0.36/drivers/net/wireless: iwmc3200wifi




diff -r linux-3.0.36/drivers/net/wireless/Kconfig linux-3.0.36-lenovo/drivers/net/wireless/Kconfig
20,112c20,103
< config PCMCIA_RAYCS
< 	tristate "Aviator/Raytheon 2.4GHz wireless support"
< 	depends on PCMCIA
< 	select WIRELESS_EXT
< 	select WEXT_SPY
< 	select WEXT_PRIV
< 	---help---
< 	  Say Y here if you intend to attach an Aviator/Raytheon PCMCIA
< 	  (PC-card) wireless Ethernet networking card to your computer.
< 	  Please read the file <file:Documentation/networking/ray_cs.txt> for
< 	  details.
< 
< 	  To compile this driver as a module, choose M here: the module will be
< 	  called ray_cs.  If unsure, say N.
< 
< config LIBERTAS_THINFIRM
< 	tristate "Marvell 8xxx Libertas WLAN driver support with thin firmware"
< 	depends on MAC80211
< 	select FW_LOADER
< 	---help---
< 	  A library for Marvell Libertas 8xxx devices using thinfirm.
< 
< config LIBERTAS_THINFIRM_DEBUG
< 	bool "Enable full debugging output in the Libertas thin firmware module."
< 	depends on LIBERTAS_THINFIRM
< 	---help---
< 	  Debugging support.
< 
< config LIBERTAS_THINFIRM_USB
< 	tristate "Marvell Libertas 8388 USB 802.11b/g cards with thin firmware"
< 	depends on LIBERTAS_THINFIRM && USB
< 	---help---
< 	  A driver for Marvell Libertas 8388 USB devices using thinfirm.
< 
< config AIRO
< 	tristate "Cisco/Aironet 34X/35X/4500/4800 ISA and PCI cards"
< 	depends on ISA_DMA_API && (PCI || BROKEN)
< 	select WIRELESS_EXT
< 	select CRYPTO
< 	select WEXT_SPY
< 	select WEXT_PRIV
< 	---help---
< 	  This is the standard Linux driver to support Cisco/Aironet ISA and
< 	  PCI 802.11 wireless cards.
< 	  It supports the new 802.11b cards from Cisco (Cisco 34X, Cisco 35X
< 	  - with or without encryption) as well as card before the Cisco
< 	  acquisition (Aironet 4500, Aironet 4800, Aironet 4800B).
< 
< 	  This driver support both the standard Linux Wireless Extensions
< 	  and Cisco proprietary API, so both the Linux Wireless Tools and the
< 	  Cisco Linux utilities can be used to configure the card.
< 
< 	  The driver can be compiled as a module and will be named "airo".
< 
< config ATMEL
<       tristate "Atmel at76c50x chipset  802.11b support"
<       depends on (PCI || PCMCIA)
<       select WIRELESS_EXT
<       select WEXT_PRIV
<       select FW_LOADER
<       select CRC32
<        ---help---
<         A driver 802.11b wireless cards based on the Atmel fast-vnet
<         chips. This driver supports standard Linux wireless extensions.
< 
<         Many  cards based on this chipset do not have flash memory
<         and need their firmware loaded at start-up. If yours is
<         one of these, you will need to provide a firmware image
<         to be loaded into the card by the driver. The Atmel
<         firmware package can be downloaded from
<         <http://www.thekelleys.org.uk/atmel>
< 
< config PCI_ATMEL
<       tristate "Atmel at76c506 PCI cards"
<       depends on ATMEL && PCI
<        ---help---
<         Enable support for PCI and mini-PCI cards containing the
<         Atmel at76c506 chip.
< 
< config PCMCIA_ATMEL
< 	tristate "Atmel at76c502/at76c504 PCMCIA cards"
< 	depends on ATMEL && PCMCIA
< 	select WIRELESS_EXT
< 	select FW_LOADER
< 	select CRC32
< 	---help---
< 	  Enable support for PCMCIA cards containing the
< 	  Atmel at76c502 and at76c504 chips.
< 
< config AT76C50X_USB
<         tristate "Atmel at76c503/at76c505/at76c505a USB cards"
<         depends on MAC80211 && USB
<         select FW_LOADER
---
> config WLAN_80211
> 	bool "Wireless LAN (IEEE 802.11)"
> 	depends on NETDEVICES
> 	---help---
> 	  Say Y if you have any 802.11 wireless LAN hardware.
> 
> 	  This option does not affect the kernel build, it only
> 	  lets you choose drivers.
> 
> config AIDC
>     bool "Enable WIFI AIDS(Automatic Identification USB Wifi Type)"
> 	depends on RTL8188EU || RTL8192CU || RTL8723AU || RT5370
> 	default n
> 	---help---
> 
> choice
> 	prompt "WiFi device driver support"
> 	default WIFI_NONE
> 
> 	config WIFI_NONE
> 	  bool "No WiFi"
> 
> 	config BCM4329
> 	  depends on WLAN_80211 && MMC
> 	  select WIRELESS_EXT
> 	  select WEXT_PRIV
> 	  select IEEE80211
> 	  select FW_LOADER
> 	  bool "Broadcom BCM4329 WiFi/BT Combo SDIO"
> 	  ---help---
> 	    A library for Broadcom BCM4329 SDIO WLAN/BT combo devices.
> 	    So far, the following modules have been verified:
> 	      (1) Samsung    SWL-B23
> 	      
> 	config BCM4319
> 	  depends on WLAN_80211 && MMC
> 	  select WIRELESS_EXT
> 	  select WEXT_PRIV
> 	  select IEEE80211
> 	  select FW_LOADER
> 	  bool "Broadcom BCM4319 WiFi SDIO"
> 	  ---help---
> 	    A library for Broadcom BCM4319 SDIO WLAN devices. 
> 
>         config MT6620
>           depends on WLAN_80211 && MMC && MTK_COMBO
>           select WIRELESS_EXT
>           select WEXT_PRIV
>           select IEEE80211
>           select FW_LOADER
>           bool "MTK MT6620 WiFi SDIO"
>           ---help---
>             A library for MTK_wcn_combo SDIO WLAN devices.
> 	config RDA5990
> 	  depends on WLAN_80211 && MMC
> 	  select WIRELESS_EXT
> 	  select WEXT_PRIV
> 	  select IEEE80211
> 	  bool "rda 5990p"
> 	  ---help---
> 	    rda5990P fm bt wifi
> 	    
> 	config MV8686
> 	  depends on WLAN_80211 && MMC
> 	  select WIRELESS_EXT
> 	  select IEEE80211
> 	  select FW_LOADER
> 	  bool "Marvell MV8686 SDIO"
> 	  ---help---
> 	    A library for Marvell 8686 SDIO WLAN devices.
> 	    So far, the following modules have been verified:
> 	      (1) Samsung    SWL-2480
> 	      (2) Azurewave  AW-GH321
> 	      (3) USI        WM-G-MR-09
> 	      (4) Murata     SP-8HEP-P
> 
> 	config RTL8189ES
>         tristate "Realtek 8189ES SDIO WiFi Support"
>         depends on WLAN_80211 && MMC
>         select WIRELESS_EXT
>         select WEXT_PRIV
>         select IEEE80211
>         select CFG80211
>         select MAC80211
114,163d104
<           Enable support for USB Wireless devices using Atmel at76c503,
<           at76c505 or at76c505a chips.
< 
< config AIRO_CS
< 	tristate "Cisco/Aironet 34X/35X/4500/4800 PCMCIA cards"
< 	depends on PCMCIA && (BROKEN || !M32R)
< 	select WIRELESS_EXT
< 	select WEXT_SPY
< 	select WEXT_PRIV
< 	select CRYPTO
< 	select CRYPTO_AES
< 	---help---
< 	  This is the standard Linux driver to support Cisco/Aironet PCMCIA
< 	  802.11 wireless cards.  This driver is the same as the Aironet
< 	  driver part of the Linux Pcmcia package.
< 	  It supports the new 802.11b cards from Cisco (Cisco 34X, Cisco 35X
< 	  - with or without encryption) as well as card before the Cisco
< 	  acquisition (Aironet 4500, Aironet 4800, Aironet 4800B). It also
< 	  supports OEM of Cisco such as the DELL TrueMobile 4800 and Xircom
< 	  802.11b cards.
< 
< 	  This driver support both the standard Linux Wireless Extensions
< 	  and Cisco proprietary API, so both the Linux Wireless Tools and the
< 	  Cisco Linux utilities can be used to configure the card.
< 
< config PCMCIA_WL3501
< 	tristate "Planet WL3501 PCMCIA cards"
< 	depends on EXPERIMENTAL && PCMCIA
< 	select WIRELESS_EXT
< 	select WEXT_SPY
< 	help
< 	  A driver for WL3501 PCMCIA 802.11 wireless cards made by Planet.
< 	  It has basic support for Linux wireless extensions and initial
< 	  micro support for ethtool.
< 
< config PRISM54
< 	tristate 'Intersil Prism GT/Duette/Indigo PCI/Cardbus (DEPRECATED)'
< 	depends on PCI && EXPERIMENTAL
< 	select WIRELESS_EXT
< 	select WEXT_SPY
< 	select WEXT_PRIV
< 	select FW_LOADER
< 	---help---
< 	  This enables support for FullMAC PCI/Cardbus prism54 devices. This
< 	  driver is now deprecated in favor for the SoftMAC driver, p54pci.
< 	  p54pci supports FullMAC PCI/Cardbus devices as well. For details on
< 	  the scheduled removal of this driver on the kernel see the feature
< 	  removal schedule:
< 
< 	  Documentation/feature-removal-schedule.txt
165,266c106,171
< 	  For more information refer to the p54 wiki:
< 
< 	  http://wireless.kernel.org/en/users/Drivers/p54
< 
< 	  Note: You need a motherboard with DMA support to use any of these cards
< 
< 	  When built as module you get the module prism54
< 
< config USB_ZD1201
< 	tristate "USB ZD1201 based Wireless device support"
< 	depends on USB
< 	select WIRELESS_EXT
< 	select WEXT_PRIV
< 	select FW_LOADER
< 	---help---
< 	  Say Y if you want to use wireless LAN adapters based on the ZyDAS
< 	  ZD1201 chip.
< 
< 	  This driver makes the adapter appear as a normal Ethernet interface,
< 	  typically on wlan0.
< 
< 	  The zd1201 device requires external firmware to be loaded.
< 	  This can be found at http://linux-lc100020.sourceforge.net/
< 
< 	  To compile this driver as a module, choose M here: the
< 	  module will be called zd1201.
< 
< config USB_NET_RNDIS_WLAN
< 	tristate "Wireless RNDIS USB support"
< 	depends on USB && EXPERIMENTAL
< 	depends on CFG80211
< 	select USB_USBNET
< 	select USB_NET_CDCETHER
< 	select USB_NET_RNDIS_HOST
< 	---help---
< 	  This is a driver for wireless RNDIS devices.
< 	  These are USB based adapters found in devices such as:
< 
< 	  Buffalo WLI-U2-KG125S
< 	  U.S. Robotics USR5421
< 	  Belkin F5D7051
< 	  Linksys WUSB54GSv2
< 	  Linksys WUSB54GSC
< 	  Asus WL169gE
< 	  Eminent EM4045
< 	  BT Voyager 1055
< 	  Linksys WUSB54GSv1
< 	  U.S. Robotics USR5420
< 	  BUFFALO WLI-USB-G54
< 
< 	  All of these devices are based on Broadcom 4320 chip which is the
< 	  only wireless RNDIS chip known to date.
< 
< 	  If you choose to build a module, it'll be called rndis_wlan.
< 
< source "drivers/net/wireless/rtl818x/Kconfig"
< 
< config ADM8211
< 	tristate "ADMtek ADM8211 support"
< 	depends on MAC80211 && PCI && EXPERIMENTAL
< 	select CRC32
< 	select EEPROM_93CX6
< 	---help---
< 	  This driver is for ADM8211A, ADM8211B, and ADM8211C based cards.
< 	  These are PCI/mini-PCI/Cardbus 802.11b chips found in cards such as:
< 
< 	  Xterasys Cardbus XN-2411b
< 	  Blitz NetWave Point PC
< 	  TrendNet 221pc
< 	  Belkin F5D6001
< 	  SMC 2635W
< 	  Linksys WPC11 v1
< 	  Fiberline FL-WL-200X
< 	  3com Office Connect (3CRSHPW796)
< 	  Corega WLPCIB-11
< 	  SMC 2602W V2 EU
< 	  D-Link DWL-520 Revision C
< 
< 	  However, some of these cards have been replaced with other chips
< 	  like the RTL8180L (Xterasys Cardbus XN-2411b, Belkin F5D6001) or
< 	  the Ralink RT2400 (SMC2635W) without a model number change.
< 
< 	  Thanks to Infineon-ADMtek for their support of this driver.
< 
< config MAC80211_HWSIM
< 	tristate "Simulated radio testing tool for mac80211"
< 	depends on MAC80211
< 	---help---
< 	  This driver is a developer testing tool that can be used to test
< 	  IEEE 802.11 networking stack (mac80211) functionality. This is not
< 	  needed for normal wireless LAN usage and is only for testing. See
< 	  Documentation/networking/mac80211_hwsim for more information on how
< 	  to use this tool.
< 
< 	  To compile this driver as a module, choose M here: the module will be
< 	  called mac80211_hwsim.  If unsure, say N.
< 
< config MWL8K
< 	tristate "Marvell 88W8xxx PCI/PCIe Wireless support"
< 	depends on MAC80211 && PCI && EXPERIMENTAL
< 	---help---
< 	  This driver supports Marvell TOPDOG 802.11 wireless cards.
---
> source "drivers/net/wireless/mt5931/Kconfig"
> source "drivers/net/wireless/rkusbwifi/rtl8192cu/Kconfig"
> source "drivers/net/wireless/rkusbwifi/rtl8188eu/Kconfig"
> source "drivers/net/wireless/rkusbwifi/rtl8723au/Kconfig"
> source "drivers/net/wireless/rkusbwifi/rt5370/Kconfig"
> source "drivers/net/wireless/rkusbwifi/mt7601/Kconfig"
> source "drivers/net/wireless/ar6003/Kconfig"
> source "drivers/net/wireless/rtl8723as/Kconfig"
> source "drivers/net/wireless/rkwifi/Kconfig"
> endchoice
> 
> choice	
> 	depends on RKWIFI && WLAN_80211
> 	prompt "Select the wifi module"
> 	default RK903
> 	
> 	config BCM4330 
>     	bool "BCM4330"
>     	depends on RKWIFI && WLAN_80211
> 
> 	config RK903
>     	bool "RK903"
> 	    depends on RKWIFI && WLAN_80211
> 
> 	config RK901
>     	bool "RK901"
> 	    depends on RKWIFI && WLAN_80211
> 	
> 	config AP6181
> 		bool "AP6181"
> 		depends on RKWIFI && WLAN_80211
> 
> 	config AP6210
> 		bool "AP6210"
> 		depends on RKWIFI && WLAN_80211
> 
> 	config AP6330
> 		bool "AP6330"
> 		depends on RKWIFI && WLAN_80211
> 
> 	config AP6476
> 		bool "AP6476"
> 		depends on RKWIFI && WLAN_80211
> 
> 	config AP6493
> 		bool "AP6493"
> 		depends on RKWIFI && WLAN_80211
> 
> 	config GB86302I
> 		bool "GB86302I"
> 		depends on RKWIFI && WLAN_80211
> 
> endchoice
> 
> choice	
> 	depends on RKWIFI && WLAN_80211 && RK903
> 	prompt "Select the wifi module crystal freq"
> 	default RKWIFI_37_4M
> 
> 	config RKWIFI_37_4M
>     	bool "37_4M"
> 	    depends on RKWIFI && WLAN_80211 && RK903
> 
> 	config RKWIFI_26M
>     	bool "26M"
> 	    depends on RKWIFI && WLAN_80211 && RK903
268,269c173
< 	  To compile this driver as a module, choose M here: the module
< 	  will be called mwl8k.  If unsure, say N.
---
> endchoice
271,287c175
< source "drivers/net/wireless/ath/Kconfig"
< source "drivers/net/wireless/b43/Kconfig"
< source "drivers/net/wireless/b43legacy/Kconfig"
< source "drivers/net/wireless/hostap/Kconfig"
< source "drivers/net/wireless/ipw2x00/Kconfig"
< source "drivers/net/wireless/iwlwifi/Kconfig"
< source "drivers/net/wireless/iwlegacy/Kconfig"
< source "drivers/net/wireless/iwmc3200wifi/Kconfig"
< source "drivers/net/wireless/libertas/Kconfig"
< source "drivers/net/wireless/orinoco/Kconfig"
< source "drivers/net/wireless/p54/Kconfig"
< source "drivers/net/wireless/rt2x00/Kconfig"
< source "drivers/net/wireless/rtlwifi/Kconfig"
< source "drivers/net/wireless/wl1251/Kconfig"
< source "drivers/net/wireless/wl12xx/Kconfig"
< source "drivers/net/wireless/zd1211rw/Kconfig"
< source "drivers/net/wireless/mwifiex/Kconfig"
---
> endif
289d176
< endif # WLAN
Only in linux-3.0.36/drivers/net/wireless: libertas
Only in linux-3.0.36/drivers/net/wireless: libertas_tf
Only in linux-3.0.36/drivers/net/wireless: mac80211_hwsim.c




diff -r linux-3.0.36/drivers/net/wireless/Makefile linux-3.0.36-lenovo/drivers/net/wireless/Makefile
4,60c4,19
< 
< obj-$(CONFIG_IPW2100) += ipw2x00/
< obj-$(CONFIG_IPW2200) += ipw2x00/
< 
< obj-$(CONFIG_HERMES)		+= orinoco/
< 
< obj-$(CONFIG_AIRO)		+= airo.o
< obj-$(CONFIG_AIRO_CS)		+= airo_cs.o airo.o
< 
< obj-$(CONFIG_ATMEL)             += atmel.o
< obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
< obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
< 
< obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
< 
< obj-$(CONFIG_PRISM54)		+= prism54/
< 
< obj-$(CONFIG_HOSTAP)		+= hostap/
< obj-$(CONFIG_B43)		+= b43/
< obj-$(CONFIG_B43LEGACY)		+= b43legacy/
< obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
< obj-$(CONFIG_RTL8180)		+= rtl818x/
< obj-$(CONFIG_RTL8187)		+= rtl818x/
< obj-$(CONFIG_RTLWIFI)		+= rtlwifi/
< 
< # 16-bit wireless PCMCIA client drivers
< obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
< obj-$(CONFIG_PCMCIA_WL3501)	+= wl3501_cs.o
< 
< obj-$(CONFIG_USB_NET_RNDIS_WLAN)	+= rndis_wlan.o
< 
< obj-$(CONFIG_USB_ZD1201)	+= zd1201.o
< obj-$(CONFIG_LIBERTAS)		+= libertas/
< 
< obj-$(CONFIG_LIBERTAS_THINFIRM)	+= libertas_tf/
< 
< obj-$(CONFIG_ADM8211)	+= adm8211.o
< 
< obj-$(CONFIG_MWL8K)	+= mwl8k.o
< 
< obj-$(CONFIG_IWLAGN)	+= iwlwifi/
< obj-$(CONFIG_IWLWIFI_LEGACY)	+= iwlegacy/
< obj-$(CONFIG_RT2X00)	+= rt2x00/
< 
< obj-$(CONFIG_P54_COMMON)	+= p54/
< 
< obj-$(CONFIG_ATH_COMMON)	+= ath/
< 
< obj-$(CONFIG_MAC80211_HWSIM)	+= mac80211_hwsim.o
< 
< obj-$(CONFIG_WL1251)	+= wl1251/
< obj-$(CONFIG_WL12XX)	+= wl12xx/
< obj-$(CONFIG_WL12XX_PLATFORM_DATA)	+= wl12xx/
< 
< obj-$(CONFIG_IWM)	+= iwmc3200wifi/
< 
< obj-$(CONFIG_MWIFIEX)	+= mwifiex/
---
> obj-y += wifi_sys/rkwifi_sys_iface.o
> obj-$(CONFIG_BCM4329)   += bcm4329/
> obj-$(CONFIG_MV8686)   += mv8686/
> obj-$(CONFIG_BCM4319)   += bcm4319/
> obj-$(CONFIG_RTL8192CU) += rkusbwifi/
> obj-$(CONFIG_RTL8188EU)	+= rkusbwifi/
> obj-$(CONFIG_RTL8723AU)	+= rkusbwifi/
> obj-$(CONFIG_RT5370)	+= rkusbwifi/
> obj-$(CONFIG_AR6003)   += ar6003/
> obj-$(CONFIG_RKWIFI)   += rkwifi/
> obj-$(CONFIG_RDA5990) += rda5990/
> obj-$(CONFIG_MT5931)  += mt5931/
> obj-$(CONFIG_MT5931_MT6622)  += mt5931/
> #obj-$(CONFIG_RTL8723AS) += rtl8723as/
> obj-$(CONFIG_MT7601)	+= rkusbwifi/
> #obj-m	+= wlan/
Only in linux-3.0.36-lenovo/drivers/net/wireless: mt5931
Only in linux-3.0.36-lenovo/drivers/net/wireless: mv8686




diff -r linux-3.0.36/drivers/net/wireless/mwifiex/11n_rxreorder.c linux-3.0.36-lenovo/drivers/net/wireless/mwifiex/11n_rxreorder.c
270c270,271
< 	if (last_seq >= new_node->start_win)
---
> 	if (last_seq != MWIFIEX_DEF_11N_RX_SEQ_NUM &&
> 	    last_seq >= new_node->start_win)
615c616
< 	memset(priv->rx_seq, 0, sizeof(priv->rx_seq));
---
> 	mwifiex_reset_11n_rx_seq_num(priv);




diff -r linux-3.0.36/drivers/net/wireless/mwifiex/11n_rxreorder.h linux-3.0.36-lenovo/drivers/net/wireless/mwifiex/11n_rxreorder.h
39a40,46
> #define MWIFIEX_DEF_11N_RX_SEQ_NUM	0xffff
> 
> static inline void mwifiex_reset_11n_rx_seq_num(struct mwifiex_private *priv)
> {
> 	memset(priv->rx_seq, 0xff, sizeof(priv->rx_seq));
> }
> 




diff -r linux-3.0.36/drivers/net/wireless/mwifiex/sdio.c linux-3.0.36-lenovo/drivers/net/wireless/mwifiex/sdio.c
125d124
< 	int hs_actived = 0;
152,155c151,153
< 	hs_actived = mwifiex_enable_hs(adapter);
< 	if (hs_actived) {
< 		pr_debug("cmd: suspend with MMC_PM_KEEP_POWER\n");
< 		ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
---
> 	if (!mwifiex_enable_hs(adapter)) {
> 		dev_err(adapter->dev, "cmd: failed to suspend\n");
> 		return -EFAULT;
156a155,157
> 
> 	dev_dbg(adapter->dev, "cmd: suspend with MMC_PM_KEEP_POWER\n");
> 	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);




diff -r linux-3.0.36/drivers/net/wireless/mwifiex/wmm.c linux-3.0.36-lenovo/drivers/net/wireless/mwifiex/wmm.c
408a409,410
> 		mwifiex_reset_11n_rx_seq_num(priv);
> 
Only in linux-3.0.36/drivers/net/wireless: mwl8k.c
Only in linux-3.0.36/drivers/net/wireless: orinoco
Only in linux-3.0.36/drivers/net/wireless: p54
Only in linux-3.0.36/drivers/net/wireless: prism54
Only in linux-3.0.36/drivers/net/wireless: ray_cs.c
Only in linux-3.0.36/drivers/net/wireless: ray_cs.h
Only in linux-3.0.36/drivers/net/wireless: rayctl.h
Only in linux-3.0.36-lenovo/drivers/net/wireless: rda5990
Only in linux-3.0.36-lenovo/drivers/net/wireless: rkusbwifi
Only in linux-3.0.36-lenovo/drivers/net/wireless: rkwifi
Only in linux-3.0.36/drivers/net/wireless: rndis_wlan.c
Only in linux-3.0.36/drivers/net/wireless: rt2x00
Only in linux-3.0.36/drivers/net/wireless/rtl818x: Kconfig
Only in linux-3.0.36/drivers/net/wireless/rtl818x: Makefile
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: dev.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: grf5101.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: Makefile
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: max2820.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: rtl8225.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8180: sa2400.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: dev.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: leds.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: Makefile
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: rfkill.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: rtl8187.h
Only in linux-3.0.36/drivers/net/wireless/rtl818x/rtl8187: rtl8225.c
Only in linux-3.0.36/drivers/net/wireless/rtl818x: rtl818x.h
Only in linux-3.0.36-lenovo/drivers/net/wireless: rtl8723as




diff -r linux-3.0.36/drivers/net/wireless/rtlwifi/pci.c linux-3.0.36-lenovo/drivers/net/wireless/rtlwifi/pci.c
957,961c957
< 	if (pskb) {
< 		struct rtl_tx_desc *entry = &ring->desc[ring->idx];
< 		pci_unmap_single(rtlpci->pdev, rtlpriv->cfg->ops->get_desc(
< 				 (u8 *) entry, true, HW_DESC_TXBUFF_ADDR),
< 				 pskb->len, PCI_DMA_TODEVICE);
---
> 	if (pskb)
963d958
< 	}
1188,1193c1183,1186
< 	if (ring->desc) {
< 		pci_free_consistent(rtlpci->pdev,
< 				    sizeof(*ring->desc) * ring->entries,
< 				    ring->desc, ring->dma);
< 		ring->desc = NULL;
< 	}
---
> 	pci_free_consistent(rtlpci->pdev,
> 			    sizeof(*ring->desc) * ring->entries,
> 			    ring->desc, ring->dma);
> 	ring->desc = NULL;
1217,1218c1210
< 		if (rtlpci->rx_ring[rx_queue_idx].desc) {
< 			pci_free_consistent(rtlpci->pdev,
---
> 		pci_free_consistent(rtlpci->pdev,
1223,1224c1215
< 			rtlpci->rx_ring[rx_queue_idx].desc = NULL;
< 		}
---
> 		rtlpci->rx_ring[rx_queue_idx].desc = NULL;
1991d1981
< 	rtlpriv->cfg->ops->disable_interrupt(hw);




diff -r linux-3.0.36/drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c linux-3.0.36-lenovo/drivers/net/wireless/rtlwifi/rtl8192c/dm_common.c
526,529d525
< 	dm_digtable.cur_igvalue += 2;
< 	if (dm_digtable.cur_igvalue > 0x3f)
< 		dm_digtable.cur_igvalue = 0x3f;
< 
1225,1230c1221,1222
< 			/* Only the PCI card uses sta in the update rate table
< 			 * callback routine */
< 			if (rtlhal->interface == INTF_PCI) {
< 				rcu_read_lock();
< 				sta = ieee80211_find_sta(mac->vif, mac->bssid);
< 			}
---
> 			rcu_read_lock();
> 			sta = ieee80211_find_sta(mac->vif, mac->bssid);
1235,1236c1227
< 			if (rtlhal->interface == INTF_PCI)
< 				rcu_read_unlock();
---
> 			rcu_read_unlock();




diff -r linux-3.0.36/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c linux-3.0.36-lenovo/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c
297a298
> 	{RTL_USB_DEVICE(0x050d, 0x11f2, rtl92cu_hal_cfg)}, /*Belkin - ISY*/




diff -r linux-3.0.36/drivers/net/wireless/rtlwifi/rtl8192se/fw.c linux-3.0.36-lenovo/drivers/net/wireless/rtlwifi/rtl8192se/fw.c
199,200d198
< 		if (!skb)
< 			return false;
580,581d577
< 	if (!skb)
< 		return false;




diff -r linux-3.0.36/drivers/net/wireless/rtlwifi/usb.c linux-3.0.36-lenovo/drivers/net/wireless/rtlwifi/usb.c
545,546c545,546
< 		_rtl_usb_rx_process_agg(hw, skb);
< 		ieee80211_rx_irqsafe(hw, skb);
---
> 		_rtl_usb_rx_process_agg(hw, _skb);
> 		ieee80211_rx_irqsafe(hw, _skb);
Only in linux-3.0.36-lenovo/drivers/net/wireless: wifi_launcher
Only in linux-3.0.36-lenovo/drivers/net/wireless: wifi_power
Only in linux-3.0.36-lenovo/drivers/net/wireless: wifi_sys




diff -r linux-3.0.36/drivers/net/wireless/wl1251/main.c linux-3.0.36-lenovo/drivers/net/wireless/wl1251/main.c
482d481
< 	cancel_delayed_work_sync(&wl->elp_work);




diff -r linux-3.0.36/drivers/net/wireless/wl1251/sdio.c linux-3.0.36-lenovo/drivers/net/wireless/wl1251/sdio.c
262d261
< 		irq_set_status_flags(wl->irq, IRQ_NOAUTOEN);
269a269
> 		disable_irq(wl->irq);
317d316
< 	wl1251_free_hw(wl);
318a318
> 	wl1251_free_hw(wl);




diff -r linux-3.0.36/drivers/net/wireless/wl1251/spi.c linux-3.0.36-lenovo/drivers/net/wireless/wl1251/spi.c
283d282
< 	irq_set_status_flags(wl->irq, IRQ_NOAUTOEN);
290a290,291
> 
> 	disable_irq(wl->irq);




diff -r linux-3.0.36/drivers/net/wireless/wl12xx/boot.c linux-3.0.36-lenovo/drivers/net/wireless/wl12xx/boot.c
331,333d330
< 			if (nvs_ptr + 3 >= (u8 *) wl->nvs + nvs_len)
< 				goto out_badnvs;
< 
345,347d341
< 
< 		if (nvs_ptr >= (u8 *) wl->nvs + nvs_len)
< 			goto out_badnvs;
359,362d352
< 
< 	if (nvs_ptr >= (u8 *) wl->nvs + nvs_len)
< 		goto out_badnvs;
< 
378,381d367
< 
< out_badnvs:
< 	wl1271_error("nvs data is malformed");
< 	return -EILSEQ;




diff -r linux-3.0.36/drivers/net/wireless/wl12xx/cmd.c linux-3.0.36-lenovo/drivers/net/wireless/wl12xx/cmd.c
124,128d123
< 	if (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {
< 		wl1271_warning("FEM index from INI out of bounds");
< 		return -EINVAL;
< 	}
< 
152,157d146
< 	if (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {
< 		wl1271_warning("FEM index from FW out of bounds");
< 		ret = -EINVAL;
< 		goto out;
< 	}
< 
177,181d165
< 	if (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {
< 		wl1271_warning("FEM index from ini out of bounds");
< 		return -EINVAL;
< 	}
< 
205,210d188
< 
< 	if (gp->tx_bip_fem_manufacturer >= WL1271_INI_FEM_MODULE_COUNT) {
< 		wl1271_warning("FEM index from FW out of bounds");
< 		ret = -EINVAL;
< 		goto out;
< 	}
Only in linux-3.0.36/drivers/net/wireless/wl12xx: Kconfig
Only in linux-3.0.36/drivers/net/wireless/wl12xx: Makefile




diff -r linux-3.0.36/drivers/net/wireless/wl12xx/scan.c linux-3.0.36-lenovo/drivers/net/wireless/wl12xx/scan.c
85a86
> 
90,97c91,93
< 		    (req->channels[i]->band == band) &&
< 		    /*
< 		     * In passive scans, we scan all remaining
< 		     * channels, even if not marked as such.
< 		     * In active scans, we only scan channels not
< 		     * marked as passive.
< 		     */
< 		    (passive || !(flags & IEEE80211_CHAN_PASSIVE_SCAN))) {
---
> 		    ((!!(flags & IEEE80211_CHAN_PASSIVE_SCAN)) == passive) &&
> 		    (req->channels[i]->band == band)) {
> 
149,152d144
< 	/* skip active scans if we don't have SSIDs */
< 	if (!passive && wl->scan.req->n_ssids == 0)
< 		return WL1271_NOTHING_TO_SCAN;
< 
163c155,156
< 	if (passive)
---
> 	/* No SSIDs means that we have a forced passive scan */
> 	if (passive || wl->scan.req->n_ssids == 0)
Only in linux-3.0.36/drivers/net/wireless/wl12xx: wl12xx_80211.h
Only in linux-3.0.36/drivers/net/wireless: wl3501_cs.c
Only in linux-3.0.36/drivers/net/wireless: wl3501.h
Only in linux-3.0.36/drivers/net/wireless: zd1201.c
Only in linux-3.0.36/drivers/net/wireless: zd1201.h
Only in linux-3.0.36/drivers/net/wireless: zd1211rw




diff -r linux-3.0.36/drivers/net/xen-netback/common.h linux-3.0.36-lenovo/drivers/net/xen-netback/common.h
154a155,157
> /* Prevent the device from generating any further traffic. */
> void xenvif_carrier_off(struct xenvif *vif);
> 




diff -r linux-3.0.36/drivers/net/xen-netback/interface.c linux-3.0.36-lenovo/drivers/net/xen-netback/interface.c
345c345
< void xenvif_disconnect(struct xenvif *vif)
---
> void xenvif_carrier_off(struct xenvif *vif)
348,355c348,360
< 	if (netif_carrier_ok(dev)) {
< 		rtnl_lock();
< 		netif_carrier_off(dev); /* discard queued packets */
< 		if (netif_running(dev))
< 			xenvif_down(vif);
< 		rtnl_unlock();
< 		xenvif_put(vif);
< 	}
---
> 
> 	rtnl_lock();
> 	netif_carrier_off(dev); /* discard queued packets */
> 	if (netif_running(dev))
> 		xenvif_down(vif);
> 	rtnl_unlock();
> 	xenvif_put(vif);
> }
> 
> void xenvif_disconnect(struct xenvif *vif)
> {
> 	if (netif_carrier_ok(vif->dev))
> 		xenvif_carrier_off(vif);




diff -r linux-3.0.36/drivers/net/xen-netback/netback.c linux-3.0.36-lenovo/drivers/net/xen-netback/netback.c
146c146,147
< static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx);
---
> static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,
> 				  u8 status);
841c842
< 		if (cons >= end)
---
> 		if (cons == end)
849a851,857
> static void netbk_fatal_tx_err(struct xenvif *vif)
> {
> 	netdev_err(vif->dev, "fatal error; disabling device\n");
> 	xenvif_carrier_off(vif);
> 	xenvif_put(vif);
> }
> 
863c871,872
< 			netdev_dbg(vif->dev, "Need more frags\n");
---
> 			netdev_err(vif->dev, "Need more frags\n");
> 			netbk_fatal_tx_err(vif);
868c877,878
< 			netdev_dbg(vif->dev, "Too many frags\n");
---
> 			netdev_err(vif->dev, "Too many frags\n");
> 			netbk_fatal_tx_err(vif);
875c885,886
< 			netdev_dbg(vif->dev, "Frags galore\n");
---
> 			netdev_err(vif->dev, "Frag is bigger than frame.\n");
> 			netbk_fatal_tx_err(vif);
883c894
< 			netdev_dbg(vif->dev, "txp->offset: %x, size: %u\n",
---
> 			netdev_err(vif->dev, "txp->offset: %x, size: %u\n",
884a896
> 			netbk_fatal_tx_err(vif);
928c940
< 			return NULL;
---
> 			goto err;
951a964,974
> err:
> 	/* Unwind, freeing all pages and sending error responses. */
> 	while (i-- > start) {
> 		xen_netbk_idx_release(netbk, (unsigned long)shinfo->frags[i].page,
> 				      XEN_NETIF_RSP_ERROR);
> 	}
> 	/* The head too, if necessary. */
> 	if (start)
> 		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);
> 
> 	return NULL;
960,962d982
< 	struct pending_tx_info *pending_tx_info = netbk->pending_tx_info;
< 	struct xenvif *vif = pending_tx_info[pending_idx].vif;
< 	struct xen_netif_tx_request *txp;
969,976c989,990
< 	if (unlikely(err)) {
< 		pending_ring_idx_t index;
< 		index = pending_index(netbk->pending_prod++);
< 		txp = &pending_tx_info[pending_idx].req;
< 		make_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);
< 		netbk->pending_ring[index] = pending_idx;
< 		xenvif_put(vif);
< 	}
---
> 	if (unlikely(err))
> 		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);
979c993
< 	start = ((unsigned long)shinfo->frags[0].page == pending_idx);
---
> 	start = ((unsigned long)shinfo->frags[i].page == pending_idx);
983d996
< 		pending_ring_idx_t index;
992c1005
< 				xen_netbk_idx_release(netbk, pending_idx);
---
> 				xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
997,1001c1010
< 		txp = &netbk->pending_tx_info[pending_idx].req;
< 		make_tx_response(vif, txp, XEN_NETIF_RSP_ERROR);
< 		index = pending_index(netbk->pending_prod++);
< 		netbk->pending_ring[index] = pending_idx;
< 		xenvif_put(vif);
---
> 		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_ERROR);
1009c1018
< 		xen_netbk_idx_release(netbk, pending_idx);
---
> 		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
1012c1021
< 			xen_netbk_idx_release(netbk, pending_idx);
---
> 			xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
1047c1056
< 		xen_netbk_idx_release(netbk, pending_idx);
---
> 		xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
1060c1069,1070
< 			netdev_dbg(vif->dev, "Missing extra info\n");
---
> 			netdev_err(vif->dev, "Missing extra info\n");
> 			netbk_fatal_tx_err(vif);
1069c1079
< 			netdev_dbg(vif->dev,
---
> 			netdev_err(vif->dev,
1070a1081
> 			netbk_fatal_tx_err(vif);
1086c1097,1098
< 		netdev_dbg(vif->dev, "GSO size must not be zero.\n");
---
> 		netdev_err(vif->dev, "GSO size must not be zero.\n");
> 		netbk_fatal_tx_err(vif);
1092c1104,1105
< 		netdev_dbg(vif->dev, "Bad GSO type %d.\n", gso->u.gso.type);
---
> 		netdev_err(vif->dev, "Bad GSO type %d.\n", gso->u.gso.type);
> 		netbk_fatal_tx_err(vif);
1228a1242,1246
> 		/* This can sometimes happen because the test of
> 		 * list_empty(net_schedule_list) at the top of the
> 		 * loop is unlocked.  Just go back and have another
> 		 * look.
> 		 */
1231a1250,1260
> 		if (vif->tx.sring->req_prod - vif->tx.req_cons >
> 		    XEN_NETIF_TX_RING_SIZE) {
> 			netdev_err(vif->dev,
> 				   "Impossible number of requests. "
> 				   "req_prod %d, req_cons %d, size %ld\n",
> 				   vif->tx.sring->req_prod, vif->tx.req_cons,
> 				   XEN_NETIF_TX_RING_SIZE);
> 			netbk_fatal_tx_err(vif);
> 			continue;
> 		}
> 
1259,1260c1288
< 			if (unlikely(work_to_do < 0)) {
< 				netbk_tx_err(vif, &txreq, idx);
---
> 			if (unlikely(work_to_do < 0))
1262d1289
< 			}
1266,1267c1293
< 		if (unlikely(ret < 0)) {
< 			netbk_tx_err(vif, &txreq, idx - ret);
---
> 		if (unlikely(ret < 0))
1269c1295
< 		}
---
> 
1281c1307
< 			netdev_dbg(vif->dev,
---
> 			netdev_err(vif->dev,
1285c1311
< 			netbk_tx_err(vif, &txreq, idx);
---
> 			netbk_fatal_tx_err(vif);
1312a1339
> 				/* Failure in netbk_set_skb_gso is fatal. */
1314d1340
< 				netbk_tx_err(vif, &txreq, idx);
1415c1441
< 			xen_netbk_idx_release(netbk, pending_idx);
---
> 			xen_netbk_idx_release(netbk, pending_idx, XEN_NETIF_RSP_OKAY);
1470c1496,1497
< static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx)
---
> static void xen_netbk_idx_release(struct xen_netbk *netbk, u16 pending_idx,
> 				  u8 status)
1484c1511
< 	make_tx_response(vif, &pending_tx_info->req, XEN_NETIF_RSP_OKAY);
---
> 	make_tx_response(vif, &pending_tx_info->req, status);




diff -r linux-3.0.36/drivers/oprofile/oprofile_perf.c linux-3.0.36-lenovo/drivers/oprofile/oprofile_perf.c
28c28
< static struct perf_event **perf_events[nr_cpumask_bits];
---
> static struct perf_event **perf_events[NR_CPUS];




diff -r linux-3.0.36/drivers/pci/hotplug/acpiphp_glue.c linux-3.0.36-lenovo/drivers/pci/hotplug/acpiphp_glue.c
134c134,139
< 	acpi_evaluate_integer(handle, "_ADR", NULL, &adr);
---
> 	status = acpi_evaluate_integer(handle, "_ADR", NULL, &adr);
> 	if (ACPI_FAILURE(status)) {
> 		warn("can't evaluate _ADR (%#x)\n", status);
> 		return AE_OK;
> 	}
> 




diff -r linux-3.0.36/drivers/pci/intel-iommu.c linux-3.0.36-lenovo/drivers/pci/intel-iommu.c
1796c1796
< 			if (largepage_lvl > 1)
---
> 			if (largepage_lvl > 1) {
1798c1798,1804
< 			else
---
> 				/* Ensure that old small page tables are removed to make room
> 				   for superpage, if they exist. */
> 				dma_pte_clear_range(domain, iov_pfn,
> 						    iov_pfn + lvl_to_nr_pages(largepage_lvl) - 1);
> 				dma_pte_free_pagetable(domain, iov_pfn,
> 						       iov_pfn + lvl_to_nr_pages(largepage_lvl) - 1);
> 			} else {
1799a1806
> 			}
2284a2292,2309
> static bool device_has_rmrr(struct pci_dev *dev)
> {
> 	struct dmar_rmrr_unit *rmrr;
> 	int i;
> 
> 	for_each_rmrr_units(rmrr) {
> 		for (i = 0; i < rmrr->devices_cnt; i++) {
> 			/*
> 			 * Return TRUE if this RMRR contains the device that
> 			 * is passed in.
> 			 */
> 			if (rmrr->devices[i] == dev)
> 				return true;
> 		}
> 	}
> 	return false;
> }
> 
2286a2312,2324
> 
> 	/*
> 	 * We want to prevent any device associated with an RMRR from
> 	 * getting placed into the SI Domain. This is done because
> 	 * problems exist when devices are moved in and out of domains
> 	 * and their respective RMRR info is lost. We exempt USB devices
> 	 * from this process due to their usage of RMRRs that are known
> 	 * to not be needed after BIOS hand-off to OS.
> 	 */
> 	if (device_has_rmrr(pdev) &&
> 	    (pdev->class >> 8) != PCI_CLASS_SERIAL_USB)
> 		return 0;
> 
3575a3614,3615
> 	spin_unlock_irqrestore(&device_domain_lock, flags);
> 
3592,3593d3631
< 
< 	spin_unlock_irqrestore(&device_domain_lock, flags);




diff -r linux-3.0.36/drivers/pci/pci.c linux-3.0.36-lenovo/drivers/pci/pci.c
1685,1689d1684
< 	/* Some devices mustn't be in D3 during system sleep */
< 	if (target_state == PCI_D3hot &&
< 			(dev->dev_flags & PCI_DEV_FLAGS_NO_D3_DURING_SLEEP))
< 		return 0;
< 




diff -r linux-3.0.36/drivers/pci/pci-driver.c linux-3.0.36-lenovo/drivers/pci/pci-driver.c
728a729,740
> 	/*
> 	 * Some BIOSes from ASUS have a bug: If a USB EHCI host controller's
> 	 * PCI COMMAND register isn't 0, the BIOS assumes that the controller
> 	 * hasn't been quiesced and tries to turn it off.  If the controller
> 	 * is already in D3, this can hang or cause memory corruption.
> 	 *
> 	 * Since the value of the COMMAND register doesn't matter once the
> 	 * device has been suspended, we can safely set it to 0 here.
> 	 */
> 	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
> 		pci_write_config_word(pci_dev, PCI_COMMAND, 0);
> 
925a938,944
> 
> 	/*
> 	 * The reason for doing this here is the same as for the analogous code
> 	 * in pci_pm_suspend_noirq().
> 	 */
> 	if (pci_dev->class == PCI_CLASS_SERIAL_USB_EHCI)
> 		pci_write_config_word(pci_dev, PCI_COMMAND, 0);




diff -r linux-3.0.36/drivers/pci/pcie/aspm.c linux-3.0.36-lenovo/drivers/pci/pcie/aspm.c
792a793,795
> 	if (aspm_force)
> 		return;
> 




diff -r linux-3.0.36/drivers/pci/probe.c linux-3.0.36-lenovo/drivers/pci/probe.c
667,668c667,670
< 	    (primary != bus->number || secondary <= bus->number)) {
< 		dev_dbg(&dev->dev, "bus configuration invalid, reconfiguring\n");
---
> 	    (primary != bus->number || secondary <= bus->number ||
> 	     secondary > subordinate)) {
> 		dev_info(&dev->dev, "bridge configuration invalid ([bus %02x-%02x]), reconfiguring\n",
> 			 secondary, subordinate);




diff -r linux-3.0.36/drivers/pci/quirks.c linux-3.0.36-lenovo/drivers/pci/quirks.c
2749c2749
< 	 * RICOH 0xe823 SD/MMC card reader fails to recognize
---
> 	 * RICOH 0xe822 and 0xe823 SD/MMC card readers fail to recognize
2760c2760,2761
< 	if (dev->device == PCI_DEVICE_ID_RICOH_R5CE823) {
---
> 	if (dev->device == PCI_DEVICE_ID_RICOH_R5CE822 ||
> 	    dev->device == PCI_DEVICE_ID_RICOH_R5CE823) {
2786a2788,2789
> DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE822, ricoh_mmc_fixup_r5c832);
> DECLARE_PCI_FIXUP_RESUME_EARLY(PCI_VENDOR_ID_RICOH, PCI_DEVICE_ID_RICOH_R5CE822, ricoh_mmc_fixup_r5c832);
2858,2883d2860
< 
< /*
<  * The Intel 6 Series/C200 Series chipset's EHCI controllers on many
<  * ASUS motherboards will cause memory corruption or a system crash
<  * if they are in D3 while the system is put into S3 sleep.
<  */
< static void __devinit asus_ehci_no_d3(struct pci_dev *dev)
< {
< 	const char *sys_info;
< 	static const char good_Asus_board[] = "P8Z68-V";
< 
< 	if (dev->dev_flags & PCI_DEV_FLAGS_NO_D3_DURING_SLEEP)
< 		return;
< 	if (dev->subsystem_vendor != PCI_VENDOR_ID_ASUSTEK)
< 		return;
< 	sys_info = dmi_get_system_info(DMI_BOARD_NAME);
< 	if (sys_info && memcmp(sys_info, good_Asus_board,
< 			sizeof(good_Asus_board) - 1) == 0)
< 		return;
< 
< 	dev_info(&dev->dev, "broken D3 during system sleep on ASUS\n");
< 	dev->dev_flags |= PCI_DEV_FLAGS_NO_D3_DURING_SLEEP;
< 	device_set_wakeup_capable(&dev->dev, false);
< }
< DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c26, asus_ehci_no_d3);
< DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 0x1c2d, asus_ehci_no_d3);




diff -r linux-3.0.36/drivers/pci/remove.c linux-3.0.36-lenovo/drivers/pci/remove.c
21a22,23
> 	pci_pme_active(dev, false);
> 




diff -r linux-3.0.36/drivers/pci/setup-bus.c linux-3.0.36-lenovo/drivers/pci/setup-bus.c
36a37
> 	resource_size_t min_align;
68c69
< 		 resource_size_t add_size)
---
> 		 resource_size_t add_size, resource_size_t min_align)
86a88
> 	tmp->min_align = min_align;
93c95,97
< 	add_to_list(head, dev, res, 0);
---
> 	add_to_list(head, dev, res,
> 			0 /* dont care */,
> 			0 /* dont care */);
162,164c166,168
< 		if (!resource_size(res) && add_size) {
< 			 res->end = res->start + add_size - 1;
< 			 if(pci_assign_resource(list->dev, idx))
---
> 		if (!resource_size(res)) {
> 			res->end = res->start + add_size - 1;
> 			if(pci_assign_resource(list->dev, idx))
166,168c170,175
< 		} else if (add_size) {
< 			adjust_resource(res, res->start,
< 				resource_size(res) + add_size);
---
> 		} else {
> 			resource_size_t align = list->min_align;
> 			res->flags |= list->flags & (IORESOURCE_STARTALIGN|IORESOURCE_SIZEALIGN);
> 			if (pci_reassign_resource(list->dev, idx, add_size, align))
> 				dev_printk(KERN_DEBUG, &list->dev->dev, "failed to add optional resources res=%pR\n",
> 							res);
545a553,566
> static resource_size_t get_res_add_size(struct resource_list_x *add_head,
> 					struct resource *res)
> {
> 	struct resource_list_x *list;
> 
> 	/* check if it is in add_head list */
> 	for (list = add_head->next; list && list->res != res;
> 			list = list->next);
> 	if (list)
> 		return list->add_size;
> 
> 	return 0;
> }
> 
564a586
> 	resource_size_t children_add_size = 0;
584a607,609
> 
> 			if (add_head)
> 				children_add_size += get_res_add_size(add_head, r);
588a614,615
> 	if (children_add_size > add_size)
> 		add_size = children_add_size;
590c617
< 		calculate_iosize(size, min_size+add_size, size1,
---
> 		calculate_iosize(size, min_size, add_size + size1,
605c632
< 		add_to_list(add_head, bus->self, b_res, size1-size0);
---
> 		add_to_list(add_head, bus->self, b_res, size1-size0, 4096);
629a657
> 	resource_size_t children_add_size = 0;
670a699,701
> 
> 			if (add_head)
> 				children_add_size += get_res_add_size(add_head, r);
686a718,719
> 	if (children_add_size > add_size)
> 		add_size = children_add_size;
688c721
< 		calculate_memsize(size, min_size+add_size, 0,
---
> 		calculate_memsize(size, min_size, add_size,
702c735
< 		add_to_list(add_head, bus->self, b_res, size1-size0);
---
> 		add_to_list(add_head, bus->self, b_res, size1-size0, min_align);




diff -r linux-3.0.36/drivers/pci/setup-res.c linux-3.0.36-lenovo/drivers/pci/setup-res.c
131a132,133
> 
> 
133c135
< 				 int resno)
---
> 		int resno, resource_size_t size, resource_size_t align)
136c138
< 	resource_size_t size, min, align;
---
> 	resource_size_t min;
139d140
< 	size = resource_size(res);
141d141
< 	align = pci_resource_alignment(dev, res);
157a158,159
> 	return ret;
> }
159,161c161,189
< 	if (ret < 0 && dev->fw_addr[resno]) {
< 		struct resource *root, *conflict;
< 		resource_size_t start, end;
---
> static int pci_revert_fw_address(struct resource *res, struct pci_dev *dev,
> 		int resno, resource_size_t size)
> {
> 	struct resource *root, *conflict;
> 	resource_size_t start, end;
> 	int ret = 0;
> 
> 	if (res->flags & IORESOURCE_IO)
> 		root = &ioport_resource;
> 	else
> 		root = &iomem_resource;
> 
> 	start = res->start;
> 	end = res->end;
> 	res->start = dev->fw_addr[resno];
> 	res->end = res->start + size - 1;
> 	dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
> 		 resno, res);
> 	conflict = request_resource_conflict(root, res);
> 	if (conflict) {
> 		dev_info(&dev->dev,
> 			 "BAR %d: %pR conflicts with %s %pR\n", resno,
> 			 res, conflict->name, conflict);
> 		res->start = start;
> 		res->end = end;
> 		ret = 1;
> 	}
> 	return ret;
> }
163,167c191,196
< 		/*
< 		 * If we failed to assign anything, let's try the address
< 		 * where firmware left it.  That at least has a chance of
< 		 * working, which is better than just leaving it disabled.
< 		 */
---
> static int _pci_assign_resource(struct pci_dev *dev, int resno, int size, resource_size_t min_align)
> {
> 	struct resource *res = dev->resource + resno;
> 	struct pci_bus *bus;
> 	int ret;
> 	char *type;
169,170c198,212
< 		if (res->flags & IORESOURCE_IO)
< 			root = &ioport_resource;
---
> 	bus = dev->bus;
> 	while ((ret = __pci_assign_resource(bus, dev, resno, size, min_align))) {
> 		if (!bus->parent || !bus->self->transparent)
> 			break;
> 		bus = bus->parent;
> 	}
> 
> 	if (ret) {
> 		if (res->flags & IORESOURCE_MEM)
> 			if (res->flags & IORESOURCE_PREFETCH)
> 				type = "mem pref";
> 			else
> 				type = "mem";
> 		else if (res->flags & IORESOURCE_IO)
> 			type = "io";
172c214,218
< 			root = &iomem_resource;
---
> 			type = "unknown";
> 		dev_info(&dev->dev,
> 			 "BAR %d: can't assign %s (size %#llx)\n",
> 			 resno, type, (unsigned long long) resource_size(res));
> 	}
174,188c220,233
< 		start = res->start;
< 		end = res->end;
< 		res->start = dev->fw_addr[resno];
< 		res->end = res->start + size - 1;
< 		dev_info(&dev->dev, "BAR %d: trying firmware assignment %pR\n",
< 			 resno, res);
< 		conflict = request_resource_conflict(root, res);
< 		if (conflict) {
< 			dev_info(&dev->dev,
< 				 "BAR %d: %pR conflicts with %s %pR\n", resno,
< 				 res, conflict->name, conflict);
< 			res->start = start;
< 			res->end = end;
< 		} else
< 			ret = 0;
---
> 	return ret;
> }
> 
> int pci_reassign_resource(struct pci_dev *dev, int resno, resource_size_t addsize,
> 			resource_size_t min_align)
> {
> 	struct resource *res = dev->resource + resno;
> 	resource_size_t new_size;
> 	int ret;
> 
> 	if (!res->parent) {
> 		dev_info(&dev->dev, "BAR %d: can't reassign an unassigned resouce %pR "
> 			 "\n", resno, res);
> 		return -EINVAL;
190a236,238
> 	/* already aligned with min_align */
> 	new_size = resource_size(res) + addsize;
> 	ret = _pci_assign_resource(dev, resno, new_size, min_align);
193c241
< 		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
---
> 		dev_info(&dev->dev, "BAR %d: reassigned %pR\n", resno, res);
197d244
< 
204c251
< 	resource_size_t align;
---
> 	resource_size_t align, size;
207d253
< 	char *type;
217,225c263,264
< 	while ((ret = __pci_assign_resource(bus, dev, resno))) {
< 		if (bus->parent && bus->self->transparent)
< 			bus = bus->parent;
< 		else
< 			bus = NULL;
< 		if (bus)
< 			continue;
< 		break;
< 	}
---
> 	size = resource_size(res);
> 	ret = _pci_assign_resource(dev, resno, size, align);
227,240c266,272
< 	if (ret) {
< 		if (res->flags & IORESOURCE_MEM)
< 			if (res->flags & IORESOURCE_PREFETCH)
< 				type = "mem pref";
< 			else
< 				type = "mem";
< 		else if (res->flags & IORESOURCE_IO)
< 			type = "io";
< 		else
< 			type = "unknown";
< 		dev_info(&dev->dev,
< 			 "BAR %d: can't assign %s (size %#llx)\n",
< 			 resno, type, (unsigned long long) resource_size(res));
< 	}
---
> 	/*
> 	 * If we failed to assign anything, let's try the address
> 	 * where firmware left it.  That at least has a chance of
> 	 * working, which is better than just leaving it disabled.
> 	 */
> 	if (ret < 0 && dev->fw_addr[resno])
> 		ret = pci_revert_fw_address(res, dev, resno, size);
241a274,279
> 	if (!ret) {
> 		res->flags &= ~IORESOURCE_STARTALIGN;
> 		dev_info(&dev->dev, "BAR %d: assigned %pR\n", resno, res);
> 		if (resno < PCI_BRIDGE_RESOURCES)
> 			pci_update_resource(dev, resno);
> 	}
243a282
> 




diff -r linux-3.0.36/drivers/pcmcia/pxa2xx_sharpsl.c linux-3.0.36-lenovo/drivers/pcmcia/pxa2xx_sharpsl.c
225c225
< static struct pcmcia_low_level sharpsl_pcmcia_ops __initdata = {
---
> static struct pcmcia_low_level sharpsl_pcmcia_ops = {




diff -r linux-3.0.36/drivers/platform/x86/acer-wmi.c linux-3.0.36-lenovo/drivers/platform/x86/acer-wmi.c
106a107
> 	{KE_KEY, 0x29, {KEY_PROG3} },    /* P_Key for TM8372 */




diff -r linux-3.0.36/drivers/platform/x86/asus-laptop.c linux-3.0.36-lenovo/drivers/platform/x86/asus-laptop.c
649c649
< 	rv = acpi_evaluate_integer(asus->handle, "HRWS", NULL, &temp);
---
> 	rv = acpi_evaluate_integer(asus->handle, "HWRS", NULL, &temp);
651c651
< 		len += sprintf(page + len, "HRWS value         : %#x\n",
---
> 		len += sprintf(page + len, "HWRS value         : %#x\n",
1343c1343
< 	    acpi_evaluate_integer(asus->handle, "HRWS", NULL, &hwrs_result);
---
> 	    acpi_evaluate_integer(asus->handle, "HWRS", NULL, &hwrs_result);
1345c1345
< 		pr_notice("  HRWS returned %x", (int)hwrs_result);
---
> 		pr_notice("  HWRS returned %x", (int)hwrs_result);




diff -r linux-3.0.36/drivers/platform/x86/asus-nb-wmi.c linux-3.0.36-lenovo/drivers/platform/x86/asus-nb-wmi.c
70a71,74
> 	{ KE_KEY, 0xA0, { KEY_SWITCHVIDEOMODE } }, /* SDSP HDMI only */
> 	{ KE_KEY, 0xA1, { KEY_SWITCHVIDEOMODE } }, /* SDSP LCD + HDMI */
> 	{ KE_KEY, 0xA2, { KEY_SWITCHVIDEOMODE } }, /* SDSP CRT + HDMI */
> 	{ KE_KEY, 0xA3, { KEY_SWITCHVIDEOMODE } }, /* SDSP TV + HDMI */




diff -r linux-3.0.36/drivers/platform/x86/intel_ips.c linux-3.0.36-lenovo/drivers/platform/x86/intel_ips.c
74a75
> #include <linux/dmi.h>
1507a1509,1526
> static int ips_blacklist_callback(const struct dmi_system_id *id)
> {
> 	pr_info("Blacklisted intel_ips for %s\n", id->ident);
> 	return 1;
> }
> 
> static const struct dmi_system_id ips_blacklist[] = {
> 	{
> 		.callback = ips_blacklist_callback,
> 		.ident = "HP ProBook",
> 		.matches = {
> 			DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
> 			DMI_MATCH(DMI_PRODUCT_NAME, "HP ProBook"),
> 		},
> 	},
> 	{ }	/* terminating entry */
> };
> 
1515a1535,1537
> 
> 	if (dmi_check_system(ips_blacklist))
> 		return -ENODEV;




diff -r linux-3.0.36/drivers/pnp/pnpacpi/core.c linux-3.0.36-lenovo/drivers/pnp/pnpacpi/core.c
60c60
< 	if (!('@' <= (c) || (c) <= 'Z')) \
---
> 	if (!('A' <= (c) && (c) <= 'Z')) \
95a96,98
> 
> 	if (WARN_ON_ONCE(acpi_dev != dev->data))
> 		dev->data = acpi_dev;
Only in linux-3.0.36-lenovo/drivers/power: blueberry_batfwi2c.c
Only in linux-3.0.36-lenovo/drivers/power: blueberry_batfwi2c.h
Only in linux-3.0.36-lenovo/drivers/power: blueberry_battery.c
Only in linux-3.0.36-lenovo/drivers/power: blueberry_battery.h
Only in linux-3.0.36-lenovo/drivers/power: blueberry_ecfw.c
Only in linux-3.0.36-lenovo/drivers/power: blueberry_firmware.c
Only in linux-3.0.36-lenovo/drivers/power: blueberry_firmware.h
Only in linux-3.0.36-lenovo/drivers/power: bq24193_charger.c
Only in linux-3.0.36-lenovo/drivers/power: bq24195_charger.c
Only in linux-3.0.36-lenovo/drivers/power: bq27510_battery.c
Only in linux-3.0.36-lenovo/drivers/power: bq27541_battery.c
Only in linux-3.0.36-lenovo/drivers/power: bq3060_battery.c
Only in linux-3.0.36-lenovo/drivers/power: cw2015_battery.c
Only in linux-3.0.36-lenovo/drivers/power: cw2015_charge.c




diff -r linux-3.0.36/drivers/power/Kconfig linux-3.0.36-lenovo/drivers/power/Kconfig
52a53,66
> config WM831X_CHARGER_DISPLAY
> 	tristate "WM831X Charger display support"
> 	depends on WM831X_POWER
> 	help
> 	  Say Y here to enable support for the power management unit
> 	  provided by Wolfson Microelectronics WM831x Charger Display.  
> 
> config WM831X_WITH_BATTERY
> 	tristate "WM831X battery exist"
> 	depends on WM831X_POWER
> 	default n
> 	help
> 	  WM831X battery exist.
> 
129a144,180
> config BATTERY_BLUEBERRY
> 	tristate "Blueberry battery and firmware update driver"
> 	help
> 	  Say Y here to enable support for blueberry battery and EC update.
> 
> config BLUEBERRY_FW_KERNEL_UPGRADE
> 	bool "Blueberry EC firmware kernel upgrade support"
> 	depends on BATTERY_BLUEBERRY
> 	help
> 	  Say Y here to upgrade blueberry ec firmware.
> 
> config REPORT_FULL_DATA_ITEM
> 	bool "Enable full set of battery items report"
> 	depends on BATTERY_BLUEBERRY
> 	help
> 	  Android only interested in seven battery parameter items, but other
> 	  application like battery-monitor need more. if enabled, battery-monitor
> 	  like application can give user more information. But it will put more
> 	  pressure on EC.
> 
> config BAT_ADC_DET
> 	bool "Enable battery plug/unplug detection to use ADC channel 0"
> 	depends on BATTERY_BLUEBERRY
> 	help
> 	  We can use two methods to detect battery present. One is use EC reported
>  	  data and another is using adc channel 0. If use EC reported data, then 
> 	  there will be more communication between EC and driver, that put more
> 	  pressure on EC. If using ADC detection, will help EC a lot. PCB ver 1.0
> 	  can nott use ADC detection because of recovery pin leakage. Enable this 
> 	  at later PCB version.
> 
> config CHARGER_INPUT_SELECT
>     bool "Enable bq24192 power selection control"
>     depends on BATTERY_BLUEBERRY
>     help
>       Enable bq24192 power selection control.
> 
187a239,279
> config BATTERY_STC3100
> 	tristate "STC3100 battery driver"
> 	depends on I2C && ARCH_RK29
> 	help
> 	  Say Y here to enable support for batteries with STC3100(I2C) chip.
> 
> config BATTERY_BQ27510
> 	tristate "BQ27510 battery driver"
> 	depends on I2C_RK29 || I2C_RK30
> 	help
> 	  Say Y here to enable support for batteries with BQ27510(I2C) chip.
> 
> config BATTERY_BQ27541
> 	tristate "BQ27541 battery driver"
> 	depends on I2C_RK29 || I2C_RK30
> 	help
> 	  Say Y here to enable support for batteries with BQ27541(I2C) chip.
> 	
> config BATTERY_BQ3060
> 	tristate "BQ3060 battery driver"
> 	depends on I2C && ARCH_RK29
> 	help
> 	  Say Y here to enable support for batteries with BQ3060(I2C) chip.  
> 
> config CHECK_BATT_CAPACITY
> 	tristate "check the capacity in BQ27510 battery if 1000mah write capacity for BATT_CAPACITY_MAH"
> 	depends on BATTERY_BQ27510 || BATTERY_BQ3060
> 	default n
> 
> config BATT_CAPACITY_MAH
> 	depends on CHECK_BATT_CAPACITY
> 	int "battery capacity (in mah)"
> 	default 2200
> 
> config NO_BATTERY_IC
> 	tristate "no BQ27510 battery ic in board"
> 	depends on BATTERY_BQ27510 || BATTERY_BQ27541 || BATTERY_BQ3060 
> 	default n
> 	help
> 	  Say no BQ27510(I2C) chip in board .
> 
226a319,329
> config CHARGER_CW2015
> 	tristate "cw2015 charger driver"
> 	help
> 	  Say Y here to enable support for TWL4030 Battery Charge Interface.
> 
> config TWL6030_BCI_BATTERY
> 	tristate "OMAP TWL6030 BCI Battery driver"
> 	depends on TWL4030_CORE && TWL6030_GPADC
> 	help
> 	  Support for OMAP TWL6030 BCI Battery driver.
> 	  This driver can give support for TWL6030 Battery Charge Interface.
236a340,432
> 
> config BATTERY_RK29_ADC
> 	tristate "RK29 ADC Battery"
> 	depends on ADC_RK29
> 	help
> 	  Say Y to enable support for the battery on the RK2918.
> 
> config BATTERY_RK29_AC_CHARGE
> 	tristate "RK29 AC CHARGE"
> 	depends on BATTERY_RK29_ADC
> 	help
> 	  say Y to enable suspport for the AC battery charge
> 
> config BATTERY_RK29_VOL3V8
> 	tristate "the battery voltage is 3.8V"
> 	depends on BATTERY_RK29_ADC
> 	help
>           say Y to enable suspport for the battery voltage 3.8V
> 
> config BATTERY_RK30_ADC
>         tristate "RK30 ADC Battery"
>         depends on ADC_RK30
>         help
>           Say Y to enable support for the battery on the RK30.
> 
> config BATTERY_OZ8806
>         tristate "Battery OZ8806"
>         help
>           Say Y to enable support for the battery on the RK3188.
> 
> 
> config BATTERY_RK30_ADC_FAC
>         tristate "RK30 ADC Battery Factory"
>         depends on ADC_RK30
>         help
>           Say Y to enable support for the battery on the RK30.
> 
> config CW2015_BATTERY
> 	tristate "CW2015 battery driver"
> 	help
> 	  Say Y to enable support for the cw2015 on the Rockchip
> 
> 
> 
> config BATTERY_RK30_AC_CHARGE
>         tristate "RK30 AC CHARGE"
>         depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
>         help
>           say Y to enable suspport for the AC battery charge
> 
> config BATTERY_RK30_USB_CHARGE
>         tristate "RK30 USB CHARGE"
>         depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
>         help
>           say Y to enable suspport for the USB battery charge
> 
> config BATTERY_RK30_VOL3V8
>        tristate "the battery voltage is 3.8V"
>         depends on BATTERY_RK30_ADC||BATTERY_RK30_ADC_FAC
>         help
>           say Y to enable suspport for the battery voltage 3.8V	
> 
> config POWER_ON_CHARGER_DISPLAY
> 	bool "Support charger display"
> 
> config WM8326_VBAT_LOW_DETECTION
> 	tristate "Support for WM8326 battery voltage detection."
> 	default n
> 
> config TWL60xx_VBAT_LOW_DETECTION
> 	tristate "Support for twl60xx low battery detection."
> 	default n
> 
> config BATTERY_OZ8806
> 	tristate "O2Micro OZ8806 Battery Fuel Gauge"
> 	help
> 	  Say Y to enable support for the battery fuel gauge.
> 
> config CHARGER_BQ24193
> 	tristate "Support TI BQ24193 Battery Charger"
> 	depends on I2C
> 	select REGMAP_I2C
> 	help
> 	  Say Y to include support for Summit TI BQ24193
> 	  Battery Charger.
> 
> config CHARGER_BQ24195
> 	tristate "Support TI BQ24195 Battery Charger"
> 	depends on I2C
> 	select REGMAP_I2C
> 	help
> 	  Say Y to include support for Summit TI BQ24195
> 	  Battery Charger.




diff -r linux-3.0.36/drivers/power/Makefile linux-3.0.36-lenovo/drivers/power/Makefile
13a14
> obj-$(CONFIG_WM831X_CHARGER_DISPLAY)	+= wm831x_charger_display.o
32a34,37
> obj-$(CONFIG_BATTERY_STC3100)	+= stc3100_battery.o
> obj-$(CONFIG_BATTERY_BQ27510)	+= bq27510_battery.o
> obj-$(CONFIG_BATTERY_BQ27541)	+= bq27541_battery.o
> obj-$(CONFIG_BATTERY_BQ3060)	+= bq3060_battery.o
37a43,45
> obj-$(CONFIG_CHARGER_CW2015) += cw2015_charge.o
> obj-$(CONFIG_BLUEBERRY_FW_KERNEL_UPGRADE) += blueberry_ecfw.o
> obj-$(CONFIG_BATTERY_BLUEBERRY) += blueberry_batfwi2c.o blueberry_battery.o blueberry_firmware.o
38a47,55
> obj-$(CONFIG_TWL6030_BCI_BATTERY)	+= twl6030_bci_battery.o
> obj-$(CONFIG_BATTERY_RK29_ADC)	+= rk29_adc_battery.o
> obj-$(CONFIG_BATTERY_RK30_ADC)  += rk30_adc_battery.o
> obj-$(CONFIG_PLAT_RK)		+= rk29_charger_display.o
> obj-$(CONFIG_BATTERY_RK30_ADC_FAC)  += rk30_factory_adc_battery.o
> obj-$(CONFIG_BATTERY_OZ8806)  += oz8806/
> obj-$(CONFIG_CW2015_BATTERY)  += cw2015_battery.o
> obj-$(CONFIG_CHARGER_BQ24193) += bq24193_charger.o
> obj-$(CONFIG_CHARGER_BQ24195) += bq24195_charger.o
Only in linux-3.0.36-lenovo/drivers/power: oz8806




diff -r linux-3.0.36/drivers/power/pda_power.c linux-3.0.36-lenovo/drivers/power/pda_power.c
16a17
> #include <linux/notifier.h>
41d41
< #ifdef CONFIG_USB_OTG_UTILS
43c43
< #endif
---
> static struct notifier_block otg_nb;
225c225,260
< 	return (transceiver->state == OTG_STATE_B_PERIPHERAL);
---
> 	return (transceiver->last_event == USB_EVENT_VBUS ||
> 		transceiver->last_event == USB_EVENT_ENUMERATED);
> }
> 
> static int otg_is_ac_online(void)
> {
> 	return (transceiver->last_event == USB_EVENT_CHARGER);
> }
> 
> static int otg_handle_notification(struct notifier_block *nb,
> 		unsigned long event, void *unused)
> {
> 	switch (event) {
> 	case USB_EVENT_CHARGER:
> 		ac_status = PDA_PSY_TO_CHANGE;
> 		break;
> 	case USB_EVENT_VBUS:
> 	case USB_EVENT_ENUMERATED:
> 		usb_status = PDA_PSY_TO_CHANGE;
> 		break;
> 	case USB_EVENT_NONE:
> 		ac_status = PDA_PSY_TO_CHANGE;
> 		usb_status = PDA_PSY_TO_CHANGE;
> 		break;
> 	default:
> 		return NOTIFY_OK;
> 	}
> 
> 	/*
> 	 * Wait a bit before reading ac/usb line status and setting charger,
> 	 * because ac/usb status readings may lag from irq.
> 	 */
> 	mod_timer(&charger_timer,
> 		  jiffies + msecs_to_jiffies(pdata->wait_for_status));
> 
> 	return NOTIFY_OK;
284a320,327
> 	transceiver = otg_get_transceiver();
> 	if (transceiver && !pdata->is_usb_online) {
> 		pdata->is_usb_online = otg_is_usb_online;
> 	}
> 	if (transceiver && !pdata->is_ac_online) {
> 		pdata->is_ac_online = otg_is_ac_online;
> 	}
> 
306,312d348
< #ifdef CONFIG_USB_OTG_UTILS
< 	transceiver = otg_get_transceiver();
< 	if (transceiver && !pdata->is_usb_online) {
< 		pdata->is_usb_online = otg_is_usb_online;
< 	}
< #endif
< 
333a370,379
> 	if (transceiver && pdata->use_otg_notifier) {
> 		otg_nb.notifier_call = otg_handle_notification;
> 		ret = otg_register_notifier(transceiver, &otg_nb);
> 		if (ret) {
> 			dev_err(dev, "failure to register otg notifier\n");
> 			goto otg_reg_notifier_failed;
> 		}
> 		polling = 0;
> 	}
> 
345a392,394
> otg_reg_notifier_failed:
> 	if (pdata->is_usb_online && usb_irq)
> 		free_irq(usb_irq->start, &pda_psy_usb);
352d400
< #ifdef CONFIG_USB_OTG_UTILS
355d402
< #endif




diff -r linux-3.0.36/drivers/power/power_supply_core.c linux-3.0.36-lenovo/drivers/power/power_supply_core.c
43a44
> 	unsigned long flags;
49,50c50,53
< 	class_for_each_device(power_supply_class, NULL, psy,
< 			      __power_supply_changed_work);
---
> 	spin_lock_irqsave(&psy->changed_lock, flags);
> 	if (psy->changed) {
> 		psy->changed = false;
> 		spin_unlock_irqrestore(&psy->changed_lock, flags);
52c55,56
< 	power_supply_update_leds(psy);
---
> 		class_for_each_device(power_supply_class, NULL, psy,
> 				      __power_supply_changed_work);
54c58,65
< 	kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
---
> 		power_supply_update_leds(psy);
> 
> 		kobject_uevent(&psy->dev->kobj, KOBJ_CHANGE);
> 		spin_lock_irqsave(&psy->changed_lock, flags);
> 	}
> 	if (!psy->changed)
> 		wake_unlock(&psy->work_wake_lock);
> 	spin_unlock_irqrestore(&psy->changed_lock, flags);
58a70,71
> 	unsigned long flags;
> 
60a74,77
> 	spin_lock_irqsave(&psy->changed_lock, flags);
> 	psy->changed = true;
> 	wake_lock(&psy->work_wake_lock);
> 	spin_unlock_irqrestore(&psy->changed_lock, flags);
183a201,203
> 	spin_lock_init(&psy->changed_lock);
> 	wake_lock_init(&psy->work_wake_lock, WAKE_LOCK_SUSPEND, "power-supply");
> 
192a213
> 	wake_lock_destroy(&psy->work_wake_lock);
205a227
> 	wake_lock_destroy(&psy->work_wake_lock);
Only in linux-3.0.36-lenovo/drivers/power: rk29_adc_battery.c
Only in linux-3.0.36-lenovo/drivers/power: rk29_charger_display.c
Only in linux-3.0.36-lenovo/drivers/power: rk30_adc_battery.c
Only in linux-3.0.36-lenovo/drivers/power: rk30_factory_adc_battery.c
Only in linux-3.0.36-lenovo/drivers/power: stc3100_battery.c




diff -r linux-3.0.36/drivers/power/test_power.c linux-3.0.36-lenovo/drivers/power/test_power.c
191,192c191,192
< 	{ 0,  "on"  },
< 	{ 1,  "off" },
---
> 	{ 1,  "on"  },
> 	{ 0,  "off" },
Only in linux-3.0.36-lenovo/drivers/power: twl6030_bci_battery.c
Only in linux-3.0.36-lenovo/drivers/power: wm831x_charger_display.c




diff -r linux-3.0.36/drivers/power/wm831x_power.c linux-3.0.36-lenovo/drivers/power/wm831x_power.c
20a21,88
> #include <linux/mfd/wm831x/irq.h>
> 
> #define WM831X_DEBUG
> #undef  WM831X_DEBUG
> 
> #ifdef WM831X_DEBUG
> #define	WM_BATT_DBG(x...) printk(KERN_INFO x)
> #else
> #define	WM_BATT_DBG(x...)  do {} while (0)
> #endif
> 
> #define WM831X_CHG_SYSLO_SHIFT   4
> #define WM831X_CHG_SYSOK_SHIFT   0
> #define WM831X_CHG_SYSLO_MASK  ~(0x7 << 4)
> #define WM831X_CHG_SYSOK_MASK  ~(0x7 << 0)
> 
> #define batt_num   52
> 
> static int batt_step_table[batt_num] = {
> 	3400,3420,3440,3475,3505,3525,
> 	3540,3557,3570,3580,3610,
> 	3630,3640,3652,3662,3672,
> 	3680,3687,3693,3699,3705,
> 	3710,3714,3718,3722,3726,
> 	3730,3734,3738,3742,3746,
> 	3750,3756,3764,3774,3786,
> 	3800,3808,3817,3827,3845,
> 	3950,3964,3982,4002,4026,
> 	4030,4034,4055,4070,4085,4120
> };
> 
> static int batt_disp_table[batt_num] = {
> 	0,1,2,3,5,7,
> 	9,11,13,15,17,
> 	19,21,23,25,27,
> 	29,31,33,35,37,
> 	39,41,43,45,47,
> 	49,51,53,55,57,
> 	59,61,63,65,67,
> 	69,71,73,75,77,
> 	79,81,83,85,87,
> 	89,91,93,95,97,100
> };
> 
> static int batt_chg_step_table[batt_num] = {
> 	3520,3525,3575,3600,3620,3644,//+160
> 	3662,3670,3684,3700,3715,//+150
> 	3720,3748,3756,3775,3790,//+140
> 	3810,3814,3818,3822,3825,//+130
> 	3830,3832,3834,3836,3837,//+120
> 	3839,3841,3842,3844,3844,//+110
> 	3855,3860,3864,3871,3890,//+100
> 	3910,3930,3952,3977,3997,//+90
> 	4030,4047,4064,4080,4096,//+80
> 	4132,4144,4150,4170,4195,4200//+70
> };
> 
> 
> 
> #define TIMER_MS_COUNTS 1000
> struct wm_batt_priv_data {
> 	int online;
> 	int status;
> 	int health;
> 	int level;
> 	int temp;
> 	int voltage;
> };
26a95,99
> 	struct work_struct batt_work;
> 	struct timer_list timer;
> 	struct wm_batt_priv_data batt_info;
> 	struct wake_lock 	syslo_wake;
> 	int interval;
28a102,125
> struct wm831x_power *g_wm831x_power;
> 
> static int power_test_sysfs_init(void);
> extern void wm831x_batt_vol_level(struct wm831x_power *power, int batt_vol, int *level);
> static DEFINE_MUTEX(charging_mutex);
> static struct wake_lock batt_wake_lock;
> 
> int wm831x_read_on_pin_status(void)
> {
> 	int ret;
> 	
> 	if(!g_wm831x_power)
> 	{
> 		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
> 		return -1;
> 	}
> 	
> 	ret = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_ON_PIN_CONTROL);
> 	if (ret < 0)
> 		return ret;
> 
> 	return !(ret & WM831X_ON_PIN_STS) ? 1 : 0;
> }
> 
45a143,164
> int wm831x_read_chg_status(void)
> {
> 	int ret, usb_chg = 0, wall_chg = 0;
> 	
> 	if(!g_wm831x_power)
> 	{
> 		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
> 		return -1;
> 	}
> 	
> 	ret = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_SYSTEM_STATUS);
> 	if (ret < 0)
> 		return ret;
> 
> 	if (ret & WM831X_PWR_USB)
> 		usb_chg = 1;
> 	if (ret & WM831X_PWR_WALL)
> 		wall_chg = 1;
> 
> 	return ((usb_chg | wall_chg) ? 1 : 0);
> }
> 
51d169
< 
54a173,175
> 	
> 	return ret ;
> }
55a177,187
> int wm831x_read_batt_voltage(void)
> {
> 	int ret = 0;
> 	
> 	if(!g_wm831x_power)
> 	{
> 		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
> 		return -1;
> 	}
> 	
> 	ret = wm831x_auxadc_read_uv(g_wm831x_power->wm831x, WM831X_AUX_BATT);
57a190
> //EXPORT_SYMBOL_GPL(wm831x_get_batt_voltage);
192a326,347
> static struct chg_map chg_syslos[] = {
> 	{ 2800, 0 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 2900, 1 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3000, 2 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3100, 3 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3200, 4 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3300, 5 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3400, 6 << WM831X_CHG_SYSLO_SHIFT},
> 	{ 3500, 7 << WM831X_CHG_SYSLO_SHIFT},
> };
> 
> static struct chg_map chg_sysoks[] = {
> 	{ 2800, 0 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 2900, 1 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3000, 2 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3100, 3 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3200, 4 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3300, 5 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3400, 6 << WM831X_CHG_SYSOK_SHIFT},
> 	{ 3500, 7 << WM831X_CHG_SYSOK_SHIFT},
> };
> 
199d353
< 
216c370
< 	int ret, reg1, reg2;
---
> 	int ret, reg1, reg2, reg3;
227a382
> 	reg3 = 0;
260a416,423
> 	wm831x_battey_apply_config(wm831x, chg_syslos, ARRAY_SIZE(chg_syslos),
> 				   pdata->syslo, &reg3,
> 				   "syslo voltage", "mV");
> 
> 	wm831x_battey_apply_config(wm831x, chg_sysoks, ARRAY_SIZE(chg_sysoks),
> 				   pdata->sysok, &reg3,
> 				   "sysok voltage", "mV");
> 
272c435
< 	if (ret != 0)
---
> 	if (ret != 0) {
275c438
< 
---
> 	}
283c446
< 	if (ret != 0)
---
> 	if (ret != 0) {
285a449,457
> 	}
> 
> 	ret = wm831x_set_bits(wm831x, WM831X_SYSVDD_CONTROL,
> 				          WM831X_CHG_SYSLO_MASK |
> 						  WM831X_CHG_SYSOK_MASK,
> 						  reg3);
> 	if (ret < 0) {
> 		dev_err(wm831x->dev, "Failed to set sysvdd control reg: %d\n",ret);
> 	}
306a479
> 
322a496,512
> int wm831x_read_bat_charging_status(void)
> {
> 	int ret, status;
> 	
> 	if(!g_wm831x_power)
> 	{
> 		printk("err:%s:g_wm831x_power address is 0\n",__FUNCTION__);
> 		return -1;
> 	}
> 	
> 	ret = wm831x_bat_check_status(g_wm831x_power->wm831x, &status);
> 	if (ret < 0)
> 		return ret;
> 	if (status == POWER_SUPPLY_STATUS_CHARGING) 
> 		return 1;
> 	return 0;
> }
326a517,542
> #ifdef WM831X_DEBUG_0 
> 	ret = wm831x_reg_read(wm831x, WM831X_POWER_STATE);
> 	if (ret < 0)
> 		return ret;
> 	WM_BATT_DBG("%s: wm831x power status %#x\n", __FUNCTION__, ret);
> 
> 	ret = wm831x_reg_read(wm831x, WM831X_SYSTEM_STATUS);
> 	if (ret < 0)
> 		return ret;
> 	WM_BATT_DBG("%s: wm831x system status %#x\n", __FUNCTION__, ret);
> 
> 	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_1);
> 	if (ret < 0)
> 		return ret;
> 	WM_BATT_DBG("%s: wm831x charger control1 %#x\n", __FUNCTION__, ret);
> 
> 	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_CONTROL_2);
> 	if (ret < 0)
> 		return ret;
> 	WM_BATT_DBG("%s: wm831x charger control2 %#x\n", __FUNCTION__, ret);
> 
> 	ret = wm831x_reg_read(wm831x, WM831X_CHARGER_STATUS);
> 	if (ret < 0)
> 		return ret;
> 	WM_BATT_DBG("%s: wm831x charger status %#x\n\n", __FUNCTION__, ret);
> #endif
394c610
< 	int ret = 0;
---
> 	int  ret = 0;
398a615
> 		//val->intval = wm831x_power->batt_info.status;
400,402c617,620
< 	case POWER_SUPPLY_PROP_ONLINE:
< 		ret = wm831x_power_check_online(wm831x, WM831X_PWR_SRC_BATT,
< 						val);
---
> 	case POWER_SUPPLY_PROP_PRESENT:
> 	//case POWER_SUPPLY_PROP_ONLINE:
> 		//ret = wm831x_power_check_online(wm831x, WM831X_PWR_SRC_BATT, val);
> 		val->intval = wm831x_power->batt_info.online;
405c623,624
< 		ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
---
> 		//ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
> 		val->intval = wm831x_power->batt_info.voltage;//uV
408c627,628
< 		ret = wm831x_bat_check_health(wm831x, &val->intval);
---
> 		//ret = wm831x_bat_check_health(wm831x, &val->intval);
> 		val->intval = wm831x_power->batt_info.health;
412a633,644
> 	case POWER_SUPPLY_PROP_CAPACITY:
> 		//ret = wm831x_power_read_voltage(wm831x, WM831X_AUX_BATT, val);
> 		//wm831x_batt_vol_level(wm831x_power, val->intval, &level);
> 		//val->intval = level;
> 		val->intval = wm831x_power->batt_info.level;
> 		break;
> 	case POWER_SUPPLY_PROP_TEMP:
> 		val->intval = 0;
> 		break;
> 	case POWER_SUPPLY_PROP_TECHNOLOGY:
> 		val->intval = POWER_SUPPLY_TECHNOLOGY_LION;
> 		break;
423,424d654
< 	POWER_SUPPLY_PROP_ONLINE,
< 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
425a656,660
> 	POWER_SUPPLY_PROP_PRESENT,
> 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
> 	POWER_SUPPLY_PROP_CAPACITY, /* in percents! */
> 	POWER_SUPPLY_PROP_TECHNOLOGY,
> 	POWER_SUPPLY_PROP_TEMP,
428a664
> #ifdef CONFIG_WM831X_WITH_BATTERY
444,446c680,684
< 
< 	dev_dbg(wm831x->dev, "Battery status changed: %d\n", irq);
< 
---
> 	int irq0;
> 	
> 	irq0 = wm831x->irq_base + WM831X_IRQ_CHG_BATT_HOT + 1;
> 	dev_crit(wm831x->dev, "battery changed: i=%d\n", irq-irq0);
> 			
453c691
< 
---
> #endif
466,467c704,705
< 	dev_crit(wm831x->dev, "SYSVDD under voltage\n");
< 
---
> 	dev_crit(wm831x->dev, "SYSVDD under voltage and wake lock 60s\n");
> 	wake_lock_timeout(&wm831x_power->syslo_wake,60*HZ);//wait for android closing system
475a714
> 	wake_lock_timeout(&batt_wake_lock, 30 * HZ);
477c716
< 
---
> 	WM_BATT_DBG("%s:Power source changed\n", __FUNCTION__); 
482a722
> 
485a726,1047
> static void wm831x_batt_timer_handler(unsigned long data)
> {
> 	struct wm831x_power *wm831x_power = (struct wm831x_power*)data;
> 	schedule_work(&wm831x_power->batt_work);
> 	mod_timer(&wm831x_power->timer, jiffies + msecs_to_jiffies(wm831x_power->interval));
> }
> 
> void wm831x_batt_vol_level(struct wm831x_power *wm831x_power, int batt_vol, int *level)
> {
> 	int i, ret, status;
> 	static int chg_plus = 1000;
> 	static int chg_minus = 1000;
> 	static int chg_curr = 0;
> 	static int chg_num = 60;
> 	static int disp_plus = 1000;
> 	static int disp_minus = 1000;
> 	static int disp_minus2 = 1000;
> 	static int disp_curr = 0;
> 	static int disp_num = 50;
> 	static int batt_level_all = 0;
> 	static int batt_level[20];
> 	static int avr_num = 0;
> 	static int avr_int = 0;
> 
> 
> 	*level = wm831x_power->batt_info.level;
> 	ret = wm831x_bat_check_status(wm831x_power->wm831x, &status);
> 	if (ret < 0) {
> 		printk("%s: check bat status failer...err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 
> 	if (status == POWER_SUPPLY_STATUS_NOT_CHARGING 
> 			&& batt_vol >= batt_step_table[batt_num-1]) {
> 		*level = 100;
> 		return;
> 	}
> 
> 	if (status == POWER_SUPPLY_STATUS_CHARGING) 
> 	{
> 		disp_plus = 0;
> 		disp_minus = 0;
> 		disp_minus2 = 0;
> 		disp_curr = 0;
> 		for(i = 0; i < batt_num; i++){        
> 			if(batt_vol >= batt_chg_step_table[i] && 
> 					 batt_vol < batt_chg_step_table[i+1])
> 				break;     
> 		}
> 		if(batt_vol <= batt_chg_step_table[0])
> 			i = 0;
> 		if(batt_vol >= batt_chg_step_table[batt_num-1])
> 			i = batt_num-1;
> 		if(avr_int==0){
> 		       	batt_level[avr_num] = batt_disp_table[i];
> 		  	batt_level_all += batt_level[avr_num];
> 			avr_num++;
> 			if(avr_num >= 20)
> 			{
> 				avr_num = 0;
> 				avr_int = 1;
> 			}
> 			else
> 			{
> 				*level = batt_disp_table[i];
> 				return 0;
> 			}
> 		}
> 		else {
> 			batt_level_all -= batt_level[avr_num];
> 			batt_level[avr_num]=batt_disp_table[i];
> 			batt_level_all += batt_level[avr_num];
> 			avr_num++;
> 		}
> 		if(avr_num >= 20) 
> 	       		avr_num = 0;
> 		*level = batt_level_all/20;
> 		if ((chg_plus == 1000) && (chg_minus == 1000))
> 		{
> 			*level = *level;
> 			chg_plus = 0;
> 			chg_minus = 0;
> 			chg_curr = 0;
> 
> 		}
> 		else
> 		{			
> 
> 			if (*level >= (wm831x_power->batt_info.level+1))
> 			{
> 				chg_minus = 0;
> 				chg_curr = 0;
> 				if(*level < 85)
> 					chg_num =10;
> 				else
> 					chg_num = 5;
> 				if (++chg_plus > chg_num)
> 				{
> 					*level = wm831x_power->batt_info.level + 1;
> 					chg_plus = 0;
> 				
> 				}
> 				else
> 				{
> 					*level = wm831x_power->batt_info.level;
> 				}
> 			}
> 			else
> 			{
> 				chg_plus = 0;
> 				chg_minus = 0;
> 				chg_curr = 0;
> 				*level = wm831x_power->batt_info.level;
> 			}
> 		}
> 		
> 
> 		if (*level >= 100)
> 			*level = 100;
> 		if (*level < 0)
> 			*level = 0;
> 	}
> 	else 
> 	{
> 		chg_plus = 0;
> 		chg_minus = 0;
> 		chg_curr = 0;
> 		for(i = 0; i < batt_num; i++){        
> 			if(batt_vol >= batt_step_table[i] && 
> 					 batt_vol < batt_step_table[i+1])
> 				break;     
> 		}
> 		if(batt_vol <= batt_step_table[0])
> 			i = 0;
> 		if(batt_vol >= batt_step_table[batt_num-1])
> 			i = batt_num-1;
> 		if(avr_int==0){
> 		       	batt_level[avr_num] = batt_disp_table[i];
> 		  	batt_level_all += batt_level[avr_num];
> 			avr_num++;
> 			if(avr_num >= 20)
> 			{
> 				avr_num = 0;
> 				avr_int = 1;
> 			}
> 			else
> 			{
> 				*level = batt_disp_table[i];
> 				return 0;
> 			}
> 		}
> 		else {
> 			batt_level_all -= batt_level[avr_num];
> 			batt_level[avr_num]=batt_disp_table[i];
> 			batt_level_all += batt_level[avr_num];
> 			avr_num++;
> 		}
> 		if(avr_num >= 20) 
> 	       		avr_num = 0;
> 		*level = batt_level_all/20;
> 		if ((disp_plus == 1000) && (disp_minus == 1000))
> 		{
> 			*level = *level;
> 			disp_plus = 0;
> 			disp_minus = 0;
> 			disp_minus2 =0;
> 			disp_curr = 0;
> 		}
> 		else
> 		{	
> 			if(*level <= (wm831x_power ->batt_info.level -20))
> 			{
> 				disp_plus = 0;
> 				disp_curr = 0;
> 				disp_minus2 = 0;
> 				disp_num = 1;
> 				 if (++disp_minus > disp_num)
> 				{
> 					*level = wm831x_power->batt_info.level - 20;
> 					disp_minus = 0;
> 				}
> 				else
> 				{
> 					*level = wm831x_power->batt_info.level;
> 				}
> 			}
> 			else if (*level <= (wm831x_power->batt_info.level-1)) 	
> 			{
> 				disp_plus = 0;
> 				disp_curr = 0;
> 				disp_minus = 0;
> 				if((*level < 17) || (*level > 85))
> 					disp_num = 30;
> 				else
> 					disp_num = 80;
> 		
> 				 if (++disp_minus2 > disp_num)
> 				{
> 					*level = wm831x_power->batt_info.level - 1;
> 					disp_minus2 = 0;
> 				}
> 				else
> 				{
> 
> 					*level = wm831x_power->batt_info.level;
> 				}
> 			}
> 			else
> 			{
> 				disp_plus = 0;
> 				disp_minus = 0;
> 				disp_minus2 = 0;
> 				disp_curr = 0;
> 				*level = wm831x_power->batt_info.level;
> 			}
> 		}
> 
> 		if (*level >= 100)
> 			*level = 100;
> 		if (*level < 0)
> 			*level = 0;
> 	}
> }
> 
> static void wm831x_batt_work(struct work_struct *work)
> {
> 	int online, status,health,level, ret; 
>     union power_supply_propval val;
> 	struct wm831x_power *power = container_of(work, struct wm831x_power, batt_work);
> 
> 	ret = wm831x_power_check_online(power->wm831x, WM831X_PWR_SRC_BATT, &val);
> 	if (ret < 0) {
> 		printk("%s: check bat online failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 	online = val.intval;
> 
> 	ret = wm831x_bat_check_status(power->wm831x, &status);
> 	if (ret < 0) {
> 		printk("%s: check bat status failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 
> 	ret = wm831x_bat_check_health(power->wm831x, &health);
> 	if (ret < 0) {
> 		printk("%s: check bat health failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 
> 	ret = wm831x_power_read_voltage(power->wm831x, WM831X_AUX_BATT, &val);
> 	if (ret < 0) {
> 		printk("%s: read bat voltage failer...err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 	power->batt_info.voltage = val.intval;
> 
> 	wm831x_batt_vol_level(power, val.intval / 1000, &level);
> 	//mod_timer(&power->timer, jiffies + msecs_to_jiffies(power->interval));
> 
> 	if (online != power->batt_info.online || status != power->batt_info.status
> 			|| health != power->batt_info.health || level != power->batt_info.level)
> 	{
> 		power->batt_info.online = online;
> 		power->batt_info.status = status;
> 		power->batt_info.health = health;
> 		power->batt_info.level  = level;
> 
> 		power_supply_changed(&power->battery);
> 	}
> 
> }
> 
> #ifdef CONFIG_POWER_ON_CHARGER_DISPLAY
> static void wm831x_batt_check(struct wm831x_power *power)
> {
> 	int online, status,health,level, ret; 
> 	union power_supply_propval val;
> //	struct wm831x_power *power = container_of(work, struct wm831x_power, batt_work);
> 
> 	ret = wm831x_power_check_online(power->wm831x, WM831X_PWR_SRC_BATT, &val);
> 	if (ret < 0) {
> 		printk("%s: check bat online failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 	online = val.intval;
> 
> 	ret = wm831x_bat_check_status(power->wm831x, &status);
> 	if (ret < 0) {
> 		printk("%s: check bat status failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 
> 	ret = wm831x_bat_check_health(power->wm831x, &health);
> 	if (ret < 0) {
> 		printk("%s: check bat health failer...  err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 
> 	ret = wm831x_power_read_voltage(power->wm831x, WM831X_AUX_BATT, &val);
> 	if (ret < 0) {
> 		printk("%s: read bat voltage failer...err = %d\n", __FUNCTION__, ret);
> 		return;
> 	}
> 	power->batt_info.voltage = val.intval;
> 
> 	wm831x_batt_vol_level(power, val.intval / 1000, &level);
> 	//mod_timer(&power->timer, jiffies + msecs_to_jiffies(power->interval));
> 
> 	if (online != power->batt_info.online || status != power->batt_info.status
> 			|| health != power->batt_info.health || level != power->batt_info.level)
> 	{
> 		power->batt_info.online = online;
> 		power->batt_info.status = status;
> 		power->batt_info.health = health;
> 		power->batt_info.level  = level;
> 
> 		power_supply_changed(&power->battery);
> 	}
> }
> #endif
> 
> 
493c1055
< 	int ret, irq, i;
---
> 	int ret, irq;
509a1072
> 	wake_lock_init(&batt_wake_lock, WAKE_LOCK_SUSPEND, "batt_lock");
557a1121,1122
> #ifdef CONFIG_WM831X_WITH_BATTERY
> 	int i;
563a1129
> 		WM_BATT_DBG("%s: %s irq no %d\n", __FUNCTION__, wm831x_bat_irqs[i], irq);
570a1137
> #endif
571a1139,1158
> 	power->interval = TIMER_MS_COUNTS;
> 	power->batt_info.level = 100;
> 	power->batt_info.voltage   = 4200000;
> 	power->batt_info.online    = 1;
> 	power->batt_info.status    = POWER_SUPPLY_STATUS_DISCHARGING;
> 	power->batt_info.health    = POWER_SUPPLY_HEALTH_GOOD;
> 
> 	wake_lock_init(&power->syslo_wake, WAKE_LOCK_SUSPEND, "wm831x_syslo_wake");
> 	INIT_WORK(&power->batt_work, wm831x_batt_work);
> 	setup_timer(&power->timer, wm831x_batt_timer_handler, (unsigned long)power);
> 	power->timer.expires = jiffies + msecs_to_jiffies(1000);
> 	add_timer(&power->timer);
> 
> 	g_wm831x_power = power;
> #ifdef CONFIG_POWER_ON_CHARGER_DISPLAY
> 	wm831x_batt_check(power);//xsf
> #endif
> 	
> 	printk("%s:wm831x_power initialized\n",__FUNCTION__);
> 	power_test_sysfs_init();
573c1160,1161
< 
---
> 	
> #ifdef CONFIG_WM831X_WITH_BATTERY
580a1169,1170
> #endif
> 
598,599c1188,1190
< 	int irq, i;
< 
---
> 	int irq;
> #ifdef CONFIG_WM831X_WITH_BATTERY
> 	int i;
604c1195
< 
---
> #endif
617a1209,1229
> #ifdef CONFIG_PM
> static int wm831x_battery_suspend(struct platform_device *dev, pm_message_t state)
> {
> 	struct wm831x_power *power = (struct wm831x_power *)platform_get_drvdata(dev);
> 	flush_scheduled_work();
> 	del_timer(&power->timer);
> 	return 0;
> }
> 
> static int wm831x_battery_resume(struct platform_device *dev)
> {
> 	struct wm831x_power *power = (struct wm831x_power *)platform_get_drvdata(dev);
> 	power->timer.expires = jiffies + msecs_to_jiffies(power->interval);
> 	add_timer(&power->timer);
> 	return 0;
> }
> #else
> #define wm831x_battery_suspend NULL
> #define wm831x_battery_resume  NULL
> #endif
> 
620a1233,1234
> 	.suspend = wm831x_battery_suspend,
> 	.resume = wm831x_battery_resume,
625d1238
< 
629a1243
> #ifndef CONFIG_POWER_ON_CHARGER_DISPLAY
630a1245,1247
> #else
> subsys_initcall(wm831x_power_init);
> #endif
636a1254,1343
> 
> 
> static ssize_t power_prop_show(struct device *dev,
> 		struct device_attribute *attr, char *buf)
> {
> 	ssize_t ret = 0;
> 	int level, power_status, system_status, chg_ctl1, chg_ctl2, chg_status;
>     union power_supply_propval val;
> 
> 	if (!g_wm831x_power)
> 		return -1;
> 	power_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_POWER_STATE);
> 	if (power_status < 0)
> 		return power_status;
> 	//printk("wm831x power status %#x\n", ret);
> 
> 	system_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_SYSTEM_STATUS);
> 	if (system_status < 0)
> 		return system_status;
> 	//printk("wm831x system status %#x\n", ret);
> 
> 	chg_ctl1 = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_CONTROL_1);
> 	if (chg_ctl1 < 0)
> 		return chg_ctl1;
> 	//printk("wm831x charger control1 %#x\n", ret);
> 
> 	chg_ctl2 = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_CONTROL_2);
> 	if (chg_ctl2 < 0)
> 		return chg_ctl2;
> 	//printk("wm831x charger control2 %#x\n", ret);
> 
> 	chg_status = wm831x_reg_read(g_wm831x_power->wm831x, WM831X_CHARGER_STATUS);
> 	if (chg_status < 0)
> 		return chg_status;
> 	//printk("wm831x charger status %#x\n", ret);
> 
> 	ret = wm831x_power_read_voltage(g_wm831x_power->wm831x, WM831X_AUX_BATT, &val);
> 	if (ret < 0)
> 		return ret;
> 	wm831x_batt_vol_level(g_wm831x_power, val.intval / 1000, &level);
> 	//printk("batt_vol = %d batt_level = %d\n", val.intval, level);
> 	//
> 	sprintf(buf, "power_status=%#x\n"
> 			     "system_status=%#x\n"
> 				 "chg_ctl1=%#x\n"
> 				 "chg_ctl2=%#x\n"
> 				 "chg_status=%#x\n"
> 				 "batt_vol=%d\n"
> 				 "batt_level=%d%%\n",
> 				 power_status,
> 				 system_status,
> 				 chg_ctl1,
> 				 chg_ctl2,
> 				 chg_status,
> 				 val.intval,
> 				 level);
> 	ret = strlen(buf) + 1;
> 	return ret;
> }
> 
> static DEVICE_ATTR(prop, 0444, power_prop_show, NULL);
> 
> static struct kobject *power_test_kobj;
> 
> static int power_test_sysfs_init(void)
> {
> 	int ret ;
> 	power_test_kobj = kobject_create_and_add("power_test_prop", NULL);
> 	if (power_test_kobj == NULL) {
> 		printk(KERN_ERR
> 		       "power_test_sysfs_init:"\
> 		       "subsystem_register failed\n");
> 		ret = -ENOMEM;
> 		goto err;
> 	}
> 	ret = sysfs_create_file(power_test_kobj, &dev_attr_prop.attr);
> 	if (ret) {
> 		printk(KERN_ERR
> 		       "power_test_sysfs_init:"\
> 		       "sysfs_create_group failed\n");
> 		goto err1;
> 	}
> 
> 	return 0 ;
> err1:
> 	kobject_del(power_test_kobj);
> err:
> 	return ret ;
> }
> 
Only in linux-3.0.36-lenovo/drivers/regulator: act8846.c
Only in linux-3.0.36-lenovo/drivers/regulator: act8891.c
Only in linux-3.0.36-lenovo/drivers/regulator: act8931.c
Only in linux-3.0.36-lenovo/drivers/regulator: charge-regulator.c




diff -r linux-3.0.36/drivers/regulator/core.c linux-3.0.36-lenovo/drivers/regulator/core.c
917c917
< 	print_constraints(rdev);
---
> //	print_constraints(rdev);
1781a1782,1794
> 	if (ret < 0) {
> 	int ret_volt = 0;
> 	msleep(1);
> 	ret_volt = _regulator_get_voltage(rdev);
> 	if (ret_volt == regulator->max_uV) {
> 		ret = 0;
> 	} else {
> 		regulator->min_uV = 0;
> 		regulator->max_uV = 0;
> 		ret = -1;
> 	}
>   }
> 
1786a1800,1817
> 
> int regulator_set_suspend_voltage(struct regulator *regulator, int uV)
> {
>         struct regulator_dev *rdev = regulator->rdev;
>         int ret = 0;
> 
>         if (rdev->desc->ops->set_suspend_voltage && uV > 0) {
>                 ret = rdev->desc->ops->set_suspend_voltage(rdev, uV);
>                 if (ret < 0) {
>                         printk(KERN_ERR "%s: failed to set voltage\n",
>                                 __func__);
>                         return ret;
>                 }
>         }
> 
>         return ret;
> }
> EXPORT_SYMBOL_GPL(regulator_set_suspend_voltage);




diff -r linux-3.0.36/drivers/regulator/Kconfig linux-3.0.36-lenovo/drivers/regulator/Kconfig
127a128,138
> config REGULATOR_TPS65910
> 	tristate "TI TPS65910/TPS65911 Power Regulators"
> 	depends on MFD_TPS65910
> 	help
> 	  This driver supports TPS65910/TPS65911 voltage regulator chips.
> 
> config REGULATOR_TPS65912
> 	tristate "TI TPS65912 Power regulator"
> 	depends on (MFD_TPS65912_I2C || MFD_TPS65912_SPI)
> 	help
> 	    This driver supports TPS65912 voltage regulator chip.
250a262,315
> config RK2818_REGULATOR_CHARGE
> 	tristate "rk2818 Charger IC"
> 	help
> 	  Say Y to enable support for the current regulators charge on the RK2818.
> 
> config RK2818_REGULATOR_LP8725
> 	tristate "rk2818 pmic lp8725"
> 	depends on I2C
> 	help
> 	  Say Y to enable support for the voltage regulators pmic lp8725 on the RK2818.
> 
> config REGULATOR_ACT8891
> 	tristate "Active Semi ACT8891 PMIC regulators"
> 	depends on I2C
> 	help
> 	  Support the voltage and current regulators of the ACT8891 series of PMIC devices.
> 
> config REGULATOR_ACT8931
> 	tristate "Active Semi ACT8931 PMIC regulators"
> 	depends on I2C
> 	help
> 	  Support the voltage and current regulators of the ACT8931 series of PMIC devices.
> 
> config REGULATOR_ACT8846
> 	tristate "Active Semi ACT8846 PMIC regulators"
> 	depends on I2C
> 	help
> 	  Support the voltage and current regulators of the ACT8846 series of PMIC devices.
> 
> config ACT8846_SUPPORT_RESET
> 	tristate "ACT8846 PMIC SUPPORT RESET"
> 	depends on REGULATOR_ACT8846=y
> 	help
> 	  Support short press key to restart.
> 
> config ACT8846_SUPPORT_HSIC_REMOTE_WAKEUP
> 	bool "Support blueberry board hsic usb hub remote wakeup"
> 	depends on REGULATOR_ACT8846=y && (MACH_RK3188_A10=y || MACH_RK3188_FLEX10=y)
> 	help
> 	  Support blueberry board hsic usb hub remote wakeup, when enabled, vcc_18
> 	  for usbvdd is on, otherwise, it is off.
> 	  When on, it also disable CLK_SWITCH_TO_32K, othereise, CLK_SWITCH_TO_32K depends
> 	  on user's setting.
> 
> config RK29_PWM_REGULATOR
> 	tristate "rk2918 pwm voltage regulator"
> 	help
> 	  Say Y to enable support for the voltage regulators charge on the RK2918.
> 
> config RK30_PWM_REGULATOR
> 	tristate "rk30 pwm voltage regulator for discrete dcdc or ldo"
> 	help
> 	  Say Y to enable support for the voltage regulators control on the RK30 .
> 
300,304c365
< config REGULATOR_TPS65910
< 	tristate "TI TPS65910 Power Regulator"
< 	depends on MFD_TPS65910
< 	help
< 	  This driver supports TPS65910 voltage regulator chips.
---
> 




diff -r linux-3.0.36/drivers/regulator/Makefile linux-3.0.36-lenovo/drivers/regulator/Makefile
37a38,43
> obj-$(CONFIG_RK2818_REGULATOR_LP8725) += rk2818_lp8725.o
> obj-$(CONFIG_RK2818_REGULATOR_CHARGE) += charge-regulator.o
> obj-$(CONFIG_RK29_PWM_REGULATOR) += rk29-pwm-regulator.o
> obj-$(CONFIG_RK30_PWM_REGULATOR) += rk30-pwm-regulator.o
> 
> 
45a52,55
> obj-$(CONFIG_REGULATOR_TPS65912) += tps65912-regulator.o
> obj-$(CONFIG_REGULATOR_ACT8891) += act8891.o
> obj-$(CONFIG_REGULATOR_ACT8931) += act8931.o
> obj-$(CONFIG_REGULATOR_ACT8846) += act8846.o
Only in linux-3.0.36-lenovo/drivers/regulator: rk29-pwm-regulator.c
Only in linux-3.0.36-lenovo/drivers/regulator: rk30-pwm-regulator.c




diff -r linux-3.0.36/drivers/regulator/tps65910-regulator.c linux-3.0.36-lenovo/drivers/regulator/tps65910-regulator.c
28,52d27
< #define TPS65910_REG_VRTC		0
< #define TPS65910_REG_VIO		1
< #define TPS65910_REG_VDD1		2
< #define TPS65910_REG_VDD2		3
< #define TPS65910_REG_VDD3		4
< #define TPS65910_REG_VDIG1		5
< #define TPS65910_REG_VDIG2		6
< #define TPS65910_REG_VPLL		7
< #define TPS65910_REG_VDAC		8
< #define TPS65910_REG_VAUX1		9
< #define TPS65910_REG_VAUX2		10
< #define TPS65910_REG_VAUX33		11
< #define TPS65910_REG_VMMC		12
< 
< #define TPS65911_REG_VDDCTRL		4
< #define TPS65911_REG_LDO1		5
< #define TPS65911_REG_LDO2		6
< #define TPS65911_REG_LDO3		7
< #define TPS65911_REG_LDO4		8
< #define TPS65911_REG_LDO5		9
< #define TPS65911_REG_LDO6		10
< #define TPS65911_REG_LDO7		11
< #define TPS65911_REG_LDO8		12
< 
< #define TPS65910_NUM_REGULATOR		13
53a29,32
> #define EXT_SLEEP_CONTROL (TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1 |	\
> 			TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2 |		\
> 			TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3 |		\
> 			TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)
60c39,65
< /* VSEL tables for TPS65910 specific LDOs and dcdc's */
---
> /* TPS65910 VDD1 and VDD2 */
> /* value round off 12.5 is made as 12 */
> static const u16 VDD1_VSEL_table[] = {
> 	   0,  600,  600,  600,  612,  625,  637,  650,
> 	 662,  675,  687,  700,  712,  725,  737,  750,
> 	 762,  775,  787,  800,  812,  825,  837,  850,
> 	 862,  875,  887,  900,  912,  925,  937,  950,
> 	 962,  975,  987, 1000, 1012, 1025, 1037, 1050,
> 	1062, 1075, 1087, 1100, 1112, 1125, 1137, 1150,
> 	1162, 1175, 1187, 1200, 1212, 1225, 1237, 1250,
> 	1262, 1275, 1287, 1300, 1312, 1325, 1337, 1350,
> 	1362, 1375, 1387, 1400, 1412, 1425, 1437, 1450,
> 	1462, 1475, 1487, 1500,
> };
> 
> static const u16 VDD2_VSEL_table[] = {
> 	   0,  600,  600,  600,  612,  625,  637,  650,
> 	 662,  675,  687,  700,  712,  725,  737,  750,
> 	 762,  775,  787,  800,  812,  825,  837,  850,
> 	 862,  875,  887,  900,  912,  925,  937,  950,
> 	 962,  975,  987, 1000, 1012, 1025, 1037, 1050,
> 	1062, 1075, 1087, 1100, 1112, 1125, 1137, 1150,
> 	1162, 1175, 1187, 1200, 1212, 1225, 1237, 1250,
> 	1262, 1275, 1287, 1300, 1312, 1325, 1337, 1350,
> 	1362, 1375, 1387, 1400, 1412, 1425, 1437, 1450,
> 	1462, 1475, 1487, 1500,
> };
62c67
< /* supported VDD3 voltages in milivolts */
---
> /* TPS65910 VDD3 */
64c69
< 	5000,
---
> 	1000,1400
66a72
> 
111,112c117,119
< 	u8 table_len;
< 	const u16 *table;
---
> 	u8 n_voltages;
> 	const u16 *voltage_table;
> 	int enable_time_us;
117a125
> 		.enable_time_us = 2200,
123,124c131,133
< 		.table_len = ARRAY_SIZE(VIO_VSEL_table),
< 		.table = VIO_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VIO_VSEL_table),
> 		.voltage_table = VIO_VSEL_table,
> 		.enable_time_us = 350,
129c138,141
< 		.max_uV = 4500000,
---
> 		.max_uV = 1500000,
> 		.n_voltages = ARRAY_SIZE(VDD1_VSEL_table),
> 		.voltage_table = VDD1_VSEL_table,
> 		.enable_time_us = 350,
134c146,149
< 		.max_uV = 4500000,
---
> 		.max_uV = 1500000,
> 		.n_voltages = ARRAY_SIZE(VDD2_VSEL_table),
> 		.voltage_table = VDD2_VSEL_table,
> 		.enable_time_us = 350,
138,141c153,157
< 		.min_uV = 5000000,
< 		.max_uV = 5000000,
< 		.table_len = ARRAY_SIZE(VDD3_VSEL_table),
< 		.table = VDD3_VSEL_table,
---
> 		.min_uV = 1000000,
> 		.max_uV = 1400000,
> 		.n_voltages = ARRAY_SIZE(VDD3_VSEL_table),
> 		.voltage_table = VDD3_VSEL_table,
> 		.enable_time_us = 200,
147,148c163,165
< 		.table_len = ARRAY_SIZE(VDIG1_VSEL_table),
< 		.table = VDIG1_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VDIG1_VSEL_table),
> 		.voltage_table = VDIG1_VSEL_table,
> 		.enable_time_us = 100,
154,155c171,173
< 		.table_len = ARRAY_SIZE(VDIG2_VSEL_table),
< 		.table = VDIG2_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VDIG2_VSEL_table),
> 		.voltage_table = VDIG2_VSEL_table,
> 		.enable_time_us = 100,
161,162c179,181
< 		.table_len = ARRAY_SIZE(VPLL_VSEL_table),
< 		.table = VPLL_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VPLL_VSEL_table),
> 		.voltage_table = VPLL_VSEL_table,
> 		.enable_time_us = 100,
168,169c187,189
< 		.table_len = ARRAY_SIZE(VDAC_VSEL_table),
< 		.table = VDAC_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VDAC_VSEL_table),
> 		.voltage_table = VDAC_VSEL_table,
> 		.enable_time_us = 100,
175,176c195,197
< 		.table_len = ARRAY_SIZE(VAUX1_VSEL_table),
< 		.table = VAUX1_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VAUX1_VSEL_table),
> 		.voltage_table = VAUX1_VSEL_table,
> 		.enable_time_us = 100,
182,183c203,205
< 		.table_len = ARRAY_SIZE(VAUX2_VSEL_table),
< 		.table = VAUX2_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VAUX2_VSEL_table),
> 		.voltage_table = VAUX2_VSEL_table,
> 		.enable_time_us = 100,
189,190c211,213
< 		.table_len = ARRAY_SIZE(VAUX33_VSEL_table),
< 		.table = VAUX33_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VAUX33_VSEL_table),
> 		.voltage_table = VAUX33_VSEL_table,
> 		.enable_time_us = 100,
196,197c219,221
< 		.table_len = ARRAY_SIZE(VMMC_VSEL_table),
< 		.table = VMMC_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VMMC_VSEL_table),
> 		.voltage_table = VMMC_VSEL_table,
> 		.enable_time_us = 100,
202a227,230
> 		.name = "VRTC",
> 		.enable_time_us = 2200,
> 	},
> 	{
206,207c234,236
< 		.table_len = ARRAY_SIZE(VIO_VSEL_table),
< 		.table = VIO_VSEL_table,
---
> 		.n_voltages = ARRAY_SIZE(VIO_VSEL_table),
> 		.voltage_table = VIO_VSEL_table,
> 		.enable_time_us = 350,
212a242,243
> 		.n_voltages = 73,
> 		.enable_time_us = 350,
217a249,250
> 		.n_voltages = 73,
> 		.enable_time_us = 350,
222a256,257
> 		.n_voltages = 65,
> 		.enable_time_us = 900,
227a263,264
> 		.n_voltages = 47,
> 		.enable_time_us = 420,
232a270,271
> 		.n_voltages = 47,
> 		.enable_time_us = 420,
237a277,278
> 		.n_voltages = 24,
> 		.enable_time_us = 230,
242a284,285
> 		.n_voltages = 47,
> 		.enable_time_us = 230,
247a291,292
> 		.n_voltages = 24,
> 		.enable_time_us = 230,
252a298,299
> 		.n_voltages = 24,
> 		.enable_time_us = 230,
257a305,306
> 		.n_voltages = 24,
> 		.enable_time_us = 230,
262a312,313
> 		.n_voltages = 24,
> 		.enable_time_us = 230,
265a317,349
> #define EXT_CONTROL_REG_BITS(id, regs_offs, bits) (((regs_offs) << 8) | (bits))
> static unsigned int tps65910_ext_sleep_control[] = {
> 	0,
> 	EXT_CONTROL_REG_BITS(VIO,    1, 0),
> 	EXT_CONTROL_REG_BITS(VDD1,   1, 1),
> 	EXT_CONTROL_REG_BITS(VDD2,   1, 2),
> 	EXT_CONTROL_REG_BITS(VDD3,   1, 3),
> 	EXT_CONTROL_REG_BITS(VDIG1,  0, 1),
> 	EXT_CONTROL_REG_BITS(VDIG2,  0, 2),
> 	EXT_CONTROL_REG_BITS(VPLL,   0, 6),
> 	EXT_CONTROL_REG_BITS(VDAC,   0, 7),
> 	EXT_CONTROL_REG_BITS(VAUX1,  0, 3),
> 	EXT_CONTROL_REG_BITS(VAUX2,  0, 4),
> 	EXT_CONTROL_REG_BITS(VAUX33, 0, 5),
> 	EXT_CONTROL_REG_BITS(VMMC,   0, 0),
> };
> 
> static unsigned int tps65911_ext_sleep_control[] = {
> 	0,
> 	EXT_CONTROL_REG_BITS(VIO,     1, 0),
> 	EXT_CONTROL_REG_BITS(VDD1,    1, 1),
> 	EXT_CONTROL_REG_BITS(VDD2,    1, 2),
> 	EXT_CONTROL_REG_BITS(VDDCTRL, 1, 3),
> 	EXT_CONTROL_REG_BITS(LDO1,    0, 1),
> 	EXT_CONTROL_REG_BITS(LDO2,    0, 2),
> 	EXT_CONTROL_REG_BITS(LDO3,    0, 7),
> 	EXT_CONTROL_REG_BITS(LDO4,    0, 6),
> 	EXT_CONTROL_REG_BITS(LDO5,    0, 3),
> 	EXT_CONTROL_REG_BITS(LDO6,    0, 0),
> 	EXT_CONTROL_REG_BITS(LDO7,    0, 5),
> 	EXT_CONTROL_REG_BITS(LDO8,    0, 4),
> };
> 
267c351
< 	struct regulator_desc desc[TPS65910_NUM_REGULATOR];
---
> 	struct regulator_desc *desc;
269,270c353,354
< 	struct regulator_dev *rdev[TPS65910_NUM_REGULATOR];
< 	struct tps_info *info[TPS65910_NUM_REGULATOR];
---
> 	struct regulator_dev **rdev;
> 	struct tps_info **info;
271a356
> 	int num_regulators;
273a359,360
> 	unsigned int *ext_sleep_control;
> 	unsigned int board_ext_control[TPS65910_NUM_REGS];
318c405
< static int tps65910_reg_read(struct tps65910_reg *pmic, u8 reg)
---
> static int tps65910_pmic_reg_read(struct tps65910_reg *pmic, u8 reg)
332c419
< static int tps65910_reg_write(struct tps65910_reg *pmic, u8 reg, u8 val)
---
> static int tps65910_pmic_reg_write(struct tps65910_reg *pmic, u8 reg, u8 val)
423c510
< 	value = tps65910_reg_read(pmic, reg);
---
> 	value = tps65910_pmic_reg_read(pmic, reg);
455a543,548
> static int tps65910_enable_time(struct regulator_dev *dev)
> {
> 	struct tps65910_reg *pmic = rdev_get_drvdata(dev);
> 	int id = rdev_get_id(dev);
> 	return pmic->info[id]->enable_time_us;
> }
490c583
< 	value = tps65910_reg_read(pmic, reg);
---
> 	value = tps65910_pmic_reg_read(pmic, reg);
494c587
< 	if (value & LDO_ST_ON_BIT)
---
> 	if (!(value & LDO_ST_ON_BIT))
502c595
< static int tps65910_get_voltage_dcdc(struct regulator_dev *dev)
---
> static int tps65910_get_voltage_dcdc_sel(struct regulator_dev *dev)
505c598
< 	int id = rdev_get_id(dev), voltage = 0;
---
> 	int id = rdev_get_id(dev);
510,511c603,604
< 		opvsel = tps65910_reg_read(pmic, TPS65910_VDD1_OP);
< 		mult = tps65910_reg_read(pmic, TPS65910_VDD1);
---
> 		opvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD1_OP);
> 		mult = tps65910_pmic_reg_read(pmic, TPS65910_VDD1);
513c606
< 		srvsel = tps65910_reg_read(pmic, TPS65910_VDD1_SR);
---
> 		srvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD1_SR);
520,521c613,614
< 		opvsel = tps65910_reg_read(pmic, TPS65910_VDD2_OP);
< 		mult = tps65910_reg_read(pmic, TPS65910_VDD2);
---
> 		opvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD2_OP);
> 		mult = tps65910_pmic_reg_read(pmic, TPS65910_VDD2);
523c616
< 		srvsel = tps65910_reg_read(pmic, TPS65910_VDD2_SR);
---
> 		srvsel = tps65910_pmic_reg_read(pmic, TPS65910_VDD2_SR);
530,531c623,624
< 		opvsel = tps65910_reg_read(pmic, TPS65911_VDDCTRL_OP);
< 		srvsel = tps65910_reg_read(pmic, TPS65911_VDDCTRL_SR);
---
> 		opvsel = tps65910_pmic_reg_read(pmic, TPS65911_VDDCTRL_OP);
> 		srvsel = tps65910_pmic_reg_read(pmic, TPS65911_VDDCTRL_SR);
549,551c642
< 		srvsel -= 3;
< 
< 		voltage = (srvsel * VDD1_2_OFFSET + VDD1_2_MIN_VOLT) * 100;
---
> 		return srvsel - 3;
559,561c650
< 		opvsel -= 3;
< 
< 		voltage = (opvsel * VDD1_2_OFFSET + VDD1_2_MIN_VOLT) * 100;
---
> 		return opvsel - 3;
563,566c652
< 
< 	voltage *= mult;
< 
< 	return voltage;
---
> 	return -EINVAL;
578c664
< 	value = tps65910_reg_read(pmic, reg);
---
> 	value = tps65910_pmic_reg_read(pmic, reg);
599c685
< 	voltage = pmic->info[id]->table[value] * 1000;
---
> 	voltage = pmic->info[id]->voltage_table[value] * 1000;
617c703
< 	value = tps65910_reg_read(pmic, reg);
---
> 	value = tps65910_pmic_reg_read(pmic, reg);
649,650c735,737
< 		return pmic->info[id]->table[value] * 1000;
< 		break;
---
> 		value &= LDO_SEL_MASK;
> 		value >>= LDO_SEL_SHIFT;
> 		return pmic->info[id]->voltage_table[value] * 1000;
658,659c745,746
< static int tps65910_set_voltage_dcdc(struct regulator_dev *dev,
< 				unsigned selector)
---
> static int tps65910_set_voltage_dcdc_sel(struct regulator_dev *dev,
> 					 unsigned selector)
667c754
< 		dcdc_mult = (selector / VDD1_2_NUM_VOLTS) + 1;
---
> 		dcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
670c757
< 		vsel = (selector % VDD1_2_NUM_VOLTS) + 3;
---
> 		vsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;
675c762
< 		tps65910_reg_write(pmic, TPS65910_VDD1_OP, vsel);
---
> 		tps65910_pmic_reg_write(pmic, TPS65910_VDD1_OP, vsel);
678c765
< 		dcdc_mult = (selector / VDD1_2_NUM_VOLTS) + 1;
---
> 		dcdc_mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
681c768
< 		vsel = (selector % VDD1_2_NUM_VOLTS) + 3;
---
> 		vsel = (selector % VDD1_2_NUM_VOLT_FINE) + 3;
686c773
< 		tps65910_reg_write(pmic, TPS65910_VDD2_OP, vsel);
---
> 		tps65910_pmic_reg_write(pmic, TPS65910_VDD2_OP, vsel);
689,690c776,777
< 		vsel = selector;
< 		tps65910_reg_write(pmic, TPS65911_VDDCTRL_OP, vsel);
---
> 		vsel = selector + 3;
> 		tps65910_pmic_reg_write(pmic, TPS65911_VDDCTRL_OP, vsel);
696c783,784
< static int tps65910_set_voltage(struct regulator_dev *dev, unsigned selector)
---
> static int tps65910_set_voltage_sel(struct regulator_dev *dev,
> 				    unsigned selector)
722c810,811
< static int tps65911_set_voltage(struct regulator_dev *dev, unsigned selector)
---
> static int tps65911_set_voltage_sel(struct regulator_dev *dev,
> 				    unsigned selector)
742d830
< 	case TPS65910_REG_VIO:
744a833,835
> 	case TPS65910_REG_VIO:
> 		return tps65910_modify_bits(pmic, reg,
> 				(selector << LDO_SEL_SHIFT), LDO_SEL_MASK);
759c850
< 		mult = (selector / VDD1_2_NUM_VOLTS) + 1;
---
> 		mult = (selector / VDD1_2_NUM_VOLT_FINE) + 1;
761c852
< 				(selector % VDD1_2_NUM_VOLTS) * VDD1_2_OFFSET;
---
> 				(selector % VDD1_2_NUM_VOLT_FINE) * VDD1_2_OFFSET;
783c874
< 	if (selector >= pmic->info[id]->table_len)
---
> 	if (selector >= pmic->info[id]->n_voltages)
786,787c877,878
< 		voltage = pmic->info[id]->table[selector] * 1000;
< 
---
> 		voltage = pmic->info[id]->voltage_table[selector] * 1000;
> 	
822c913
< 		return pmic->info[id]->table[selector] * 1000;
---
> 		return pmic->info[id]->voltage_table[selector] * 1000;
829a921,945
> static int tps65910_set_voltage_dcdc_time_sel(struct regulator_dev *dev,
> 		unsigned int old_selector, unsigned int new_selector)
> {
> 	int id = rdev_get_id(dev);
> 	int old_volt, new_volt;
> 
> 	old_volt = tps65910_list_voltage_dcdc(dev, old_selector);
> 	if (old_volt < 0)
> 		return old_volt;
> 
> 	new_volt = tps65910_list_voltage_dcdc(dev, new_selector);
> 	if (new_volt < 0)
> 		return new_volt;
> 
> 	/* VDD1 and VDD2 are 12.5mV/us, VDDCTRL is 100mV/20us */
> 	switch (id) {
> 	case TPS65910_REG_VDD1:
> 	case TPS65910_REG_VDD2:
> 		return DIV_ROUND_UP(abs(old_volt - new_volt)*2, 12500);
> 	case TPS65911_REG_VDDCTRL:
> 		return DIV_ROUND_UP(abs(old_volt - new_volt), 5000);
> 	}
> 	return -EINVAL;
> }
> 
834a951
> 	.enable_time		= tps65910_enable_time,
837,838c954,956
< 	.get_voltage		= tps65910_get_voltage_dcdc,
< 	.set_voltage_sel	= tps65910_set_voltage_dcdc,
---
> 	.get_voltage_sel	= tps65910_get_voltage_dcdc_sel,
> 	.set_voltage_sel	= tps65910_set_voltage_dcdc_sel,
> 	.set_voltage_time_sel	= tps65910_set_voltage_dcdc_time_sel,
845a964
> 	.enable_time		= tps65910_enable_time,
855a975
> 	.enable_time		= tps65910_enable_time,
859c979
< 	.set_voltage_sel	= tps65910_set_voltage,
---
> 	.set_voltage_sel	= tps65910_set_voltage_sel,
866a987
> 	.enable_time		= tps65910_enable_time,
870c991
< 	.set_voltage_sel	= tps65911_set_voltage,
---
> 	.set_voltage_sel	= tps65911_set_voltage_sel,
873a995,1127
> static int tps65910_set_ext_sleep_config(struct tps65910_reg *pmic,
> 		int id, int ext_sleep_config)
> {
> 	struct tps65910 *mfd = pmic->mfd;
> 	u8 regoffs = (pmic->ext_sleep_control[id] >> 8) & 0xFF;
> 	u8 bit_pos = (1 << pmic->ext_sleep_control[id] & 0xFF);
> 	int ret;
> 
> 	/*
> 	 * Regulator can not be control from multiple external input EN1, EN2
> 	 * and EN3 together.
> 	 */
> 	if (ext_sleep_config & EXT_SLEEP_CONTROL) {
> 		int en_count;
> 		en_count = ((ext_sleep_config &
> 				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1) != 0);
> 		en_count += ((ext_sleep_config &
> 				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2) != 0);
> 		en_count += ((ext_sleep_config &
> 				TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3) != 0);
> 		en_count += ((ext_sleep_config &
> 				TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP) != 0);
> 		if (en_count > 1) {
> 			dev_err(mfd->dev,
> 				"External sleep control flag is not proper\n");
> 			return -EINVAL;
> 		}
> 	}
> 
> 	pmic->board_ext_control[id] = ext_sleep_config;
> 
> 	/* External EN1 control */
> 	if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1)
> 		ret = tps65910_set_bits(mfd,
> 				TPS65910_EN1_LDO_ASS + regoffs, bit_pos);
> 	else
> 		ret = tps65910_clear_bits(mfd,
> 				TPS65910_EN1_LDO_ASS + regoffs, bit_pos);
> 	if (ret < 0) {
> 		dev_err(mfd->dev,
> 			"Error in configuring external control EN1\n");
> 		return ret;
> 	}
> 
> 	/* External EN2 control */
> 	if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2)
> 		ret = tps65910_set_bits(mfd,
> 				TPS65910_EN2_LDO_ASS + regoffs, bit_pos);
> 	else
> 		ret = tps65910_clear_bits(mfd,
> 				TPS65910_EN2_LDO_ASS + regoffs, bit_pos);
> 	if (ret < 0) {
> 		dev_err(mfd->dev,
> 			"Error in configuring external control EN2\n");
> 		return ret;
> 	}
> 
> 	/* External EN3 control for TPS65910 LDO only */
> 	if ((tps65910_chip_id(mfd) == TPS65910) &&
> 			(id >= TPS65910_REG_VDIG1)) {
> 		if (ext_sleep_config & TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3)
> 			ret = tps65910_set_bits(mfd,
> 				TPS65910_EN3_LDO_ASS + regoffs, bit_pos);
> 		else
> 			ret = tps65910_clear_bits(mfd,
> 				TPS65910_EN3_LDO_ASS + regoffs, bit_pos);
> 		if (ret < 0) {
> 			dev_err(mfd->dev,
> 				"Error in configuring external control EN3\n");
> 			return ret;
> 		}
> 	}
> 
> 	/* Return if no external control is selected */
> 	if (!(ext_sleep_config & EXT_SLEEP_CONTROL)) {
> 		/* Clear all sleep controls */
> 		ret = tps65910_clear_bits(mfd,
> 			TPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);
> 		if (!ret)
> 			ret = tps65910_clear_bits(mfd,
> 				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
> 		if (ret < 0)
> 			dev_err(mfd->dev,
> 				"Error in configuring SLEEP register\n");
> 		return ret;
> 	}
> 
> 	/*
> 	 * For regulator that has separate operational and sleep register make
> 	 * sure that operational is used and clear sleep register to turn
> 	 * regulator off when external control is inactive
> 	 */
> 	if ((id == TPS65910_REG_VDD1) ||
> 		(id == TPS65910_REG_VDD2) ||
> 			((id == TPS65911_REG_VDDCTRL) &&
> 				(tps65910_chip_id(mfd) == TPS65911))) {
> 		int op_reg_add = pmic->get_ctrl_reg(id) + 1;
> 		int sr_reg_add = pmic->get_ctrl_reg(id) + 2;
> 		int opvsel = tps65910_pmic_reg_read(pmic, op_reg_add);
> 		int srvsel = tps65910_pmic_reg_read(pmic, sr_reg_add);
> 		if (opvsel & VDD1_OP_CMD_MASK) {
> 			u8 reg_val = srvsel & VDD1_OP_SEL_MASK;
> 			ret = tps65910_pmic_reg_write(pmic, op_reg_add, reg_val);
> 			if (ret < 0) {
> 				dev_err(mfd->dev,
> 					"Error in configuring op register\n");
> 				return ret;
> 			}
> 		}
> 		ret = tps65910_pmic_reg_write(pmic, sr_reg_add, 0);
> 		if (ret < 0) {
> 			dev_err(mfd->dev, "Error in settting sr register\n");
> 			return ret;
> 		}
> 	}
> 
> 	ret = tps65910_clear_bits(mfd,
> 			TPS65910_SLEEP_KEEP_LDO_ON + regoffs, bit_pos);
> 	if (!ret) {
> 		if (ext_sleep_config & TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP)
> 			ret = tps65910_set_bits(mfd,
> 				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
> 		else
> 			ret = tps65910_clear_bits(mfd,
> 				TPS65910_SLEEP_SET_LDO_OFF + regoffs, bit_pos);
> 	}
> 	if (ret < 0)
> 		dev_err(mfd->dev,
> 			"Error in configuring SLEEP register\n");
> 
> 	return ret;
> }
> 
888,889d1141
< 	reg_data = pmic_plat_data->tps65910_pmic_init_data;
< 
904a1157,1158
> 		pmic->num_regulators = ARRAY_SIZE(tps65910_regs);
> 		pmic->ext_sleep_control = tps65910_ext_sleep_control;
908a1163,1164
> 		pmic->num_regulators = ARRAY_SIZE(tps65911_regs);
> 		pmic->ext_sleep_control = tps65911_ext_sleep_control;
912a1169
> 		kfree(pmic);
916c1173,1203
< 	for (i = 0; i < TPS65910_NUM_REGULATOR; i++, info++, reg_data++) {
---
> 	pmic->desc = kcalloc(pmic->num_regulators,
> 			sizeof(struct regulator_desc), GFP_KERNEL);
> 	if (!pmic->desc) {
> 		err = -ENOMEM;
> 		goto err_free_pmic;
> 	}
> 
> 	pmic->info = kcalloc(pmic->num_regulators,
> 			sizeof(struct tps_info *), GFP_KERNEL);
> 	if (!pmic->info) {
> 		err = -ENOMEM;
> 		goto err_free_desc;
> 	}
> 
> 	pmic->rdev = kcalloc(pmic->num_regulators,
> 			sizeof(struct regulator_dev *), GFP_KERNEL);
> 	if (!pmic->rdev) {
> 		err = -ENOMEM;
> 		goto err_free_info;
> 	}
> 
> 	for (i = 0; i < pmic->num_regulators && i < TPS65910_NUM_REGS;
> 			i++, info++) {
> 
> 		reg_data = pmic_plat_data->tps65910_pmic_init_data[i];
> 
> 		/* Regulator API handles empty constraints but not NULL
> 		 * constraints */
> 		if (!reg_data)
> 			continue;
> 
922c1209
< 		pmic->desc[i].n_voltages = info->table_len;
---
> 		pmic->desc[i].n_voltages = info->n_voltages;
925a1213,1214
> 			pmic->desc[i].n_voltages = VDD1_2_NUM_VOLT_FINE *
> 							VDD1_2_NUM_VOLT_COARSE;
937a1227,1236
> 		err = tps65910_set_ext_sleep_config(pmic, i,
> 				pmic_plat_data->regulator_ext_sleep_control[i]);
> 		/*
> 		 * Failing on regulator for configuring externally control
> 		 * is not a serious issue, just throw warning.
> 		 */
> 		if (err < 0)
> 			dev_warn(tps65910->dev,
> 				"Failed to initialise ext control config\n");
> 
948c1247
< 			goto err;
---
> 			goto err_unregister_regulator;
956c1255
< err:
---
> err_unregister_regulator:
959c1258,1263
< 
---
> 	kfree(pmic->rdev);
> err_free_info:
> 	kfree(pmic->info);
> err_free_desc:
> 	kfree(pmic->desc);
> err_free_pmic:
966c1270
< 	struct tps65910_reg *tps65910_reg = platform_get_drvdata(pdev);
---
> 	struct tps65910_reg *pmic = platform_get_drvdata(pdev);
969,970c1273,1274
< 	for (i = 0; i < TPS65910_NUM_REGULATOR; i++)
< 		regulator_unregister(tps65910_reg->rdev[i]);
---
> 	for (i = 0; i < pmic->num_regulators; i++)
> 		regulator_unregister(pmic->rdev[i]);
972c1276,1279
< 	kfree(tps65910_reg);
---
> 	kfree(pmic->rdev);
> 	kfree(pmic->info);
> 	kfree(pmic->desc);
> 	kfree(pmic);
975a1283,1312
> static void tps65910_shutdown(struct platform_device *pdev)
> {
> 	struct tps65910_reg *pmic = platform_get_drvdata(pdev);
> 	int i;
> 
> 	/*
> 	 * Before bootloader jumps to kernel, it makes sure that required
> 	 * external control signals are in desired state so that given rails
> 	 * can be configure accordingly.
> 	 * If rails are configured to be controlled from external control
> 	 * then before shutting down/rebooting the system, the external
> 	 * control configuration need to be remove from the rails so that
> 	 * its output will be available as per register programming even
> 	 * if external controls are removed. This is require when the POR
> 	 * value of the control signals are not in active state and before
> 	 * bootloader initializes it, the system requires the rail output
> 	 * to be active for booting.
> 	 */
> 	for (i = 0; i < pmic->num_regulators; i++) {
> 		int err;
> 		if (!pmic->rdev[i])
> 			continue;
> 
> 		err = tps65910_set_ext_sleep_config(pmic, i, 0);
> 		if (err < 0)
> 			dev_err(&pdev->dev,
> 				"Error in clearing external control\n");
> 	}
> }
> 
982a1320
> 	.shutdown = tps65910_shutdown,
989c1327
< subsys_initcall(tps65910_init);
---
> subsys_initcall_sync(tps65910_init);
998c1336
< MODULE_DESCRIPTION("TPS6507x voltage regulator driver");
---
> MODULE_DESCRIPTION("TPS65910/TPS65911 voltage regulator driver");




diff -r linux-3.0.36/drivers/regulator/twl-regulator.c linux-3.0.36-lenovo/drivers/regulator/twl-regulator.c
78a79
> #define VREG_VOLTAGE_DVS_SMPS 3      //add
84a86,97
> /* TWL6030 LDO register values for CFG_TRANS */
> #define TWL6030_CFG_TRANS_STATE_MASK	0x03
> #define TWL6030_CFG_TRANS_STATE_OFF	0x00
> /*
>  * Auto means the following:
>  * SMPS:	AUTO(PWM/PFM)
>  * LDO:		AMS(SLP/ACT)
>  * resource:	ON
>  */
> #define TWL6030_CFG_TRANS_STATE_AUTO	0x01
> #define TWL6030_CFG_TRANS_SLEEP_SHIFT	2
> 
92c105,107
< #define TWL6030_CFG_STATE_APP_MASK	(0x03 << TWL6030_CFG_STATE_APP_SHIFT)
---
> #define TWL6030_CFG_STATE_MASK		0x03
> #define TWL6030_CFG_STATE_APP_MASK	(TWL6030_CFG_STATE_MASK << \
> 						TWL6030_CFG_STATE_APP_SHIFT)
100c115
< /* twl6025 SMPS EPROM values */
---
> /* twl6032 SMPS EPROM values */
106a122,135
> 
> 
> /* TWL6030 VUSB supplemental config registers */
> #define TWL6030_MISC2		0xE5
> #define TWL6030_CFG_LDO_PD2	0xF5
> 
> /*
>  * TWL603X SMPS has 6 bits xxxx_CFG_VOLTAGE.VSEL[5:0] to configure voltages and
>  * each bit combination corresponds to a particular voltage (value 63 is
>  * reserved).
>  */
> #define TWL603X_SMPS_VSEL_MASK	0x3F
> #define TWL603X_SMPS_NUMBER_VOLTAGES TWL603X_SMPS_VSEL_MASK
> 
112d140
< 
164c192
< 	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
---
> 	if (!(info->features & TWL6032_SUBCLASS)) {
166,167c194,195
< 	if (grp < 0)
< 		return grp;
---
> 		if (grp < 0)
> 			return grp;
169d196
< 	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
171c198,202
< 	else
---
> 		val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
> 		val = TWL6030_CFG_STATE_APP(val);
> 	} else {
> 		val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
> 		val &= TWL6030_CFG_STATE_MASK;
173,175c204
< 
< 	val = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_STATE);
< 	val = TWL6030_CFG_STATE_APP(val);
---
> 	}
179a209,234
> static int twl6030reg_set_trans_state(struct regulator_dev *rdev,
> 				      u8 shift, u8 val)
> {
> 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
> 	int			rval;
> 	u8			mask;
> 
> 	/* Read CFG_TRANS register of TWL6030 */
> 	rval = twlreg_read(info, TWL_MODULE_PM_RECEIVER, VREG_TRANS);
> 
> 	if (rval < 0)
> 		return rval;
> 
> 	mask = TWL6030_CFG_TRANS_STATE_MASK << shift;
> 	val = (val << shift) & mask;
> 
> 	/* If value is already set, no need to write to reg */
> 	if (val == (rval & mask))
> 		return 0;
> 
> 	rval &= ~mask;
> 	rval |= val;
> 
> 	return twlreg_write(info, TWL_MODULE_PM_RECEIVER, VREG_TRANS, rval);
> }
> 
205c260
< 	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
---
> 	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
213c268,275
< 
---
> 	/*
> 	 * Ensure it stays in Auto mode when we enter suspend state.
> 	 * (TWL6030 in sleep mode).
> 	 */
> 	if (!ret)
> 		ret = twl6030reg_set_trans_state(rdev,
> 				TWL6030_CFG_TRANS_SLEEP_SHIFT,
> 				TWL6030_CFG_TRANS_STATE_AUTO);
242c304
< 	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
---
> 	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
249a312,316
> 	/* Ensure it remains OFF when we enter suspend (TWL6030 in sleep). */
> 	if (!ret)
> 		ret = twl6030reg_set_trans_state(rdev,
> 				TWL6030_CFG_TRANS_SLEEP_SHIFT,
> 				TWL6030_CFG_TRANS_STATE_OFF);
280c347,352
< 	switch (TWL6030_CFG_STATE_APP(val)) {
---
> 	if (info->features & TWL6032_SUBCLASS)
> 		val &= TWL6030_CFG_STATE_MASK;
> 	else
> 		val = TWL6030_CFG_STATE_APP(val);
> 
> 	switch (val) {
336c408
< 	if (!(twl_class_is_6030() && (info->features & TWL6025_SUBCLASS)))
---
> 	if (!(twl_class_is_6030() && (info->features & TWL6032_SUBCLASS)))
359a432,443
> static int twl6030ldo_suspend_enable(struct regulator_dev *rdev)
> {
> 	return twl6030reg_set_trans_state(rdev, TWL6030_CFG_TRANS_SLEEP_SHIFT,
> 					TWL6030_CFG_TRANS_STATE_AUTO);
> }
> 
> static int twl6030ldo_suspend_disable(struct regulator_dev *rdev)
> {
> 	return twl6030reg_set_trans_state(rdev, TWL6030_CFG_TRANS_SLEEP_SHIFT,
> 					TWL6030_CFG_TRANS_STATE_OFF);
> }
> 
572a657,659
> 
> 	.set_suspend_enable	= twl6030ldo_suspend_enable,
> 	.set_suspend_disable	= twl6030ldo_suspend_disable,
619a707,709
> 
> 	.set_suspend_enable	= twl6030ldo_suspend_enable,
> 	.set_suspend_disable	= twl6030ldo_suspend_disable,
808a899,905
> //add
> #if 1
> static int twl6030dvssmps_set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
> 			unsigned int *selector)
> {
> 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
> 	int	vsel = 0;
809a907,996
> 	switch (info->flags) {
> 	case 0:
> 		if (min_uV == 0)
> 			vsel = 0;
> 		else if ((min_uV >= 600000) && (max_uV <= 1300000)) {
> 			vsel = (min_uV - 600000) / 125;
> 			if (vsel % 100)
> 				vsel += 100;
> 			vsel /= 100;
> 			vsel++;
> 		}
> 		/* Values 1..57 for vsel are linear and can be calculated
> 		 * values 58..62 are non linear.
> 		 */
> 		else if ((min_uV > 1900000) && (max_uV >= 2100000))
> 			vsel = 62;
> 		else if ((min_uV > 1800000) && (max_uV >= 1900000))
> 			vsel = 61;
> 		else if ((min_uV > 1500000) && (max_uV >= 1800000))
> 			vsel = 60;
> 		else if ((min_uV > 1350000) && (max_uV >= 1500000))
> 			vsel = 59;
> 		else if ((min_uV > 1300000) && (max_uV >= 1350000))
> 			vsel = 58;
> 		else
> 			return -EINVAL;
> 		break;
> 	case SMPS_OFFSET_EN:
> 		if (min_uV == 0)
> 			vsel = 0;
> 		else if ((min_uV >= 700000) && (max_uV <= 1420000)) {
> 			vsel = (min_uV - 700000) / 125;
> 			if (vsel % 100)
> 				vsel += 100;
> 			vsel /= 100;
> 			vsel++;
> 		}
> 		/* Values 1..57 for vsel are linear and can be calculated
> 		 * values 58..62 are non linear.
> 		 */
> 		else if ((min_uV > 1900000) && (max_uV >= 2100000))
> 			vsel = 62;
> 		else if ((min_uV > 1800000) && (max_uV >= 1900000))
> 			vsel = 61;
> 		else if ((min_uV > 1350000) && (max_uV >= 1800000))
> 			vsel = 60;
> 		else if ((min_uV > 1350000) && (max_uV >= 1500000))
> 			vsel = 59;
> 		else if ((min_uV > 1300000) && (max_uV >= 1350000))
> 			vsel = 58;
> 		else
> 			return -EINVAL;
> 		break;
> 	case SMPS_EXTENDED_EN:
> 		if (min_uV == 0)
> 			vsel = 0;
> 		else if ((min_uV >= 1852000) && (max_uV <= 4013600)) {
> 			vsel = (min_uV - 1852000) / 386;
> 			if (vsel % 100)
> 				vsel += 100;
> 			vsel /= 100;
> 			vsel++;
> 		}
> 		break;
> 	case SMPS_OFFSET_EN|SMPS_EXTENDED_EN:
> 		if (min_uV == 0)
> 			vsel = 0;
> 		else if ((min_uV >= 2161000) && (max_uV <= 4321000)) {
> 			vsel = (min_uV - 1852000) / 386;
> 			if (vsel % 100)
> 				vsel += 100;
> 			vsel /= 100;
> 			vsel++;
> 		}
> 		break;
> 	}
> 
> 	*selector = vsel;
> 
> 	return twlreg_write(info, TWL_MODULE_PM_DVS, VREG_VOLTAGE_DVS_SMPS,
> 							vsel);
> }
> 
> static int twl6030dvssmps_get_voltage_sel(struct regulator_dev *rdev)
> {
> 	struct twlreg_info	*info = rdev_get_drvdata(rdev);
> 
> 	return twlreg_read(info, TWL_MODULE_PM_DVS, VREG_VOLTAGE_DVS_SMPS);
> }
> #endif
829a1017,1032
> 
> 	.set_suspend_enable	= twl6030ldo_suspend_enable,
> 	.set_suspend_disable	= twl6030ldo_suspend_disable,
> };
> 
> static struct regulator_ops twl6030_external_control_pin_ops = {
> 	.enable			= twl6030reg_enable,
> 	.disable		= twl6030reg_disable,
> 	.is_enabled		= twl6030reg_is_enabled,
> 
> 	.set_mode		= twl6030reg_set_mode,
> 
> 	.get_status		= twl6030reg_get_status,
> 
> 	.set_suspend_enable	= twl6030ldo_suspend_enable,
> 	.set_suspend_disable	= twl6030ldo_suspend_disable,
830a1034,1039
> //add
> static struct regulator_ops twldvssmps_ops = {
> 	.list_voltage		= twl6030smps_list_voltage,
> 
> 	.set_voltage		= twl6030dvssmps_set_voltage,
> 	.get_voltage_sel	= twl6030dvssmps_get_voltage_sel,
831a1041,1051
> 	.enable			= twl6030reg_enable,
> 	.disable		= twl6030reg_disable,
> 	.is_enabled		= twl6030reg_is_enabled,
> 
> 	.set_mode		= twl6030reg_set_mode,
> 
> 	.get_status		= twl6030reg_get_status,
> 
> 	.set_suspend_enable	= twl6030ldo_suspend_enable,
> 	.set_suspend_disable	= twl6030ldo_suspend_disable,
> };
838,839c1058,1059
< #define TWL6030_FIXED_LDO(label, offset, mVolts, num, turnon_delay) \
< 		TWL_FIXED_LDO(label, offset, mVolts, num, turnon_delay, \
---
> #define TWL6030_FIXED_LDO(label, offset, mVolts, turnon_delay) \
> 		TWL_FIXED_LDO(label, offset, mVolts, 0x0, turnon_delay, \
859c1079
< #define TWL6030_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts, num) { \
---
> #define TWL6030_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts) { \
861d1080
< 	.id = num, \
867c1086
< 		.n_voltages = (max_mVolts - min_mVolts)/100, \
---
> 		.n_voltages = (max_mVolts - min_mVolts)/100 + 1, \
874c1093
< #define TWL6025_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts, num) { \
---
> #define TWL6032_ADJUSTABLE_LDO(label, offset, min_mVolts, max_mVolts) { \
876d1094
< 	.id = num, \
881c1099
< 		.id = TWL6025_REG_##label, \
---
> 		.id = TWL6032_REG_##label, \
906c1124
< #define TWL6030_FIXED_RESOURCE(label, offset, num, turnon_delay) { \
---
> #define TWL6030_FIXED_RESOURCE(label, offset, turnon_delay) { \
908d1125
< 	.id = num, \
919c1136,1150
< #define TWL6025_ADJUSTABLE_SMPS(label, offset, num) { \
---
> #define TWL6030_ADJUSTABLE_SMPS(label, offset, min_mVolts, max_mVolts) { \
> 	.base = offset, \
> 	.min_mV = min_mVolts, \
> 	.max_mV = max_mVolts, \
> 	.desc = { \
> 		.name = #label, \
> 		.id = TWL6030_REG_##label, \
> 		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
> 		.ops = &twlsmps_ops, \
> 		.type = REGULATOR_VOLTAGE, \
> 		.owner = THIS_MODULE, \
> 		}, \
> 	}
> 
> #define TWL6032_ADJUSTABLE_SMPS(label, offset) { \
921d1151
< 	.id = num, \
926,927c1156,1157
< 		.id = TWL6025_REG_##label, \
< 		.n_voltages = 63, \
---
> 		.id = TWL6032_REG_##label, \
> 		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
933a1164,1190
> #define TWL6030_EXTERNAL_CONTROL_PIN(label, offset, turnon_delay) { \
> 	.base = offset, \
> 	.delay = turnon_delay, \
> 	.desc = { \
> 		.name = #label, \
> 		.id = TWL6030_REG_##label, \
> 		.ops = &twl6030_external_control_pin_ops, \
> 		.type = REGULATOR_VOLTAGE, \
> 		.owner = THIS_MODULE, \
> 		}, \
> 	}
> 	
> 	//add
> #define TWL6032_ADJUSTABLE_DVSSMPS(label, offset) { \
> 	.base = offset, \
> 	.min_mV = 600, \
> 	.max_mV = 2100, \
> 	.desc = { \
> 		.name = #label, \
> 		.id = TWL6032_REG_##label, \
> 		.n_voltages = TWL603X_SMPS_NUMBER_VOLTAGES, \
> 		.ops = &twldvssmps_ops, \
> 		.type = REGULATOR_VOLTAGE, \
> 		.owner = THIS_MODULE, \
> 		}, \
> 	}
> 
964,989c1221,1260
< 	TWL6030_ADJUSTABLE_LDO(VAUX1_6030, 0x54, 1000, 3300, 1),
< 	TWL6030_ADJUSTABLE_LDO(VAUX2_6030, 0x58, 1000, 3300, 2),
< 	TWL6030_ADJUSTABLE_LDO(VAUX3_6030, 0x5c, 1000, 3300, 3),
< 	TWL6030_ADJUSTABLE_LDO(VMMC, 0x68, 1000, 3300, 4),
< 	TWL6030_ADJUSTABLE_LDO(VPP, 0x6c, 1000, 3300, 5),
< 	TWL6030_ADJUSTABLE_LDO(VUSIM, 0x74, 1000, 3300, 7),
< 	TWL6030_FIXED_LDO(VANA, 0x50, 2100, 15, 0),
< 	TWL6030_FIXED_LDO(VCXIO, 0x60, 1800, 16, 0),
< 	TWL6030_FIXED_LDO(VDAC, 0x64, 1800, 17, 0),
< 	TWL6030_FIXED_LDO(VUSB, 0x70, 3300, 18, 0),
< 	TWL6030_FIXED_RESOURCE(CLK32KG, 0x8C, 48, 0),
< 
< 	/* 6025 are renamed compared to 6030 versions */
< 	TWL6025_ADJUSTABLE_LDO(LDO2, 0x54, 1000, 3300, 1),
< 	TWL6025_ADJUSTABLE_LDO(LDO4, 0x58, 1000, 3300, 2),
< 	TWL6025_ADJUSTABLE_LDO(LDO3, 0x5c, 1000, 3300, 3),
< 	TWL6025_ADJUSTABLE_LDO(LDO5, 0x68, 1000, 3300, 4),
< 	TWL6025_ADJUSTABLE_LDO(LDO1, 0x6c, 1000, 3300, 5),
< 	TWL6025_ADJUSTABLE_LDO(LDO7, 0x74, 1000, 3300, 7),
< 	TWL6025_ADJUSTABLE_LDO(LDO6, 0x60, 1000, 3300, 16),
< 	TWL6025_ADJUSTABLE_LDO(LDOLN, 0x64, 1000, 3300, 17),
< 	TWL6025_ADJUSTABLE_LDO(LDOUSB, 0x70, 1000, 3300, 18),
< 
< 	TWL6025_ADJUSTABLE_SMPS(SMPS3, 0x34, 1),
< 	TWL6025_ADJUSTABLE_SMPS(SMPS4, 0x10, 2),
< 	TWL6025_ADJUSTABLE_SMPS(VIO, 0x16, 3),
---
> 	TWL6030_ADJUSTABLE_LDO(VAUX1_6030, 0x54, 1000, 3300),
> 	TWL6030_ADJUSTABLE_LDO(VAUX2_6030, 0x58, 1000, 3300),
> 	TWL6030_ADJUSTABLE_LDO(VAUX3_6030, 0x5c, 1000, 3300),
> 	TWL6030_ADJUSTABLE_LDO(VMMC, 0x68, 1000, 3300),
> 	TWL6030_ADJUSTABLE_LDO(VPP, 0x6c, 1000, 3300),
> 	TWL6030_ADJUSTABLE_LDO(VUSIM, 0x74, 1000, 3300),
> 	TWL6030_FIXED_LDO(VANA, 0x50, 2100, 0),
> 	TWL6030_FIXED_LDO(VCXIO, 0x60, 1800, 0),
> 	TWL6030_FIXED_LDO(VDAC, 0x64, 1800, 0),
> 	TWL6030_FIXED_LDO(VUSB, 0x70, 3300, 0),
> 	TWL6030_FIXED_RESOURCE(CLK32KG, 0x8C, 0),
> 	TWL6030_FIXED_RESOURCE(CLK32KAUDIO, 0x8F, 0),
> 	TWL6030_ADJUSTABLE_SMPS(VDD1, 0x22, 600, 4000),
> 	TWL6030_ADJUSTABLE_SMPS(VDD2, 0x28, 600, 4000),
> 	TWL6030_ADJUSTABLE_SMPS(VDD3, 0x2e, 600, 4000),
> 	TWL6030_ADJUSTABLE_SMPS(VMEM, 0x34, 600, 4000),
> 	TWL6030_ADJUSTABLE_SMPS(V2V1, 0x1c, 1800, 2100),
> 
> 	/* 6032 are renamed compared to 6030 versions */
> 	TWL6032_ADJUSTABLE_LDO(LDO2, 0x54, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO4, 0x58, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO3, 0x5c, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO5, 0x68, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO1, 0x6c, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO7, 0x74, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDO6, 0x60, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDOLN, 0x64, 1000, 3300),
> 	TWL6032_ADJUSTABLE_LDO(LDOUSB, 0x70, 1000, 3300),
> 
> 	TWL6032_ADJUSTABLE_SMPS(SMPS3, 0x34),
> 	TWL6032_ADJUSTABLE_SMPS(SMPS4, 0x10),
> 	TWL6032_ADJUSTABLE_SMPS(VIO, 0x16),
> 	
> 	TWL6032_ADJUSTABLE_DVSSMPS(SMPS1, 0x22),
> 	TWL6032_ADJUSTABLE_DVSSMPS(SMPS2, 0x28),
> 	TWL6032_ADJUSTABLE_DVSSMPS(SMPS5, 0x16),
> 	
> 	TWL6030_EXTERNAL_CONTROL_PIN(SYSEN, 0x83, 0),
> 	TWL6030_EXTERNAL_CONTROL_PIN(REGEN1, 0x7d, 0),
> 
1016a1288
> 	int ret;
1051a1324,1335
> 	case TWL6030_REG_VUSB:
> 		/* Program CFG_LDO_PD2 register and set VUSB bit */
> 		ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, 0x1,
> 				TWL6030_CFG_LDO_PD2);
> 		if (ret < 0)
> 			return ret;
> 
> 		/* Program MISC2 register and set bit VUSB_IN_VBAT */
> 		ret = twl_i2c_write_u8(TWL6030_MODULE_ID0, 0x10, TWL6030_MISC2);
> 		if (ret < 0)
> 			return ret;
> 		break;
1057c1341
< 	case TWL6025_REG_SMPS3:
---
> 	case TWL6032_REG_SMPS3:
1063c1347
< 	case TWL6025_REG_SMPS4:
---
> 	case TWL6032_REG_SMPS4:
1069c1353,1354
< 	case TWL6025_REG_VIO:
---
> 	
> 	case TWL6032_REG_VIO:
1122c1407
< subsys_initcall(twlreg_init);
---
> subsys_initcall_sync(twlreg_init);




diff -r linux-3.0.36/drivers/regulator/wm831x-dcdc.c linux-3.0.36-lenovo/drivers/regulator/wm831x-dcdc.c
29a30,41
> #include <linux/delay.h>
> #include <linux/time.h>
> #include <linux/timer.h>
> #include <linux/string.h>
> 
> //#include "../../arch/arm/mach-rk29/include/mach/gpio.h"
> 
> //#include <linux/hrtimer.h>
> 
> 
> 
> 
38c50
< #define WM831X_DCDC_MAX_NAME 6
---
> //#define WM831X_DCDC_MAX_NAME 6
50c62
< 
---
> #if 0
61a74
> #endif
123d135
< 		return -EINVAL;
303a316,331
> //wm831x_buckv_get_voltage
> 
> int wm831x_reg_read(struct wm831x *wm831x, unsigned short reg);
> static int wm831x_buckv_read_voltage(struct regulator_dev *rdev)
> {
> 	int vol_read;
> 	int ret;
> 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
> 	struct wm831x *wm831x = dcdc->wm831x;
> 	int on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
> 
> 	ret = wm831x_reg_read(wm831x, on_reg);
> 	if (ret < 0)
> 		return ret;
> 	ret &= WM831X_DC1_ON_VSEL_MASK;
> 	vol_read = (ret-8)*12500 + 600000;
304a333,337
> 	return vol_read;
> 
> 
> 
> }
306c339
< 				    int min_uV, int max_uV, unsigned *selector)
---
> 				    int min_uV, int max_uV)
318,319d350
< 	*selector = vsel;
< 
329a361,362
> 	{
> 		dcdc->on_vsel = 0;
330a364
> 	}
381c415
< static int wm831x_buckv_get_voltage_sel(struct regulator_dev *rdev)
---
> static int wm831x_buckv_get_voltage(struct regulator_dev *rdev)
384c418,423
< 
---
> 	struct wm831x *wm831x = dcdc->wm831x;
> 	int on_reg = dcdc->base + WM831X_DCDC_ON_CONFIG;
> 	if (dcdc->on_vsel == 0){
> 	dcdc->on_vsel = wm831x_reg_read(wm831x,on_reg);
> 	dcdc->on_vsel = dcdc->on_vsel & WM831X_DC1_DVS_VSEL_MASK;
> 	}
386c425
< 		return dcdc->dvs_vsel;
---
> 		return wm831x_buckv_list_voltage(rdev, dcdc->dvs_vsel);
388c427
< 		return dcdc->on_vsel;
---
> 		return wm831x_buckv_list_voltage(rdev, dcdc->on_vsel);
395a435,506
> static int wm831x_buckv_set_voltage_step(struct regulator_dev * rdev, int min_uV, int max_uV, unsigned *selector)
> {
> 	int old_vol;
> 	int new_min_uV,new_max_uV;
> 	int diff_value,step;
> 	int ret=0;
> 
> 	struct wm831x_dcdc *dcdc = rdev_get_drvdata(rdev);
> 	struct wm831x *wm831x = dcdc->wm831x;
> 	struct wm831x_pdata *pdata = wm831x->dev->platform_data;
> 
> 
> 	//if(strcmp(rdev->constraints->name,"DCDC2") != 0)
> 	if(strcmp(pdata->dcdc[1]->consumer_supplies[1].supply,"vcore") != 0)
> 	{
> 
> 		ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
> 	}
> 	else
> 	{
> 		old_vol = wm831x_buckv_read_voltage(rdev);
> 
> 		new_min_uV = old_vol;
> 		new_max_uV = old_vol+max_uV-min_uV;
> 
> 		if(old_vol > min_uV) //reduce voltage
> 		{
> 			diff_value = (old_vol - min_uV);
> 
> 			for(step = 100000; step<=diff_value; step += 100000)
> 			{
> 				new_min_uV = old_vol-step;
> 				new_max_uV = old_vol+max_uV-min_uV-step;
> 
> 				ret = wm831x_buckv_set_voltage(rdev,new_min_uV,new_max_uV);
> 				usleep_range(1000,1000);
> 			}
> 
> 			if(new_min_uV > min_uV) //0<  old_vol - min_uV < 100000 ||0< new_min_uV  - min_uV < 1000000
> 			{
> 
> 				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
> 				usleep_range(1000,1000);
> 
> 			}
> 
> 		}
> 		else                    //rise  voltage
> 		{
> 			diff_value = (min_uV- old_vol);
> 
> 			for(step = 100000; step<=diff_value; step += 100000)
> 			{
> 				new_min_uV = old_vol + step;
> 				new_max_uV = old_vol+max_uV-min_uV+step;
> 
> 				ret = wm831x_buckv_set_voltage(rdev,new_min_uV,new_max_uV);
> 				usleep_range(1000,1000);
> 			}
> 			if(new_min_uV < min_uV)//  min_uV - old_vol < 100000 || new_min_uV - old_vol < 100000
> 			{
> 				ret = wm831x_buckv_set_voltage(rdev,min_uV,max_uV);
> 				usleep_range(1000,1000);
> 			}
> 
> 		}
> 
> 	}
> 	return ret;
> 
> }
> 
427a539,549
> int wm831x_dcdc_set_suspend_enable(struct regulator_dev *rdev)
> {
> 
>         return 0;
> }
> int wm831x_dcdc_set_suspend_disable(struct regulator_dev *rdev)
> {
> 
>         return 0;
> }
> 
429,430c551,552
< 	.set_voltage = wm831x_buckv_set_voltage,
< 	.get_voltage_sel = wm831x_buckv_get_voltage_sel,
---
> 	.set_voltage = wm831x_buckv_set_voltage_step,
> 	.get_voltage = wm831x_buckv_get_voltage,
442a565,566
> 	.set_suspend_enable = wm831x_dcdc_set_suspend_enable,
> 	.set_suspend_disable = wm831x_dcdc_set_suspend_disable,
568,569c692,694
< 	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
< 				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
> 				 IRQF_TRIGGER_RISING, dcdc->name,
> 				 dcdc);
577,578c702,704
< 	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_oc_irq,
< 				   IRQF_TRIGGER_RISING, dcdc->name, dcdc);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_oc_irq,
> 				 IRQF_TRIGGER_RISING, dcdc->name,
> 				 dcdc);
590c716
< 	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
602a729
> 	struct wm831x *wm831x = dcdc->wm831x;
606,607c733,734
< 	free_irq(platform_get_irq_byname(pdev, "HC"), dcdc);
< 	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "HC"), dcdc);
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
639c766
< 					int min_uV, int max_uV, int *selector)
---
> 					int min_uV, int max_uV)
653,654d779
< 	*selector = vsel;
< 
659,660c784
< 				    int min_uV, int max_uV,
< 				    unsigned *selector)
---
> 				    int min_uV, int max_uV, unsigned *selector)
665,666c789
< 	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV,
< 					    selector);
---
> 	return wm831x_buckp_set_voltage_int(rdev, reg, min_uV, max_uV);
674d796
< 	unsigned selector;
676c798
< 	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV, &selector);
---
> 	return wm831x_buckp_set_voltage_int(rdev, reg, uV, uV);
679c801
< static int wm831x_buckp_get_voltage_sel(struct regulator_dev *rdev)
---
> static int wm831x_buckp_get_voltage(struct regulator_dev *rdev)
690c812
< 	return val & WM831X_DC3_ON_VSEL_MASK;
---
> 	return wm831x_buckp_list_voltage(rdev, val & WM831X_DC3_ON_VSEL_MASK);
695c817
< 	.get_voltage_sel = wm831x_buckp_get_voltage_sel,
---
> 	.get_voltage = wm831x_buckp_get_voltage,
705a828,829
> 	.set_suspend_enable = wm831x_dcdc_set_suspend_enable,
> 	.set_suspend_disable = wm831x_dcdc_set_suspend_disable,
756,757c880,882
< 	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
< 				   IRQF_TRIGGER_RISING,	dcdc->name, dcdc);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
> 				 IRQF_TRIGGER_RISING, dcdc->name,
> 				 dcdc);
777a903
> 	struct wm831x *wm831x = dcdc->wm831x;
781c907
< 	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
883,885c1009,1011
< 	ret = request_threaded_irq(irq, NULL, wm831x_dcdc_uv_irq,
< 				   IRQF_TRIGGER_RISING, dcdc->name,
< 				   dcdc);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_dcdc_uv_irq,
> 				 IRQF_TRIGGER_RISING, dcdc->name,
> 				 dcdc);
905a1032
> 	struct wm831x *wm831x = dcdc->wm831x;
909c1036
< 	free_irq(platform_get_irq_byname(pdev, "UV"), dcdc);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), dcdc);
1013a1141
> 	printk("%s \n", __FUNCTION__);




diff -r linux-3.0.36/drivers/regulator/wm831x-isink.c linux-3.0.36-lenovo/drivers/regulator/wm831x-isink.c
28c28
< #define WM831X_ISINK_MAX_NAME 7
---
> //#define WM831X_ISINK_MAX_NAME 7
29a30
> #if 0
36a38
> #endif
43c45
< 
---
> 	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
55c57
< 
---
> 	printk("%s:line=%d,ret=0x%x\n",__FUNCTION__,__LINE__,ret);
65c67
< 
---
> 	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
83c85
< 
---
> 	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
87c89
< 
---
> 	
161c163
< 
---
> 	printk("%s:line=%d\n",__FUNCTION__,__LINE__);
201,202c203,206
< 	ret = request_threaded_irq(irq, NULL, wm831x_isink_irq,
< 				   IRQF_TRIGGER_RISING, isink->name, isink);
---
> 	printk("%s:line=%d,irq=%d\n",__FUNCTION__,__LINE__,irq);
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_isink_irq,
> 				 IRQF_TRIGGER_RISING, isink->name,
> 				 isink);
222a227
> 	struct wm831x *wm831x = isink->wm831x;
226c231
< 	free_irq(platform_get_irq(pdev, 0), isink);
---
> 	wm831x_free_irq(wm831x, platform_get_irq(pdev, 0), isink);




diff -r linux-3.0.36/drivers/regulator/wm831x-ldo.c linux-3.0.36-lenovo/drivers/regulator/wm831x-ldo.c
28c28
< #define WM831X_LDO_MAX_NAME 6
---
> //#define WM831X_LDO_MAX_NAME 6
36a37
> #if 0
43a45
> #endif
48c50
< 
---
> extern int reboot_cmd_get(void);
71c73
< 
---
> 	//printk("%s,%x\n", __FUNCTION__,mask);
80c82
< 
---
> 	//printk("%s\n", __FUNCTION__);
116,117c118
< 					 int min_uV, int max_uV,
< 					 unsigned *selector)
---
> 					 int min_uV, int max_uV)
137,138d137
< 	*selector = vsel;
< 
143,144c142
< 				     int min_uV, int max_uV,
< 				     unsigned *selector)
---
> 				     int min_uV, int max_uV, unsigned *selector)
148,150c146,147
< 
< 	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
< 					     selector);
---
> 	//printk("%s base=%x,%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
> 	return wm831x_gp_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
158d154
< 	unsigned int selector;
160c156
< 	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
---
> 	return wm831x_gp_ldo_set_voltage_int(rdev, reg, uV, uV);
163c159
< static int wm831x_gp_ldo_get_voltage_sel(struct regulator_dev *rdev)
---
> static int wm831x_gp_ldo_get_voltage(struct regulator_dev *rdev)
173c169
< 
---
> 	//printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
176c172
< 	return ret;
---
> 	return wm831x_gp_ldo_list_voltage(rdev, ret);
213c209
< 
---
> //	printk("%s base=%x,mode=%x\n", __FUNCTION__,ldo->base,mode);
292a289,298
> int wm831x_ldo_set_suspend_enable(struct regulator_dev *rdev)
> {
> 
>         return 0;
> }
> int wm831x_ldo_set_suspend_disable(struct regulator_dev *rdev)
> {
> 
>         return 0;
> }
296c302
< 	.get_voltage_sel = wm831x_gp_ldo_get_voltage_sel,
---
> 	.get_voltage = wm831x_gp_ldo_get_voltage,
306a313,314
> 	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
> 	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
319c327
< 
---
> //	printk("Probing LDO%d\n", id + 1);
357,359c365,367
< 	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
< 				   IRQF_TRIGGER_RISING, ldo->name,
< 				   ldo);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
> 				 IRQF_TRIGGER_RISING, ldo->name,
> 				 ldo);
379a388
> 	struct wm831x *wm831x = ldo->wm831x;
383c392
< 	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
421,422c430
< 				       int min_uV, int max_uV,
< 				       unsigned *selector)
---
> 					 int min_uV, int max_uV)
442,443d449
< 	*selector = vsel;
< 
448c454
< 				   int min_uV, int max_uV, unsigned *selector)
---
> 				     int min_uV, int max_uV, unsigned *selector)
452,454c458,459
< 
< 	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV,
< 					   selector);
---
> 	//printk("%s base=%x,min_uV=%d,%d\n", __FUNCTION__,ldo->base,min_uV,max_uV);
> 	return wm831x_aldo_set_voltage_int(rdev, reg, min_uV, max_uV);
462d466
< 	unsigned int selector;
464c468
< 	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV, &selector);
---
> 	return wm831x_aldo_set_voltage_int(rdev, reg, uV, uV);
467c471
< static int wm831x_aldo_get_voltage_sel(struct regulator_dev *rdev)
---
> static int wm831x_aldo_get_voltage(struct regulator_dev *rdev)
477c481
< 
---
> 	printk("%s base=%x,ret=%x\n", __FUNCTION__,ldo->base,ret);
480c484
< 	return ret;
---
> 	return wm831x_aldo_list_voltage(rdev, ret);
561c565
< 	.get_voltage_sel = wm831x_aldo_get_voltage_sel,
---
> 	.get_voltage = wm831x_aldo_get_voltage,
570a575,576
> 	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
> 	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
583c589
< 
---
> //	printk("Probing LDO%d--\n", id + 1);
621,622c627,629
< 	ret = request_threaded_irq(irq, NULL, wm831x_ldo_uv_irq,
< 				   IRQF_TRIGGER_RISING, ldo->name, ldo);
---
> 	ret = wm831x_request_irq(wm831x, irq, wm831x_ldo_uv_irq,
> 				 IRQF_TRIGGER_RISING, ldo->name,
> 				 ldo);
642a650
> 	struct wm831x *wm831x = ldo->wm831x;
644c652
< 	free_irq(platform_get_irq_byname(pdev, "UV"), ldo);
---
> 	wm831x_free_irq(wm831x, platform_get_irq_byname(pdev, "UV"), ldo);
677,678c685
< 					    int min_uV, int max_uV,
< 					    unsigned *selector)
---
> 					    int min_uV, int max_uV)
692,693d698
< 	*selector = vsel;
< 
698,699c703
< 					int min_uV, int max_uV,
< 					unsigned *selector)
---
> 				     int min_uV, int max_uV, unsigned *selector)
704,705c708
< 	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV,
< 						selector);
---
> 	return wm831x_alive_ldo_set_voltage_int(rdev, reg, min_uV, max_uV);
713d715
< 	unsigned selector;
715c717
< 	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV, &selector);
---
> 	return wm831x_alive_ldo_set_voltage_int(rdev, reg, uV, uV);
718c720
< static int wm831x_alive_ldo_get_voltage_sel(struct regulator_dev *rdev)
---
> static int wm831x_alive_ldo_get_voltage(struct regulator_dev *rdev)
731c733
< 	return ret;
---
> 	return wm831x_alive_ldo_list_voltage(rdev, ret);
753c755
< 	.get_voltage_sel = wm831x_alive_ldo_get_voltage_sel,
---
> 	.get_voltage = wm831x_alive_ldo_get_voltage,
760a763,764
> 	.set_suspend_enable = wm831x_ldo_set_suspend_enable,
> 	.set_suspend_disable = wm831x_ldo_set_suspend_disable,
773c777
< 
---
> //	printk("wm831x_alive_ldo_probe Probing LDO%d\n", id + 1);
828a833,885
> static __devexit void wm831x_alive_ldo_shutdown(struct platform_device *pdev)	/*ZMF*/
> {
> 	//struct wm831x_ldo *ldo = platform_get_drvdata(pdev);
> #if 0
> 	//close ldo in wm831x_last_deinit()
> 	struct regulator* ldo;
> 
> 	//if (reboot_cmd_get())
> 	//	return 0;
> 	printk("%s\n", __FUNCTION__);
> 
> 	ldo = regulator_get(NULL, "ldo1");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 	
> 	ldo = regulator_get(NULL, "ldo2");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 	
> 	ldo = regulator_get(NULL, "ldo3");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 	
> 	ldo = regulator_get(NULL, "ldo4");
> 	//regulator_disable(ldo);	
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo5");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo6");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo7");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo8");
> 	//regulator_disable(ldo);			
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo9");
> 	regulator_disable(ldo);			
> 	regulator_put(ldo);
> 
> 	ldo = regulator_get(NULL, "ldo10");
> 	regulator_disable(ldo);						
> 	regulator_put(ldo);
> #endif
> }
> 
831a889
> 	.shutdown = __devexit_p(wm831x_alive_ldo_shutdown),
841c899
< 
---
> 	printk("%s \n", __FUNCTION__);	
854,855c912
< 
< 	return 0;
---
>     return 0;




diff -r linux-3.0.36/drivers/regulator/wm8994-regulator.c linux-3.0.36-lenovo/drivers/regulator/wm8994-regulator.c
23a24
> #include <linux/delay.h>
27a29,30
> #include <mach/iomux.h>
> 
238c241,244
< 
---
> 	
> 	if(pdata->ldo[id].iomux_name != NULL)
> 		rk29_mux_api_set(pdata->ldo[id].iomux_name, pdata->ldo[id].iomux_mode);
> 	
240a247
> 		ldo->is_enabled = true;
254a262
> 		msleep(50);
Only in linux-3.0.36-lenovo/drivers/rtc: alarm.c
Only in linux-3.0.36-lenovo/drivers/rtc: alarm-dev.c
Only in linux-3.0.36-lenovo/drivers/rtc: auto-wake.c




diff -r linux-3.0.36/drivers/rtc/class.c linux-3.0.36-lenovo/drivers/rtc/class.c
44,45c44,45
< static time_t		oldtime;
< static struct timespec	oldts;
---
> static struct timespec old_rtc, old_system, old_delta;
> 
51c51
< 
---
> 	struct timespec		delta, delta_delta;
54a55
> 	/* snapshot the current RTC and system time at suspend*/
56,57c57,78
< 	ktime_get_ts(&oldts);
< 	rtc_tm_to_time(&tm, &oldtime);
---
> 	getnstimeofday(&old_system);
> 	rtc_tm_to_time(&tm, &old_rtc.tv_sec);
> 
> 
> 	/*
> 	 * To avoid drift caused by repeated suspend/resumes,
> 	 * which each can add ~1 second drift error,
> 	 * try to compensate so the difference in system time
> 	 * and rtc time stays close to constant.
> 	 */
> 	delta = timespec_sub(old_system, old_rtc);
> 	delta_delta = timespec_sub(delta, old_delta);
> 	if (delta_delta.tv_sec < -2 || delta_delta.tv_sec >= 2) {
> 		/*
> 		 * if delta_delta is too large, assume time correction
> 		 * has occured and set old_delta to the current delta.
> 		 */
> 		old_delta = delta;
> 	} else {
> 		/* Otherwise try to adjust old_system to compensate */
> 		old_system = timespec_sub(old_system, delta_delta);
> 	}
66,68c87,88
< 	time_t			newtime;
< 	struct timespec		time;
< 	struct timespec		newts;
---
> 	struct timespec		new_system, new_rtc;
> 	struct timespec		sleep_time;
73c93,94
< 	ktime_get_ts(&newts);
---
> 	/* snapshot the current rtc and system time at resume */
> 	getnstimeofday(&new_system);
79,82c100,104
< 	rtc_tm_to_time(&tm, &newtime);
< 	if (newtime <= oldtime) {
< 		if (newtime < oldtime)
< 			pr_debug("%s:  time travel!\n", dev_name(&rtc->dev));
---
> 	rtc_tm_to_time(&tm, &new_rtc.tv_sec);
> 	new_rtc.tv_nsec = 0;
> 
> 	if (new_rtc.tv_sec < old_rtc.tv_sec) {
> 		pr_debug("%s:  time travel!\n", dev_name(&rtc->dev));
85,86d106
< 	/* calculate the RTC time delta */
< 	set_normalized_timespec(&time, newtime - oldtime, 0);
88,89c108,119
< 	/* subtract kernel time between rtc_suspend to rtc_resume */
< 	time = timespec_sub(time, timespec_sub(newts, oldts));
---
> 	/* calculate the RTC time delta (sleep time)*/
> 	sleep_time = timespec_sub(new_rtc, old_rtc);
> 
> 	/*
> 	 * Since these RTC suspend/resume handlers are not called
> 	 * at the very end of suspend or the start of resume,
> 	 * some run-time may pass on either sides of the sleep time
> 	 * so subtract kernel run-time between rtc_suspend to rtc_resume
> 	 * to keep things accurate.
> 	 */
> 	sleep_time = timespec_sub(sleep_time,
> 			timespec_sub(new_system, old_system));
91c121,122
< 	timekeeping_inject_sleeptime(&time);
---
> 	if (sleep_time.tv_sec >= 0)
> 		timekeeping_inject_sleeptime(&sleep_time);




diff -r linux-3.0.36/drivers/rtc/Kconfig linux-3.0.36-lenovo/drivers/rtc/Kconfig
108a109,134
> config RTC_INTF_ALARM
> 	bool "Android alarm driver"
> 	depends on RTC_CLASS
> 	default y
> 	help
> 	  Provides non-wakeup and rtc backed wakeup alarms based on rtc or
> 	  elapsed realtime, and a non-wakeup alarm on the monotonic clock.
> 	  Also provides an interface to set the wall time which must be used
> 	  for elapsed realtime to work.
> 
> config RTC_INTF_ALARM_DEV
> 	bool "Android alarm device"
> 	depends on RTC_INTF_ALARM
> 	default y
> 	help
> 	  Exports the alarm interface to user-space.
> 
> config AUTO_WAKE_UP
> 	tristate "Support auto wake up"
> 	depends on RTC_INTF_ALARM_DEV
> 
> config AUTO_WAKE_UP_PERIOD
> 	int "auto wake up period(sec)"
> 	depends on AUTO_WAKE_UP
> 	default 3600
> 
137a164,178
> config RTC_HYM8563
>         tristate "RK2818 or RK29 extern HYM8563 RTC"
> 	depends on I2C_RK2818 || I2C_RK29 || I2C_RK30
>         help
>           If you say yes here you will get support for the
>           HYM8563 I2C RTC chip.
>           This driver can also be built as a module. If so, the module
>           will be called rtc-HYM8563.
> 
> config RTC_M41T66
> 	tristate "ST M41T66"
> 	depends on I2C_RK2818 || I2C_RK29
> 	help
> 	  If you say Y here you will get support for the ST M41T66.
> 
335a377,386
> config RTC_DRV_S35392A
> 	tristate "Seiko Instruments S-35392A"
> 	select BITREVERSE
> 	help
> 	  If you say yes here you will get support for the Seiko
> 	  Instruments S-35392A.
> 
> 	  This driver can also be built as a module. If so the module
> 	  will be called rtc-s35392a.
> 
1061a1113,1123
> config  TPS65910_RTC
> 	tristate "tps65910 rtc for rk"
> 	depends on MFD_TPS65910
> 	help
> 		enable tps65910 rtc for system
> 
> config  RK808_RTC
> 	tristate "rk808 rtc for rk"
> 	depends on MFD_RK808
> 	help
> 		enable rk808 rtc for system




diff -r linux-3.0.36/drivers/rtc/Makefile linux-3.0.36-lenovo/drivers/rtc/Makefile
11a12,13
> obj-$(CONFIG_RTC_INTF_ALARM) += alarm.o
> obj-$(CONFIG_RTC_INTF_ALARM_DEV) += alarm-dev.o
15a18,19
> obj-$(CONFIG_AUTO_WAKE_UP) += auto-wake.o
> 
91a96
> obj-$(CONFIG_RTC_DRV_S35392A)	+= rtc-s35392a.o
110a116,119
> obj-$(CONFIG_RTC_HYM8563)	+= rtc-HYM8563.o
> obj-$(CONFIG_RTC_M41T66)	+= rtc-m41t66.o
> obj-$(CONFIG_TPS65910_RTC)  += rtc-tps65910.o
> obj-$(CONFIG_RK808_RTC)  += rtc-rk808.o
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-HYM8563.c
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-HYM8563.h




diff -r linux-3.0.36/drivers/rtc/rtc-imxdi.c linux-3.0.36-lenovo/drivers/rtc/rtc-imxdi.c
393a394,395
> 	spin_lock_init(&imxdi->irq_lock);
> 




diff -r linux-3.0.36/drivers/rtc/rtc-isl1208.c linux-3.0.36-lenovo/drivers/rtc/rtc-isl1208.c
496a497
> 	struct rtc_device *rtc = i2c_get_clientdata(client);
517a519,520
> 
> 		rtc_update_irq(rtc, 1, RTC_IRQF | RTC_AF);
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-m41t66.c




diff -r linux-3.0.36/drivers/rtc/rtc-mxc.c linux-3.0.36-lenovo/drivers/rtc/rtc-mxc.c
193a194
> 	unsigned long flags;
197c198
< 	spin_lock_irq(&pdata->rtc->irq_lock);
---
> 	spin_lock_irqsave(&pdata->rtc->irq_lock, flags);
220c221
< 	spin_unlock_irq(&pdata->rtc->irq_lock);
---
> 	spin_unlock_irqrestore(&pdata->rtc->irq_lock, flags);




diff -r linux-3.0.36/drivers/rtc/rtc-pcf8563.c linux-3.0.36-lenovo/drivers/rtc/rtc-pcf8563.c
239c239
< 	{ "pcf8563", 0 },
---
> 	{ "rtc-pcf8563", 0 },
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-rk808.c




diff -r linux-3.0.36/drivers/rtc/rtc-rs5c348.c linux-3.0.36-lenovo/drivers/rtc/rtc-rs5c348.c
124,125c124,126
< 		tm->tm_hour %= 12;
< 		if (rxbuf[RS5C348_REG_HOURS] & RS5C348_BIT_PM)
---
> 		if (rxbuf[RS5C348_REG_HOURS] & RS5C348_BIT_PM) {
> 			tm->tm_hour -= 20;
> 			tm->tm_hour %= 12;
126a128,129
> 		} else
> 			tm->tm_hour %= 12;
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-s35392a.c
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-s35392a.h




diff -r linux-3.0.36/drivers/rtc/rtc-test.c linux-3.0.36-lenovo/drivers/rtc/rtc-test.c
33c33,35
< 	rtc_time_to_tm(get_seconds(), tm);
---
> 	unsigned long time = 0xffffff;
> 	rtc_time_to_tm(time, tm);
> 	//rtc_time_to_tm(get_seconds(), tm);
Only in linux-3.0.36-lenovo/drivers/rtc: rtc-tps65910.c




diff -r linux-3.0.36/drivers/rtc/rtc-twl.c linux-3.0.36-lenovo/drivers/rtc/rtc-twl.c
365,372d364
< #ifdef CONFIG_LOCKDEP
< 	/* WORKAROUND for lockdep forcing IRQF_DISABLED on us, which
< 	 * we don't want and can't tolerate.  Although it might be
< 	 * friendlier not to borrow this thread context...
< 	 */
< 	local_irq_enable();
< #endif
< 
431c423
< 	int ret = 0;
---
> 	int ret = -EINVAL;
434c426
< 
---
> 	printk("+++ twl_rtc_probe +++\n");
436,448c428
< 		return -EINVAL;
< 
< 	rtc = rtc_device_register(pdev->name,
< 				  &pdev->dev, &twl_rtc_ops, THIS_MODULE);
< 	if (IS_ERR(rtc)) {
< 		ret = PTR_ERR(rtc);
< 		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
< 			PTR_ERR(rtc));
< 		goto out0;
< 
< 	}
< 
< 	platform_set_drvdata(pdev, rtc);
---
> 		goto out1;
465,472d444
< 	ret = request_irq(irq, twl_rtc_interrupt,
< 				IRQF_TRIGGER_RISING,
< 				dev_name(&rtc->dev), rtc);
< 	if (ret < 0) {
< 		dev_err(&pdev->dev, "IRQ is not free.\n");
< 		goto out1;
< 	}
< 
483c455
< 		goto out2;
---
> 		goto out1;
490c462
< 			goto out2;
---
> 			goto out1;
492a465,469
> 	/* ensure interrupts are disabled, bootloaders can be strange */
> 	ret = twl_rtc_write_u8(0, REG_RTC_INTERRUPTS_REG);
> 	if (ret < 0)
> 		dev_warn(&pdev->dev, "unable to disable interrupt\n");
> 
495a473,489
> 		goto out1;
> 
> 	rtc = rtc_device_register(pdev->name,
> 				  &pdev->dev, &twl_rtc_ops, THIS_MODULE);
> 	if (IS_ERR(rtc)) {
> 		ret = PTR_ERR(rtc);
> 		dev_err(&pdev->dev, "can't register RTC device, err %ld\n",
> 			PTR_ERR(rtc));
> 		goto out1;
> 
> 	}
> 
> 	ret = request_threaded_irq(irq, NULL, twl_rtc_interrupt,
> 				   IRQF_TRIGGER_RISING,
> 				   dev_name(&rtc->dev), rtc);
> 	if (ret < 0) {
> 		dev_err(&pdev->dev, "IRQ is not free.\n");
496a491
> 	}
498c493,497
< 	return ret;
---
> 	if (enable_irq_wake(irq) < 0)
> 		dev_warn(&pdev->dev, "Cannot enable wakeup for IRQ %d\n", irq);
> 
> 	platform_set_drvdata(pdev, rtc);
> 	return 0;
501,502d499
< 	free_irq(irq, rtc);
< out1:
504c501
< out0:
---
> out1:




diff -r linux-3.0.36/drivers/rtc/rtc-vt8500.c linux-3.0.36-lenovo/drivers/rtc/rtc-vt8500.c
72c72
< #define VT8500_RTC_CR_24H	(1 << 1)	/* 24h time format */
---
> #define VT8500_RTC_CR_12H	(1 << 1)	/* 12h time format */
119c119
< 	tm->tm_mon = bcd2bin((date & DATE_MONTH_MASK) >> DATE_MONTH_S);
---
> 	tm->tm_mon = bcd2bin((date & DATE_MONTH_MASK) >> DATE_MONTH_S) - 1;
138,139c138,140
< 		| (bin2bcd(tm->tm_mon) << DATE_MONTH_S)
< 		| (bin2bcd(tm->tm_mday)),
---
> 		| (bin2bcd(tm->tm_mon + 1) << DATE_MONTH_S)
> 		| (bin2bcd(tm->tm_mday))
> 		| ((tm->tm_year >= 200) << DATE_CENTURY_S),
249c250
< 	writel(VT8500_RTC_CR_ENABLE | VT8500_RTC_CR_24H,
---
> 	writel(VT8500_RTC_CR_ENABLE,




diff -r linux-3.0.36/drivers/rtc/rtc-wm831x.c linux-3.0.36-lenovo/drivers/rtc/rtc-wm831x.c
27c27
< 
---
> #include <linux/random.h>
98a99,118
> static void wm831x_rtc_add_randomness(struct wm831x *wm831x)
> {
> 	int ret;
> 	u16 reg;
> 
> 	/*
> 	 * The write counter contains a pseudo-random number which is
> 	 * regenerated every time we set the RTC so it should be a
> 	 * useful per-system source of entropy.
> 	 */
> 	ret = wm831x_reg_read(wm831x, WM831X_RTC_WRITE_COUNTER);
> 	if (ret >= 0) {
> 		reg = ret;
> 		add_device_randomness(&reg, sizeof(reg));
> 	} else {
> 		dev_warn(wm831x->dev, "Failed to read RTC write counter: %d\n",
> 			 ret);
> 	}
> }
> 
410a431
> 	struct rtc_time tm;
411a433
> 	//printk("wm831x_rtc_probe\n");
418a441,447
> #ifdef CONFIG_ARCH_RK30
> 	wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);
> 	wm831x_set_bits(wm831x, WM831X_SECURITY_KEY, 0x9716, 0x9716);  //0x4090h bit15 is encrypted, if this bit need modify, we must write 0x4008h as 0x9716 first.
> 	wm831x_set_bits(wm831x, WM831X_CLOCK_CONTROL_1, 0x8700, 0x8100); //open the clk out
> 	wm831x_reg_read(wm831x, WM831X_CLOCK_CONTROL_1);
> #endif
> 
426a456,466
> 	ret = wm831x_rtc_readtime(&pdev->dev, &tm);
> 	if (ret < 0 || tm.tm_year < 111) {
> 		if (ret)
> 			dev_err(&pdev->dev, "Failed to read RTC time\n");
> 		else
> 			dev_err(&pdev->dev, "Invalid RTC date/time %4d-%02d-%02d(%d) %02d:%02d:%02d\n",
> 				1900 + tm.tm_year, tm.tm_mon + 1, tm.tm_mday, tm.tm_wday,
> 				tm.tm_hour, tm.tm_min, tm.tm_sec);
> 		wm831x_rtc_set_mmss(&pdev->dev, 1293883200); // 2011-01-01 12:00:00
> 	}
> 
450a491,492
> 
> 	wm831x_rtc_add_randomness(wm831x);




diff -r linux-3.0.36/drivers/s390/cio/device_pgid.c linux-3.0.36-lenovo/drivers/s390/cio/device_pgid.c
237c237
< 			 int *mismatch, int *reserved, u8 *reset)
---
> 			 int *mismatch, u8 *reserved, u8 *reset)
251c251
< 			*reserved = 1;
---
> 			*reserved |= lpm;
319c319
< 	int reserved = 0;
---
> 	u8 reserved = 0;
326c326
< 	if (reserved)
---
> 	if (reserved == cdev->private->pgid_valid_mask)
339c339
< 		      "todo=%02x mism=%d rsvd=%d reset=%02x\n", id->ssid,
---
> 		      "todo=%02x mism=%d rsvd=%02x reset=%02x\n", id->ssid,




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_aux.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_aux.c
520a521
> 	atomic_set(&port->units, 0);




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_ccw.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_ccw.c
41,42c41,47
< static int zfcp_ccw_activate(struct ccw_device *cdev)
< 
---
> /**
>  * zfcp_ccw_activate - activate adapter and wait for it to finish
>  * @cdev: pointer to belonging ccw device
>  * @clear: Status flags to clear.
>  * @tag: s390dbf trace record tag
>  */
> static int zfcp_ccw_activate(struct ccw_device *cdev, int clear, char *tag)
48a54
> 	zfcp_erp_clear_adapter_status(adapter, clear);
51c57
< 				"ccresu2");
---
> 				tag);
166c172
< 	zfcp_ccw_activate(cdev);
---
> 	zfcp_ccw_activate(cdev, 0, "ccsonl1");
172c178
<  * zfcp_ccw_set_offline - set_offline function of zfcp driver
---
>  * zfcp_ccw_offline_sync - shut down adapter and wait for it to finish
173a180,181
>  * @set: Status flags to set.
>  * @tag: s390dbf trace record tag
178c186
< static int zfcp_ccw_set_offline(struct ccw_device *cdev)
---
> static int zfcp_ccw_offline_sync(struct ccw_device *cdev, int set, char *tag)
185c193,194
< 	zfcp_erp_adapter_shutdown(adapter, 0, "ccsoff1");
---
> 	zfcp_erp_set_adapter_status(adapter, set);
> 	zfcp_erp_adapter_shutdown(adapter, 0, tag);
192a202,213
>  * zfcp_ccw_set_offline - set_offline function of zfcp driver
>  * @cdev: pointer to belonging ccw device
>  *
>  * This function gets called by the common i/o layer and sets an adapter
>  * into state offline.
>  */
> static int zfcp_ccw_set_offline(struct ccw_device *cdev)
> {
> 	return zfcp_ccw_offline_sync(cdev, 0, "ccsoff1");
> }
> 
> /**
208a230,234
> 		if (atomic_read(&adapter->status) &
> 		    ZFCP_STATUS_ADAPTER_SUSPENDED) { /* notification ignore */
> 			zfcp_dbf_hba_basic("ccnigo1", adapter);
> 			break;
> 		}
217a244,248
> 		if (atomic_read(&adapter->status) &
> 		    ZFCP_STATUS_ADAPTER_SUSPENDED) { /* notification ignore */
> 			zfcp_dbf_hba_basic("ccniop1", adapter);
> 			break;
> 		}
252a284,305
> static int zfcp_ccw_suspend(struct ccw_device *cdev)
> {
> 	zfcp_ccw_offline_sync(cdev, ZFCP_STATUS_ADAPTER_SUSPENDED, "ccsusp1");
> 	return 0;
> }
> 
> static int zfcp_ccw_thaw(struct ccw_device *cdev)
> {
> 	/* trace records for thaw and final shutdown during suspend
> 	   can only be found in system dump until the end of suspend
> 	   but not after resume because it's based on the memory image
> 	   right after the very first suspend (freeze) callback */
> 	zfcp_ccw_activate(cdev, 0, "ccthaw1");
> 	return 0;
> }
> 
> static int zfcp_ccw_resume(struct ccw_device *cdev)
> {
> 	zfcp_ccw_activate(cdev, ZFCP_STATUS_ADAPTER_SUSPENDED, "ccresu1");
> 	return 0;
> }
> 
265,267c318,320
< 	.freeze      = zfcp_ccw_set_offline,
< 	.thaw	     = zfcp_ccw_activate,
< 	.restore     = zfcp_ccw_activate,
---
> 	.freeze      = zfcp_ccw_suspend,
> 	.thaw	     = zfcp_ccw_thaw,
> 	.restore     = zfcp_ccw_resume,




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_cfdc.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_cfdc.c
296c296
< 	shost_for_each_device(sdev, port->adapter->scsi_host) {
---
> 	shost_for_each_device(sdev, adapter->scsi_host) {




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_dbf.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_dbf.c
165a166,185
> /**
>  * zfcp_dbf_hba_basic - trace event for basic adapter events
>  * @adapter: pointer to struct zfcp_adapter
>  */
> void zfcp_dbf_hba_basic(char *tag, struct zfcp_adapter *adapter)
> {
> 	struct zfcp_dbf *dbf = adapter->dbf;
> 	struct zfcp_dbf_hba *rec = &dbf->hba_buf;
> 	unsigned long flags;
> 
> 	spin_lock_irqsave(&dbf->hba_lock, flags);
> 	memset(rec, 0, sizeof(*rec));
> 
> 	memcpy(rec->tag, tag, ZFCP_DBF_TAG_LEN);
> 	rec->id = ZFCP_DBF_HBA_BASIC;
> 
> 	debug_event(dbf->hba, 1, rec, sizeof(*rec));
> 	spin_unlock_irqrestore(&dbf->hba_lock, flags);
> }
> 




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_dbf.h linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_dbf.h
156a157
> 	ZFCP_DBF_HBA_BASIC	= 4,




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_def.h linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_def.h
78a79
> #define ZFCP_STATUS_ADAPTER_SUSPENDED		0x00000040
205a207
> 	atomic_t		units;	       /* zfcp_unit count */




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_ext.h linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_ext.h
55a56
> extern void zfcp_dbf_hba_basic(char *, struct zfcp_adapter *);
159a161
> extern struct mutex zfcp_sysfs_port_units_mutex;




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_fsf.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_fsf.c
222c222
< 	zfcp_dbf_hba_fsf_uss("fssrh_2", req);
---
> 	zfcp_dbf_hba_fsf_uss("fssrh_4", req);
774c774
< 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
---
> 	struct zfcp_scsi_dev *zfcp_sdev;
779a780,781
> 	zfcp_sdev = sdev_to_zfcp(sdev);
> 
888c890
< 		zfcp_dbf_san_res("fsscth1", req);
---
> 		zfcp_dbf_san_res("fsscth2", req);
1733c1735
< 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
---
> 	struct zfcp_scsi_dev *zfcp_sdev;
1739a1742,1743
> 	zfcp_sdev = sdev_to_zfcp(sdev);
> 
1850c1854
< 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
---
> 	struct zfcp_scsi_dev *zfcp_sdev;
1854a1859,1860
> 	zfcp_sdev = sdev_to_zfcp(sdev);
> 
1944c1950
< 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(scsi->device);
---
> 	struct zfcp_scsi_dev *zfcp_sdev;
1958a1965
> 		zfcp_sdev = sdev_to_zfcp(scsi->device);
1996c2003
< 	struct zfcp_scsi_dev *zfcp_sdev = sdev_to_zfcp(sdev);
---
> 	struct zfcp_scsi_dev *zfcp_sdev;
2000a2008,2009
> 
> 	zfcp_sdev = sdev_to_zfcp(sdev);




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_sysfs.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_sysfs.c
229a230,231
> DEFINE_MUTEX(zfcp_sysfs_port_units_mutex);
> 
251a254,263
> 	mutex_lock(&zfcp_sysfs_port_units_mutex);
> 	if (atomic_read(&port->units) > 0) {
> 		retval = -EBUSY;
> 		mutex_unlock(&zfcp_sysfs_port_units_mutex);
> 		goto out;
> 	}
> 	/* port is about to be removed, so no more unit_add */
> 	atomic_set(&port->units, -1);
> 	mutex_unlock(&zfcp_sysfs_port_units_mutex);
> 
291a304
> 	int retval;
296,297c309,311
< 	if (zfcp_unit_add(port, fcp_lun))
< 		return -EINVAL;
---
> 	retval = zfcp_unit_add(port, fcp_lun);
> 	if (retval)
> 		return retval;




diff -r linux-3.0.36/drivers/s390/scsi/zfcp_unit.c linux-3.0.36-lenovo/drivers/s390/scsi/zfcp_unit.c
107c107
< 	put_device(&unit->port->dev);
---
> 	atomic_dec(&unit->port->units);
121a122,129
> 	int retval = 0;
> 
> 	mutex_lock(&zfcp_sysfs_port_units_mutex);
> 	if (atomic_read(&port->units) == -1) {
> 		/* port is already gone */
> 		retval = -ENODEV;
> 		goto out;
> 	}
126c134,135
< 		return -EEXIST;
---
> 		retval = -EEXIST;
> 		goto out;
130,131c139,142
< 	if (!unit)
< 		return -ENOMEM;
---
> 	if (!unit) {
> 		retval = -ENOMEM;
> 		goto out;
> 	}
142c153,154
< 		return -ENOMEM;
---
> 		retval = -ENOMEM;
> 		goto out;
145,146d156
< 	get_device(&port->dev);
< 
149c159,160
< 		return -ENOMEM;
---
> 		retval = -ENOMEM;
> 		goto out;
154c165,166
< 		return -EINVAL;
---
> 		retval = -EINVAL;
> 		goto out;
156a169,170
> 	atomic_inc(&port->units); /* under zfcp_sysfs_port_units_mutex ! */
> 
163c177,179
< 	return 0;
---
> out:
> 	mutex_unlock(&zfcp_sysfs_port_units_mutex);
> 	return retval;




diff -r linux-3.0.36/drivers/scsi/atp870u.c linux-3.0.36-lenovo/drivers/scsi/atp870u.c
1177c1177,1186
< 	udelay(0x800);
---
> 	/*
> 	 * The funny division into multiple delays is to accomodate
> 	 * arches like ARM where udelay() multiplies its argument by
> 	 * a large number to initialize a loop counter.  To avoid
> 	 * overflow, the maximum supported udelay is 2000 microseconds.
> 	 *
> 	 * XXX it would be more polite to find a way to use msleep()
> 	 */
> 	mdelay(2);
> 	udelay(48);




diff -r linux-3.0.36/drivers/scsi/bnx2i/bnx2i_hwi.c linux-3.0.36-lenovo/drivers/scsi/bnx2i/bnx2i_hwi.c
1262a1263,1265
> 	memset(&iscsi_init, 0x00, sizeof(struct iscsi_kwqe_init1));
> 	memset(&iscsi_init2, 0x00, sizeof(struct iscsi_kwqe_init2));
> 




diff -r linux-3.0.36/drivers/scsi/device_handler/scsi_dh_alua.c linux-3.0.36-lenovo/drivers/scsi/device_handler/scsi_dh_alua.c
622,623c622
< 	case TPGS_STATE_UNAVAILABLE:
< 		/* Path unusable for unavailable/offline */
---
> 		/* Path unusable */




diff -r linux-3.0.36/drivers/scsi/hpsa.c linux-3.0.36-lenovo/drivers/scsi/hpsa.c
1211a1212
> 		cmd->result = DID_ERROR << 16;
1213c1214
< 			"protocol error \n", cp);
---
> 			"protocol error\n", cp);
2895c2896
< 			c->Request.CDB[1] = 0x03;  /* Reset target above */
---
> 			c->Request.CDB[1] = HPSA_RESET_TYPE_LUN;




diff -r linux-3.0.36/drivers/scsi/ibmvscsi/ibmvscsi.c linux-3.0.36-lenovo/drivers/scsi/ibmvscsi/ibmvscsi.c
1549a1550,1552
> 	/* The transport length field is only 16-bit */
> 	length = min(0xffff, length);
> 




diff -r linux-3.0.36/drivers/scsi/isci/init.c linux-3.0.36-lenovo/drivers/scsi/isci/init.c
461d460
< 			devm_kfree(&pdev->dev, orom);




diff -r linux-3.0.36/drivers/scsi/isci/probe_roms.c linux-3.0.36-lenovo/drivers/scsi/isci/probe_roms.c
107d106
< 		devm_kfree(&pdev->dev, rom);




diff -r linux-3.0.36/drivers/scsi/isci/request.c linux-3.0.36-lenovo/drivers/scsi/isci/request.c
1696c1696
< 			sci_controller_copy_sata_response(&ireq->stp.req,
---
> 			sci_controller_copy_sata_response(&ireq->stp.rsp,




diff -r linux-3.0.36/drivers/scsi/libsas/sas_expander.c linux-3.0.36-lenovo/drivers/scsi/libsas/sas_expander.c
773c773
< static int sas_ex_join_wide_port(struct domain_device *parent, int phy_id)
---
> static bool sas_ex_join_wide_port(struct domain_device *parent, int phy_id)
789c789
< 			return 0;
---
> 			return true;
793c793
< 	return -ENODEV;
---
> 	return false;
931,932c931
< 	res = sas_ex_join_wide_port(dev, phy_id);
< 	if (!res) {
---
> 	if (sas_ex_join_wide_port(dev, phy_id)) {
977,978c976
< 				res = sas_ex_join_wide_port(dev, i);
< 				if (!res)
---
> 				if (sas_ex_join_wide_port(dev, i))
1841,1842c1839
< 	bool found = false;
< 	int res, i;
---
> 	int res;
1848,1861c1845,1847
< 		goto out;
< 	/* to support the wide port inserted */
< 	for (i = 0; i < dev->ex_dev.num_phys; i++) {
< 		struct ex_phy *ex_phy_temp = &dev->ex_dev.ex_phy[i];
< 		if (i == phy_id)
< 			continue;
< 		if (SAS_ADDR(ex_phy_temp->attached_sas_addr) ==
< 		    SAS_ADDR(ex_phy->attached_sas_addr)) {
< 			found = true;
< 			break;
< 		}
< 	}
< 	if (found) {
< 		sas_ex_join_wide_port(dev, phy_id);
---
> 		return res;
> 
> 	if (sas_ex_join_wide_port(dev, phy_id))
1863c1849
< 	}
---
> 
1865,1866c1851,1852
< 	if (!res)
< 		goto out;
---
> 	if (res)
> 		return res;
1876d1861
< out:
1975,1977c1960
< 	if (res)
< 		goto out;
< 	if (dev) {
---
> 	while (res == 0 && dev) {
1988a1972,1974
> 
> 		dev = NULL;
> 		res = sas_find_bcast_dev(port_dev, &dev);
1990d1975
< out:




diff -r linux-3.0.36/drivers/scsi/megaraid/megaraid_sas_base.c linux-3.0.36-lenovo/drivers/scsi/megaraid/megaraid_sas_base.c
4055d4054
< 	spin_lock_init(&poll_aen_lock);
5381a5381,5382
> 
> 	spin_lock_init(&poll_aen_lock);




diff -r linux-3.0.36/drivers/scsi/mpt2sas/mpt2sas_base.c linux-3.0.36-lenovo/drivers/scsi/mpt2sas/mpt2sas_base.c
1099a1100,1106
> 	/* Check whether controller SAS2008 B0 controller,
> 	   if it is SAS2008 B0 controller use IO-APIC instead of MSIX */
> 	if (ioc->pdev->device == MPI2_MFGPAGE_DEVID_SAS2008 &&
> 	    ioc->pdev->revision == 0x01) {
> 		return -EINVAL;
> 	}
> 
2143,2146c2150,2156
< 	if (max_queue_depth != -1)
< 		max_request_credit = (max_queue_depth < facts->RequestCredit)
< 		    ? max_queue_depth : facts->RequestCredit;
< 	else
---
> 	if (max_queue_depth != -1 && max_queue_depth != 0) {
> 		max_request_credit = min_t(u16, max_queue_depth +
> 			ioc->hi_priority_depth + ioc->internal_depth,
> 			facts->RequestCredit);
> 		if (max_request_credit > MAX_HBA_QUEUE_DEPTH)
> 			max_request_credit =  MAX_HBA_QUEUE_DEPTH;
> 	} else
2221c2231
< 	ioc->shost->can_queue = ioc->scsiio_depth - (2);
---
> 	ioc->shost->can_queue = ioc->scsiio_depth;




diff -r linux-3.0.36/drivers/scsi/mvsas/mv_94xx.h linux-3.0.36-lenovo/drivers/scsi/mvsas/mv_94xx.h
196,197d195
< #define mv_ffc(x)   ffz(x)
< 
201,210c199,200
< 	int i;
< 	i = mv_ffc((u32)v);
< 	if (i >= 0)
< 		return i;
< 	i = mv_ffc((u32)(v>>32));
< 
< 	if (i != 0)
< 		return 32 + i;
< 
< 	return -1;
---
> 	u64 x = ~v;
> 	return x ? __ffs64(x) : -1;




diff -r linux-3.0.36/drivers/scsi/mvsas/mv_sas.h linux-3.0.36-lenovo/drivers/scsi/mvsas/mv_sas.h
76c76
< #define bit(n) ((u32)1 << n)
---
> #define bit(n) ((u64)1 << n)




diff -r linux-3.0.36/drivers/scsi/qla2xxx/qla_os.c linux-3.0.36-lenovo/drivers/scsi/qla2xxx/qla_os.c
3409c3409,3410
< 		if (test_bit(FCPORT_UPDATE_NEEDED, &base_vha->dpc_flags)) {
---
> 		if (test_and_clear_bit(FCPORT_UPDATE_NEEDED,
> 		    &base_vha->dpc_flags)) {
3411d3411
< 			clear_bit(FCPORT_UPDATE_NEEDED, &base_vha->dpc_flags);




diff -r linux-3.0.36/drivers/scsi/scsi_error.c linux-3.0.36-lenovo/drivers/scsi/scsi_error.c
43a44,45
> static void scsi_eh_done(struct scsi_cmnd *scmd);
> 
242a245,252
> 	if (scmd->cmnd[0] == TEST_UNIT_READY && scmd->scsi_done != scsi_eh_done)
> 		/*
> 		 * nasty: for mid-layer issued TURs, we need to return the
> 		 * actual sense data without any recovery attempt.  For eh
> 		 * issued ones, we need to try to recover and interpret
> 		 */
> 		return SUCCESS;
> 
1667a1678,1691
> 
> 	/*
> 	 * if eh is active and host_eh_scheduled is pending we need to re-run
> 	 * recovery.  we do this check after scsi_run_host_queues() to allow
> 	 * everything pent up since the last eh run a chance to make forward
> 	 * progress before we sync again.  Either we'll immediately re-run
> 	 * recovery or scsi_device_unbusy() will wake us again when these
> 	 * pending commands complete.
> 	 */
> 	spin_lock_irqsave(shost->host_lock, flags);
> 	if (shost->host_eh_scheduled)
> 		if (scsi_host_set_state(shost, SHOST_RECOVERY))
> 			WARN_ON(scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY));
> 	spin_unlock_irqrestore(shost->host_lock, flags);




diff -r linux-3.0.36/drivers/scsi/scsi_lib.c linux-3.0.36-lenovo/drivers/scsi/scsi_lib.c
402c402
< 	struct scsi_device *sdev = q->queuedata;
---
> 	struct scsi_device *sdev;
406a407,413
> 	/*if reset ehci and smsc hub, q may be Null, so return.wlf@20130720*/
> 	if(!q){
> 		return;
> 	}else{
> 		sdev = q->queuedata;
> 	}
> 
483a491
> 	struct scsi_device *sdev = cmd->device;
486a495,502
> 	/*
> 	 * We need to hold a reference on the device to avoid the queue being
> 	 * killed after the unlock and before scsi_run_queue is invoked which
> 	 * may happen because scsi_unprep_request() puts the command which
> 	 * releases its reference on the device.
> 	 */
> 	get_device(&sdev->sdev_gendev);
> 
492a509,510
> 
> 	put_device(&sdev->sdev_gendev);




diff -r linux-3.0.36/drivers/scsi/scsi_scan.c linux-3.0.36-lenovo/drivers/scsi/scsi_scan.c
778a779,788
> 	if (strncmp(sdev->vendor, "ATA     ", 8) == 0) {
> 		/*
> 		 * sata emulation layer device.  This is a hack to work around
> 		 * the SATL power management specifications which state that
> 		 * when the SATL detects the device has gone into standby
> 		 * mode, it shall respond with NOT READY.
> 		 */
> 		sdev->allow_restart = 1;
> 	}
> 
1712a1723,1725
> 		/* target removed before the device could be added */
> 		if (sdev->sdev_state == SDEV_DEL)
> 			continue;




diff -r linux-3.0.36/drivers/scsi/scsi_sysfs.c linux-3.0.36-lenovo/drivers/scsi/scsi_sysfs.c
965d964
< 	starget->reap_ref++;
979,986d977
< 	scsi_target_reap(starget);
< }
< 
< static int __remove_child (struct device * dev, void * data)
< {
< 	if (scsi_is_target_device(dev))
< 		__scsi_remove_target(to_scsi_target(dev));
< 	return 0;
999,1001c990,1010
< 	if (scsi_is_target_device(dev)) {
< 		__scsi_remove_target(to_scsi_target(dev));
< 		return;
---
> 	struct Scsi_Host *shost = dev_to_shost(dev->parent);
> 	struct scsi_target *starget, *last = NULL;
> 	unsigned long flags;
> 
> 	/* remove targets being careful to lookup next entry before
> 	 * deleting the last
> 	 */
> 	spin_lock_irqsave(shost->host_lock, flags);
> 	list_for_each_entry(starget, &shost->__targets, siblings) {
> 		if (starget->state == STARGET_DEL)
> 			continue;
> 		if (starget->dev.parent == dev || &starget->dev == dev) {
> 			/* assuming new targets arrive at the end */
> 			starget->reap_ref++;
> 			spin_unlock_irqrestore(shost->host_lock, flags);
> 			if (last)
> 				scsi_target_reap(last);
> 			last = starget;
> 			__scsi_remove_target(starget);
> 			spin_lock_irqsave(shost->host_lock, flags);
> 		}
1002a1012
> 	spin_unlock_irqrestore(shost->host_lock, flags);
1004,1006c1014,1015
< 	get_device(dev);
< 	device_for_each_child(dev, NULL, __remove_child);
< 	put_device(dev);
---
> 	if (last)
> 		scsi_target_reap(last);




diff -r linux-3.0.36/drivers/scsi/sd.c linux-3.0.36-lenovo/drivers/scsi/sd.c
2829,2832d2828
< 	err = scsi_register_driver(&sd_template.gendrv);
< 	if (err)
< 		goto err_out_class;
< 
2845a2842,2845
> 	err = scsi_register_driver(&sd_template.gendrv);
> 	if (err)
> 		goto err_out_driver;
> 
2847a2848,2850
> err_out_driver:
> 	mempool_destroy(sd_cdb_pool);
> 
2869a2873
> 	scsi_unregister_driver(&sd_template.gendrv);
2873d2876
< 	scsi_unregister_driver(&sd_template.gendrv);
Only in linux-3.0.36-lenovo/drivers: smc




diff -r linux-3.0.36/drivers/spi/Kconfig linux-3.0.36-lenovo/drivers/spi/Kconfig
426a427,466
> config SPIM_RK29
> 	tristate "RK SPI master controller core support"
> 	depends on PLAT_RK && SPI_MASTER
> 	help
> 	  general driver for SPI controller core from RockChips 
> 
> config SPIM0_RK29
> 	bool "RK SPI0 master controller"
> 	depends on SPIM_RK29
> 	help
> 	  enable SPI0 master controller for RK29 	 
> 
> config SPIM1_RK29
> 	bool "RK SPI1 master controller"
> 	depends on SPIM_RK29 && !ARCH_RK2928
> 	help
> 	  enable SPI1 master controller for RK29 	
> 
> config RK_SPIM_TEST
> 	bool "RK SPIM test"
> 
> config LCD_USE_SPIM_CONTROL
> 	bool "Switch gpio to spim with spin lock"
> 	depends on SPIM_RK29
> 	help
> 	  switch gpio that used for lcd to spim with spin lock.
> 
> config LCD_USE_SPI0
> 	bool "If lcd use spi0 to init lcd then select this item"
> 	depends on SPIM_RK29 && LCD_USE_SPIM_CONTROL
> 	help
> 	  choose spi bus num to use.
> 
> config LCD_USE_SPI1
> 	bool "If lcd use spi1 to init lcd then select this item"
> 	depends on SPIM_RK29 && LCD_USE_SPIM_CONTROL
> 	default y if LCD_USE_SPIM_CONTROL
> 	help
> 	  choose spi bus num to use.
> 




diff -r linux-3.0.36/drivers/spi/Makefile linux-3.0.36-lenovo/drivers/spi/Makefile
16c16
< obj-$(CONFIG_SPI_BFIN_SPORT)		+= spi_bfin_sport.o
---
> obj-$(CONFIG_SPI_BFIN_SPORT)	+= spi_bfin_sport.o
20c20,22
< obj-$(CONFIG_SPI_COLDFIRE_QSPI)		+= coldfire_qspi.o
---
> obj-$(CONFIG_SPIM_RK29)		    += rk29_spim.o
> obj-$(CONFIG_RK_SPIM_TEST)		+= spi_test.o
> obj-$(CONFIG_SPI_COLDFIRE_QSPI)	+= coldfire_qspi.o
22c24
< obj-$(CONFIG_SPI_DESIGNWARE)		+= dw_spi.o
---
> obj-$(CONFIG_SPI_DESIGNWARE)	+= dw_spi.o
Only in linux-3.0.36-lenovo/drivers/spi: rk29_spim.c
Only in linux-3.0.36-lenovo/drivers/spi: rk29_spim.h




diff -r linux-3.0.36/drivers/spi/spi.c linux-3.0.36-lenovo/drivers/spi/spi.c
1026c1026
< #define	SPI_BUFSIZ	max(32,SMP_CACHE_BYTES)
---
> #define	SPI_BUFSIZ	max(1028,SMP_CACHE_BYTES)
1085a1086
> 	memset(local_buf, 0, SPI_BUFSIZ);




diff -r linux-3.0.36/drivers/spi/spi_fsl_spi.c linux-3.0.36-lenovo/drivers/spi/spi_fsl_spi.c
142c142
< 	struct fsl_spi_platform_data *pdata = spi->dev.parent->platform_data;
---
> 	struct fsl_spi_platform_data *pdata;
145a146,147
> 	pdata = spi->dev.parent->parent->platform_data;
> 
937c939
< 	struct device *dev = spi->dev.parent;
---
> 	struct device *dev = spi->dev.parent->parent;
Only in linux-3.0.36-lenovo/drivers/spi: spi_test.c
Only in linux-3.0.36-lenovo/drivers/staging: android




diff -r linux-3.0.36/drivers/staging/comedi/comedidev.h linux-3.0.36-lenovo/drivers/staging/comedi/comedidev.h
239a240
> 	struct device *hardware_device;




diff -r linux-3.0.36/drivers/staging/comedi/comedi_fops.c linux-3.0.36-lenovo/drivers/staging/comedi/comedi_fops.c
140a141,143
> 		if (rc == 0)
> 			/* Evade comedi_auto_unconfig(). */
> 			dev_file_info->hardware_device = NULL;
846c849
< 			ret = s->async->inttrig(dev, s, insn->data[0]);
---
> 			ret = s->async->inttrig(dev, s, data[0]);
1091d1093
< 	kfree(async->cmd.chanlist);
1835a1838,1839
> 		kfree(async->cmd.chanlist);
> 		async->cmd.chanlist = NULL;
2208a2213
> 	info->hardware_device = hardware_device;
2295a2301,2317
> }
> 
> int comedi_find_board_minor(struct device *hardware_device)
> {
> 	int minor;
> 	struct comedi_device_file_info *info;
> 
> 	for (minor = 0; minor < COMEDI_NUM_BOARD_MINORS; minor++) {
> 		spin_lock(&comedi_file_info_table_lock);
> 		info = comedi_file_info_table[minor];
> 		if (info && info->hardware_device == hardware_device) {
> 			spin_unlock(&comedi_file_info_table_lock);
> 			return minor;
> 		}
> 		spin_unlock(&comedi_file_info_table_lock);
> 	}
> 	return -ENODEV;




diff -r linux-3.0.36/drivers/staging/comedi/drivers/amplc_pc236.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers/amplc_pc236.c
473c473
< 	if (devpriv)
---
> 	if (dev->iobase)




diff -r linux-3.0.36/drivers/staging/comedi/drivers/comedi_test.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers/comedi_test.c
464c464
< 	del_timer(&devpriv->timer);
---
> 	del_timer_sync(&devpriv->timer);




diff -r linux-3.0.36/drivers/staging/comedi/drivers/das08.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers/das08.c
658c658
< 	msb = (data[0] >> 8) & 0xf;
---
> 	msb = (data[0] >> 8) & 0xff;




diff -r linux-3.0.36/drivers/staging/comedi/drivers/jr3_pci.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers/jr3_pci.c
916c916
< 	devpriv->iobase->channel[0].reset = 0;
---
> 	writel(0, &devpriv->iobase->channel[0].reset);




diff -r linux-3.0.36/drivers/staging/comedi/drivers/s626.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers/s626.c
2373c2373
< 	Preload(dev, k, *(insn->data));
---
> 	Preload(dev, k, data[0]);




diff -r linux-3.0.36/drivers/staging/comedi/drivers.c linux-3.0.36-lenovo/drivers/staging/comedi/drivers.c
822d821
< 	unsigned *private_data = NULL;
824,825c823
< 	if (!comedi_autoconfig) {
< 		dev_set_drvdata(hardware_device, NULL);
---
> 	if (!comedi_autoconfig)
827d824
< 	}
833,840d829
< 	private_data = kmalloc(sizeof(unsigned), GFP_KERNEL);
< 	if (private_data == NULL) {
< 		retval = -ENOMEM;
< 		goto cleanup;
< 	}
< 	*private_data = minor;
< 	dev_set_drvdata(hardware_device, private_data);
< 
853,855c842
< cleanup:
< 	if (retval < 0) {
< 		kfree(private_data);
---
> 	if (retval < 0)
857d843
< 	}
863,867c849
< 	unsigned *minor = (unsigned *)dev_get_drvdata(hardware_device);
< 	if (minor == NULL)
< 		return;
< 
< 	BUG_ON(*minor >= COMEDI_NUM_BOARD_MINORS);
---
> 	int minor;
869,871c851,857
< 	comedi_free_board_minor(*minor);
< 	dev_set_drvdata(hardware_device, NULL);
< 	kfree(minor);
---
> 	if (hardware_device == NULL)
> 		return;
> 	minor = comedi_find_board_minor(hardware_device);
> 	if (minor < 0)
> 		return;
> 	BUG_ON(minor >= COMEDI_NUM_BOARD_MINORS);
> 	comedi_free_board_minor(minor);




diff -r linux-3.0.36/drivers/staging/comedi/internal.h linux-3.0.36-lenovo/drivers/staging/comedi/internal.h
9a10
> int comedi_find_board_minor(struct device *hardware_device);




diff -r linux-3.0.36/drivers/staging/comedi/Kconfig linux-3.0.36-lenovo/drivers/staging/comedi/Kconfig
426a427
> 	select COMEDI_FC




diff -r linux-3.0.36/drivers/staging/hv/hv_kvp.c linux-3.0.36-lenovo/drivers/staging/hv/hv_kvp.c
204,205c204,206
< 	keylen = utf8s_to_utf16s(key_name, strlen(key_name),
< 				(wchar_t *)kvp_data->data.key);
---
> 	keylen = utf8s_to_utf16s(key_name, strlen(key_name), UTF16_HOST_ENDIAN,
> 				(wchar_t *) kvp_data->data.key,
> 				HV_KVP_EXCHANGE_MAX_KEY_SIZE / 2);
207,208c208,210
< 	valuelen = utf8s_to_utf16s(value, strlen(value),
< 				(wchar_t *)kvp_data->data.value);
---
> 	valuelen = utf8s_to_utf16s(value, strlen(value), UTF16_HOST_ENDIAN,
> 				(wchar_t *) kvp_data->data.value,
> 				HV_KVP_EXCHANGE_MAX_VALUE_SIZE / 2);




diff -r linux-3.0.36/drivers/staging/Kconfig linux-3.0.36-lenovo/drivers/staging/Kconfig
72a73,74
> source "drivers/staging/android/Kconfig"
> 
103a106,108
> 
> #source "drivers/staging/rk29/vivante/Kconfig"
> source "drivers/staging/rk29/ipp/Kconfig"




diff -r linux-3.0.36/drivers/staging/lirc/lirc_sir.c linux-3.0.36-lenovo/drivers/staging/lirc/lirc_sir.c
55a56
> #include <linux/platform_device.h>
490a492
> static struct platform_device *lirc_sir_dev;
493a496
> 	driver.dev = &lirc_sir_dev->dev;
1218a1222,1239
> static int __devinit lirc_sir_probe(struct platform_device *dev)
> {
> 	return 0;
> }
> 
> static int __devexit lirc_sir_remove(struct platform_device *dev)
> {
> 	return 0;
> }
> 
> static struct platform_driver lirc_sir_driver = {
> 	.probe		= lirc_sir_probe,
> 	.remove		= __devexit_p(lirc_sir_remove),
> 	.driver		= {
> 		.name	= "lirc_sir",
> 		.owner	= THIS_MODULE,
> 	},
> };
1223a1245,1267
> 	retval = platform_driver_register(&lirc_sir_driver);
> 	if (retval) {
> 		printk(KERN_ERR LIRC_DRIVER_NAME ": Platform driver register "
> 		       "failed!\n");
> 		return -ENODEV;
> 	}
> 
> 	lirc_sir_dev = platform_device_alloc("lirc_dev", 0);
> 	if (!lirc_sir_dev) {
> 		printk(KERN_ERR LIRC_DRIVER_NAME ": Platform device alloc "
> 		       "failed!\n");
> 		retval = -ENOMEM;
> 		goto pdev_alloc_fail;
> 	}
> 
> 	retval = platform_device_add(lirc_sir_dev);
> 	if (retval) {
> 		printk(KERN_ERR LIRC_DRIVER_NAME ": Platform device add "
> 		       "failed!\n");
> 		retval = -ENODEV;
> 		goto pdev_add_fail;
> 	}
> 
1226c1270,1271
< 		return retval;
---
> 		goto fail;
> 
1230c1275
< 		return retval;
---
> 		goto fail;
1231a1277
> 
1232a1279,1286
> 
> fail:
> 	platform_device_del(lirc_sir_dev);
> pdev_add_fail:
> 	platform_device_put(lirc_sir_dev);
> pdev_alloc_fail:
> 	platform_driver_unregister(&lirc_sir_driver);
> 	return retval;
1239a1294,1295
> 	platform_device_unregister(lirc_sir_dev);
> 	platform_driver_unregister(&lirc_sir_driver);




diff -r linux-3.0.36/drivers/staging/Makefile linux-3.0.36-lenovo/drivers/staging/Makefile
31a32
> obj-$(CONFIG_ANDROID)		+= android/
44a46,47
> #obj-$(CONFIG_VIVANTE)		+= rk29/vivante/
> obj-y            		+= rk29/ipp/
Only in linux-3.0.36-lenovo/drivers/staging: rk29




diff -r linux-3.0.36/drivers/staging/rtl8712/recv_linux.c linux-3.0.36-lenovo/drivers/staging/rtl8712/recv_linux.c
116,121d115
< #ifdef NET_SKBUFF_DATA_USES_OFFSET
< 	skb->tail = (sk_buff_data_t)(precv_frame->u.hdr.rx_tail -
< 		     precv_frame->u.hdr.rx_head);
< #else
< 	skb->tail = (sk_buff_data_t)precv_frame->u.hdr.rx_tail;
< #endif
122a117
> 	skb_set_tail_pointer(skb, skb->len);




diff -r linux-3.0.36/drivers/staging/rtl8712/usb_intf.c linux-3.0.36-lenovo/drivers/staging/rtl8712/usb_intf.c
64a65,66
> 	/* ISY IWL - Belkin clone */
> 	{USB_DEVICE(0x050D, 0x11F1)},




diff -r linux-3.0.36/drivers/staging/speakup/main.c linux-3.0.36-lenovo/drivers/staging/speakup/main.c
1858c1858
< 	static u_char *goto_buf = "\0\0\0\0\0\0";
---
> 	static u_char goto_buf[8];




diff -r linux-3.0.36/drivers/staging/speakup/speakup_soft.c linux-3.0.36-lenovo/drivers/staging/speakup/speakup_soft.c
43c43
< static int initialized;
---
> static int init_pos;
197c197
< 	initialized = 0;
---
> 	init_pos = 0;
242,248c242,243
< 		} else if (!initialized) {
< 			if (*init) {
< 				ch = *init;
< 				init++;
< 			} else {
< 				initialized = 1;
< 			}
---
> 		} else if (init[init_pos]) {
> 			ch = init[init_pos++];




diff -r linux-3.0.36/drivers/staging/speakup/synth.c linux-3.0.36-lenovo/drivers/staging/speakup/synth.c
345c345
< 	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
---
> 	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)
426c426
< 	for (i = 0; synths[i] != NULL && i < MAXSYNTHS; i++)
---
> 	for (i = 0; i < MAXSYNTHS && synths[i] != NULL; i++)




diff -r linux-3.0.36/drivers/staging/usbip/usbip_common.c linux-3.0.36-lenovo/drivers/staging/usbip/usbip_common.c
764c764
< int usbip_pad_iso(struct usbip_device *ud, struct urb *urb)
---
> void usbip_pad_iso(struct usbip_device *ud, struct urb *urb)
768d767
< 	int ret;
772c771
< 		return 0;
---
> 		return;
776c775
< 		return 0;
---
> 		return;
783c782
< 		return 0;
---
> 		return;
795,796d793
< 
< 	return ret;




diff -r linux-3.0.36/drivers/staging/usbip/usbip_common.h linux-3.0.36-lenovo/drivers/staging/usbip/usbip_common.h
330c330
< int usbip_pad_iso(struct usbip_device *ud, struct urb *urb);
---
> void usbip_pad_iso(struct usbip_device *ud, struct urb *urb);




diff -r linux-3.0.36/drivers/staging/usbip/vhci_rx.c linux-3.0.36-lenovo/drivers/staging/usbip/vhci_rx.c
97,98c97
< 	if (usbip_pad_iso(ud, urb) < 0)
< 		return;
---
> 	usbip_pad_iso(ud, urb);




diff -r linux-3.0.36/drivers/staging/vt6656/bssdb.h linux-3.0.36-lenovo/drivers/staging/vt6656/bssdb.h
95d94
< #pragma pack(1)




diff -r linux-3.0.36/drivers/staging/vt6656/dpc.c linux-3.0.36-lenovo/drivers/staging/vt6656/dpc.c
203c203
< 	if ((*pwType == cpu_to_le16(ETH_P_IPX)) ||
---
> 	if ((*pwType == cpu_to_be16(ETH_P_IPX)) ||
1259c1259
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %x\n", *pdwRxTSC47_16);
1370c1370
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %lx\n",*pdwRxTSC47_16);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"ExtIV: %x\n", *pdwRxTSC47_16);




diff -r linux-3.0.36/drivers/staging/vt6656/int.h linux-3.0.36-lenovo/drivers/staging/vt6656/int.h
37d36
< #pragma pack(1)




diff -r linux-3.0.36/drivers/staging/vt6656/iocmd.h linux-3.0.36-lenovo/drivers/staging/vt6656/iocmd.h
98d97
< #pragma pack(1)
104c103
< } SCmdRequest, *PSCmdRequest;
---
> } __packed SCmdRequest, *PSCmdRequest;
114c113
< } SCmdScan, *PSCmdScan;
---
> } __packed SCmdScan, *PSCmdScan;
129c128
< } SCmdBSSJoin, *PSCmdBSSJoin;
---
> } __packed SCmdBSSJoin, *PSCmdBSSJoin;
140c139
< } SCmdZoneTypeSet, *PSCmdZoneTypeSet;
---
> } __packed SCmdZoneTypeSet, *PSCmdZoneTypeSet;
148c147
< } SWPAResult, *PSWPAResult;
---
> } __packed SWPAResult, *PSWPAResult;
160c159
< } SCmdStartAP, *PSCmdStartAP;
---
> } __packed SCmdStartAP, *PSCmdStartAP;
170c169
< } SCmdSetWEP, *PSCmdSetWEP;
---
> } __packed SCmdSetWEP, *PSCmdSetWEP;
183c182
< } SBSSIDItem;
---
> } __packed SBSSIDItem;
190c189
< } SBSSIDList, *PSBSSIDList;
---
> } __packed SBSSIDList, *PSBSSIDList;
211c210
< } SNodeItem;
---
> } __packed SNodeItem;
219c218
< } SNodeList, *PSNodeList;
---
> } __packed SNodeList, *PSNodeList;
232c231
< } SCmdLinkStatus, *PSCmdLinkStatus;
---
> } __packed SCmdLinkStatus, *PSCmdLinkStatus;
250c249
< } SDot11MIBCount, *PSDot11MIBCount;
---
> } __packed SDot11MIBCount, *PSDot11MIBCount;
358c357
< } SStatMIBCount, *PSStatMIBCount;
---
> } __packed SStatMIBCount, *PSStatMIBCount;
364c363
< } SCmdValue,  *PSCmdValue;
---
> } __packed SCmdValue,  *PSCmdValue;
434c433
< };
---
> } __packed;




diff -r linux-3.0.36/drivers/staging/vt6656/iowpa.h linux-3.0.36-lenovo/drivers/staging/vt6656/iowpa.h
70d69
< #pragma pack(1)
75c74
< } viawget_wpa_header;
---
> } __packed viawget_wpa_header;
116c115
< };
---
> } __packed;
118d116
< #pragma pack(1)
133c131
< };
---
> } __packed;




diff -r linux-3.0.36/drivers/staging/vt6656/key.c linux-3.0.36-lenovo/drivers/staging/vt6656/key.c
226c226
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,
238c238,239
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Enter KeybSetKey: %lX\n", dwKeyIndex);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
> 		"Enter KeybSetKey: %X\n", dwKeyIndex);
264c265,267
<                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Group transmit key(R)[%lX]: %d\n", pTable->KeyTable[i].dwGTKeyIndex, i);
---
> 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
> 				"Group transmit key(R)[%X]: %d\n",
> 					pTable->KeyTable[i].dwGTKeyIndex, i);
305,307c308,313
<             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %lx\n ", pKey->dwTSC47_16);
<             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->wTSC15_0: %x\n ", pKey->wTSC15_0);
<             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %lx\n ", pKey->dwKeyIndex);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %x\n ",
> 			pKey->dwTSC47_16);
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->wTSC15_0: %x\n ",
> 			pKey->wTSC15_0);
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %x\n ",
> 			pKey->dwKeyIndex);
329c335,337
<                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Group transmit key(N)[%lX]: %d\n", pTable->KeyTable[j].dwGTKeyIndex, j);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
> 			"Group transmit key(N)[%X]: %d\n",
> 				pTable->KeyTable[j].dwGTKeyIndex, j);
370c378,379
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %lx\n ", pKey->dwTSC47_16);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %x\n ",
> 		pKey->dwTSC47_16);
372c381,382
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %lx\n ", pKey->dwKeyIndex);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %x\n ",
> 		pKey->dwKeyIndex);
600c610,611
<                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwGTKeyIndex: %lX\n", pTable->KeyTable[i].dwGTKeyIndex);
---
> 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"dwGTKeyIndex: %X\n",
> 				pTable->KeyTable[i].dwGTKeyIndex);
667c678
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,
696c707,710
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Group transmit key(R)[%lX]: %d\n", pTable->KeyTable[MAX_KEY_TABLE-1].dwGTKeyIndex, MAX_KEY_TABLE-1);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
> 		"Group transmit key(R)[%X]: %d\n",
> 		pTable->KeyTable[MAX_KEY_TABLE-1].dwGTKeyIndex,
> 		MAX_KEY_TABLE-1);
747c761,762
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %lx\n", pKey->dwTSC47_16);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwTSC47_16: %x\n",
> 		pKey->dwTSC47_16);
749c764,765
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %lx\n", pKey->dwKeyIndex);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"pKey->dwKeyIndex: %x\n",
> 		pKey->dwKeyIndex);
775c791
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,
787c803,804
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Enter KeybSetAllGroupKey: %lX\n", dwKeyIndex);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Enter KeybSetAllGroupKey: %X\n",
> 		dwKeyIndex);
804c821,823
<                 DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Group transmit key(R)[%lX]: %d\n", pTable->KeyTable[i].dwGTKeyIndex, i);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO
> 			"Group transmit key(R)[%X]: %d\n",
> 			pTable->KeyTable[i].dwGTKeyIndex, i);




diff -r linux-3.0.36/drivers/staging/vt6656/key.h linux-3.0.36-lenovo/drivers/staging/vt6656/key.h
61c61
<     unsigned long       uKeyLength;
---
> 	u32 uKeyLength;
110c110
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,
149c149
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,
159c159
<     unsigned long           uKeyLength,
---
> 	u32 uKeyLength,




diff -r linux-3.0.36/drivers/staging/vt6656/mac.c linux-3.0.36-lenovo/drivers/staging/vt6656/mac.c
265c265,266
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %lX, KeyCtl:%X\n", wOffset, dwData1, wKeyCtl);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"1. wOffset: %d, Data: %X,"\
> 		" KeyCtl:%X\n", wOffset, dwData1, wKeyCtl);
282c283,284
<     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %lX\n", wOffset, dwData2);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"2. wOffset: %d, Data: %X\n",
> 		wOffset, dwData2);




diff -r linux-3.0.36/drivers/staging/vt6656/main_usb.c linux-3.0.36-lenovo/drivers/staging/vt6656/main_usb.c
225c225
< static struct usb_device_id vt6656_table[] __devinitdata = {
---
> static struct usb_device_id vt6656_table[] = {




diff -r linux-3.0.36/drivers/staging/vt6656/rf.c linux-3.0.36-lenovo/drivers/staging/vt6656/rf.c
771a772,774
> 	if (uCH == 0)
> 		return -EINVAL;
> 




diff -r linux-3.0.36/drivers/staging/vt6656/rxtx.c linux-3.0.36-lenovo/drivers/staging/vt6656/rxtx.c
380c380,381
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"vFillTxKey()---- pdwExtIV: %lx\n", *pdwExtIV);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"vFillTxKey()---- pdwExtIV: %x\n",
> 		*pdwExtIV);
1704c1705
< 		if ((psEthHeader->wType == cpu_to_le16(ETH_P_IPX)) ||
---
> 		if ((psEthHeader->wType == cpu_to_be16(ETH_P_IPX)) ||
1756c1757,1758
<         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC KEY: %lX, %lX\n", dwMICKey0, dwMICKey1);
---
> 	DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC KEY: %X, %X\n",
> 		dwMICKey0, dwMICKey1);
2638c2640,2641
<             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"DMA0_tx_8021:MIC KEY: %lX, %lX\n", dwMICKey0, dwMICKey1);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"DMA0_tx_8021:MIC KEY:"\
> 			" %X, %X\n", dwMICKey0, dwMICKey1);
2658c2661,2662
<             DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC:%lx, %lx\n", *pdwMIC_L, *pdwMIC_R);
---
> 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"MIC:%x, %x\n",
> 			*pdwMIC_L, *pdwMIC_R);
2843,2846c2847,2850
<     if (pDevice->sTxEthHeader.wType == cpu_to_le16(ETH_P_PAE)) {
< 	/* 802.1x OR eapol-key challenge frame transfer */
< 	if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
< 		(Packet_Type == 3)) {
---
> 	if (pDevice->sTxEthHeader.wType == cpu_to_be16(ETH_P_PAE)) {
> 		/* 802.1x OR eapol-key challenge frame transfer */
> 		if (((Protocol_Version == 1) || (Protocol_Version == 2)) &&
> 			(Packet_Type == 3)) {
2992,3004c2996,3008
<     if (pDevice->sTxEthHeader.wType == cpu_to_le16(ETH_P_PAE)) {
<         if (pDevice->byBBType != BB_TYPE_11A) {
<             pDevice->wCurrentRate = RATE_1M;
<             pDevice->byACKRate = RATE_1M;
<             pDevice->byTopCCKBasicRate = RATE_1M;
<             pDevice->byTopOFDMBasicRate = RATE_6M;
<         } else {
<             pDevice->wCurrentRate = RATE_6M;
<             pDevice->byACKRate = RATE_6M;
<             pDevice->byTopCCKBasicRate = RATE_1M;
<             pDevice->byTopOFDMBasicRate = RATE_6M;
<         }
<     }
---
> 	if (pDevice->sTxEthHeader.wType == cpu_to_be16(ETH_P_PAE)) {
> 		if (pDevice->byBBType != BB_TYPE_11A) {
> 			pDevice->wCurrentRate = RATE_1M;
> 			pDevice->byACKRate = RATE_1M;
> 			pDevice->byTopCCKBasicRate = RATE_1M;
> 			pDevice->byTopOFDMBasicRate = RATE_6M;
> 		} else {
> 			pDevice->wCurrentRate = RATE_6M;
> 			pDevice->byACKRate = RATE_6M;
> 			pDevice->byTopCCKBasicRate = RATE_1M;
> 			pDevice->byTopOFDMBasicRate = RATE_6M;
> 		}
> 	}
3020c3024
< 	if ((pDevice->sTxEthHeader.wType) == cpu_to_le16(ETH_P_PAE)) {
---
> 	if ((pDevice->sTxEthHeader.wType) == cpu_to_be16(ETH_P_PAE)) {
3032c3036,3037
<                         DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
---
> 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%X]\n",
> 				pTransmitKey->dwKeyIndex);
3046c3051,3052
<                     DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%lX]\n", pTransmitKey->dwKeyIndex);
---
> 			DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO"Find PTK [%X]\n",
> 				pTransmitKey->dwKeyIndex);




diff -r linux-3.0.36/drivers/staging/vt6656/ttype.h linux-3.0.36-lenovo/drivers/staging/vt6656/ttype.h
31a32,33
> #include <linux/types.h>
> 
45,47c47,49
< typedef unsigned char   BYTE;           //  8-bit
< typedef unsigned short  WORD;           // 16-bit
< typedef unsigned long   DWORD;          // 32-bit
---
> typedef u8 BYTE;
> typedef u16 WORD;
> typedef u32 DWORD;
54,55c56,57
<         DWORD   dwLowDword;
<         DWORD   dwHighDword;
---
> 	u32 dwLowDword;
> 	u32 dwHighDword;
63,64c65,66
< typedef unsigned long   ULONG_PTR;      // 32-bit
< typedef unsigned long   DWORD_PTR;      // 32-bit
---
> typedef u32 ULONG_PTR;
> typedef u32 DWORD_PTR;




diff -r linux-3.0.36/drivers/staging/vt6656/wcmd.c linux-3.0.36-lenovo/drivers/staging/vt6656/wcmd.c
319c319
< void vCommandTimerWait(void *hDeviceContext, unsigned int MSecond)
---
> void vCommandTimerWait(void *hDeviceContext, unsigned long MSecond)
321c321
<     PSDevice        pDevice = (PSDevice)hDeviceContext;
---
> 	PSDevice pDevice = (PSDevice)hDeviceContext;
323,329c323,331
<     init_timer(&pDevice->sTimerCommand);
<     pDevice->sTimerCommand.data = (unsigned long)pDevice;
<     pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
<     // RUN_AT :1 msec ~= (HZ/1024)
<     pDevice->sTimerCommand.expires = (unsigned int)RUN_AT((MSecond * HZ) >> 10);
<     add_timer(&pDevice->sTimerCommand);
<     return;
---
> 	init_timer(&pDevice->sTimerCommand);
> 
> 	pDevice->sTimerCommand.data = (unsigned long)pDevice;
> 	pDevice->sTimerCommand.function = (TimerFunction)vRunCommand;
> 	pDevice->sTimerCommand.expires = RUN_AT((MSecond * HZ) / 1000);
> 
> 	add_timer(&pDevice->sTimerCommand);
> 
> 	return;




diff -r linux-3.0.36/drivers/staging/vt6656/wpa2.h linux-3.0.36-lenovo/drivers/staging/vt6656/wpa2.h
48,49c48,49
<     unsigned long       BSSIDInfoCount;
<     PMKIDInfo   BSSIDInfo[MAX_PMKID_CACHE];
---
> 	u32 BSSIDInfoCount;
> 	PMKIDInfo BSSIDInfo[MAX_PMKID_CACHE];




diff -r linux-3.0.36/drivers/staging/winbond/wbusb.c linux-3.0.36-lenovo/drivers/staging/winbond/wbusb.c
27c27
< static const struct usb_device_id wb35_table[] __devinitconst = {
---
> static const struct usb_device_id wb35_table[] = {
Only in linux-3.0.36-lenovo/drivers: switch




diff -r linux-3.0.36/drivers/target/target_core_configfs.c linux-3.0.36-lenovo/drivers/target/target_core_configfs.c
3237c3237,3238
< 	if (core_dev_setup_virtual_lun0() < 0)
---
> 	ret = core_dev_setup_virtual_lun0();
> 	if (ret < 0)




diff -r linux-3.0.36/drivers/target/target_core_transport.c linux-3.0.36-lenovo/drivers/target/target_core_transport.c
3675c3675,3680
< 
---
> 		/*
> 		 * For the overflow case keep the existing fabric provided
> 		 * ->data_length.  Otherwise for the underflow case, reset
> 		 * ->data_length to the smaller SCSI expected data transfer
> 		 * length.
> 		 */
3681a3687
> 			cmd->data_length = size;
3683d3688
< 		cmd->data_length = size;




diff -r linux-3.0.36/drivers/target/tcm_fc/tfc_sess.c linux-3.0.36-lenovo/drivers/target/tcm_fc/tfc_sess.c
67c67,68
< 	tport = rcu_dereference(lport->prov[FC_TYPE_FCP]);
---
> 	tport = rcu_dereference_protected(lport->prov[FC_TYPE_FCP],
> 					  lockdep_is_held(&ft_lport_lock));
395c396
< 		return 0;	/* not a target for this local port */
---
> 		goto not_target;	/* not a target for this local port */
399c400
< 		return 0;
---
> 		goto not_target;	/* no target for this remote */
436d436
< 	 * TBD XXX - indicate RETRY capability?
439a440
> 	fcp_parm &= ~FCP_SPPF_RETRY;
441a443,448
> 
> not_target:
> 	fcp_parm = ntohl(spp->spp_params);
> 	fcp_parm &= ~FCP_SPPF_TARG_FCN;
> 	spp->spp_params = htonl(fcp_parm);
> 	return 0;
470d476
< 	transport_deregister_session(sess->se_sess);
477a484
> 	transport_deregister_session(sess->se_sess);




diff -r linux-3.0.36/drivers/telephony/ixj.c linux-3.0.36-lenovo/drivers/telephony/ixj.c
3193,3198c3193,3198
< 	strcpy(sdmf1, j->cid_send.month);
< 	strcat(sdmf1, j->cid_send.day);
< 	strcat(sdmf1, j->cid_send.hour);
< 	strcat(sdmf1, j->cid_send.min);
< 	strcpy(sdmf2, j->cid_send.number);
< 	strcpy(sdmf3, j->cid_send.name);
---
> 	strlcpy(sdmf1, j->cid_send.month, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.day, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.hour, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.min, sizeof(sdmf1));
> 	strlcpy(sdmf2, j->cid_send.number, sizeof(sdmf2));
> 	strlcpy(sdmf3, j->cid_send.name, sizeof(sdmf3));
3343,3348c3343,3348
< 	strcpy(sdmf1, j->cid_send.month);
< 	strcat(sdmf1, j->cid_send.day);
< 	strcat(sdmf1, j->cid_send.hour);
< 	strcat(sdmf1, j->cid_send.min);
< 	strcpy(sdmf2, j->cid_send.number);
< 	strcpy(sdmf3, j->cid_send.name);
---
> 	strlcpy(sdmf1, j->cid_send.month, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.day, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.hour, sizeof(sdmf1));
> 	strlcat(sdmf1, j->cid_send.min, sizeof(sdmf1));
> 	strlcpy(sdmf2, j->cid_send.number, sizeof(sdmf2));
> 	strlcpy(sdmf3, j->cid_send.name, sizeof(sdmf3));
Only in linux-3.0.36-lenovo/drivers: testcode




diff -r linux-3.0.36/drivers/tty/n_gsm.c linux-3.0.36-lenovo/drivers/tty/n_gsm.c
845c845
< 		dlci->skb = skb_dequeue(&dlci->skb_list);
---
> 		dlci->skb = skb_dequeue_tail(&dlci->skb_list);
869c869,871
< 	if (msg == NULL)
---
> 	if (msg == NULL) {
> 		skb_queue_tail(&dlci->skb_list, dlci->skb);
> 		dlci->skb = NULL;
870a873
> 	}
1154a1158,1159
> 	unsigned long flags;
> 
1179a1185
> 		spin_lock_irqsave(&gsm->tx_lock, flags);
1180a1187
> 		spin_unlock_irqrestore(&gsm->tx_lock, flags);
2271a2279
> 	spin_lock_irqsave(&gsm->tx_lock, flags);
2274d2281
< 		spin_lock_irqsave(&gsm->tx_lock, flags);
2276d2282
< 		spin_unlock_irqrestore(&gsm->tx_lock, flags);
2277a2284
> 	spin_unlock_irqrestore(&gsm->tx_lock, flags);




diff -r linux-3.0.36/drivers/tty/n_tty.c linux-3.0.36-lenovo/drivers/tty/n_tty.c
1731c1731,1732
< 	BUG_ON(!tty->read_buf);
---
> 	if (WARN_ON(!tty->read_buf))
> 		return -EAGAIN;




diff -r linux-3.0.36/drivers/tty/serial/8250.c linux-3.0.36-lenovo/drivers/tty/serial/8250.c
84c84
< #define PASS_LIMIT	256
---
> #define PASS_LIMIT	512




diff -r linux-3.0.36/drivers/tty/serial/8250_pci.c linux-3.0.36-lenovo/drivers/tty/serial/8250_pci.c
1013a1014,1015
> #define PCI_SUBDEVICE_ID_SIIG_DUAL_00	0x2500
> #define PCI_SUBDEVICE_ID_SIIG_DUAL_30	0x2530
3012,3013c3014,3018
< 		PCI_SUBVENDOR_ID_SIIG, PCI_SUBDEVICE_ID_SIIG_DUAL_SERIAL, 0, 0,
< 		pbn_b0_2_115200 },
---
> 		PCI_SUBVENDOR_ID_SIIG, PCI_SUBDEVICE_ID_SIIG_DUAL_00,
> 		0, 0, pbn_b0_2_115200 },
> 	{	PCI_VENDOR_ID_OXSEMI, 0x950a,
> 		PCI_SUBVENDOR_ID_SIIG, PCI_SUBDEVICE_ID_SIIG_DUAL_30,
> 		0, 0, pbn_b0_2_115200 },




diff -r linux-3.0.36/drivers/tty/serial/amba-pl011.c linux-3.0.36-lenovo/drivers/tty/serial/amba-pl011.c
1622a1623,1634
> 	/*
> 	 * Workaround for the ST Micro oversampling variants to
> 	 * increase the bitrate slightly, by lowering the divisor,
> 	 * to avoid delayed sampling of start bit at high speeds,
> 	 * else we see data corruption.
> 	 */
> 	if (uap->vendor->oversampling) {
> 		if ((baud >= 3000000) && (baud < 3250000) && (quot > 1))
> 			quot -= 1;
> 		else if ((baud > 3250000) && (quot > 2))
> 			quot -= 2;
> 	}
1629c1641,1642
< 	 * NOTE: MUST BE WRITTEN AFTER UARTLCR_M & UARTLCR_L
---
> 	 * NOTE: lcrh_tx and lcrh_rx MUST BE WRITTEN AFTER
> 	 * UART011_FBRD & UART011_IBRD.




diff -r linux-3.0.36/drivers/tty/serial/ifx6x60.c linux-3.0.36-lenovo/drivers/tty/serial/ifx6x60.c
553a554
> 	del_timer(&ifx_dev->spi_timer);




diff -r linux-3.0.36/drivers/tty/serial/Kconfig linux-3.0.36-lenovo/drivers/tty/serial/Kconfig
1514a1515,1595
> config SERIAL_RK29
> 	bool "RockChip RK29/RK30 serial port support"
> 	depends on PLAT_RK
> 	select SERIAL_CORE
> 
> config UART0_RK29
> 	bool "Serial port 0 support"
> 	depends on SERIAL_RK29
> 
> config UART0_CTS_RTS_RK29
> 	bool "Serial port 0 CTS/RTS support"
> 	depends on UART0_RK29
> 
> config UART0_DMA_RK29
> 	int "Serial port 0 DMA support (EXPERIMENTAL)"
> 	depends on UART0_RK29
> 	default 0
> 	help 
> 		 1:enable dma tx
> 		 2:enable dma rx
> 		 3:both enable dma tx and rx 
> config UART1_RK29
> 	bool "Serial port 1 support"
> 	depends on SERIAL_RK29
> 
> config UART1_CTS_RTS_RK29
> 	bool "Serial port 1 CTS/RTS support"
> 	depends on UART1_RK29 && !ARCH_RK29
> 
> config UART1_DMA_RK29
> 	int "Serial port 1 DMA support (EXPERIMENTAL)"
> 	depends on UART1_RK29
> 	default 0
> 	help 
> 		 1:enable dma tx
> 	 	 2:enable dma rx
> 	 	 3:both enable dma tx and rx 
> config UART2_RK29
> 	bool "Serial port 2 support"
> 	depends on SERIAL_RK29
> 
> config UART2_CTS_RTS_RK29
> 	bool "Serial port 2 CTS/RTS support"
> 	depends on UART2_RK29 && !ARCH_RK30 && !ARCH_RK3188
> 
> config UART2_DMA_RK29
> 	int "Serial port 2 DMA support (EXPERIMENTAL)"
> 	depends on UART2_RK29
> 	default 0
> 	help 
> 		 1:enable dma tx
> 	 	 2:enable dma rx
> 	 	 3:both enable dma tx and rx 
> config UART3_RK29
> 	bool "Serial port 3 support"
> 	depends on SERIAL_RK29 && !ARCH_RK2928
> 
> config UART3_CTS_RTS_RK29
> 	bool "Serial port 3 CTS/RTS support"
> 	depends on UART3_RK29
> 
> config UART3_DMA_RK29
> 	int "Serial port 3 DMA support (EXPERIMENTAL)"
> 	depends on UART3_RK29
> 	default 0
> 	help 
> 		 1:enable dma tx
> 	 	 2:enable dma rx
> 	 	 3:both enable dma tx and rx 
> config SERIAL_RK29_CONSOLE
> 	bool "Serial console support"
> 	depends on SERIAL_RK29=y
> 	select SERIAL_CORE_CONSOLE
> 
> config SERIAL_SC8800
> 	tristate "SC8800 support"
> 	depends on SPI
> 	select SERIAL_CORE
> 	help
> 	  SC8800 spi-serial support
> 




diff -r linux-3.0.36/drivers/tty/serial/Makefile linux-3.0.36-lenovo/drivers/tty/serial/Makefile
85a86,87
> obj-$(CONFIG_SERIAL_RK29) += rk_serial.o
> obj-$(CONFIG_SERIAL_SC8800) += sc8800.o




diff -r linux-3.0.36/drivers/tty/serial/pch_uart.c linux-3.0.36-lenovo/drivers/tty/serial/pch_uart.c
661c661,662
< 	pch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT);
---
> 	pch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |
> 					    PCH_UART_HAL_RX_ERR_INT);
716c717,718
< 		pch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT);
---
> 		pch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |
> 						     PCH_UART_HAL_RX_ERR_INT);
978c980,981
< 							PCH_UART_HAL_RX_INT);
---
> 						PCH_UART_HAL_RX_INT |
> 						PCH_UART_HAL_RX_ERR_INT);
982c985,986
< 							PCH_UART_HAL_RX_INT);
---
> 						PCH_UART_HAL_RX_INT |
> 						PCH_UART_HAL_RX_ERR_INT);
1108c1112,1113
< 	pch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT);
---
> 	pch_uart_hal_disable_interrupt(priv, PCH_UART_HAL_RX_INT |
> 					     PCH_UART_HAL_RX_ERR_INT);
1163a1169
> 		break;
1201c1207,1208
< 	pch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT);
---
> 	pch_uart_hal_enable_interrupt(priv, PCH_UART_HAL_RX_INT |
> 					    PCH_UART_HAL_RX_ERR_INT);
1259c1266
< 		if (!(termios->c_cflag & PARODD))
---
> 		if (termios->c_cflag & PARODD)
Only in linux-3.0.36-lenovo/drivers/tty/serial: rk2818_serial.h
Only in linux-3.0.36-lenovo/drivers/tty/serial: rk_serial.c
Only in linux-3.0.36-lenovo/drivers/tty/serial: sc8800.c
Only in linux-3.0.36-lenovo/drivers/tty/serial: sc8800.h




diff -r linux-3.0.36/drivers/tty/serial/serial_core.c linux-3.0.36-lenovo/drivers/tty/serial/serial_core.c
93a94,96
> 	if (port->ops->wake_peer)
> 		port->ops->wake_peer(port);
> 
2394,2396c2397,2398
< 		device_init_wakeup(tty_dev, 1);
< 		device_set_wakeup_enable(tty_dev, 0);
< 	} else
---
> 		device_set_wakeup_capable(tty_dev, 1);
> 	} else {
2398a2401
> 	}




diff -r linux-3.0.36/drivers/usb/class/cdc-acm.c linux-3.0.36-lenovo/drivers/usb/class/cdc-acm.c
763,766d762
< static const __u8 acm_tty_size[] = {
< 	5, 6, 7, 8
< };
< 
783c779,793
< 	newline.bDataBits = acm_tty_size[(termios->c_cflag & CSIZE) >> 4];
---
> 	switch (termios->c_cflag & CSIZE) {
> 	case CS5:
> 		newline.bDataBits = 5;
> 		break;
> 	case CS6:
> 		newline.bDataBits = 6;
> 		break;
> 	case CS7:
> 		newline.bDataBits = 7;
> 		break;
> 	case CS8:
> 	default:
> 		newline.bDataBits = 8;
> 		break;
> 	}
1046c1056,1057
< 	if (data_interface->cur_altsetting->desc.bNumEndpoints < 2)
---
> 	if (data_interface->cur_altsetting->desc.bNumEndpoints < 2 ||
> 	    control_interface->cur_altsetting->desc.bNumEndpoints == 0)
1174c1185
< 				usb_sndbulkpipe(usb_dev, epwrite->bEndpointAddress),
---
> 				usb_sndintpipe(usb_dev, epwrite->bEndpointAddress),
1496a1508,1513
> 	},
> 	{ USB_DEVICE(0x0572, 0x1340), /* Conexant CX93010-2x UCMxx */
> 	.driver_info = NO_UNION_NORMAL,
> 	},
> 	{ USB_DEVICE(0x05f9, 0x4002), /* PSC Scanning, Magellan 800i */
> 	.driver_info = NO_UNION_NORMAL,




diff -r linux-3.0.36/drivers/usb/class/cdc-wdm.c linux-3.0.36-lenovo/drivers/usb/class/cdc-wdm.c
459a460,461
> 			dev_dbg(&desc->intf->dev, "%s: zero length - clearing WDM_READ\n", __func__);
> 			clear_bit(WDM_READ, &desc->flags);




diff -r linux-3.0.36/drivers/usb/core/config.c linux-3.0.36-lenovo/drivers/usb/core/config.c
707c707
< 			break;
---
> 			goto err;




diff -r linux-3.0.36/drivers/usb/core/devices.c linux-3.0.36-lenovo/drivers/usb/core/devices.c
627c627
< 		if (!bus->root_hub)
---
> 		if (!bus_to_hcd(bus)->rh_registered)




diff -r linux-3.0.36/drivers/usb/core/devio.c linux-3.0.36-lenovo/drivers/usb/core/devio.c
1560,1562c1560,1565
< 	if (as->userbuffer && urb->actual_length)
< 		if (copy_to_user(as->userbuffer, urb->transfer_buffer,
< 				 urb->actual_length))
---
> 	if (as->userbuffer && urb->actual_length) {
> 		if (urb->number_of_packets > 0)		/* Isochronous */
> 			i = urb->transfer_buffer_length;
> 		else					/* Non-Isoc */
> 			i = urb->actual_length;
> 		if (copy_to_user(as->userbuffer, urb->transfer_buffer, i))
1563a1567
> 	}




diff -r linux-3.0.36/drivers/usb/core/hcd.c linux-3.0.36-lenovo/drivers/usb/core/hcd.c
980,983c980
< 	}
< 	mutex_unlock(&usb_bus_list_lock);
< 
< 	if (retval == 0) {
---
> 	} else {
991a989
> 	mutex_unlock(&usb_bus_list_lock);
1585c1583,1587
< 	urb->complete (urb);
---
> 	if(!atomic_read(&urb->use_count))
> 	{
> 	    printk("%s %d\n", __func__, atomic_read(&urb->use_count));
> 	    return;
> 	}
1586a1589
> 	urb->complete (urb);
1959a1963
> 		printk("%s,error,everest\n",__func__);




diff -r linux-3.0.36/drivers/usb/core/hub.c linux-3.0.36-lenovo/drivers/usb/core/hub.c
26a27
> #include <linux/random.h>
39a41,42
> extern struct delayed_work hsic_reset_work;
> extern struct mutex hsic_mutex;
484c487
< 	while (--limit && !list_empty (&hub->tt.clear_list)) {
---
> 	while (!list_empty(&hub->tt.clear_list)) {
490a494,496
> 		if (!hub->quiescing && --limit < 0)
> 			break;
> 
628c634
< 	if (ret)
---
> 	if (ret){
630a637,643
> 		/* modify by wlf for lenovo A10 hsic hub[usb4604]@20130720*/
> 		if( mutex_trylock(&hsic_mutex)){
> 			schedule_delayed_work(&hsic_reset_work, 1);
> 		}else{
> 			printk("fail to get hsic_mutex!!!!!\n");
> 		}
> 	}
954c967
< 		cancel_work_sync(&hub->tt.clear_work);
---
> 		flush_work_sync(&hub->tt.clear_work);
1285c1298
< 
---
> struct usb_hub *g_root_hub20 = NULL;
1345c1358,1361
< 
---
> 	if(!g_root_hub20)
> 	{
> 		g_root_hub20 = hub;
> 	}
1905c1921,1933
< 	device_enable_async_suspend(&udev->dev);
---
> 	if (udev->serial)
> 		add_device_randomness(udev->serial, strlen(udev->serial));
> 	if (udev->product)
> 		add_device_randomness(udev->product, strlen(udev->product));
> 	if (udev->manufacturer)
> 		add_device_randomness(udev->manufacturer,
> 				      strlen(udev->manufacturer));
> 
> 	/* kever@rk 20111205
> 	 * We don't use async suspend in rk29 usb
> 	 * to make sure usb1.1 host is suspend before usb 2.0 host.
> 	 */
> 	//device_enable_async_suspend(&udev->dev);
2032c2060
< #define PORT_RESET_TRIES	5
---
> #define PORT_RESET_TRIES	2//5
2041c2069
< #define HUB_RESET_TIMEOUT	500
---
> #define HUB_RESET_TIMEOUT	800
2160a2189,2194
> 	/* modify by wlf for lenovo A10 hsic hub[usb4604]@20130720*/
> 	if( mutex_trylock(&hsic_mutex)){
> 		schedule_delayed_work(&hsic_reset_work, 1);
> 	}else{
> 		printk("fail to get hsic_mutex!!!!!\n");
> 	}
2341a2376,2386
> 	/* Ignore Lenovo EasyCamera, Manufacturer: Alcor Micro, Corp.*/
> 	if(udev->descriptor.idVendor == 0x058f && udev->descriptor.idProduct == 0x5608){
> 		return 0;
> 	}
> 	
> 	/* Ignore Lenovo EasyCamera, Manufacturer:	Manufacturer: Azurewave*/
> 	if(udev->descriptor.idVendor == 0x13d3 && udev->descriptor.idProduct == 0x5739){
> 		return 0;
> 	}
> 		
> 
2404c2449
< 	u16	devstatus;
---
> 	u16	devstatus = 0;
2449c2494,2500
< 	} else if (udev->actconfig) {
---
> 	/*
> 	 * There are a few quirky devices which violate the standard
> 	 * by claiming to have remote wakeup enabled after a reset,
> 	 * which crash if the feature is cleared, hence check for
> 	 * udev->reset_resume
> 	 */
> 	} else if (udev->actconfig && !udev->reset_resume) {
2509a2561,2570
> 	/* Ignore Lenovo EasyCamera, Manufacturer: Alcor Micro, Corp.*/
> 	if(udev->descriptor.idVendor == 0x058f && udev->descriptor.idProduct == 0x5608){
> 		return 0;
> 	}
> 
> 	/* Ignore Lenovo EasyCamera, Manufacturer:  Manufacturer: Azurewave*/
> 	if(udev->descriptor.idVendor == 0x13d3 && udev->descriptor.idProduct == 0x5739){
> 		return 0;
> 	}
> 
2894a2956,2960
> 			
> 	/* yk@rk 20110617
> 	 * parent hub has no TT would not be error in rk29
> 	 */
> 		#if 0
2899a2966
> 		#endif
3630a3698,3705
> }
> 
> /* yk@rk 20100730 
>  * disconnect all devices on root hub
>  */
> void hub_disconnect_device(struct usb_hub *hub)
> {
>     	hub_port_connect_change(hub, 1, 0, 0x2);




diff -r linux-3.0.36/drivers/usb/core/message.c linux-3.0.36-lenovo/drivers/usb/core/message.c
1773,1794c1773,1774
< 	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
< 			      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
< 			      NULL, 0, USB_CTRL_SET_TIMEOUT);
< 	if (ret < 0) {
< 		/* All the old state is gone, so what else can we do?
< 		 * The device is probably useless now anyway.
< 		 */
< 		cp = NULL;
< 	}
< 
< 	dev->actconfig = cp;
< 	if (!cp) {
< 		usb_set_device_state(dev, USB_STATE_ADDRESS);
< 		usb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);
< 		mutex_unlock(hcd->bandwidth_mutex);
< 		usb_autosuspend_device(dev);
< 		goto free_interfaces;
< 	}
< 	mutex_unlock(hcd->bandwidth_mutex);
< 	usb_set_device_state(dev, USB_STATE_CONFIGURED);
< 
< 	/* Initialize the new interface structures and the
---
> 	/*
> 	 * Initialize the new interface structures and the
1836a1817,1845
> 
> 	ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0),
> 			      USB_REQ_SET_CONFIGURATION, 0, configuration, 0,
> 			      NULL, 0, USB_CTRL_SET_TIMEOUT);
> 	if (ret < 0 && cp) {
> 		/*
> 		 * All the old state is gone, so what else can we do?
> 		 * The device is probably useless now anyway.
> 		 */
> 		usb_hcd_alloc_bandwidth(dev, NULL, NULL, NULL);
> 		for (i = 0; i < nintf; ++i) {
> 			usb_disable_interface(dev, cp->interface[i], true);
> 			put_device(&cp->interface[i]->dev);
> 			cp->interface[i] = NULL;
> 		}
> 		cp = NULL;
> 	}
> 
> 	dev->actconfig = cp;
> 	mutex_unlock(hcd->bandwidth_mutex);
> 
> 	if (!cp) {
> 		usb_set_device_state(dev, USB_STATE_ADDRESS);
> 
> 		/* Leave LPM disabled while the device is unconfigured. */
> 		usb_autosuspend_device(dev);
> 		return ret;
> 	}
> 	usb_set_device_state(dev, USB_STATE_CONFIGURED);




diff -r linux-3.0.36/drivers/usb/core/quirks.c linux-3.0.36-lenovo/drivers/usb/core/quirks.c
98a99,102
> 	/* Microchip Joss Optical infrared touchboard device */
> 	{ USB_DEVICE(0x04d8, 0x000c), .driver_info =
> 			USB_QUIRK_CONFIG_INTF_STRINGS },
> 
Only in linux-3.0.36-lenovo/drivers/usb: dwc_otg




diff -r linux-3.0.36/drivers/usb/early/ehci-dbgp.c linux-3.0.36-lenovo/drivers/usb/early/ehci-dbgp.c
453c453
< 	loop = 10;
---
> 	loop = 1000;
Only in linux-3.0.36-lenovo/drivers/usb/gadget: android.c




diff -r linux-3.0.36/drivers/usb/gadget/composite.c linux-3.0.36-lenovo/drivers/usb/gadget/composite.c
75c75
< 
---
> static int gadget_connected = 0;
422a423,425
> 	
> 	/* reset delay status to zero every time usb reconnect */
> 	cdev->delayed_status = 0;
476a480,482
> 
> 	/* usb gadget connect flag */
> 	gadget_connected = 1;
478a485
> 
515a523
> 			printk("usb_add_config, already configed,everest\n");
525a534
> 	memset(config->interface, '\0', sizeof(config->interface));
564a574,613
> static int unbind_config(struct usb_composite_dev *cdev,
> 			      struct usb_configuration *config)
> {
> 	while (!list_empty(&config->functions)) {
> 		struct usb_function		*f;
> 
> 		f = list_first_entry(&config->functions,
> 				struct usb_function, list);
> 		list_del(&f->list);
> 		if (f->unbind) {
> 			DBG(cdev, "unbind function '%s'/%p\n", f->name, f);
> 			f->unbind(config, f);
> 			/* may free memory for "f" */
> 		}
> 	}
> 	if (config->unbind) {
> 		DBG(cdev, "unbind config '%s'/%p\n", config->label, config);
> 		config->unbind(config);
> 			/* may free memory for "c" */
> 	}
> 	return 0;
> }
> 
> int usb_remove_config(struct usb_composite_dev *cdev,
> 		      struct usb_configuration *config)
> {
> 	unsigned long flags;
> 
> 	spin_lock_irqsave(&cdev->lock, flags);
> 
> 	if (cdev->config == config)
> 		reset_config(cdev);
> 
> 	list_del(&config->list);
> 
> 	spin_unlock_irqrestore(&cdev->lock, flags);
> 
> 	return unbind_config(cdev, config);
> }
> 
1012a1062,1063
> 	/* usb gadget connect flag */
> 	gadget_connected = 0;
1016a1068,1072
> int get_gadget_connect_flag( void )
> {
>     return gadget_connected;
> }
> EXPORT_SYMBOL(get_gadget_connect_flag);
1044d1099
< 
1047,1059d1101
< 		while (!list_empty(&c->functions)) {
< 			struct usb_function		*f;
< 
< 			f = list_first_entry(&c->functions,
< 					struct usb_function, list);
< 			list_del(&f->list);
< 			if (f->unbind) {
< 				DBG(cdev, "unbind function '%s'/%p\n",
< 						f->name, f);
< 				f->unbind(c, f);
< 				/* may free memory for "f" */
< 			}
< 		}
1061,1065c1103
< 		if (c->unbind) {
< 			DBG(cdev, "unbind config '%s'/%p\n", c->label, c);
< 			c->unbind(c);
< 			/* may free memory for "c" */
< 		}
---
> 		unbind_config(cdev, c);
1346a1385,1387
> 	}
> 	else{
> 	    WARN(cdev, "%s: Unexpected delayed status 0x%x\n", __func__, cdev->delayed_status);




diff -r linux-3.0.36/drivers/usb/gadget/dummy_hcd.c linux-3.0.36-lenovo/drivers/usb/gadget/dummy_hcd.c
125,128c125
< 	/* act like a net2280: high speed, six configurable endpoints */
< 	"ep-a", "ep-b", "ep-c", "ep-d", "ep-e", "ep-f",
< 
< 	/* or like pxa250: fifteen fixed function endpoints */
---
> 	/* act like a pxa250: fifteen fixed function endpoints */
135a133,136
> 
> 	/* and now some generic EPs so we have enough in multi config */
> 	"ep3out", "ep4in", "ep5out", "ep6out", "ep7in", "ep8out", "ep9in",
> 	"ep10out", "ep11out", "ep12in", "ep13out", "ep14in", "ep15out",




diff -r linux-3.0.36/drivers/usb/gadget/epautoconf.c linux-3.0.36-lenovo/drivers/usb/gadget/epautoconf.c
97c97
< 				if ('s' == tmp[2])	// == "-iso"
---
> 				if ('n' != tmp[2])	// == "-int"
114a115,118
> #ifdef CONFIG_ARCH_RK29
>     		if (USB_ENDPOINT_XFER_INT == type)
>     		    return 0;
> #endif    		    
147a152
> 		break;
Only in linux-3.0.36-lenovo/drivers/usb/gadget: f_accessory.c




diff -r linux-3.0.36/drivers/usb/gadget/f_acm.c linux-3.0.36-lenovo/drivers/usb/gadget/f_acm.c
408,410d407
< 			acm->notify_desc = ep_choose(cdev->gadget,
< 					acm->hs.notify,
< 					acm->fs.notify);
411a409,411
> 		acm->notify_desc = ep_choose(cdev->gadget,
> 				acm->hs.notify,
> 				acm->fs.notify);
421,424d420
< 			acm->port.in_desc = ep_choose(cdev->gadget,
< 					acm->hs.in, acm->fs.in);
< 			acm->port.out_desc = ep_choose(cdev->gadget,
< 					acm->hs.out, acm->fs.out);
425a422,425
> 		acm->port.in_desc = ep_choose(cdev->gadget,
> 				acm->hs.in, acm->fs.in);
> 		acm->port.out_desc = ep_choose(cdev->gadget,
> 				acm->hs.out, acm->fs.out);
699a700
> 	kfree(acm->port.func.name);
771c772,776
< 	acm->port.func.name = "acm";
---
> 	acm->port.func.name = kasprintf(GFP_KERNEL, "acm%u", port_num);
> 	if (!acm->port.func.name) {
> 		kfree(acm);
> 		return -ENOMEM;
> 	}
Only in linux-3.0.36-lenovo/drivers/usb/gadget: f_adb.c
Only in linux-3.0.36-lenovo/drivers/usb/gadget: f_audio_source.c




diff -r linux-3.0.36/drivers/usb/gadget/f_mass_storage.c linux-3.0.36-lenovo/drivers/usb/gadget/f_mass_storage.c
300a301,311
> #ifdef CONFIG_PLAT_RK
> /* flush after every 4 meg of writes to avoid excessive block level caching */
> #define MAX_UNFLUSHED_BYTES  (64 * 1024)// (4 * 1024 * 1024) //original value is 4MB,Modifyed by xbw at 2011-08-18
> #define MAX_UNFLUSHED_PACKETS 4//16
> 
> #include <linux/power_supply.h>
> #include <linux/reboot.h>
> #include <linux/syscalls.h>
> 
> #endif
> 
799a811,817
> 		/* kever@rk
> 		 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
> 		 * because of the DOEPTSIZ.PKTCNT has only 10 bits
> 		 */
> 		if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
> 		    amount = 0x8000;
> 
977a996,1002
> 				
> 			/* kever@rk
> 			 * max size for dwc_otg ctonroller is 64(max pkt sizt) * 1023(pkt)
> 			 * because of the DOEPTSIZ.PKTCNT has only 10 bits
> 			 */
> 			if((common->gadget->speed != USB_SPEED_HIGH)&&(amount >0x8000))
> 			    amount = 0x8000;
1042a1068,1076
> #ifdef MAX_UNFLUSHED_PACKETS
> 			curlun->unflushed_packet ++;
> 			curlun->unflushed_bytes += nwritten;
> 			if( (curlun->unflushed_packet >= MAX_UNFLUSHED_PACKETS) || (curlun->unflushed_bytes >= MAX_UNFLUSHED_BYTES)) {
> 				fsg_lun_fsync_sub(curlun);
> 				curlun->unflushed_packet = 0;
> 				curlun->unflushed_bytes = 0;
> 			}
> #endif
1942a1977,2123
> #ifdef CONFIG_PLAT_RK
> static void deferred_restart(struct work_struct *dummy)
> {
> 	sys_sync();
> 	kernel_restart("loader");
> }
> static DECLARE_WORK(restart_work, deferred_restart);
> 
> typedef struct tagLoaderParam
> {
> 	int	tag;
> 	int	length;
> 	char	parameter[1];
> 	int	crc;
> } PARM_INFO;
> #define PARM_TAG			0x4D524150
> #define MSC_EXT_DBG			1
> extern int  GetParamterInfo(char * pbuf , int len);
> 
> /* the buf is bh->buf,it is large enough. */
> static char * get_param_tag( char* buf , const char* tag )
> {
> 	PARM_INFO	*pi;
> 	int 		i;
> 	char		*pp = buf+256;
> 	char		*spp;
> 	i = GetParamterInfo( pp , 1024 );
> 	pi = (PARM_INFO*)pp;
> 	if( pi->tag != PARM_TAG ){
> error_out:	
> 		printk("paramter error,tag=0x%x\n" , pi->tag );
> 		return NULL;
> 	}
> 	if( pi->length+sizeof(PARM_INFO) > i ) {
> 		GetParamterInfo( pp , pi->length+sizeof(PARM_INFO)  + 511 );
> 	}
> 	pp = strstr( pi->parameter , tag );
> 	if( !pp ) goto error_out;
> 	pp += strlen(tag); // sizeof "MACHINE_MODEL:"
> 	while( *pp == ' ' || *pp == '\t' ) {
> 		if(pp - pi->parameter >= pi->length)
> 		  break;	
> 		pp++;
> 	}
> 	spp = pp;
> 	while( *pp != 0x0d && *pp != 0x0a ) {
> 		if(pp - pi->parameter >= pi->length)
> 		  break;
> 		pp++;
> 	}
> 	*pp = 0;
> 	if( spp == pp ) return NULL;
> 	return spp;
> }
> 
> static int do_get_product_name(int ret ,char *buf)
> {
> 	char		*tag = "MACHINE_MODEL:";
> 	char		*pname;
> 	#if MSC_EXT_DBG
> 	char 		tbuf[1300];
> 	if( buf == NULL )   buf = tbuf;
> 	#endif
> 	memset( buf , 0 , ret );
> 	pname = get_param_tag( buf , tag );
> 	if( pname ){
> 		strcpy( buf , pname);
> 	} 
> 	#if MSC_EXT_DBG
> 	printk("%s%s\n" , tag , buf );
> 	#endif
> 	return ret;
> }
> 
> static int do_get_versions( int ret ,char* buf )
> {
> 	/* get boot version and fireware version from cmdline
> 	* bootver=2010-07-08#4.02 firmware_ver=1.0.0 // Firmware Ver:16.01.0000
> 	* return format: 0x02 0x04 0x00 0x00 0x00 0x01 
> 	* RK29: bootver=2011-07-18#2.05 firmware_ver=0.2.3 (==00.02.0003)
> 	* for the old loader,the firmware_ver may be empty,so get the fw ver from paramter.
> 	*/
> #define ASC_BCD0( c )  (((c-'0'))&0xf)
> #define ASC_BCD1( c )  (((c-'0')<<4)&0xf0)
> 
> 	char *ver = buf;
> 	char *p_l , *p_f;
> 	char		*l_tag = "bootver=";
> 	char		*fw_tag = "FIRMWARE_VER:";
> 	
> 	#if MSC_EXT_DBG
> 	char 		tbuf[1300];
> 	if( ver == NULL )   ver = tbuf;
> 	#endif
> 	
> 	memset( ver , 0x00 , ret );
> 	p_l = strstr( saved_command_line , l_tag );
> 	if( !p_l ) {
> 	        return ret;
> 	} 
> 	p_l+=strlen( l_tag );
> 	if( (p_l = strchr( p_l,'#')) ) {
> 		p_l++;
> 		if( p_l[1] == '.' ) {
> 		        ver[1] = ASC_BCD0(p_l[0]);
> 		        p_l+=2;
> 		} else {
> 		        ver[1] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
> 		        p_l+=3;
> 		}
> 		ver[0] = ASC_BCD1(p_l[0])|ASC_BCD0(p_l[1]);
> 	}
> 	
> 	p_f = get_param_tag( ver , fw_tag );
> 	if( !p_f ) return ret;
> 	
> 	if( p_f[1] == '.' ) {
> 	        ver[5] = ASC_BCD0(p_f[0]);
> 	        p_f+=2;
> 	} else {
> 	        ver[5] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
> 	        p_f+=3;
> 	} 
> 	if( p_f[1] == '.' ) {
> 	        ver[4] = ASC_BCD0(p_f[0]);
> 	        p_f+=2;
> 	} else {
> 	        ver[4] = ASC_BCD1(p_f[0])|ASC_BCD0(p_f[1]);
> 	        p_f+=3;
> 	} 
> 	ver[2] = ASC_BCD0(p_f[0]);
> 	p_f++;
> 	if( p_f[0] != ' ' ){
> 	        ver[2] |= ASC_BCD1(p_f[0]);
> 	        p_f++;
> 	}
> 	// only support 2 byte version.
> 	ver[3] = 0;
> 
> 	#if MSC_EXT_DBG
> 	printk("VERSION:%02x %02x %02x %02x %02x %02x\n" , 
> 		ver[0],ver[1],ver[2],ver[3],ver[4],ver[5]);
> 	#endif
> 	return ret;
> }
> #endif
> 
1949a2131,2133
> #ifdef CONFIG_PLAT_RK
> 	struct fsg_common	*fsg = common;
> #endif
2139a2324,2326
> #ifdef CONFIG_PLAT_RK
> 			reply = 0; //zyf 20100302
> #else
2140a2328
> #endif
2195a2384,2403
> #ifdef CONFIG_PLAT_RK
> 	case 0xff:
> 		if( fsg->cmnd[1] != 0xe0 ||
> 		    fsg->cmnd[2] != 0xff || fsg->cmnd[3] != 0xff ||
> 		    fsg->cmnd[4] != 0xff )
> 		    break;
> 		if (fsg->cmnd_size >= 6 && fsg->cmnd[5] == 0xfe) {
> 			schedule_work(&restart_work);
> 		}
> 		else if ( fsg->cmnd[5] == 0xf3 ) {
> 			fsg->data_size_from_cmnd = fsg->data_size;
> 		/* get product name from parameter section */
> 			reply = do_get_product_name( fsg->data_size,bh->buf );
> 		}
> 		else if ( fsg->cmnd[5] == 0xff ){
> 			fsg->data_size_from_cmnd = fsg->data_size;
> 			reply = do_get_versions( fsg->data_size,bh->buf ); 
> 		}
> 		break;
> #endif
2379a2588
> 			fsg->bulk_in->driver_data = NULL;
2383a2593
> 			fsg->bulk_out->driver_data = NULL;
3055c3265
< 	fsg->function.name        = FSG_DRIVER_DESC;
---
> 	fsg->function.name        = "mass_storage";
3179a3390,3517
> 
> #ifdef CONFIG_USB_ANDROID_MASS_STORAGE
> 
> #ifdef CONFIG_PLAT_RK
> static enum power_supply_property usb_props[] = {
> //	POWER_SUPPLY_PROP_STATUS,
> 	POWER_SUPPLY_PROP_ONLINE,
> };
> 
> static int usb_get_property(struct power_supply *psy,
> 				enum power_supply_property psp,
> 					union power_supply_propval *val)
> {
> 	int ret = 0;
> 
> 	switch (psp) {
> 	case POWER_SUPPLY_PROP_ONLINE:
> #ifndef CONFIG_DWC_OTG_HOST_ONLY
> 		val->intval = get_msc_connect_flag();
> #else
> 		val->intval = 0;
> #endif
> 		break;
> 	default:
> 		return -EINVAL;
> 	}
> 
> 	return ret;
> }
> 
> static int usb_power_supply_register(struct device* parent)
> {
> 	struct power_supply *ps;
> 	int retval = 0;
> 
> 	ps = kzalloc(sizeof(*ps), GFP_KERNEL);
> 	if (!ps) {
> 		dev_err(parent, "failed to allocate power supply data\n");
> 		retval = -ENOMEM;
> 		goto out;
> 	}
> 	ps->name = "usb";
> 	ps->type = POWER_SUPPLY_TYPE_USB;
> 	ps->properties = usb_props;
> 	ps->num_properties = ARRAY_SIZE(usb_props);
> 	ps->get_property = usb_get_property;
> 	ps->external_power_changed = NULL;
> 	retval = power_supply_register(parent, ps);
> 	if (retval) {
> 		dev_err(parent, "failed to register battery\n");
> 		goto out;
> 	}
> out:
> 	return retval;
> }
> #endif
> 
> static struct fsg_config fsg_cfg;
> 
> static int fsg_probe(struct platform_device *pdev)
> {
> 	struct usb_mass_storage_platform_data *pdata = pdev->dev.platform_data;
> 	int i, nluns;
> 
> 	printk(KERN_INFO "fsg_probe pdev: %p, pdata: %p\n", pdev, pdata);
> 	if (!pdata)
> 		return -1;
> 
> 	nluns = pdata->nluns;
> 	if (nluns > FSG_MAX_LUNS)
> 		nluns = FSG_MAX_LUNS;
> 	fsg_cfg.nluns = nluns;
> 	for (i = 0; i < nluns; i++)
> 		fsg_cfg.luns[i].removable = 1;
> 
> 	fsg_cfg.vendor_name = pdata->vendor;
> 	fsg_cfg.product_name = pdata->product;
> 	fsg_cfg.release = pdata->release;
> 	fsg_cfg.can_stall = 0;
> 	fsg_cfg.pdev = pdev;
> 
> #ifdef CONFIG_PLAT_RK
> {
> 	/*
> 	 * Initialize usb power supply
> 	 */
> 	int retval = usb_power_supply_register(&pdev->dev);
> 	if (retval != 0) {
> 		dev_err(&pdev->dev, "usb_power_supply_register failed\n");
> 	}
> 
> 	return retval;
> }
> #else
> 	return 0;
> #endif
> }
> 
> static struct platform_driver fsg_platform_driver = {
> 	.driver = { .name = FUNCTION_NAME, },
> 	.probe = fsg_probe,
> };
> 
> int mass_storage_bind_config(struct usb_configuration *c)
> {
> 	struct fsg_common *common = fsg_common_init(NULL, c->cdev, &fsg_cfg);
> 	if (IS_ERR(common))
> 		return -1;
> 	return fsg_add(c->cdev, c, common);
> }
> 
> static struct android_usb_function mass_storage_function = {
> 	.name = FUNCTION_NAME,
> 	.bind_config = mass_storage_bind_config,
> };
> 
> static int __init init(void)
> {
> 	int		rc;
> 	printk(KERN_INFO "f_mass_storage init\n");
> 	rc = platform_driver_register(&fsg_platform_driver);
> 	if (rc != 0)
> 		return rc;
> 	android_register_function(&mass_storage_function);
> 	return 0;
> }module_init(init);
> 
> #endif /* CONFIG_USB_ANDROID_MASS_STORAGE */
Only in linux-3.0.36-lenovo/drivers/usb/gadget: f_mtp.c




diff -r linux-3.0.36/drivers/usb/gadget/f_phonet.c linux-3.0.36-lenovo/drivers/usb/gadget/f_phonet.c
544c544
< 			goto err;
---
> 			goto err_req;
553c553
< 		goto err;
---
> 		goto err_req;
559a560,562
> err_req:
> 	for (i = 0; i < phonet_rxq_size && fp->out_reqv[i]; i++)
> 		usb_ep_free_request(fp->out_ep, fp->out_reqv[i]);
560a564
> 




diff -r linux-3.0.36/drivers/usb/gadget/f_rndis.c linux-3.0.36-lenovo/drivers/usb/gadget/f_rndis.c
29c29
< #include <linux/device.h>
---
> #include <linux/platform_device.h>
88a89,90
> 	u32				vendorID;
> 	const char			*manufacturer;
90a93
> 
190d192
< 
195c197
< 	.bFunctionProtocol =	USB_CDC_PROTO_NONE,
---
> 	.bFunctionProtocol =	USB_CDC_ACM_PROTO_VENDOR,
489,491d490
< 			rndis->notify_desc = ep_choose(cdev->gadget,
< 					rndis->hs.notify,
< 					rndis->fs.notify);
492a492,494
> 		rndis->notify_desc = ep_choose(cdev->gadget,
> 				rndis->hs.notify,
> 				rndis->fs.notify);
506,509d507
< 			rndis->port.in = ep_choose(cdev->gadget,
< 					rndis->hs.in, rndis->fs.in);
< 			rndis->port.out = ep_choose(cdev->gadget,
< 					rndis->hs.out, rndis->fs.out);
510a509,512
> 		rndis->port.in = ep_choose(cdev->gadget,
> 				rndis->hs.in, rndis->fs.in);
> 		rndis->port.out = ep_choose(cdev->gadget,
> 				rndis->hs.out, rndis->fs.out);
709,714c711,713
< #if 0
< // FIXME
< 	if (rndis_set_param_vendor(rndis->config, vendorID,
< 				manufacturer))
< 		goto fail0;
< #endif
---
> 	if (rndis_set_param_vendor(rndis->config, rndis->vendorID,
> 				   rndis->manufacturer))
> 			goto fail;
789c788,789
< rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
---
> rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
> 				u32 vendorID, const char *manufacturer)
796a797,801
> 	/* setup RNDIS itself */
> 	status = rndis_init();
> 	if (status < 0)
> 		return status;
> 
800,804d804
< 		/* ... and setup RNDIS itself */
< 		status = rndis_init();
< 		if (status < 0)
< 			return status;
< 
833a834,835
> 	rndis->vendorID = vendorID;
> 	rndis->manufacturer = manufacturer;




diff -r linux-3.0.36/drivers/usb/gadget/gadget_chips.h linux-3.0.36-lenovo/drivers/usb/gadget/gadget_chips.h
132a133,138
> #ifdef CONFIG_USB_GADGET_DWC_OTG
> #define gadget_is_dwc_otg(g)    !strcmp("dwc_otg_pcd", (g)->name)
> #else
> #define gadget_is_dwc_otg(g)    0
> #endif
> 
215a222,223
> 	else if (gadget_is_dwc_otg(gadget))
> 		return 0x22;




diff -r linux-3.0.36/drivers/usb/gadget/Kconfig linux-3.0.36-lenovo/drivers/usb/gadget/Kconfig
114a115
> 	default USB_GADGET_DWC_OTG
545a547,559
> config USB_GADGET_DWC_OTG
> 	boolean "Synopsys DWC OTG Controller"
> 	select USB_GADGET_DUALSPEED
> 	help
> 	  This driver provides USB Device Controller support for the
> 	  Synopsys DesignWare USB OTG Core used on the Rockchip RK28.
> 
> config USB_DWC_OTG
> 	tristate
> 	depends on USB_GADGET_DWC_OTG
> 	default USB_GADGET
> 	select USB_GADGET_SELECTED
> 
645c659
< 	tristate "USB Gadget Drivers"
---
> 	bool "USB Gadget Drivers"
647c661
< 	default USB_ETH
---
> 	default USB_G_ANDROID
937a952,959
> 
> config USB_G_ANDROID
> 	boolean "Android Gadget"
> 	depends on SWITCH
> 	help
> 	  The Android gadget driver supports multiple USB functions.
> 	  The functions can be configured via a board file and may be
> 	  enabled and disabled dynamically.




diff -r linux-3.0.36/drivers/usb/gadget/Makefile linux-3.0.36-lenovo/drivers/usb/gadget/Makefile
51a52
> g_android-y			:= android.o
69a71
> obj-$(CONFIG_USB_G_ANDROID)	+= g_android.o




diff -r linux-3.0.36/drivers/usb/gadget/rndis.c linux-3.0.36-lenovo/drivers/usb/gadget/rndis.c
1149a1150
> static bool rndis_initialized;
1154a1156,1158
> 	if (rndis_initialized)
> 		return 0;
> 
1180a1185
> 	rndis_initialized = true;
1188a1194
> #endif
1189a1196,1200
> 	if (!rndis_initialized)
> 		return;
> 	rndis_initialized = false;
> 
> #ifdef CONFIG_USB_GADGET_DEBUG_FILES




diff -r linux-3.0.36/drivers/usb/gadget/storage_common.c linux-3.0.36-lenovo/drivers/usb/gadget/storage_common.c
235a236,239
> #ifdef MAX_UNFLUSHED_PACKETS
> 	unsigned int	unflushed_packet;
> 	unsigned int	unflushed_bytes;
> #endif
765a770,777
> #ifdef CONFIG_PLAT_RK
> 	printk("store_file: \"%s\"\n", buf);
> #endif
> 
> #ifndef CONFIG_USB_G_ANDROID
> 	/* disabled in android because we need to allow closing the backing file
> 	 * if the media was removed
> 	 */
769a782
> #endif




diff -r linux-3.0.36/drivers/usb/gadget/u_ether.c linux-3.0.36-lenovo/drivers/usb/gadget/u_ether.c
33a34
> static gfp_t g_gfp_flags;
256c257
< 	skb_reserve(skb, NET_IP_ALIGN);
---
> 	//skb_reserve(skb, NET_IP_ALIGN);
579a581,595
> 	
> 	// for tx fixup
> 	{
> 		struct sk_buff *tx_skb;
> 		if ((unsigned long)skb->data % 4) {
> 			tx_skb = alloc_skb(skb->len + NET_IP_ALIGN, g_gfp_flags);
> 			if (tx_skb)
> 				memcpy(skb_put(tx_skb, skb->len), skb->data, skb->len);
> 			dev_kfree_skb_any(skb);
> 			skb = tx_skb;
> 		}
> 		length = skb->len;
> 	}	
> 	// for tx fixup
> 	
634a651,652
> 	
> 	g_gfp_flags = gfp_flags;
767a786,805
> 	return gether_setup_name(g, ethaddr, "usb");
> }
> 
> /**
>  * gether_setup_name - initialize one ethernet-over-usb link
>  * @g: gadget to associated with these links
>  * @ethaddr: NULL, or a buffer in which the ethernet address of the
>  *	host side of the link is recorded
>  * @netname: name for network device (for example, "usb")
>  * Context: may sleep
>  *
>  * This sets up the single network link that may be exported by a
>  * gadget driver using this framework.  The link layer addresses are
>  * set up using module parameters.
>  *
>  * Returns negative errno, or zero on success
>  */
> int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
> 		const char *netname)
> {
790c828
< 	strcpy(net->name, "usb%d");
---
> 	snprintf(net->name, sizeof(net->name), "%s%%d", netname);
806,811d843
< 	/* two kinds of host-initiated state changes:
< 	 *  - iff DATA transfer is active, carrier is "on"
< 	 *  - tx queueing enabled if open *and* carrier is "on"
< 	 */
< 	netif_carrier_off(net);
< 
824a857,862
> 
> 		/* two kinds of host-initiated state changes:
> 		 *  - iff DATA transfer is active, carrier is "on"
> 		 *  - tx queueing enabled if open *and* carrier is "on"
> 		 */
> 		netif_carrier_off(net);
946d983
< 	WARN_ON(!dev);




diff -r linux-3.0.36/drivers/usb/gadget/u_ether.h linux-3.0.36-lenovo/drivers/usb/gadget/u_ether.h
88a89,91
> /* variant of gether_setup that allows customizing network device name */
> int gether_setup_name(struct usb_gadget *g, u8 ethaddr[ETH_ALEN],
> 		const char *netname);
115c118,119
< int rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN]);
---
> int rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
> 				u32 vendorID, const char *manufacturer);
120c124,125
< rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN])
---
> rndis_bind_config(struct usb_configuration *c, u8 ethaddr[ETH_ALEN],
> 				u32 vendorID, const char *manufacturer)




diff -r linux-3.0.36/drivers/usb/gadget/u_serial.c linux-3.0.36-lenovo/drivers/usb/gadget/u_serial.c
125c125
< #define N_PORTS		4
---
> #define N_PORTS		8
1031c1031
< static int __init
---
> static int
1077c1077
< int __init gserial_setup(struct usb_gadget *g, unsigned count)
---
> int gserial_setup(struct usb_gadget *g, unsigned count)




diff -r linux-3.0.36/drivers/usb/host/ehci.h linux-3.0.36-lenovo/drivers/usb/host/ehci.h
739a740,756
> /*
>  * Writing to dma coherent memory on ARM may be delayed via L2
>  * writing buffer, so introduce the helper which can flush L2 writing
>  * buffer into memory immediately, especially used to flush ehci
>  * descriptor to memory.
>  * */
> #ifdef	CONFIG_ARM_DMA_MEM_BUFFERABLE
> static inline void ehci_sync_mem()
> {
> 	mb();
> }
> #else
> static inline void ehci_sync_mem()
> {
> }
> #endif
> 




diff -r linux-3.0.36/drivers/usb/host/ehci-hcd.c linux-3.0.36-lenovo/drivers/usb/host/ehci-hcd.c
21a22
> #include <mach/board.h>
316c317
< 	temp &= STS_ASS | STS_PSS;
---
> 	temp &= STS_ASS;/* | STS_PSS;*/
318c319
< 					STS_ASS | STS_PSS, temp, 16 * 125))
---
> 					STS_ASS/* | STS_PSS*/, temp, 16 * 125))
328c329
< 				    STS_ASS | STS_PSS, 0, 16 * 125);
---
> 				    STS_ASS/* | STS_PSS*/, 0, 16 * 125);
868a870
> 		{
870c872,873
< 
---
> 			rk28_send_wakeup_key();  //
>         }
1292a1296,1300
> #endif
> 
> #ifdef CONFIG_USB_EHCI_RK
> #include "ehci-rk.c"
> #define PLATFORM_DRIVER		ehci_rk_driver




diff -r linux-3.0.36/drivers/usb/host/ehci-pci.c linux-3.0.36-lenovo/drivers/usb/host/ehci-pci.c
362c362,363
< 		 pdev->device == 0x8C26);
---
> 		 pdev->device == 0x8C26 ||
> 		 pdev->device == 0x9C26);




diff -r linux-3.0.36/drivers/usb/host/ehci-q.c linux-3.0.36-lenovo/drivers/usb/host/ehci-q.c
133,134c133,141
< 		/* first qtd may already be partially processed */
< 		if (cpu_to_hc32(ehci, qtd->qtd_dma) == qh->hw->hw_current)
---
> 		/*
> 		 * first qtd may already be partially processed.
> 		 * If we come here during unlink, the QH overlay region
> 		 * might have reference to the just unlinked qtd. The
> 		 * qtd is updated in qh_completions(). Update the QH
> 		 * overlay here.
> 		 */
> 		if (cpu_to_hc32(ehci, qtd->qtd_dma) == qh->hw->hw_current) {
> 			qh->hw->hw_qtd_next = qtd->hw_next;
135a143
> 		}
997a1006,1011
> 	/*
> 	 * flush qh descriptor into memory immediately,
> 	 * see comments in qh_append_tds.
> 	 * */
> 	ehci_sync_mem();
> 
1083a1098,1109
> 
> 			/*
> 			 * Writing to dma coherent buffer on ARM may
> 			 * be delayed to reach memory, so HC may not see
> 			 * hw_token of dummy qtd in time, which can cause
> 			 * the qtd transaction to be executed very late,
> 			 * and degrade performance a lot. ehci_sync_mem
> 			 * is added to flush 'token' immediatelly into
> 			 * memory, so that ehci can execute the transaction
> 			 * ASAP.
> 			 * */
> 			ehci_sync_mem();
Only in linux-3.0.36-lenovo/drivers/usb/host: ehci-rk.c




diff -r linux-3.0.36/drivers/usb/host/ehci-sched.c linux-3.0.36-lenovo/drivers/usb/host/ehci-sched.c
239c239
< max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 30, 0 };
---
> max_tt_usecs[] = { 125, 125, 125, 125, 125, 125, 125, 25 };




diff -r linux-3.0.36/drivers/usb/host/Kconfig linux-3.0.36-lenovo/drivers/usb/host/Kconfig
93a94,101
> config USB_EHCI_RK
> 	bool "Rockchip EHCI HSIC support"
> 	depends on USB_EHCI_HCD 
> 	select USB_EHCI_ROOT_HUB_TT
> 	default y
> 	---help---
> 		Enables support for the onchip USB controller on the RK3108.
> 




diff -r linux-3.0.36/drivers/usb/host/ohci-q.c linux-3.0.36-lenovo/drivers/usb/host/ohci-q.c
1132a1133,1151
> 		struct ed	*ed = td->ed;
> 
> 		/*
> 		 * Some OHCI controllers (NVIDIA for sure, maybe others)
> 		 * occasionally forget to add TDs to the done queue.  Since
> 		 * TDs for a given endpoint are always processed in order,
> 		 * if we find a TD on the donelist then all of its
> 		 * predecessors must be finished as well.
> 		 */
> 		for (;;) {
> 			struct td	*td2;
> 
> 			td2 = list_first_entry(&ed->td_list, struct td,
> 					td_list);
> 			if (td2 == td)
> 				break;
> 			takeback_td(ohci, td2);
> 		}
> 




diff -r linux-3.0.36/drivers/usb/host/pci-quirks.c linux-3.0.36-lenovo/drivers/usb/host/pci-quirks.c
75a76
> #define USB_INTEL_USB2PRM      0xD4
76a78
> #define USB_INTEL_USB3PRM      0xDC
544c546,553
< 			DMI_MATCH(DMI_BIOS_VERSION, "Lucid-GE-133"),
---
> 			DMI_MATCH(DMI_BIOS_VERSION, "Lucid-"),
> 		},
> 	},
> 	{
> 		/*  Pegatron Lucid (Ordissimo) */
> 		.matches = {
> 			DMI_MATCH(DMI_BOARD_NAME, "Ordissimo"),
> 			DMI_MATCH(DMI_BIOS_VERSION, "Lucid-"),
714a724
> #define PCI_DEVICE_ID_INTEL_LYNX_POINT_LP_XHCI	0x9C31
728c738,739
< 		pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI;
---
> 		(pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_XHCI ||
> 		 pdev->device == PCI_DEVICE_ID_INTEL_LYNX_POINT_LP_XHCI);
757a769
> #if defined(CONFIG_USB_XHCI_HCD) || defined(CONFIG_USB_XHCI_HCD_MODULE)
760c772,780
< 	ports_available = 0xffffffff;
---
> 	/* Read USB3PRM, the USB 3.0 Port Routing Mask Register
> 	 * Indicate the ports that can be changed from OS.
> 	 */
> 	pci_read_config_dword(xhci_pdev, USB_INTEL_USB3PRM,
> 			&ports_available);
> 
> 	dev_dbg(&xhci_pdev->dev, "Configurable ports to enable SuperSpeed: 0x%x\n",
> 			ports_available);
> 
762,763c782,783
< 	 * Register, to turn on SuperSpeed terminations for all
< 	 * available ports.
---
> 	 * Register, to turn on SuperSpeed terminations for the
> 	 * switchable ports.
773c793,802
< 	ports_available = 0xffffffff;
---
> 	/* Read XUSB2PRM, xHCI USB 2.0 Port Routing Mask Register
> 	 * Indicate the USB 2.0 ports to be controlled by the xHCI host.
> 	 */
> 
> 	pci_read_config_dword(xhci_pdev, USB_INTEL_USB2PRM,
> 			&ports_available);
> 
> 	dev_dbg(&xhci_pdev->dev, "Configurable USB 2.0 ports to hand over to xCHI: 0x%x\n",
> 			ports_available);
> 
784a814,825
> #else
> 	/* Don't switchover the ports if the user hasn't compiled the xHCI
> 	 * driver.  Otherwise they will see "dead" USB ports that don't power
> 	 * the devices.
> 	 */
> 	dev_warn(&xhci_pdev->dev,
> 			"CONFIG_USB_XHCI_HCD is turned off, "
> 			"defaulting to EHCI.\n");
> 	dev_warn(&xhci_pdev->dev,
> 			"USB 3.0 devices will work at USB 2.0 speeds.\n");
> #endif	/* CONFIG_USB_XHCI_HCD || CONFIG_USB_XHCI_HCD_MODULE */
> 
787a829,835
> void usb_disable_xhci_ports(struct pci_dev *xhci_pdev)
> {
> 	pci_write_config_dword(xhci_pdev, USB_INTEL_USB3_PSSEN, 0x0);
> 	pci_write_config_dword(xhci_pdev, USB_INTEL_XUSB2PR, 0x0);
> }
> EXPORT_SYMBOL_GPL(usb_disable_xhci_ports);
> 
802a851
> 	int len = pci_resource_len(pdev, 0);
807,808c856
< 	base = ioremap_nocache(pci_resource_start(pdev, 0),
< 				pci_resource_len(pdev, 0));
---
> 	base = ioremap_nocache(pci_resource_start(pdev, 0), len);
817a866,872
> 		if ((ext_cap_offset + sizeof(val)) > len) {
> 			/* We're reading garbage from the controller */
> 			dev_warn(&pdev->dev,
> 				 "xHCI controller failing to respond");
> 			return;
> 		}
> 
820a876
> 
850a907
> hc_init:
853c910
< hc_init:
---
> 




diff -r linux-3.0.36/drivers/usb/host/pci-quirks.h linux-3.0.36-lenovo/drivers/usb/host/pci-quirks.h
12a13
> void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
16a18
> static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}




diff -r linux-3.0.36/drivers/usb/host/uhci-hcd.c linux-3.0.36-lenovo/drivers/usb/host/uhci-hcd.c
448a449,452
> 	spin_lock(&uhci->lock);
> 	if (unlikely(!uhci->is_initialized))	/* not yet configured */
> 		goto done;
> 
457d460
< 			spin_lock(&uhci->lock);
475d477
< 			spin_unlock(&uhci->lock);
479c481,482
< 	if (status & USBSTS_RD)
---
> 	if (status & USBSTS_RD) {
> 		spin_unlock(&uhci->lock);
481,482c484
< 	else {
< 		spin_lock(&uhci->lock);
---
> 	} else {
483a486
>  done:
660a664
> 	spin_lock_irq(&uhci->lock);
663d666
< 	spin_lock_irq(&uhci->lock);




diff -r linux-3.0.36/drivers/usb/host/xhci.c linux-3.0.36-lenovo/drivers/usb/host/xhci.c
54c54
< static int handshake(struct xhci_hcd *xhci, void __iomem *ptr,
---
> int handshake(struct xhci_hcd *xhci, void __iomem *ptr,
107c107
< 	if (!ret)
---
> 	if (!ret) {
108a109,110
> 		xhci->cmd_ring_state = CMD_RING_STATE_STOPPED;
> 	}
166c168
< 			CMD_RESET, 0, 250 * 1000);
---
> 			CMD_RESET, 0, 10 * 1000 * 1000);
175c177,178
< 	return handshake(xhci, &xhci->op_regs->status, STS_CNR, 0, 250 * 1000);
---
> 	return handshake(xhci, &xhci->op_regs->status,
> 			 STS_CNR, 0, 10 * 1000 * 1000);
391a395
> 	xhci->cmd_ring_state = CMD_RING_STATE_RUNNING;
595a600,602
> 	if (xhci->quirks & XHCI_SPURIOUS_REBOOT)
> 		usb_disable_xhci_ports(to_pci_dev(hcd->self.controller));
> 
719c726
< 		      STS_HALT, STS_HALT, 100*100)) {
---
> 		      STS_HALT, STS_HALT, XHCI_MAX_HALT_USEC)) {
1773a1781
> 	union xhci_trb *cmd_trb;
1815a1824
> 	cmd_trb = xhci->cmd_ring->dequeue;
1837c1846
< 			USB_CTRL_SET_TIMEOUT);
---
> 			XHCI_CMD_DEFAULT_TIMEOUT);
1844c1853,1856
< 		/* FIXME cancel the configure endpoint command */
---
> 		/* cancel the configure endpoint command */
> 		ret = xhci_cancel_cmd(xhci, command, cmd_trb);
> 		if (ret < 0)
> 			return ret;
2776a2789
> 	union xhci_trb *cmd_trb;
2778a2792
> 	cmd_trb = xhci->cmd_ring->dequeue;
2790c2804
< 			USB_CTRL_SET_TIMEOUT);
---
> 			XHCI_CMD_DEFAULT_TIMEOUT);
2794,2795c2808,2809
< 		/* FIXME cancel the enable slot request */
< 		return 0;
---
> 		/* cancel the enable slot request */
> 		return xhci_cancel_cmd(xhci, NULL, cmd_trb);
2855a2870
> 	union xhci_trb *cmd_trb;
2893a2909
> 	cmd_trb = xhci->cmd_ring->dequeue;
2906c2922
< 			USB_CTRL_SET_TIMEOUT);
---
> 			XHCI_CMD_DEFAULT_TIMEOUT);
2914c2930,2933
< 		/* FIXME cancel the address device command */
---
> 		/* cancel the address device command */
> 		ret = xhci_cancel_cmd(xhci, NULL, cmd_trb);
> 		if (ret < 0)
> 			return ret;




diff -r linux-3.0.36/drivers/usb/host/xhci.h linux-3.0.36-lenovo/drivers/usb/host/xhci.h
1072a1073,1075
> #define TRB_TYPE_LINK_LE32(x)   (((x) & cpu_to_le32(TRB_TYPE_BITMASK)) == \
> 		cpu_to_le32(TRB_TYPE(TRB_LINK)))
> 
1113a1117,1126
> /* xHCI command default timeout value */
> #define XHCI_CMD_DEFAULT_TIMEOUT       (5 * HZ)
> 
> /* command descriptor */
> struct xhci_cd {
> 	struct list_head	cancel_cmd_list;
> 	struct xhci_command	*command;
> 	union xhci_trb		*cmd_trb;
> };
> 
1254a1268,1272
> 	unsigned int            cmd_ring_state;
> #define CMD_RING_STATE_RUNNING         (1 << 0)
> #define CMD_RING_STATE_ABORTED         (1 << 1)
> #define CMD_RING_STATE_STOPPED         (1 << 2)
> 	struct list_head        cancel_cmd_list;
1318a1337,1338
> #define XHCI_SPURIOUS_REBOOT	(1 << 13)
> #define XHCI_AVOID_BEI		(1 << 15)
1486a1507,1508
> int handshake(struct xhci_hcd *xhci, void __iomem *ptr,
> 		u32 mask, u32 done, int usec);
1568a1591,1592
> int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
> 		union xhci_trb *cmd_trb);




diff -r linux-3.0.36/drivers/usb/host/xhci-mem.c linux-3.0.36-lenovo/drivers/usb/host/xhci-mem.c
183c183,189
< 		if (!next)
---
> 		if (!next) {
> 			prev = ring->first_seg;
> 			while (prev) {
> 				next = prev->next;
> 				xhci_segment_free(xhci, prev);
> 				prev = next;
> 			}
184a191
> 		}
204c211
< 	xhci_ring_free(xhci, ring);
---
> 	kfree(ring);
1028a1036,1037
> 	if (ep->desc.bInterval == 0)
> 		return 0;
1507a1517
> 	struct xhci_cd  *cur_cd, *next_cd;
1527a1538,1542
> 	list_for_each_entry_safe(cur_cd, next_cd,
> 			&xhci->cancel_cmd_list, cancel_cmd_list) {
> 		list_del(&cur_cd->cancel_cmd_list);
> 		kfree(cur_cd);
> 	}
2016a2032
> 	INIT_LIST_HEAD(&xhci->cancel_cmd_list);




diff -r linux-3.0.36/drivers/usb/host/xhci-pci.c linux-3.0.36-lenovo/drivers/usb/host/xhci-pci.c
30a31
> #define PCI_DEVICE_ID_FRESCO_LOGIC_FL1400	0x1400
112,113c113,116
< 			pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK) {
< 		if (pdev->revision == 0x0) {
---
> 			(pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK ||
> 			 pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_FL1400)) {
> 		if (pdev->device == PCI_DEVICE_ID_FRESCO_LOGIC_PDK &&
> 				pdev->revision == 0x0) {
142a146,155
> 		/*
> 		 * PPT desktop boards DH77EB and DH77DF will power back on after
> 		 * a few seconds of being shutdown.  The fix for this is to
> 		 * switch the ports from xHCI to EHCI on shutdown.  We can't use
> 		 * DMI information to find those particular boards (since each
> 		 * vendor will change the board name), so we have to key off all
> 		 * PPT chipsets.
> 		 */
> 		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
> 		xhci->quirks |= XHCI_AVOID_BEI;
147a161
> 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;




diff -r linux-3.0.36/drivers/usb/host/xhci-ring.c linux-3.0.36-lenovo/drivers/usb/host/xhci-ring.c
150d149
< 	union xhci_trb *next = ++(ring->dequeue);
154,168c153,177
< 	/* Update the dequeue pointer further if that was a link TRB or we're at
< 	 * the end of an event ring segment (which doesn't have link TRBS)
< 	 */
< 	while (last_trb(xhci, ring, ring->deq_seg, next)) {
< 		if (consumer && last_trb_on_last_seg(xhci, ring, ring->deq_seg, next)) {
< 			ring->cycle_state = (ring->cycle_state ? 0 : 1);
< 			if (!in_interrupt())
< 				xhci_dbg(xhci, "Toggle cycle state for ring %p = %i\n",
< 						ring,
< 						(unsigned int) ring->cycle_state);
< 		}
< 		ring->deq_seg = ring->deq_seg->next;
< 		ring->dequeue = ring->deq_seg->trbs;
< 		next = ring->dequeue;
< 	}
---
> 
> 	do {
> 		/*
> 		 * Update the dequeue pointer further if that was a link TRB or
> 		 * we're at the end of an event ring segment (which doesn't have
> 		 * link TRBS)
> 		 */
> 		if (last_trb(xhci, ring, ring->deq_seg, ring->dequeue)) {
> 			if (consumer && last_trb_on_last_seg(xhci, ring,
> 						ring->deq_seg, ring->dequeue)) {
> 				if (!in_interrupt())
> 					xhci_dbg(xhci, "Toggle cycle state "
> 							"for ring %p = %i\n",
> 							ring,
> 							(unsigned int)
> 							ring->cycle_state);
> 				ring->cycle_state = (ring->cycle_state ? 0 : 1);
> 			}
> 			ring->deq_seg = ring->deq_seg->next;
> 			ring->dequeue = ring->deq_seg->trbs;
> 		} else {
> 			ring->dequeue++;
> 		}
> 	} while (last_trb(xhci, ring, ring->deq_seg, ring->dequeue));
> 
304a314,316
> 	if (!(xhci->cmd_ring_state & CMD_RING_STATE_RUNNING))
> 		return;
> 
310a323,430
> static int xhci_abort_cmd_ring(struct xhci_hcd *xhci)
> {
> 	u64 temp_64;
> 	int ret;
> 
> 	xhci_dbg(xhci, "Abort command ring\n");
> 
> 	if (!(xhci->cmd_ring_state & CMD_RING_STATE_RUNNING)) {
> 		xhci_dbg(xhci, "The command ring isn't running, "
> 				"Have the command ring been stopped?\n");
> 		return 0;
> 	}
> 
> 	temp_64 = xhci_read_64(xhci, &xhci->op_regs->cmd_ring);
> 	if (!(temp_64 & CMD_RING_RUNNING)) {
> 		xhci_dbg(xhci, "Command ring had been stopped\n");
> 		return 0;
> 	}
> 	xhci->cmd_ring_state = CMD_RING_STATE_ABORTED;
> 	xhci_write_64(xhci, temp_64 | CMD_RING_ABORT,
> 			&xhci->op_regs->cmd_ring);
> 
> 	/* Section 4.6.1.2 of xHCI 1.0 spec says software should
> 	 * time the completion od all xHCI commands, including
> 	 * the Command Abort operation. If software doesn't see
> 	 * CRR negated in a timely manner (e.g. longer than 5
> 	 * seconds), then it should assume that the there are
> 	 * larger problems with the xHC and assert HCRST.
> 	 */
> 	ret = handshake(xhci, &xhci->op_regs->cmd_ring,
> 			CMD_RING_RUNNING, 0, 5 * 1000 * 1000);
> 	if (ret < 0) {
> 		xhci_err(xhci, "Stopped the command ring failed, "
> 				"maybe the host is dead\n");
> 		xhci->xhc_state |= XHCI_STATE_DYING;
> 		xhci_quiesce(xhci);
> 		xhci_halt(xhci);
> 		return -ESHUTDOWN;
> 	}
> 
> 	return 0;
> }
> 
> static int xhci_queue_cd(struct xhci_hcd *xhci,
> 		struct xhci_command *command,
> 		union xhci_trb *cmd_trb)
> {
> 	struct xhci_cd *cd;
> 	cd = kzalloc(sizeof(struct xhci_cd), GFP_ATOMIC);
> 	if (!cd)
> 		return -ENOMEM;
> 	INIT_LIST_HEAD(&cd->cancel_cmd_list);
> 
> 	cd->command = command;
> 	cd->cmd_trb = cmd_trb;
> 	list_add_tail(&cd->cancel_cmd_list, &xhci->cancel_cmd_list);
> 
> 	return 0;
> }
> 
> /*
>  * Cancel the command which has issue.
>  *
>  * Some commands may hang due to waiting for acknowledgement from
>  * usb device. It is outside of the xHC's ability to control and
>  * will cause the command ring is blocked. When it occurs software
>  * should intervene to recover the command ring.
>  * See Section 4.6.1.1 and 4.6.1.2
>  */
> int xhci_cancel_cmd(struct xhci_hcd *xhci, struct xhci_command *command,
> 		union xhci_trb *cmd_trb)
> {
> 	int retval = 0;
> 	unsigned long flags;
> 
> 	spin_lock_irqsave(&xhci->lock, flags);
> 
> 	if (xhci->xhc_state & XHCI_STATE_DYING) {
> 		xhci_warn(xhci, "Abort the command ring,"
> 				" but the xHCI is dead.\n");
> 		retval = -ESHUTDOWN;
> 		goto fail;
> 	}
> 
> 	/* queue the cmd desriptor to cancel_cmd_list */
> 	retval = xhci_queue_cd(xhci, command, cmd_trb);
> 	if (retval) {
> 		xhci_warn(xhci, "Queuing command descriptor failed.\n");
> 		goto fail;
> 	}
> 
> 	/* abort command ring */
> 	retval = xhci_abort_cmd_ring(xhci);
> 	if (retval) {
> 		xhci_err(xhci, "Abort command ring failed\n");
> 		if (unlikely(retval == -ESHUTDOWN)) {
> 			spin_unlock_irqrestore(&xhci->lock, flags);
> 			usb_hc_died(xhci_to_hcd(xhci)->primary_hcd);
> 			xhci_dbg(xhci, "xHCI host controller is dead.\n");
> 			return retval;
> 		}
> 	}
> 
> fail:
> 	spin_unlock_irqrestore(&xhci->lock, flags);
> 	return retval;
> }
> 
1039a1160,1173
> /* Complete the command and detele it from the devcie's command queue.
>  */
> static void xhci_complete_cmd_in_cmd_wait_list(struct xhci_hcd *xhci,
> 		struct xhci_command *command, u32 status)
> {
> 	command->status = status;
> 	list_del(&command->cmd_list);
> 	if (command->completion)
> 		complete(command->completion);
> 	else
> 		xhci_free_command(xhci, command);
> }
> 
> 
1058,1063c1192,1193
< 	command->status = GET_COMP_CODE(le32_to_cpu(event->status));
< 	list_del(&command->cmd_list);
< 	if (command->completion)
< 		complete(command->completion);
< 	else
< 		xhci_free_command(xhci, command);
---
> 	xhci_complete_cmd_in_cmd_wait_list(xhci, command,
> 			GET_COMP_CODE(le32_to_cpu(event->status)));
1066a1197,1340
> /*
>  * Finding the command trb need to be cancelled and modifying it to
>  * NO OP command. And if the command is in device's command wait
>  * list, finishing and freeing it.
>  *
>  * If we can't find the command trb, we think it had already been
>  * executed.
>  */
> static void xhci_cmd_to_noop(struct xhci_hcd *xhci, struct xhci_cd *cur_cd)
> {
> 	struct xhci_segment *cur_seg;
> 	union xhci_trb *cmd_trb;
> 	u32 cycle_state;
> 
> 	if (xhci->cmd_ring->dequeue == xhci->cmd_ring->enqueue)
> 		return;
> 
> 	/* find the current segment of command ring */
> 	cur_seg = find_trb_seg(xhci->cmd_ring->first_seg,
> 			xhci->cmd_ring->dequeue, &cycle_state);
> 
> 	if (!cur_seg) {
> 		xhci_warn(xhci, "Command ring mismatch, dequeue = %p %llx (dma)\n",
> 				xhci->cmd_ring->dequeue,
> 				(unsigned long long)
> 				xhci_trb_virt_to_dma(xhci->cmd_ring->deq_seg,
> 					xhci->cmd_ring->dequeue));
> 		xhci_debug_ring(xhci, xhci->cmd_ring);
> 		xhci_dbg_ring_ptrs(xhci, xhci->cmd_ring);
> 		return;
> 	}
> 
> 	/* find the command trb matched by cd from command ring */
> 	for (cmd_trb = xhci->cmd_ring->dequeue;
> 			cmd_trb != xhci->cmd_ring->enqueue;
> 			next_trb(xhci, xhci->cmd_ring, &cur_seg, &cmd_trb)) {
> 		/* If the trb is link trb, continue */
> 		if (TRB_TYPE_LINK_LE32(cmd_trb->generic.field[3]))
> 			continue;
> 
> 		if (cur_cd->cmd_trb == cmd_trb) {
> 
> 			/* If the command in device's command list, we should
> 			 * finish it and free the command structure.
> 			 */
> 			if (cur_cd->command)
> 				xhci_complete_cmd_in_cmd_wait_list(xhci,
> 					cur_cd->command, COMP_CMD_STOP);
> 
> 			/* get cycle state from the origin command trb */
> 			cycle_state = le32_to_cpu(cmd_trb->generic.field[3])
> 				& TRB_CYCLE;
> 
> 			/* modify the command trb to NO OP command */
> 			cmd_trb->generic.field[0] = 0;
> 			cmd_trb->generic.field[1] = 0;
> 			cmd_trb->generic.field[2] = 0;
> 			cmd_trb->generic.field[3] = cpu_to_le32(
> 					TRB_TYPE(TRB_CMD_NOOP) | cycle_state);
> 			break;
> 		}
> 	}
> }
> 
> static void xhci_cancel_cmd_in_cd_list(struct xhci_hcd *xhci)
> {
> 	struct xhci_cd *cur_cd, *next_cd;
> 
> 	if (list_empty(&xhci->cancel_cmd_list))
> 		return;
> 
> 	list_for_each_entry_safe(cur_cd, next_cd,
> 			&xhci->cancel_cmd_list, cancel_cmd_list) {
> 		xhci_cmd_to_noop(xhci, cur_cd);
> 		list_del(&cur_cd->cancel_cmd_list);
> 		kfree(cur_cd);
> 	}
> }
> 
> /*
>  * traversing the cancel_cmd_list. If the command descriptor according
>  * to cmd_trb is found, the function free it and return 1, otherwise
>  * return 0.
>  */
> static int xhci_search_cmd_trb_in_cd_list(struct xhci_hcd *xhci,
> 		union xhci_trb *cmd_trb)
> {
> 	struct xhci_cd *cur_cd, *next_cd;
> 
> 	if (list_empty(&xhci->cancel_cmd_list))
> 		return 0;
> 
> 	list_for_each_entry_safe(cur_cd, next_cd,
> 			&xhci->cancel_cmd_list, cancel_cmd_list) {
> 		if (cur_cd->cmd_trb == cmd_trb) {
> 			if (cur_cd->command)
> 				xhci_complete_cmd_in_cmd_wait_list(xhci,
> 					cur_cd->command, COMP_CMD_STOP);
> 			list_del(&cur_cd->cancel_cmd_list);
> 			kfree(cur_cd);
> 			return 1;
> 		}
> 	}
> 
> 	return 0;
> }
> 
> /*
>  * If the cmd_trb_comp_code is COMP_CMD_ABORT, we just check whether the
>  * trb pointed by the command ring dequeue pointer is the trb we want to
>  * cancel or not. And if the cmd_trb_comp_code is COMP_CMD_STOP, we will
>  * traverse the cancel_cmd_list to trun the all of the commands according
>  * to command descriptor to NO-OP trb.
>  */
> static int handle_stopped_cmd_ring(struct xhci_hcd *xhci,
> 		int cmd_trb_comp_code)
> {
> 	int cur_trb_is_good = 0;
> 
> 	/* Searching the cmd trb pointed by the command ring dequeue
> 	 * pointer in command descriptor list. If it is found, free it.
> 	 */
> 	cur_trb_is_good = xhci_search_cmd_trb_in_cd_list(xhci,
> 			xhci->cmd_ring->dequeue);
> 
> 	if (cmd_trb_comp_code == COMP_CMD_ABORT)
> 		xhci->cmd_ring_state = CMD_RING_STATE_STOPPED;
> 	else if (cmd_trb_comp_code == COMP_CMD_STOP) {
> 		/* traversing the cancel_cmd_list and canceling
> 		 * the command according to command descriptor
> 		 */
> 		xhci_cancel_cmd_in_cd_list(xhci);
> 
> 		xhci->cmd_ring_state = CMD_RING_STATE_RUNNING;
> 		/*
> 		 * ring command ring doorbell again to restart the
> 		 * command ring
> 		 */
> 		if (xhci->cmd_ring->dequeue != xhci->cmd_ring->enqueue)
> 			xhci_ring_cmd_db(xhci);
> 	}
> 	return cur_trb_is_good;
> }
> 
1091a1366,1381
> 
> 	if ((GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_ABORT) ||
> 		(GET_COMP_CODE(le32_to_cpu(event->status)) == COMP_CMD_STOP)) {
> 		/* If the return value is 0, we think the trb pointed by
> 		 * command ring dequeue pointer is a good trb. The good
> 		 * trb means we don't want to cancel the trb, but it have
> 		 * been stopped by host. So we should handle it normally.
> 		 * Otherwise, driver should invoke inc_deq() and return.
> 		 */
> 		if (handle_stopped_cmd_ring(xhci,
> 				GET_COMP_CODE(le32_to_cpu(event->status)))) {
> 			inc_deq(xhci, xhci->cmd_ring, false);
> 			return;
> 		}
> 	}
> 
2218a2509,2510
> 			else
> 				kfree(urb_priv);
3326c3618
< 			field = TRB_TBC(burst_count) | TRB_TLBPC(residue);
---
> 			field = 0;
3328a3621,3622
> 				field = TRB_TBC(burst_count) |
> 					TRB_TLBPC(residue);
3359c3653,3655
< 				if (xhci->hci_version == 0x100) {
---
> 				if (xhci->hci_version == 0x100 &&
> 						!(xhci->quirks &
> 							XHCI_AVOID_BEI)) {




diff -r linux-3.0.36/drivers/usb/Kconfig linux-3.0.36-lenovo/drivers/usb/Kconfig
170a171,172
> source "drivers/usb/dwc_otg/Kconfig"
> 




diff -r linux-3.0.36/drivers/usb/Makefile linux-3.0.36-lenovo/drivers/usb/Makefile
52a53
> obj-$(CONFIG_DWC_OTG)		+= dwc_otg/




diff -r linux-3.0.36/drivers/usb/misc/emi62.c linux-3.0.36-lenovo/drivers/usb/misc/emi62.c
262c262
< static const struct usb_device_id id_table[] __devinitconst = {
---
> static const struct usb_device_id id_table[] = {




diff -r linux-3.0.36/drivers/usb/otg/Kconfig linux-3.0.36-lenovo/drivers/usb/otg/Kconfig
14a15,22
> config USB_OTG_WAKELOCK
> 	bool "Hold a wakelock when USB connected"
> 	depends on WAKELOCK
> 	select USB_OTG_UTILS
> 	help
> 	  Select this to automatically hold a wakelock when USB is
> 	  connected, preventing suspend.
> 




diff -r linux-3.0.36/drivers/usb/otg/Makefile linux-3.0.36-lenovo/drivers/usb/otg/Makefile
9a10,11
> obj-$(CONFIG_USB_OTG_WAKELOCK)	+= otg-wakelock.o
> obj-$(CONFIG_USB_OTG_UTILS)	+= otg_id.o
Only in linux-3.0.36-lenovo/drivers/usb/otg: otg_id.c
Only in linux-3.0.36-lenovo/drivers/usb/otg: otg-wakelock.c




diff -r linux-3.0.36/drivers/usb/otg/twl6030-usb.c linux-3.0.36-lenovo/drivers/usb/otg/twl6030-usb.c
32a33
> #include <linux/power_supply.h>
35a37,38
> //#include <plat/usb.h>
> 
66d68
< /* to be moved to LDO */
68d69
< #define TWL6030_CFG_LDO_PD2		0xF5
84a86,90
> #define SUSPEND_BOOT    (1 << 7)
> #define OPA_MODE        (1 << 6)
> #define HZ_MODE         (1 << 5)
> #define TERM            (1 << 4)
> 
88a95,97
> extern int get_gadget_connect_flag(void);
> 
> 
97a107,109
> 	/* used to set vbus, in atomic path */
> 	struct work_struct	set_vbus_work;
> 
99a112
> 	unsigned int		usb_cinlimit_mA;
101a115
> 	u8			prev_vbus;
102a117,118
> 	bool			vbus_enable;
> 	bool			is_phy_suspended;
188,189c204,210
< 	pdata->phy_suspend(dev, suspend);
< 
---
> 	if (suspend && !twl->is_phy_suspended) {
> 		pdata->phy_suspend(dev, 1);
> 		twl->is_phy_suspended = true;
> 	} else if (!suspend && twl->is_phy_suspended) {
> 		pdata->phy_suspend(dev, 0);
> 		twl->is_phy_suspended = false;
> 	}
208a230
> 	u8 misc2_data = 0;
210c232
< 	if (twl->features & TWL6025_SUBCLASS)
---
> 	if (twl->features & TWL6032_SUBCLASS)
218,223d239
< 	/* Program CFG_LDO_PD2 register and set VUSB bit */
< 	twl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x1, TWL6030_CFG_LDO_PD2);
< 
< 	/* Program MISC2 register and set bit VUSB_IN_VBAT */
< 	twl6030_writeb(twl, TWL6030_MODULE_ID0 , 0x10, TWL6030_MISC2);
< 
236a253,257
> 	/* Program MISC2 register and clear bit VUSB_IN_VBAT */
> 	misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0, TWL6030_MISC2);
> 	misc2_data &= 0xEF;
> 	twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data, TWL6030_MISC2);
> 
251,252c272,273
< 	       ret = snprintf(buf, PAGE_SIZE, "vbus\n");
< 	       break;
---
> 		ret = snprintf(buf, PAGE_SIZE, "vbus\n");
> 		break;
254,255c275,276
< 	       ret = snprintf(buf, PAGE_SIZE, "id\n");
< 	       break;
---
> 		ret = snprintf(buf, PAGE_SIZE, "id\n");
> 		break;
257,258c278,279
< 	       ret = snprintf(buf, PAGE_SIZE, "none\n");
< 	       break;
---
> 		ret = snprintf(buf, PAGE_SIZE, "none\n");
> 		break;
260c281
< 	       ret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");
---
> 		ret = snprintf(buf, PAGE_SIZE, "UNKNOWN\n");
272c293,294
< 	u8 vbus_state, hw_state;
---
> 	u8 vbus_state, hw_state, misc2_data;
> 	unsigned charger_type;
278,281c300,324
< 	if (!(hw_state & STS_USB_ID)) {
< 		if (vbus_state & VBUS_DET) {
< 			regulator_enable(twl->usb3v3);
< 			twl->asleep = 1;
---
> 	vbus_state = vbus_state & VBUS_DET;
> 
> 	/* Ignore charger events other than VBUS */
> 	if (vbus_state == twl->prev_vbus)
> 		return IRQ_HANDLED;
> 
> 	if ((vbus_state) && !(hw_state & STS_USB_ID)) {
> 		/* Program MISC2 register and set bit VUSB_IN_VBAT */
> 		misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
> 						TWL6030_MISC2);
> 		misc2_data |= 0x10;
> 		twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
> 						TWL6030_MISC2);
> 
> 		regulator_enable(twl->usb3v3);
> 		twl6030_phy_suspend(&twl->otg, 0);
> 		if(0 == get_gadget_connect_flag())
> 			charger_type = POWER_SUPPLY_TYPE_USB_DCP;
> 		else
> 			charger_type = POWER_SUPPLY_TYPE_USB;
> 		
> 		twl6030_phy_suspend(&twl->otg, 1);
> 		if ((charger_type == POWER_SUPPLY_TYPE_USB_CDP)
> 				|| (charger_type == POWER_SUPPLY_TYPE_USB)) {
> 
283a327
> 			twl->asleep = 1;
287,290c331,335
< 			atomic_notifier_call_chain(&twl->otg.notifier,
< 						status, twl->otg.gadget);
< 		} else {
< 			status = USB_EVENT_NONE;
---
> 		} else if (charger_type == POWER_SUPPLY_TYPE_USB_DCP) {
> 			regulator_disable(twl->usb3v3);
> 			status = USB_EVENT_CHARGER;
> 			twl->usb_cinlimit_mA = 1800;
> 			twl->otg.state = OTG_STATE_B_IDLE;
293,298c338,359
< 			atomic_notifier_call_chain(&twl->otg.notifier,
< 						status, twl->otg.gadget);
< 			if (twl->asleep) {
< 				regulator_disable(twl->usb3v3);
< 				twl->asleep = 0;
< 			}
---
> 		} else {
> 			regulator_disable(twl->usb3v3);
> 			goto vbus_notify;
> 		}
> 		atomic_notifier_call_chain(&twl->otg.notifier,
> 				status, &charger_type);
> 	}
> 	if (!vbus_state) {
> 		status = USB_EVENT_NONE;
> 		twl->linkstat = status;
> 		twl->otg.last_event = status;
> 		atomic_notifier_call_chain(&twl->otg.notifier,
> 				status, twl->otg.gadget);
> 		if (twl->asleep) {
> 			regulator_disable(twl->usb3v3);
> 			twl->asleep = 0;
> 			/* Program MISC2 register and clear bit VUSB_IN_VBAT */
> 			misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
> 							TWL6030_MISC2);
> 			misc2_data &= 0xEF;
> 			twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
> 							TWL6030_MISC2);
301d361
< 	sysfs_notify(&twl->dev->kobj, NULL, "vbus");
302a363,365
> vbus_notify:
> 	sysfs_notify(&twl->dev->kobj, NULL, "vbus");
> 	twl->prev_vbus = vbus_state;
307a371,372
> 
> #ifndef CONFIG_USB_MUSB_PERIPHERAL
310c375
< 	u8 hw_state;
---
> 	u8 hw_state, misc2_data;
315a381,389
> 		if (twl->otg.state == OTG_STATE_A_IDLE)
> 			return IRQ_HANDLED;
> 
> 		/* Program MISC2 register and set bit VUSB_IN_VBAT */
> 		misc2_data = twl6030_readb(twl, TWL6030_MODULE_ID0,
> 						TWL6030_MISC2);
> 		misc2_data |= 0x10;
> 		twl6030_writeb(twl, TWL6030_MODULE_ID0, misc2_data,
> 						TWL6030_MISC2);
318,320c392,393
< 		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR, 0x1);
< 		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,
< 								0x10);
---
> 		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_CLR);
> 		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_SET);
329,332c402,403
< 		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_CLR,
< 								0x10);
< 		twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET,
< 								0x1);
---
> 		twl6030_writeb(twl, TWL_MODULE_USB, 0x10, USB_ID_INT_EN_HI_CLR);
> 		twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);
334c405,406
< 	twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_LATCH_CLR, status);
---
> 	twl6030_writeb(twl, TWL_MODULE_USB, status, USB_ID_INT_LATCH_CLR);
> #endif
359c431
< 	twl6030_writeb(twl, TWL_MODULE_USB, USB_ID_INT_EN_HI_SET, 0x1);
---
> 	twl6030_writeb(twl, TWL_MODULE_USB, 0x1, USB_ID_INT_EN_HI_SET);
373c445
< static int twl6030_set_vbus(struct otg_transceiver *x, bool enabled)
---
> unsigned int twl6030_get_usb_max_power(struct otg_transceiver *x)
376a449,455
> 	return twl->usb_cinlimit_mA;
> }
> 
> static void otg_set_vbus_work(struct work_struct *data)
> {
> 	struct twl6030_usb *twl = container_of(data, struct twl6030_usb,
> 								set_vbus_work);
381c460
< 	if (enabled)
---
> 	if (twl->vbus_enable)
384c463
< 	 else
---
> 	else
386a466,498
> }
> 
> static int twl6030_set_hz_mode(struct otg_transceiver *x, bool enabled)
> {
> 	u8 val;
> 	struct twl6030_usb *twl;
> 
> 	if (!x)
> 		return -ENODEV;
> 
> 	twl = xceiv_to_twl(x);
> 
> 	/* set/reset USB charger in High impedence mode on VBUS */
> 	val = twl6030_readb(twl, TWL_MODULE_MAIN_CHARGE,
> 						CHARGERUSB_CTRL1);
> 
> 	if (enabled)
> 		val |= HZ_MODE;
> 	else
> 		val &= ~HZ_MODE;
> 
> 	twl6030_writeb(twl, TWL_MODULE_MAIN_CHARGE , val,
> 						CHARGERUSB_CTRL1);
> 
> 	return 0;
> }
> 
> static int twl6030_set_vbus(struct otg_transceiver *x, bool enabled)
> {
> 	struct twl6030_usb *twl = xceiv_to_twl(x);
> 
> 	twl->vbus_enable = enabled;
> 	schedule_work(&twl->set_vbus_work);
403a516,526
> static int twl6030_set_power(struct otg_transceiver *x, unsigned int mA)
> {
> 	struct twl6030_usb *twl = xceiv_to_twl(x);
> 
> 	twl->usb_cinlimit_mA = mA;
> 	if (mA && (twl->otg.last_event != USB_EVENT_NONE))
> 		atomic_notifier_call_chain(&twl->otg.notifier, USB_EVENT_ENUMERATED,
> 				&twl->usb_cinlimit_mA);
> 	return 0;
> }
> 
424a548
> 	twl->otg.set_hz_mode	= twl6030_set_hz_mode;
425a550
> 	twl->otg.set_power    = twl6030_set_power;
428a554
> 	twl->otg.state		= OTG_STATE_UNDEFINED;
446a573,575
> 	INIT_WORK(&twl->set_vbus_work, otg_set_vbus_work);
> 
> 	twl->vbus_enable = false;
471a601
> 	twl->is_phy_suspended = true;
496a627
> 	cancel_work_sync(&twl->set_vbus_work);




diff -r linux-3.0.36/drivers/usb/serial/cp210x.c linux-3.0.36-lenovo/drivers/usb/serial/cp210x.c
95a96
> 	{ USB_DEVICE(0x10C4, 0x815F) }, /* Timewave HamLinkUSB */
121a123
> 	{ USB_DEVICE(0x10C4, 0x85F8) }, /* Virtenio Preon32 */
136a139,140
> 	{ USB_DEVICE(0x166A, 0x0201) }, /* Clipsal 5500PACA C-Bus Pascal Automation Controller */
> 	{ USB_DEVICE(0x166A, 0x0301) }, /* Clipsal 5800PC C-Bus Wireless PC Interface */
137a142,145
> 	{ USB_DEVICE(0x166A, 0x0304) }, /* Clipsal 5000CT2 C-Bus Black and White Touchscreen */
> 	{ USB_DEVICE(0x166A, 0x0305) }, /* Clipsal C-5000CT2 C-Bus Spectrum Colour Touchscreen */
> 	{ USB_DEVICE(0x166A, 0x0401) }, /* Clipsal L51xx C-Bus Architectural Dimmer */
> 	{ USB_DEVICE(0x166A, 0x0101) }, /* Clipsal 5560884 C-Bus Multi-room Audio Matrix Switcher */
148a157,158
> 	{ USB_DEVICE(0x1E29, 0x0102) }, /* Festo CPX-USB */
> 	{ USB_DEVICE(0x1E29, 0x0501) }, /* Festo CMSP */
149a160,161
> 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
> 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */




diff -r linux-3.0.36/drivers/usb/serial/ftdi_sio.c linux-3.0.36-lenovo/drivers/usb/serial/ftdi_sio.c
197a198
> 	{ USB_DEVICE(NEWPORT_VID, NEWPORT_AGILIS_PID) },
584a586,587
> 	{ USB_DEVICE(FTDI_VID, FTDI_TIAO_UMPA_PID),
> 		.driver_info = (kernel_ulong_t)&ftdi_jtag_quirk },
587a591
> 	{ USB_DEVICE(FTDI_ELV_VID, FTDI_ELV_WS300_PID) },
673a678
> 	{ USB_DEVICE(FTDI_VID, FTDI_OMNI1509) },
704a710
> 	{ USB_DEVICE(FTDI_VID, FTDI_NZR_SEM_USB_PID) },
805c811,813
< 	{ USB_DEVICE(MICROCHIP_VID, MICROCHIP_USB_BOARD_PID) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MICROCHIP_VID, MICROCHIP_USB_BOARD_PID,
> 					USB_CLASS_VENDOR_SPEC,
> 					USB_SUBCLASS_VENDOR_SPEC, 0x00) },
810a819,825
> 	{ USB_DEVICE(FTDI_VID, PI_C865_PID) },
> 	{ USB_DEVICE(FTDI_VID, PI_C857_PID) },
> 	{ USB_DEVICE(PI_VID, PI_C866_PID) },
> 	{ USB_DEVICE(PI_VID, PI_C663_PID) },
> 	{ USB_DEVICE(PI_VID, PI_C725_PID) },
> 	{ USB_DEVICE(PI_VID, PI_E517_PID) },
> 	{ USB_DEVICE(PI_VID, PI_C863_PID) },
811a827,837
> 	{ USB_DEVICE(PI_VID, PI_C867_PID) },
> 	{ USB_DEVICE(PI_VID, PI_E609_PID) },
> 	{ USB_DEVICE(PI_VID, PI_E709_PID) },
> 	{ USB_DEVICE(PI_VID, PI_100F_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1011_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1012_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1013_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1014_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1015_PID) },
> 	{ USB_DEVICE(PI_VID, PI_1016_PID) },
> 	{ USB_DEVICE(KONDO_VID, KONDO_USB_SERIAL_PID) },
857a884,885
> 	/* Crucible Devices */
> 	{ USB_DEVICE(FTDI_VID, FTDI_CT_COMET_PID) },
1777c1805
< 	    (udev->product && !strcmp(udev->product, "BeagleBone/XDS100")))
---
> 	    (udev->product && !strcmp(udev->product, "BeagleBone/XDS100V2")))




diff -r linux-3.0.36/drivers/usb/serial/ftdi_sio_ids.h linux-3.0.36-lenovo/drivers/usb/serial/ftdi_sio_ids.h
77a78,80
> /* NZR SEM 16+ USB (http://www.nzr.de) */
> #define FTDI_NZR_SEM_USB_PID	0xC1E0	/* NZR SEM-LOG16+ */
> 
146a150,154
> /**
>  * Zolix (www.zolix.com.cb) product ids
>  */
> #define FTDI_OMNI1509			0xD491	/* Omni1509 embedded USB-serial */
> 
204c212
<  * All of these devices use FTDI's vendor ID (0x0403).
---
>  * Almost all of these devices use FTDI's vendor ID (0x0403).
211a220,221
> #define FTDI_ELV_VID	0x1B1F	/* ELV AG */
> #define FTDI_ELV_WS300_PID	0xC006	/* eQ3 WS 300 PC II */
516a527,531
> /*
>  * TIAO product ids (FTDI_VID)
>  * http://www.tiaowiki.com/w/Main_Page
>  */
> #define FTDI_TIAO_UMPA_PID	0x8a98	/* TIAO/DIYGADGET USB Multi-Protocol Adapter */
542c557,560
<  * MICROCHIP_VID (0x04D8) and MICROCHIP_USB_BOARD_PID (0x000A) are also used by:
---
>  * MICROCHIP_VID (0x04D8) and MICROCHIP_USB_BOARD_PID (0x000A) are
>  * used by single function CDC ACM class based firmware demo
>  * applications.  The VID/PID has also been used in firmware
>  * emulating FTDI serial chips by:
743a762,767
> /*
>  * Newport Cooperation (www.newport.com)
>  */
> #define NEWPORT_VID			0x104D
> #define NEWPORT_AGILIS_PID		0x3000
> 
793a818,821
> /* These two devices use the VID of FTDI */
> #define PI_C865_PID	0xe0a0  /* PI C-865 Piezomotor Controller */
> #define PI_C857_PID	0xe0a1  /* PI Encoder Trigger Box */
> 
795c823,845
< #define PI_E861_PID         0x1008  /* E-861 piezo controller USB connection */
---
> #define PI_C866_PID	0x1000  /* PI C-866 Piezomotor Controller */
> #define PI_C663_PID	0x1001  /* PI C-663 Mercury-Step */
> #define PI_C725_PID	0x1002  /* PI C-725 Piezomotor Controller */
> #define PI_E517_PID	0x1005  /* PI E-517 Digital Piezo Controller Operation Module */
> #define PI_C863_PID	0x1007  /* PI C-863 */
> #define PI_E861_PID	0x1008  /* PI E-861 Piezomotor Controller */
> #define PI_C867_PID	0x1009  /* PI C-867 Piezomotor Controller */
> #define PI_E609_PID	0x100D  /* PI E-609 Digital Piezo Controller */
> #define PI_E709_PID	0x100E  /* PI E-709 Digital Piezo Controller */
> #define PI_100F_PID	0x100F  /* PI Digital Piezo Controller */
> #define PI_1011_PID	0x1011  /* PI Digital Piezo Controller */
> #define PI_1012_PID	0x1012  /* PI Motion Controller */
> #define PI_1013_PID	0x1013  /* PI Motion Controller */
> #define PI_1014_PID	0x1014  /* PI Device */
> #define PI_1015_PID	0x1015  /* PI Device */
> #define PI_1016_PID	0x1016  /* PI Digital Servo Module */
> 
> /*
>  * Kondo Kagaku Co.Ltd.
>  * http://www.kondo-robot.com/EN
>  */
> #define KONDO_VID 		0x165c
> #define KONDO_USB_SERIAL_PID	0x0002
1218a1269,1274
> 
> /*
>  * Product: Comet Caller ID decoder
>  * Manufacturer: Crucible Technologies
>  */
> #define FTDI_CT_COMET_PID	0x8e08




diff -r linux-3.0.36/drivers/usb/serial/Kconfig linux-3.0.36-lenovo/drivers/usb/serial/Kconfig
663a664,671
> config USB_SERIAL_USI 
>  tristate "USB USI Serial driver" 
>  help 
>    Say Y here if you have a USI WCDMA modem that's connected to USB. 
>  
>    To compile this driver as a module, choose M here: the module will be called 
>    module will be called option. 
> 




diff -r linux-3.0.36/drivers/usb/serial/Makefile linux-3.0.36-lenovo/drivers/usb/serial/Makefile
62a63
> obj-$(CONFIG_USB_SERIAL_USI)			+= usiserial.o




diff -r linux-3.0.36/drivers/usb/serial/mct_u232.c linux-3.0.36-lenovo/drivers/usb/serial/mct_u232.c
580,585c580,587
< 	if (port->serial->dev) {
< 		/* shutdown our urbs */
< 		usb_kill_urb(port->write_urb);
< 		usb_kill_urb(port->read_urb);
< 		usb_kill_urb(port->interrupt_in_urb);
< 	}
---
> 	/*
> 	 * Must kill the read urb as it is actually an interrupt urb, which
> 	 * generic close thus fails to kill.
> 	 */
> 	usb_kill_urb(port->read_urb);
> 	usb_kill_urb(port->interrupt_in_urb);
> 
> 	usb_serial_generic_close(port);




diff -r linux-3.0.36/drivers/usb/serial/mos7840.c linux-3.0.36-lenovo/drivers/usb/serial/mos7840.c
238d237
< 	struct urb *int_urb;
243d241
< 	char zombie;
508d505
< 	int result = 0;
527c524
< 		goto exit;
---
> 		return;
540,550d536
< 
< exit:
< 	spin_lock(&mos7840_port->pool_lock);
< 	if (!mos7840_port->zombie)
< 		result = usb_submit_urb(mos7840_port->int_urb, GFP_ATOMIC);
< 	spin_unlock(&mos7840_port->pool_lock);
< 	if (result) {
< 		dev_err(&urb->dev->dev,
< 			"%s - Error %d submitting interrupt urb\n",
< 			__func__, result);
< 	}
658,665c644
< 				spin_lock(&mos7840_port->pool_lock);
< 				if (!mos7840_port->zombie) {
< 					rv = mos7840_get_reg(mos7840_port, wval, wreg, &Data);
< 				} else {
< 					spin_unlock(&mos7840_port->pool_lock);
< 					return;
< 				}
< 				spin_unlock(&mos7840_port->pool_lock);
---
> 				rv = mos7840_get_reg(mos7840_port, wval, wreg, &Data);
1194,1196c1173,1178
< 	for (i = 0; i < NUM_URBS; ++i)
< 		if (mos7840_port->busy[i])
< 			chars += URB_TRANSFER_BUFFER_SIZE;
---
> 	for (i = 0; i < NUM_URBS; ++i) {
> 		if (mos7840_port->busy[i]) {
> 			struct urb *urb = mos7840_port->write_urb_pool[i];
> 			chars += urb->transfer_buffer_length;
> 		}
> 	}
2595d2576
< 		serial->port[i] = NULL;
2608d2588
< 	unsigned long flags;
2626,2628d2605
< 			spin_lock_irqsave(&mos7840_port->pool_lock, flags);
< 			mos7840_port->zombie = 1;
< 			spin_unlock_irqrestore(&mos7840_port->pool_lock, flags);
2661a2639
> 			usb_free_urb(mos7840_port->control_urb);




diff -r linux-3.0.36/drivers/usb/serial/opticon.c linux-3.0.36-lenovo/drivers/usb/serial/opticon.c
163c163,167
< 	u8 buffer[2];
---
> 	u8 *buffer;
> 
> 	buffer = kzalloc(1, GFP_KERNEL);
> 	if (!buffer)
> 		return -ENOMEM;
171a176
> 	kfree(buffer);
295c300
< 		goto error;
---
> 		goto error_no_dr;
324a330,331
> 	kfree(dr);
> error_no_dr:




diff -r linux-3.0.36/drivers/usb/serial/option.c linux-3.0.36-lenovo/drivers/usb/serial/option.c
83,148c83,84
< #define HUAWEI_PRODUCT_E600			0x1001
< #define HUAWEI_PRODUCT_E220			0x1003
< #define HUAWEI_PRODUCT_E220BIS			0x1004
< #define HUAWEI_PRODUCT_E1401			0x1401
< #define HUAWEI_PRODUCT_E1402			0x1402
< #define HUAWEI_PRODUCT_E1403			0x1403
< #define HUAWEI_PRODUCT_E1404			0x1404
< #define HUAWEI_PRODUCT_E1405			0x1405
< #define HUAWEI_PRODUCT_E1406			0x1406
< #define HUAWEI_PRODUCT_E1407			0x1407
< #define HUAWEI_PRODUCT_E1408			0x1408
< #define HUAWEI_PRODUCT_E1409			0x1409
< #define HUAWEI_PRODUCT_E140A			0x140A
< #define HUAWEI_PRODUCT_E140B			0x140B
< #define HUAWEI_PRODUCT_E140C			0x140C
< #define HUAWEI_PRODUCT_E140D			0x140D
< #define HUAWEI_PRODUCT_E140E			0x140E
< #define HUAWEI_PRODUCT_E140F			0x140F
< #define HUAWEI_PRODUCT_E1410			0x1410
< #define HUAWEI_PRODUCT_E1411			0x1411
< #define HUAWEI_PRODUCT_E1412			0x1412
< #define HUAWEI_PRODUCT_E1413			0x1413
< #define HUAWEI_PRODUCT_E1414			0x1414
< #define HUAWEI_PRODUCT_E1415			0x1415
< #define HUAWEI_PRODUCT_E1416			0x1416
< #define HUAWEI_PRODUCT_E1417			0x1417
< #define HUAWEI_PRODUCT_E1418			0x1418
< #define HUAWEI_PRODUCT_E1419			0x1419
< #define HUAWEI_PRODUCT_E141A			0x141A
< #define HUAWEI_PRODUCT_E141B			0x141B
< #define HUAWEI_PRODUCT_E141C			0x141C
< #define HUAWEI_PRODUCT_E141D			0x141D
< #define HUAWEI_PRODUCT_E141E			0x141E
< #define HUAWEI_PRODUCT_E141F			0x141F
< #define HUAWEI_PRODUCT_E1420			0x1420
< #define HUAWEI_PRODUCT_E1421			0x1421
< #define HUAWEI_PRODUCT_E1422			0x1422
< #define HUAWEI_PRODUCT_E1423			0x1423
< #define HUAWEI_PRODUCT_E1424			0x1424
< #define HUAWEI_PRODUCT_E1425			0x1425
< #define HUAWEI_PRODUCT_E1426			0x1426
< #define HUAWEI_PRODUCT_E1427			0x1427
< #define HUAWEI_PRODUCT_E1428			0x1428
< #define HUAWEI_PRODUCT_E1429			0x1429
< #define HUAWEI_PRODUCT_E142A			0x142A
< #define HUAWEI_PRODUCT_E142B			0x142B
< #define HUAWEI_PRODUCT_E142C			0x142C
< #define HUAWEI_PRODUCT_E142D			0x142D
< #define HUAWEI_PRODUCT_E142E			0x142E
< #define HUAWEI_PRODUCT_E142F			0x142F
< #define HUAWEI_PRODUCT_E1430			0x1430
< #define HUAWEI_PRODUCT_E1431			0x1431
< #define HUAWEI_PRODUCT_E1432			0x1432
< #define HUAWEI_PRODUCT_E1433			0x1433
< #define HUAWEI_PRODUCT_E1434			0x1434
< #define HUAWEI_PRODUCT_E1435			0x1435
< #define HUAWEI_PRODUCT_E1436			0x1436
< #define HUAWEI_PRODUCT_E1437			0x1437
< #define HUAWEI_PRODUCT_E1438			0x1438
< #define HUAWEI_PRODUCT_E1439			0x1439
< #define HUAWEI_PRODUCT_E143A			0x143A
< #define HUAWEI_PRODUCT_E143B			0x143B
< #define HUAWEI_PRODUCT_E143C			0x143C
< #define HUAWEI_PRODUCT_E143D			0x143D
< #define HUAWEI_PRODUCT_E143E			0x143E
< #define HUAWEI_PRODUCT_E143F			0x143F
---
> #define HUAWEI_PRODUCT_E173			0x140C
> #define HUAWEI_PRODUCT_E140C                    0x140C
151,152d86
< #define HUAWEI_PRODUCT_E14AC			0x14AC
< #define HUAWEI_PRODUCT_K3806			0x14AE
154,161d87
< #define HUAWEI_PRODUCT_K5005			0x14C8
< #define HUAWEI_PRODUCT_K3770			0x14C9
< #define HUAWEI_PRODUCT_K3771			0x14CA
< #define HUAWEI_PRODUCT_K4510			0x14CB
< #define HUAWEI_PRODUCT_K4511			0x14CC
< #define HUAWEI_PRODUCT_ETS1220			0x1803
< #define HUAWEI_PRODUCT_E353			0x1506
< #define HUAWEI_PRODUCT_E173S			0x1C05
235a162
> #define NOVATELWIRELESS_PRODUCT_E362		0x9010
238a166
> #define NOVATELWIRELESS_PRODUCT_MC551		0xB001
269a198,200
> #define DELL_PRODUCT_5800_MINICARD_VZW		0x8195  /* Novatel E362 */
> #define DELL_PRODUCT_5800_V2_MINICARD_VZW	0x8196  /* Novatel E362 */
> 
314a246
> #define TELIT_PRODUCT_LE920			0x1200
323a256
> #define ZTE_PRODUCT_AC100			0x0094
359a293,294
> #define ALCATEL_PRODUCT_X220_X500D		0x0017
> #define ALCATEL_PRODUCT_L100V			0x011e
399a335
> #define HAIER_PRODUCT_IE701			0x1022
411a348,352
> /* Thinkwill products */
> #define THINKWILL_VENDOR_ID 	0x19f5
> #define THINKWILL_PRODUCT_ID	0x9909
> #define	THINKWILL_MI900_PRODUCT_ID	0x9013
> 
429a371,381
> /* leadcore LC1808*/
> #define LEADCORE_VENDOR_ID	0x1ab7
> #define LEADCORE_PRODUCT_LC1808	0x2200
> /**/
> #define SC8800G_VENDOR_ID	0x067b
> #define SC8800G_PRODUCT_ID	0x2303
> 
> /*usi mt6229 modem*/
> #define MT6229_VENDOR_ID			0x0e8d
> #define MT6229_PRODUCT_ID			0x00a0
> 
498a451,483
> #define MEDIATEK_PRODUCT_DC_1COM		0x00a0
> #define MEDIATEK_PRODUCT_DC_4COM		0x00a5
> #define MEDIATEK_PRODUCT_DC_4COM2		0x00a7
> #define MEDIATEK_PRODUCT_DC_5COM		0x00a4
> #define MEDIATEK_PRODUCT_7208_1COM		0x7101
> #define MEDIATEK_PRODUCT_7208_2COM		0x7102
> #define MEDIATEK_PRODUCT_7103_2COM		0x7103
> #define MEDIATEK_PRODUCT_7106_2COM		0x7106
> #define MEDIATEK_PRODUCT_FP_1COM		0x0003
> #define MEDIATEK_PRODUCT_FP_2COM		0x0023
> #define MEDIATEK_PRODUCT_FPDC_1COM		0x0043
> #define MEDIATEK_PRODUCT_FPDC_2COM		0x0033
> 
> /* Cellient products */
> #define CELLIENT_VENDOR_ID			0x2692
> #define CELLIENT_PRODUCT_MEN200			0x9005
> 
> /* Hyundai Petatel Inc. products */
> #define PETATEL_VENDOR_ID			0x1ff4
> #define PETATEL_PRODUCT_NP10T			0x600e
> 
> /* TP-LINK Incorporated products */
> #define TPLINK_VENDOR_ID			0x2357
> #define TPLINK_PRODUCT_MA180			0x0201
> 
> /* Changhong products */
> #define CHANGHONG_VENDOR_ID			0x2077
> #define CHANGHONG_PRODUCT_CH690			0x7001
> /* Strong Rising WCDMA modem*/
> #define STRONG_RISING_VENDOR_ID     0x21F5
> #define STRONG_RISING_PRODUCT_SPW9S  0x2012
> /* Strong Rising EVDO modem*/
> #define STRONG_RISING_PRODUCT_SP8J  0x2009
499a485
> static int viatelecom_send_setup(struct usb_serial_port *port);
551a538,541
> static const struct option_blacklist_info net_intf2_blacklist = {
> 	.reserved = BIT(2),
> };
> 
563a554,557
> static const struct option_blacklist_info net_intf6_blacklist = {
> 	.reserved = BIT(6),
> };
> 
568a563,571
> static const struct option_blacklist_info zte_1255_blacklist = {
> 	.reserved = BIT(3) | BIT(4),
> };
> 
> static const struct option_blacklist_info telit_le920_blacklist = {
> 	.sendsetup = BIT(0),
> 	.reserved = BIT(1) | BIT(5),
> };
> 
570a574,577
> 	{ USB_DEVICE(THINKWILL_VENDOR_ID,THINKWILL_PRODUCT_ID)},
> 
> 	{ USB_DEVICE(THINKWILL_VENDOR_ID,THINKWILL_MI900_PRODUCT_ID)},
> 
600,666c607,609
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E600, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E220, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E220BIS, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1401, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1402, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1403, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1404, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1405, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1406, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1407, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1408, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1409, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140A, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140B, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140C, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140D, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140E, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140F, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1410, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1411, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1412, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1413, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1414, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1415, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1416, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1417, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1418, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1419, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141A, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141B, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141C, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141D, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141E, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E141F, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1420, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1421, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1422, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1423, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1424, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1425, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1426, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1427, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1428, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1429, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142A, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142B, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142C, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142D, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142E, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E142F, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1430, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1431, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1432, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1433, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1434, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1435, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1436, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1437, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1438, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E1439, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143A, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143B, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143C, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143D, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143E, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E143F, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E173S, 0xff, 0xff, 0xff) },
---
>         { USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E140C, 0xff, 0xff, 0xff) },
> 	//{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E173, 0xff, 0xff, 0xff),
> 	//	.driver_info = (kernel_ulong_t) &net_intf1_blacklist },
671,673d613
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_ETS1220, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E14AC, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3806, 0xff, 0xff, 0xff) },
676,697c616,726
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4605, 0xff, 0x01, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4605, 0xff, 0x01, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K5005, 0xff, 0x01, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K5005, 0xff, 0x01, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K5005, 0xff, 0x01, 0x33) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3770, 0xff, 0x02, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3770, 0xff, 0x02, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3771, 0xff, 0x02, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K3771, 0xff, 0x02, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4510, 0xff, 0x01, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4510, 0xff, 0x01, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4511, 0xff, 0x01, 0x31) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4511, 0xff, 0x01, 0x32) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x01) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x02) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x03) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x10) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x12) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x01, 0x13) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x02, 0x01) },  /* E398 3G Modem */
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x02, 0x02) },  /* E398 3G PC UI Interface */
< 	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_E353, 0xff, 0x02, 0x03) },  /* E398 3G Application Interface */
---
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0xff, 0xff) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x01) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x02) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x03) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x04) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x05) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x06) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x0A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x0B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x0D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x0E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x0F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x10) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x12) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x13) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x14) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x15) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x17) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x18) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x19) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x1A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x1B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x1C) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x31) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x32) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x33) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x34) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x35) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x36) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x3A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x3B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x3D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x3E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x3F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x48) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x49) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x4A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x4B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x4C) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x61) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x62) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x63) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x64) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x65) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x66) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x6A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x6B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x6D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x6E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x6F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x78) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x79) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x7A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x7B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x01, 0x7C) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x01) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x02) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x03) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x04) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x05) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x06) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x0A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x0B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x0D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x0E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x0F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x10) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x12) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x13) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x14) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x15) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x17) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x18) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x19) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x1A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x1B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x1C) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x31) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x32) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x33) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x34) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x35) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x36) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x3A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x3B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x3D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x3E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x3F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x48) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x49) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x4A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x4B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x4C) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x61) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x62) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x63) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x64) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x65) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x66) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x6A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x6B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x6D) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x6E) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x6F) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x78) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x79) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x7A) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x7B) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, 0xff, 0x02, 0x7C) },
> 
> 
736a766,768
> 	/* Novatel Ovation MC551 a.k.a. Verizon USB551L */
> 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC551, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E362, 0xff, 0xff, 0xff) },
758a791,792
> 	{ USB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, DELL_PRODUCT_5800_MINICARD_VZW, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(DELL_VENDOR_ID, DELL_PRODUCT_5800_V2_MINICARD_VZW, 0xff, 0xff, 0xff) },
792a827,828
> 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
> 		.driver_info = (kernel_ulong_t)&telit_le920_blacklist },
893,894c929,932
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0118, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf5_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0121, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf5_blacklist },
896,899c934,941
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0123, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0124, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf5_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0125, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf6_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0126, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf5_blacklist },
900a943,946
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0135, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0136, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0137, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0139, 0xff, 0xff, 0xff) },
910,911c956,959
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0157, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf5_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0158, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf3_blacklist },
919,921c967,998
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0189, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0191, 0xff, 0xff, 0xff), /* ZTE EuFi890 */
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0196, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0197, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0199, 0xff, 0xff, 0xff), /* ZTE MF820S */
> 	  .driver_info = (kernel_ulong_t)&net_intf1_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0200, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0201, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0254, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0257, 0xff, 0xff, 0xff), /* ZTE MF821 */
> 	  .driver_info = (kernel_ulong_t)&net_intf3_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0265, 0xff, 0xff, 0xff), /* ONDA MT8205 */
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0284, 0xff, 0xff, 0xff), /* ZTE MF880 */
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0317, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0326, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0330, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0395, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0414, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0417, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1008, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1010, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1012, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1018, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1021, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf2_blacklist },
1037c1114,1115
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1245, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1039c1117,1118
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1247, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1044c1123,1124
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1252, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1046,1048c1126,1131
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1254, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1255, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&zte_1255_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1256, 0xff, 0xff, 0xff),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1092a1176,1189
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1301, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1302, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1303, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1333, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1401, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf2_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1402, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf2_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1424, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf2_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1425, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf2_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x1426, 0xff, 0xff, 0xff),  /* ZTE MF91 */
> 		.driver_info = (kernel_ulong_t)&net_intf2_blacklist },
1104,1106c1201,1206
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0130, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf1_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0133, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf3_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0141, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf5_blacklist },
1109c1209,1210
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0168, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1111,1112c1212,1215
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff) },
---
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0176, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf3_blacklist },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0178, 0xff, 0xff, 0xff),
> 		.driver_info = (kernel_ulong_t)&net_intf3_blacklist },
1116a1220,1224
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFED, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFFE, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xFFEB, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xF006, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_AC100)},
1123a1232,1235
> 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x01) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x05) },
> 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x86, 0x10) },
> 
1140a1253,1255
> 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X220_X500D) },
> 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_L100V),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
1175a1291,1378
> 	{ USB_DEVICE(LEADCORE_VENDOR_ID, LEADCORE_PRODUCT_LC1808) },  //zzc
> 	{ USB_DEVICE(SC8800G_VENDOR_ID,SC8800G_PRODUCT_ID)},
> 	{ USB_DEVICE(OLIVETTI_VENDOR_ID, OLIVETTI_PRODUCT_OLICARD100) },
> 	{ USB_DEVICE(CELOT_VENDOR_ID, CELOT_PRODUCT_CT680M) }, /* CT-650 CDMA 450 1xEVDO modem */
> 
> // cmy:
> 	{ USB_DEVICE(0x0685, 0x6000) },
> 	{ USB_DEVICE(0x1E89, 0x1E16) },
> 	{ USB_DEVICE(0x7693, 0x0001) },
> 	{ USB_DEVICE(0x1D09, 0x4308) },
> 	{ USB_DEVICE(0x1234, 0x0033) },
> 	{ USB_DEVICE(0xFEED, 0x0001) },
> 	{ USB_DEVICE(ALCATEL_VENDOR_ID, 0x0017) },
> 	{ USB_DEVICE(0x1C9E, 0x9E00) },
> 	{ USB_DEVICE(0x1C9E, 0xF000) },
> 	{ USB_DEVICE(0x19D2, 0x1303) },
> 	{ USB_DEVICE(0x19F5, 0x9013) }, // MW100
> 	{ USB_DEVICE(0x21F5, 0x2008) },
> 	{ USB_DEVICE(0x12D1, 0x1D09) },
> 	{ USB_DEVICE(0x04CC, 0x2259) },
> 	{ USB_DEVICE(0x04CC, 0x226E) },
> 	{ USB_DEVICE(0x04CC, 0x225A) },
> 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0015) },
> 	{ USB_DEVICE(ALCATEL_VENDOR_ID, 0x00b7) },
> 	{ USB_DEVICE(ZTE_VENDOR_ID, 0xFFFF) },
> 	{ USB_DEVICE(LEADCORE_VENDOR_ID, 0x5700) },
> 	{ USB_DEVICE(LEADCORE_VENDOR_ID, 0x6341) },
> 	{ USB_DEVICE(0x230D, 0x000D) },
> 	{ USB_DEVICE(0x0E8D, 0x00A2) },
> 	{ USB_DEVICE(0x1E89, 0x1A20) },
> 	{ USB_DEVICE(0x12D1, 0x1C05) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0007, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0167, 0xff, 0xff, 0xff) },
> 	{ USB_DEVICE(HUAWEI_VENDOR_ID, 0x14A8) },
> 	{ USB_DEVICE(0x20A6, 0x1105) },
> 	{ USB_DEVICE(0x1EE8, 0x005F) }, // Onda-MSA14.4
> 	{ USB_DEVICE(0x0421, 0x061E) }, // Nokia CS-11
> 	{ USB_DEVICE(0x0BDB, 0x190A) },
> 	{ USB_DEVICE(0x1d09, 0x1010) },
>     { USB_DEVICE(0x19D2, 0x1181) },
> 	{ USB_DEVICE(0x2020, 0x1005)},//S830 3G Dongle
> // cmy end
> //xxh
>    { USB_DEVICE_AND_INTERFACE_INFO(0x05c6, 0x1000, 0xff, 0xff, 0xff) },
>    { USB_DEVICE_AND_INTERFACE_INFO(0x05c6, 0x6000, 0xff, 0xff, 0xff) },
>    { USB_DEVICE_AND_INTERFACE_INFO(0x20A6, 0xF00E, 0xff, 0xff, 0xff) },
>    { USB_DEVICE_AND_INTERFACE_INFO(0x20A6, 0x1105, 0xff, 0xff, 0xff) },
>    { USB_DEVICE(0x21f5, 0x1101)},
>    { USB_DEVICE(0x230d,0x0101)},
>    { USB_DEVICE_AND_INTERFACE_INFO(0x230d, 0x1101, 0xff, 0xff, 0xff) },
>    { USB_DEVICE(0x2077,0xa000)},
>    { USB_DEVICE(0x1c9e,0x6061)},
>    { USB_DEVICE(0x1c9e,0x9605)},
>    { USB_DEVICE(0x19d2, 0x0170) },
>    { USB_DEVICE(0x19d2, 0xffe8) },
>    { USB_DEVICE(0x19D2,0x1177) },//K3770-Z
>    { USB_DEVICE(0x230D, 0x000c) },
>  //  { USB_DEVICE(0x21F5, 0x2009) },
>    {USB_DEVICE(STRONG_RISING_VENDOR_ID,STRONG_RISING_PRODUCT_SP8J)},
>    {USB_DEVICE(STRONG_RISING_VENDOR_ID,STRONG_RISING_PRODUCT_SPW9S)},
>    { USB_DEVICE(0x15eb,0x0001)},
>    { USB_DEVICE(0x12d1,0x14db) },
>    { USB_DEVICE(0x15EB,0x7152)},
>    { USB_DEVICE(0x15EB,0x0001)},
>    { USB_DEVICE(0x201E,0x1022)},
>    { USB_DEVICE(0x1A8D,0x2006)},
>    { USB_DEVICE(0x1C9E,0x9915)},
>    { USB_DEVICE(0x1C9E,0x9800)},
>    { USB_DEVICE(0x05c6,0x0016)},
>    { USB_DEVICE(0x0B3C,0xC00A)},
>    { USB_DEVICE(0x230D, 0x0103)},
>    { USB_DEVICE(0x1DBC,0x0669)},
>    { USB_DEVICE(0x2020,0x4000)},
>    { USB_DEVICE(0x230D, 0x0003)},
>    { USB_DEVICE(0x230D, 0x000C)},
>    { USB_DEVICE(0x12d1,0x1506)},
>    { USB_DEVICE(0x2001,0x7D00)},//D-Link DWM-156
>    { USB_DEVICE(0x0af0,0xd157)}, 
>    { USB_DEVICE(0x0421,0x0612)},
>    { USB_DEVICE(0x19d2,0x1218)},
>    { USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_IE701)},
>    { USB_DEVICE(0x1C9E,0x9914)},
>    { USB_DEVICE(0x19d2,0x1515)},
>    { USB_DEVICE(0x1bbb,0x0012)},
>    { USB_DEVICE(0x1c9e,0x9801)},
> //xxh end
> 
> 
1233a1437,1456
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_1COM, 0x0a, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_5COM, 0xff, 0x02, 0x01) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_5COM, 0xff, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM, 0xff, 0x02, 0x01) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM, 0xff, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_7208_1COM, 0x02, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_7208_2COM, 0x02, 0x02, 0x01) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_FP_1COM, 0x0a, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_FP_2COM, 0x0a, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_FPDC_1COM, 0x0a, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_FPDC_2COM, 0x0a, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_7103_2COM, 0xff, 0x00, 0x00) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_7106_2COM, 0x02, 0x02, 0x01) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM2, 0xff, 0x02, 0x01) },
> 	{ USB_DEVICE_AND_INTERFACE_INFO(MEDIATEK_VENDOR_ID, MEDIATEK_PRODUCT_DC_4COM2, 0xff, 0x00, 0x00) },
> 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
> 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T) },
> 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
> 	  .driver_info = (kernel_ulong_t)&net_intf4_blacklist },
> 	{ USB_DEVICE(CHANGHONG_VENDOR_ID, CHANGHONG_PRODUCT_CH690) },
1374a1598,1605
> 	/* Don't bind network interface on mt6229, it is handled by a separate module */
> 	if (serial->dev->descriptor.idVendor == MT6229_VENDOR_ID &&
> 		serial->dev->descriptor.idProduct == MT6229_PRODUCT_ID)
> 	{
> 		printk("%s:mt6229 exit\n",__func__);
> 		return -ENODEV;
> 	}
> 
1377a1609,1617
>       if ((serial->dev->descriptor.idVendor == HAIER_VENDOR_ID &&
> 			  serial->dev->descriptor.idProduct == HAIER_PRODUCT_IE701)||
> 			  (serial->dev->descriptor.idVendor == 0x15EB &&
> 			  serial->dev->descriptor.idProduct == 0x7152)) {   
> 			     
> 			    data->send_setup = viatelecom_send_setup;
> 				
> 		 }else
> 
1399a1640
> 	static int err_times = 0;
1404a1646
> 		err_times = 0;
1438,1440c1680,1690
< 	} else
< 		err("%s: error %d", __func__, status);
< 
---
> 	}
> 	else{
> 		if(status == -EPROTO && err_times++ >10){
> 			err_times = 0;
> 			printk("%s,recieve -71 error more than 10 times,so reset usb\n",__FUNCTION__);
> 			usb_queue_reset_device(port->serial->interface);
> 			return;
> 		}else		
> 			err("%s : error %d",__func__, status);
> 	}
> 	
1478,1480c1728,1755
< 	return usb_control_msg(serial->dev,
< 		usb_rcvctrlpipe(serial->dev, 0),
< 		0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
---
>  return usb_control_msg(serial->dev,
>         usb_rcvctrlpipe(serial->dev, 0),
>          0x22, 0x21, val, ifNum, NULL, 0, USB_CTRL_SET_TIMEOUT);
>  }
> 		
> static int viatelecom_send_setup(struct usb_serial_port *port)
> {
> 			struct usb_serial *serial = port->serial;
> 		    struct usb_wwan_port_private *portdata = usb_get_serial_port_data(port);
> 		    int ifNum = serial->interface->cur_altsetting->desc.bInterfaceNumber;
> 			dbg("%s", __func__);
> #if 0
> 			usb_control_msg(serial->dev,
> 		    usb_sndctrlpipe(serial->dev, 0),
> 		    0x01, 0x40, 0, ifNum,
> 		    NULL, 0, USB_CTRL_SET_TIMEOUT);
> 			/* VIA-Telecom CBP DTR format */
> 			return usb_control_msg(serial->dev,
> 	        usb_sndctrlpipe(serial->dev, 0),
> 		    0x01, 0x40, 1, ifNum,
> 		    NULL, 0, USB_CTRL_SET_TIMEOUT);
> #else
> 		/* VIA-Telecom CBP DTR format */
> 		   return usb_control_msg(serial->dev,
> 	       usb_sndctrlpipe(serial->dev, 0),
> 		   0x01, 0x40, portdata->dtr_state? 1: 0, ifNum,
> 		   NULL, 0, USB_CTRL_SET_TIMEOUT);
> #endif




diff -r linux-3.0.36/drivers/usb/serial/qcaux.c linux-3.0.36-lenovo/drivers/usb/serial/qcaux.c
39,40d38
< #define PANTECH_PRODUCT_UML190_VZW		0x3716
< #define PANTECH_PRODUCT_UML290_VZW		0x3718
71,75c69,71
< 	{ USB_DEVICE_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, PANTECH_PRODUCT_UML190_VZW, 0xff, 0xff, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, PANTECH_PRODUCT_UML190_VZW, 0xff, 0xfe, 0xff) },
< 	{ USB_DEVICE_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, PANTECH_PRODUCT_UML290_VZW, 0xff, 0xfd, 0xff) },  /* NMEA */
< 	{ USB_DEVICE_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, PANTECH_PRODUCT_UML290_VZW, 0xff, 0xfe, 0xff) },  /* WMC */
< 	{ USB_DEVICE_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, PANTECH_PRODUCT_UML290_VZW, 0xff, 0xff, 0xff) },  /* DIAG */
---
> 	{ USB_VENDOR_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, 0xff, 0xfd, 0xff) },  /* NMEA */
> 	{ USB_VENDOR_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, 0xff, 0xfe, 0xff) },  /* WMC */
> 	{ USB_VENDOR_AND_INTERFACE_INFO(UTSTARCOM_VENDOR_ID, 0xff, 0xff, 0xff) },  /* DIAG */




diff -r linux-3.0.36/drivers/usb/serial/qcserial.c linux-3.0.36-lenovo/drivers/usb/serial/qcserial.c
56a57
> 	{DEVICE_G1K(0x1bc7, 0x900e)},	/* Telit Gobi QDL device */




diff -r linux-3.0.36/drivers/usb/serial/sierra.c linux-3.0.36-lenovo/drivers/usb/serial/sierra.c
174d173
< 	struct sierra_intf_private *data;
202,206d200
< 	data = serial->private = kzalloc(sizeof(struct sierra_intf_private), GFP_KERNEL);
< 	if (!data)
< 		return -ENOMEM;
< 	spin_lock_init(&data->susp_lock);
< 
917a912
> 	struct sierra_intf_private *intfdata;
924a920,927
> 	intfdata = kzalloc(sizeof(*intfdata), GFP_KERNEL);
> 	if (!intfdata)
> 		return -ENOMEM;
> 
> 	spin_lock_init(&intfdata->susp_lock);
> 
> 	usb_set_serial_data(serial, intfdata);
> 
940c943
< 			return -ENOMEM;
---
> 			goto err;
976a980,987
> err:
> 	for (--i; i >= 0; --i) {
> 		portdata = usb_get_serial_port_data(serial->port[i]);
> 		kfree(portdata);
> 	}
> 	kfree(intfdata);
> 
> 	return -ENOMEM;
995a1007
> 	kfree(serial->private);




diff -r linux-3.0.36/drivers/usb/serial/usb-serial.c linux-3.0.36-lenovo/drivers/usb/serial/usb-serial.c
55a56,71
> #if defined(CONFIG_MU509) || defined(CONFIG_BP_AUTO_MU509)
> static int MU509_USB = 0;
> #define MU509_USB_PORT     (SERIAL_TTY_MINORS - 10)
> #endif
> #if defined(CONFIG_MW100) || defined(CONFIG_BP_AUTO_MW100)
> static int MW100_USB = 0;
> #define MW100_USB_PORT     (SERIAL_TTY_MINORS - 10)
> #endif
> #if defined(CONFIG_MT6229) || defined(CONFIG_BP_AUTO_MT6229)
> static int MT6229_USB = 0;
> #define MT6229_USB_PORT     (SERIAL_TTY_MINORS - 10)
> #endif
> #if defined(CONFIG_SEW868) || defined(CONFIG_BP_AUTO_SEW868)
> static int SEW868_USB = 0;
> #define SEW868_USB_PORT     (SERIAL_TTY_MINORS - 10)
> #endif
99a116
> 	int a=0;
105c122,138
< 	for (i = 0; i < SERIAL_TTY_MINORS; ++i) {
---
> #if defined(CONFIG_MU509) || defined(CONFIG_BP_AUTO_MU509)
> 	if (MU509_USB)
> 		a= MU509_USB_PORT;
> #endif
> #if defined(CONFIG_MW100) || defined(CONFIG_BP_AUTO_MW100)
> 	if (MW100_USB)		
> 		a= MW100_USB_PORT;
> #endif
> #if defined(CONFIG_MT6229) || defined(CONFIG_BP_AUTO_MT6229)
> 	if (MT6229_USB)		
> 		a= MT6229_USB_PORT;
> #endif
> #if defined(CONFIG_SEW868) || defined(CONFIG_BP_AUTO_SEW868)
> 	if (SEW868_USB)		
> 		a= SEW868_USB_PORT;
> #endif
> 	for (i = a; i < SERIAL_TTY_MINORS; ++i) {
767c800
< 			kfree(serial);
---
> 			usb_serial_put(serial);
839c872
< 			kfree(serial);
---
> 			usb_serial_put(serial);
853c886
< 			kfree(serial);
---
> 			usb_serial_put(serial);
1062a1096,1119
> #if defined(CONFIG_MU509) || defined(CONFIG_BP_AUTO_MU509)
> 		if ((le16_to_cpu(dev->descriptor.idVendor) == 0x12D1 ) && (le16_to_cpu(dev->descriptor.idProduct) == 0x1001))
> 			MU509_USB =1;
> 		else
> 			MU509_USB = 0;
> #endif
> #if defined(CONFIG_MW100) || defined(CONFIG_BP_AUTO_MW100)
> 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x19f5) && (le16_to_cpu(dev->descriptor.idProduct) == 0x9013))			
> 		MW100_USB =1;		
> 	else			
> 		MW100_USB = 0;
> #endif
> #if defined(CONFIG_MT6229) || defined(CONFIG_BP_AUTO_MT6229)
> 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x0E8D) && (le16_to_cpu(dev->descriptor.idProduct) == 0x00A2))			
> 		MT6229_USB =1;		
> 	else			
> 		MT6229_USB = 0;
> #endif
> #if defined(CONFIG_SEW868) || defined(CONFIG_BP_AUTO_SEW868)
> 	if ((le16_to_cpu(dev->descriptor.idVendor) == 0x19d2) && (le16_to_cpu(dev->descriptor.idProduct) == 0xffeb))			
> 		SEW868_USB =1;		
> 	else			
> 		SEW868_USB = 0;
> #endif
Only in linux-3.0.36-lenovo/drivers/usb/serial: usiserial.c




diff -r linux-3.0.36/drivers/usb/serial/whiteheat.c linux-3.0.36-lenovo/drivers/usb/serial/whiteheat.c
578a579
> 	kfree(command);




diff -r linux-3.0.36/drivers/usb/storage/initializers.c linux-3.0.36-lenovo/drivers/usb/storage/initializers.c
95,96c95,96
< /* This places the HUAWEI E220 devices in multi-port mode */
< int usb_stor_huawei_e220_init(struct us_data *us)
---
> /* This places the HUAWEI usb dongles in multi-port mode */
> static int usb_stor_huawei_feature_init(struct us_data *us)
105a106,192
> }
> 
> /*
>  * It will send a scsi switch command called rewind' to huawei dongle.
>  * When the dongle receives this command at the first time,
>  * it will reboot immediately. After rebooted, it will ignore this command.
>  * So it is  unnecessary to read its response.
>  */
> static int usb_stor_huawei_scsi_init(struct us_data *us)
> {
> 	int result = 0;
> 	int act_len = 0;
> 	struct bulk_cb_wrap *bcbw = (struct bulk_cb_wrap *) us->iobuf;
> 	char rewind_cmd[] = {0x11, 0x06, 0x20, 0x00, 0x00, 0x01, 0x01, 0x00,
> 			0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
> 
> 	bcbw->Signature = cpu_to_le32(US_BULK_CB_SIGN);
> 	bcbw->Tag = 0;
> 	bcbw->DataTransferLength = 0;
> 	bcbw->Flags = bcbw->Lun = 0;
> 	bcbw->Length = sizeof(rewind_cmd);
> 	memset(bcbw->CDB, 0, sizeof(bcbw->CDB));
> 	memcpy(bcbw->CDB, rewind_cmd, sizeof(rewind_cmd));
> 
> 	result = usb_stor_bulk_transfer_buf(us, us->send_bulk_pipe, bcbw,
> 					US_BULK_CB_WRAP_LEN, &act_len);
> 	US_DEBUGP("transfer actual length=%d, result=%d\n", act_len, result);
> 	return result;
> }
> 
> /*
>  * It tries to find the supported Huawei USB dongles.
>  * In Huawei, they assign the following product IDs
>  * for all of their mobile broadband dongles,
>  * including the new dongles in the future.
>  * So if the product ID is not included in this list,
>  * it means it is not Huawei's mobile broadband dongles.
>  */
> static int usb_stor_huawei_dongles_pid(struct us_data *us)
> {
> 	struct usb_interface_descriptor *idesc;
> 	int idProduct;
> 
> 	idesc = &us->pusb_intf->cur_altsetting->desc;
> 	idProduct = us->pusb_dev->descriptor.idProduct;
> 	/* The first port is CDROM,
> 	 * means the dongle in the single port mode,
> 	 * and a switch command is required to be sent. */
> 	if (idesc && idesc->bInterfaceNumber == 0) {
> 		if ((idProduct == 0x1001)
> 			|| (idProduct == 0x1003)
> 			|| (idProduct == 0x1004)
> 			|| (idProduct >= 0x1401 && idProduct <= 0x1500)
> 			|| (idProduct >= 0x1505 && idProduct <= 0x1600)
> 			|| (idProduct >= 0x1c02 && idProduct <= 0x2202)) {
> 			return 1;
> 		}
> 	}
> 	return 0;
> }
> 
> int usb_stor_huawei_init(struct us_data *us)
> {
> 	int result = 0;
> 
> 	if (usb_stor_huawei_dongles_pid(us)) {
> 		if (us->pusb_dev->descriptor.idProduct >= 0x1446)
> 			result = usb_stor_huawei_scsi_init(us);
> 		else
> 			result = usb_stor_huawei_feature_init(us);
> 	}
> 	return result;
> }
> 
> int usb_stor_zte_k4505_init(struct us_data *us)
>  {
> 		int result = 0;
> 		int act_len = 0;
> 		unsigned char cmd[32] = {
> 				 0x55,0x53,0x42,0x43,0x12,0x34,0x56,0x78,
> 				 0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x1b,
> 				 0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,
> 				 0x00,0x00,0x00,0x00,0x00,0x00,0x00
> 				 };
> 		result = usb_stor_bulk_transfer_buf (us, us->send_bulk_pipe, cmd, 31,&act_len);
> 	    printk("usb_stor_bulk_transfer_buf performing result is %d, transfer the actual length=%d\n", result, act_len);
> 		return (result ? 0 : -ENODEV);




diff -r linux-3.0.36/drivers/usb/storage/initializers.h linux-3.0.36-lenovo/drivers/usb/storage/initializers.h
49,50c49,52
< /* This places the HUAWEI E220 devices in multi-port mode */
< int usb_stor_huawei_e220_init(struct us_data *us);
---
> /* This places the HUAWEI usb dongles in multi-port mode */
> int usb_stor_huawei_init(struct us_data *us);
> 
> int usb_stor_zte_k4505_init(struct us_data *us);




diff -r linux-3.0.36/drivers/usb/storage/Kconfig linux-3.0.36-lenovo/drivers/usb/storage/Kconfig
202c202
< 	depends on USB && SCSI
---
> 	depends on USB && SCSI && BROKEN




diff -r linux-3.0.36/drivers/usb/storage/unusual_devs.h linux-3.0.36-lenovo/drivers/usb/storage/unusual_devs.h
1006a1007,1012
> /* Submitted by Oleksandr Chumachenko <ledest@gmail.com> */
> UNUSUAL_DEV( 0x07cf, 0x1167, 0x0100, 0x0100,
> 		"Casio",
> 		"EX-N1 DigitalCamera",
> 		USB_SC_8070, USB_PR_DEVICE, NULL, 0),
> 
1512,1552c1518
< UNUSUAL_DEV(  0x12d1, 0x1001, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1003, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1004, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1401, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1402, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1403, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1404, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1405, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1406, 0x0000, 0x0000,
---
> UNUSUAL_VENDOR_INTF(0x12d1, 0x08, 0x06, 0x50,
1555,1840c1521
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1407, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1408, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1409, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140A, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140B, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140C, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140D, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140E, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x140F, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1410, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1411, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1412, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1413, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1414, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1415, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1416, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1417, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1418, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1419, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141A, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141B, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141C, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141D, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141E, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x141F, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1420, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1421, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1422, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1423, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1424, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1425, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1426, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1427, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1428, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1429, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142A, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142B, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142C, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142D, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142E, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x142F, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1430, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1431, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1432, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1433, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1434, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1435, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1436, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1437, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1438, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x1439, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143A, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143B, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143C, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143D, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143E, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
< 		0),
< UNUSUAL_DEV(  0x12d1, 0x143F, 0x0000, 0x0000,
< 		"HUAWEI MOBILE",
< 		"Mass Storage",
< 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_e220_init,
---
> 		USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_huawei_init,
1841a1523,1538
> 
> UNUSUAL_DEV(0x19d2, 0x1007, 0x0000, 0xffff,
>          "ZTE EJECT CDROM",
>          "USB MMC Storage",
>          USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
>         0),
> UNUSUAL_DEV(0x19d2, 0x1175, 0x0000, 0xffff,
>           "ZTE EJECT CDROM",
>           "USB MMC Storage",
>           USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
>          0),
> UNUSUAL_DEV(0x19d2, 0x0101, 0x0000, 0xffff,
>           "ZTE EJECT CDROM",
> 		  "USB MMC Storage",
>           USB_SC_DEVICE, USB_PR_DEVICE, usb_stor_zte_k4505_init,
>          0),




diff -r linux-3.0.36/drivers/usb/storage/usb.c linux-3.0.36-lenovo/drivers/usb/storage/usb.c
60a61
> #include <linux/wakelock.h>
88a90
> static struct wake_lock usb_storage_wakelock;
122a125,135
> #define UNUSUAL_VENDOR_INTF(idVendor, cl, sc, pr, \
> 		vendor_name, product_name, use_protocol, use_transport, \
> 		init_function, Flags) \
> { \
> 	.vendorName = vendor_name,	\
> 	.productName = product_name,	\
> 	.useProtocol = use_protocol,	\
> 	.useTransport = use_transport,	\
> 	.initFunction = init_function,	\
> }
> 
130a144
> #undef UNUSUAL_VENDOR_INTF
899a914,915
> 	wake_lock_timeout(&usb_storage_wakelock, (8*HZ));
> 
1062a1079
> 		wake_lock_init(&usb_storage_wakelock, WAKE_LOCK_SUSPEND, "usb_storage_wakelock");
1078a1096,1098
> 
> 	wake_lock_destroy(&usb_storage_wakelock);
> 




diff -r linux-3.0.36/drivers/usb/storage/usual-tables.c linux-3.0.36-lenovo/drivers/usb/storage/usual-tables.c
48a49,62
> /* Define the device is matched with Vendor ID and interface descriptors */
> #define UNUSUAL_VENDOR_INTF(id_vendor, cl, sc, pr, \
> 			vendorName, productName, useProtocol, useTransport, \
> 			initFunction, flags) \
> { \
> 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
> 				| USB_DEVICE_ID_MATCH_VENDOR, \
> 	.idVendor    = (id_vendor), \
> 	.bInterfaceClass = (cl), \
> 	.bInterfaceSubClass = (sc), \
> 	.bInterfaceProtocol = (pr), \
> 	.driver_info = (flags) \
> }
> 
59a74
> #undef UNUSUAL_VENDOR_INTF




diff -r linux-3.0.36/drivers/vhost/net.c linux-3.0.36-lenovo/drivers/vhost/net.c
308c308,309
< 	int err, headcount, mergeable;
---
> 	int err, mergeable;
> 	s16 headcount;




diff -r linux-3.0.36/drivers/vhost/vhost.c linux-3.0.36-lenovo/drivers/vhost/vhost.c
219a220,221
> 			if (need_resched())
> 				schedule();
Only in linux-3.0.36-lenovo/drivers/video/backlight: aw9364_bl.c
Only in linux-3.0.36-lenovo/drivers/video/backlight: aw9364_bl.h
Only in linux-3.0.36-lenovo/drivers/video/backlight: fih_touchkey_led.c




diff -r linux-3.0.36/drivers/video/backlight/Kconfig linux-3.0.36-lenovo/drivers/video/backlight/Kconfig
292a293,325
> config BACKLIGHT_RK2818_BL
>         bool "rk2818 backlight driver"
> 	depends on BACKLIGHT_CLASS_DEVICE && ARCH_RK2818
> 	default y
> 	help
> 	  rk2818 backlight support.
> 	  
> config BACKLIGHT_RK29_BL
>         bool "rk backlight driver"
> 	depends on BACKLIGHT_CLASS_DEVICE && PLAT_RK
> 	default y
> 	help
> 	  rk29 backlight support.	  
> 
> config FIH_TOUCHKEY_LED
>         bool "fih touch key led driver"
> 	depends on BACKLIGHT_CLASS_DEVICE && ARCH_RK29
> 	help
> 	  fih touch key led support.
> 
> config BACKLIGHT_AW9364
>         bool "aw9364 backlight driver"
> 	depends on BACKLIGHT_CLASS_DEVICE
> 	help
> 	  aw9364 backlight support.	 
> 
> config BUTTON_LIGHT
>         bool "rk29 button light driver"
> 	depends on BACKLIGHT_CLASS_DEVICE
> 	default n
> 	help
> 	  rk29 button light support.	  
>  




diff -r linux-3.0.36/drivers/video/backlight/Makefile linux-3.0.36-lenovo/drivers/video/backlight/Makefile
35a36,39
> obj-$(CONFIG_BACKLIGHT_RK29_BL)	+= rk29_backlight.o
> obj-$(CONFIG_BACKLIGHT_AW9364)	+= aw9364_bl.o
> obj-$(CONFIG_FIH_TOUCHKEY_LED)	+= fih_touchkey_led.o
> obj-$(CONFIG_BUTTON_LIGHT)	+= rk29_buttonlight.o
Only in linux-3.0.36-lenovo/drivers/video/backlight: rk29_backlight.c
Only in linux-3.0.36-lenovo/drivers/video/backlight: rk29_buttonlight.c




diff -r linux-3.0.36/drivers/video/backlight/wm831x_bl.c linux-3.0.36-lenovo/drivers/video/backlight/wm831x_bl.c
21c21,28
< 
---
> #ifdef CONFIG_HAS_EARLYSUSPEND
> #include <linux/earlysuspend.h>
> #endif
> #include <linux/delay.h>
> #include <linux/ktime.h>
> #define BL_SET   255
> #define BL_MISC_VALUE 20
> #define BL_INIT_VALUE 102
25a33,38
> #ifdef CONFIG_HAS_EARLYSUSPEND
> 	struct 	early_suspend early_suspend;
> 	struct delayed_work work;
> 	int suspend_flag;
> 	int shutdown_flag;
> #endif
27c40,46
< 
---
> #define TS_POLL_DELAY (10000*1000*1000)
> int wm831x_bright = 0;
> int max_tp = 0;
> #ifdef CONFIG_HAS_EARLYSUSPEND
> static struct backlight_device *gwm831x_bl;
> static struct wm831x_backlight_data *gwm831x_data;
> #endif
32,33c51,54
< 	int power_up = !data->current_brightness && brightness;
< 	int power_down = data->current_brightness && !brightness;
---
> //	int power_up = !data->current_brightness && brightness;
> //	int power_down = data->current_brightness && !brightness;
> 	int power_up;
> 	int power_down;
34a56
> 	int bright_tp;
35a58,60
> 	bright_tp =( max_tp*brightness)/BL_SET;
> 	power_up =!data->current_brightness && bright_tp;
> 	power_down = data->current_brightness && !bright_tp;
66c91
< 			      WM831X_CS1_ISEL_MASK, brightness);
---
> 			      WM831X_CS1_ISEL_MASK, bright_tp);
96a122,130
> 	if (brightness<=BL_MISC_VALUE) {
> 		brightness = 8*brightness;
> 	}
> 	else if (brightness<=BL_INIT_VALUE) {
> 		brightness = 31*brightness/41 + 145;
> 	}
> 	else {
> 		brightness = 33*brightness/153 + 200;
> 	}
97a132,136
> 	if(gwm831x_data->suspend_flag == 1)
> 		brightness = 0;
> 	if (gwm831x_data->shutdown_flag == 1)
> 		brightness = 0;
> 		
106a146,147
> 	printk("backlight brightness=%d\n", brightness);
> 
116c157
< static const struct backlight_ops wm831x_backlight_ops = {
---
> static struct backlight_ops wm831x_backlight_ops = {
120a162,195
> #ifdef CONFIG_HAS_EARLYSUSPEND
> static void wm831x_bl_work(struct work_struct *work)
> {
> 	//struct wm831x_backlight_data *wm831x_data = container_of(work, struct wm831x_backlight_data,
> 						   //work.work);
> 	backlight_update_status(gwm831x_bl);
> }
> 
> static void wm831x_bl_suspend(struct early_suspend *h)
> {
> 	struct wm831x_backlight_data *wm831x_data;
> 	wm831x_data = container_of(h, struct wm831x_backlight_data, early_suspend);
> 	wm831x_data->suspend_flag = 1;
> 
> 	schedule_delayed_work(&wm831x_data->work, msecs_to_jiffies(100));		
> }
> 
> 
> static void wm831x_bl_resume(struct early_suspend *h)
> {
> 	struct wm831x_backlight_data *wm831x_data;
> 	wm831x_data = container_of(h, struct wm831x_backlight_data, early_suspend);
> 	wm831x_data->suspend_flag = 0;
> 	
> 	schedule_delayed_work(&wm831x_data->work, msecs_to_jiffies(100));
> }
> 
> #endif
> 
> int rk29_backlight_ctrl(int open)
> {
> 	gwm831x_data->suspend_flag = !open;
> 	schedule_delayed_work(&gwm831x_data->work, 0);
> }
156c231
< 
---
> 	max_tp = max_isel;
196d270
< 	props.type = BACKLIGHT_RAW;
199c273
< 				       &wm831x_backlight_ops, &props);
---
> 				       &wm831x_backlight_ops,NULL);
206c280,281
< 	bl->props.brightness = max_isel;
---
> 	bl->props.brightness = BL_INIT_VALUE;
> 	bl->props.max_brightness= BL_SET;
209a285,295
> #ifdef CONFIG_HAS_EARLYSUSPEND	
> 	data->early_suspend.level = ~0x0;
> 	data->early_suspend.suspend = wm831x_bl_suspend;
> 	data->early_suspend.resume = wm831x_bl_resume;
> 	register_early_suspend(&data->early_suspend);
> 	INIT_DELAYED_WORK(&data->work, wm831x_bl_work);
> 	gwm831x_bl = bl;
> 	gwm831x_data = data;
> #endif
> 
> 
213,214c299,300
< 
< 	backlight_update_status(bl);
---
> 	//backlight_update_status(bl);
> 	schedule_delayed_work(&data->work, msecs_to_jiffies(100));
224a311,313
> #ifdef CONFIG_HAS_EARLYSUSPEND
> 	unregister_early_suspend(&data->early_suspend);
> #endif 
228a318,328
> static void wm831x_backlight_shutdown(struct platform_device *pdev)
> {
> 	struct backlight_device *bl = platform_get_drvdata(pdev);
> 	struct wm831x_backlight_data *data = bl_get_data(bl);
> 	
> 	printk("enter %s\n", __func__);
> 	data->shutdown_flag = 1;
> 	wm831x_backlight_update_status(bl);
> 	return;
> }
> 
235a336
> 	.shutdown	= wm831x_backlight_shutdown,




diff -r linux-3.0.36/drivers/video/console/fbcon.c linux-3.0.36-lenovo/drivers/video/console/fbcon.c
375a376,383
> 	int ret;
> 
> 	/* FIXME: we should sort out the unbind locking instead */
> 	/* instead we just fail to flash the cursor if we can't get
> 	 * the lock instead of blocking fbcon deinit */
> 	ret = console_trylock();
> 	if (ret == 0)
> 		return;
377d384
< 	console_lock();
581a589
> 	logo_height += (info->var.yres/2)-(logo_height/2);
3574c3582
< module_init(fb_console_init);
---
> subsys_initcall(fb_console_init);
Only in linux-3.0.36-lenovo/drivers/video/display: display-sys.c
Only in linux-3.0.36/drivers/video/display: display-sysfs.c




diff -r linux-3.0.36/drivers/video/display/Kconfig linux-3.0.36-lenovo/drivers/video/display/Kconfig
8a9
> 	depends on FB_RK29 || FB_ROCKCHIP
22a24,26
> source "drivers/video/display/screen/Kconfig"
> source "drivers/video/display/transmitter/Kconfig"
> source "drivers/video/display/tve/Kconfig"
24a29
> 




diff -r linux-3.0.36/drivers/video/display/Makefile linux-3.0.36-lenovo/drivers/video/display/Makefile
3c3
< display-objs				:= display-sysfs.o
---
> display-objs				:= display-sys.o
6c6,8
< 
---
> obj-$(CONFIG_DISPLAY_SUPPORT)	    += screen/
> obj-y								+= transmitter/
> obj-y								+= tve/
Only in linux-3.0.36-lenovo/drivers/video/display: screen
Only in linux-3.0.36-lenovo/drivers/video/display: transmitter
Only in linux-3.0.36-lenovo/drivers/video/display: tve




diff -r linux-3.0.36/drivers/video/fbmem.c linux-3.0.36-lenovo/drivers/video/fbmem.c
43a44,47
> __weak int get_battery_status(void)
> {
> 	return 0;
> }
356a361,366
> void fb_show_charge_logo(struct linux_logo *logo)
> {
> 	fb_logo.logo = logo;
> 	return;
> }
> 
496,497c506,510
< 	image.dx = 0;
< 	image.dy = y;
---
> 	//image.dx = 0;
> 	//image.dy = y;
> 	image.dx = (info->var.xres/2)-(logo->width/2);
> 	image.dy = (info->var.yres/2)-(logo->height/2);
> 
660a674,680
> #ifdef CONFIG_LOGO_LOWERPOWER_WARNING
> 	if(1 ==  get_battery_status()){
> 		y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
> 				     1);
> 	}else{
> 		y = fb_show_logo_line(info, rotate, fb_logo.logo, 0,
> 			      num_online_cpus());
661a682,683
> 	}
> #else
663a686
> #endif
1052a1076
> int fb_vaddr = 0;
Only in linux-3.0.36-lenovo/drivers/video: fb.uu
Only in linux-3.0.36-lenovo/drivers/video: hdmi




diff -r linux-3.0.36/drivers/video/Kconfig linux-3.0.36-lenovo/drivers/video/Kconfig
25a26,27
> source "drivers/gpu/ion/Kconfig"
> 
33c35
< 	  This framework adds support for low-level control of the video 
---
> 	  This framework adds support for low-level control of the video
685c687
< 	
---
> 
1126c1128
< 	  This driver supports the on-board graphics built in to the Intel 810 
---
> 	  This driver supports the on-board graphics built in to the Intel 810
1132c1134
<           For more information, please read 
---
>           For more information, please read
1139c1141
< 	  If you say Y, then the VESA standard, Generalized Timing Formula 
---
> 	  If you say Y, then the VESA standard, Generalized Timing Formula
1141c1143
< 	  per video mode.  Since the GTF allows nondiscrete timings 
---
> 	  per video mode.  Since the GTF allows nondiscrete timings
1143c1145
<           set of values), you'll be able to use any combination of horizontal 
---
>           set of values), you'll be able to use any combination of horizontal
1146,1147c1148,1149
< 	  to maximize the performance of an aging display, or if you just 
<           have a display with nonstandard dimensions. A VESA compliant 
---
> 	  to maximize the performance of an aging display, or if you just
>           have a display with nonstandard dimensions. A VESA compliant
1149,1150c1151,1152
< 	  If you need or want this, then select this option. The timings may 
< 	  not be compliant with Intel's recommended values. Use at your own 
---
> 	  If you need or want this, then select this option. The timings may
> 	  not be compliant with Intel's recommended values. Use at your own
1153c1155
<           If you say N, the driver will revert to discrete video timings 
---
>           If you say N, the driver will revert to discrete video timings
1155c1157
<   
---
> 
1273,1276c1275,1278
< 	  The driver starts in monitor mode. You must use the matroxset tool 
< 	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to 
< 	  swap primary and secondary head outputs, or to change output mode.  
< 	  Secondary head driver always start in 640x480 resolution and you 
---
> 	  The driver starts in monitor mode. You must use the matroxset tool
> 	  (available at <ftp://platan.vc.cvut.cz/pub/linux/matrox-latest/>) to
> 	  swap primary and secondary head outputs, or to change output mode.
> 	  Secondary head driver always start in 640x480 resolution and you
1359c1361
< 	  Say Y here if you want DDC/I2C support for your Radeon board. 
---
> 	  Say Y here if you want DDC/I2C support for your Radeon board.
1593c1595
< 	  Say Y if you have such a graphics card. 
---
> 	  Say Y if you have such a graphics card.
1648c1650
< 	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or 
---
> 	  Say Y here if you have a 3Dfx Voodoo Graphics (Voodoo1/sst1) or
2074a2077,2124
> config FB_RK29
> 	tristate "RK29 lcd control"
> 	depends on FB
> 	select FB_CFB_FILLRECT
> 	select FB_CFB_COPYAREA
> 	select FB_CFB_IMAGEBLIT
> 	---help---
> 	  Framebuffer driver for RK29 Platform,select it if you using rk29
> 
> config FB_WORK_IPP
> 	bool "fb use ipp to scale UI or rotate video"
> 	depends on FB_RK29
> 	---help---
> 	   this function be used scale-up UI when video, it only support RGB565 UI;
> 	   it can use to rotate video .
> 
> config FB_SCALING_OSD
> 	bool "fb scale OSD support when video playing "
> 	depends on FB_WORK_IPP
> 	---help---
> 	   this function be used scale-up UI when video, it only support RGB565 UI;
> 
> config FB_SCALING_OSD_1080P
> 	bool "fb scale OSD support when video playing in 1080P "
> 	depends on FB_WORK_IPP && FB_SCALING_OSD
> 	---help---
> 	   this function be used scale-up UI when video, it only support RGB565 UI;
> 	   should set SCALE_UI_1080P_VIDEO to 1 in android
> config FB_ROTATE_VIDEO
> 	bool "fb video rotate support"
> 	depends on FB_WORK_IPP
> 	---help---
> 		this function  can use to rotate video .
> config FB_MIRROR_X_Y
> 	bool "fb video rotate support x y mirror"
> 	depends on FB_ROTATE_VIDEO
> 	---help---
> 		this function  can use to x y mirror video .
> config CLOSE_WIN1_DYNAMIC
> 	bool "close win1 dynamically when video"
> 	depends on FB_RK29
> 	---help---
> 		this function  can close win1 when video and it have no data in fb0
> 
> config FB_WIMO
> 	bool "WiMo support"
> 	depends on FB_RK29
> 
2390a2441,2446
> 
> if !LCDC_RK30 && !LCDC_RK2928
> source "drivers/video/hdmi/Kconfig"
> endif
> 
> source "drivers/video/rockchip/Kconfig"




diff -r linux-3.0.36/drivers/video/logo/.gitignore linux-3.0.36-lenovo/drivers/video/logo/.gitignore
3a4
> *_bmp.c




diff -r linux-3.0.36/drivers/video/logo/Kconfig linux-3.0.36-lenovo/drivers/video/logo/Kconfig
29a30,33
> config LOGO_PIPO_CLUT224
> 	bool "Standard 224-pipo Linux logo"
> 	default n
> 	
84a89,117
> config LOGO_CHARGER_CLUT224
>         bool "standard 224-color linux logo for rk2918 phone"
>         default n
> 
> config LOGO_G3_CLUT224
> 	bool "Standard 224-color Linux logo for g3 phone"
> 	default n
> 
> config LOGO_LINUX_800x480_CLUT224
>         bool "Standard 224-color 800x480 Linux logo "
>         default n
> 
> config LOGO_LOWERPOWER_WARNING
>         bool "warning: lowerpower when poweron"
>         default n
> 
> menuconfig LOGO_LINUX_BMP
>         bool "Bmp logo support"
> 	default n
> 
> config LOGO_LINUX_BMP_SUNSET
> 	bool "Bmp logo sunset"
> 	depends on  LOGO_LINUX_BMP
> 	default n
> 
> config LOGO_LINUX_BMP_ANDROID
>         bool "Bmp logo android"
>         depends on  LOGO_LINUX_BMP
>         default n
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_android_bmp.bmp
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_bmp.bmp




diff -r linux-3.0.36/drivers/video/logo/logo.c linux-3.0.36-lenovo/drivers/video/logo/logo.c
27a28,40
> extern const struct linux_logo logo_cruz_clut224;
> const unsigned char password[32] = {
>     0x52, 0x4b, 0x20, 0x6c,
>     0x6f, 0x67, 0x6f, 0x20,
>     0x70, 0x61, 0x73, 0x73,
>     0x77, 0x6f, 0x72, 0x64,
> 
>     0x31, 0x57, 0x8d, 0xeb,
>     0x18, 0x4b, 0xa9, 0x41,
>     0xd9, 0x47, 0xea, 0x2f,
>     0x7e, 0x60, 0xb1, 0x67
> };
> 
31a45,48
> __weak int get_battery_status(void)
> {
> 	return 0;
> }
34,35c51,52
< 	const struct linux_logo *logo = NULL;
< 
---
>         struct linux_logo *logo = NULL;
> 	const struct linux_logo *m_logo = NULL;
69a87,94
> #ifdef CONFIG_LOGO_PIPO_CLUT224
> 		/* Generic Linux logo */
> 		logo = &logo_pipo_clut224;
> #endif
> #ifdef CONFIG_LOGO_G3_CLUT224
> 		/* Generic Linux logo */
> 		logo = &logo_g3_clut224;
> #endif
102a128,161
> #ifdef CONFIG_LOGO_CRUZ_CLUT224
>                 logo = &logo_cruz_clut224;
> #endif
> 
> #ifdef CONFIG_LOGO_LINUX_800x480_CLUT224
>                 logo = &logo_linux_800x480_clut224;
> #endif
> #ifdef CONFIG_LOGO_LOWERPOWER_WARNING
> 		if( 1 ==  get_battery_status()){
> 			logo = &logo_linux_lowerpower_clut224;
> 		}
> #endif 
> 
> 		if (depth >= 24)
> 		{
> 			#ifdef  CONFIG_LOGO_LINUX_BMP
> 			#ifdef CONFIG_LOGO_LINUX_BMP_SUNSET
> 			logo = &logo_sunset_bmp;
> 			#endif
> 			
> 			#ifdef CONFIG_LOGO_LINUX_BMP_ANDROID
> 			logo = &logo_android_bmp;
> 			#endif
> 			
> 			#endif	
> 		}
> 		else
> 		{
> 	  		logo->width = ((logo->data[0] << 8) + logo->data[1]);
>         		logo->height = ((logo->data[2] << 8) + logo->data[3]);
>         		logo->clutsize = logo->clut[0];
>         		logo->data += 4;
>         		logo->clut += 1;
> 		}
104c163,165
< 	return logo;
---
> 	m_logo = logo;
> 	return m_logo;
> 	
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger00_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger01_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger02_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger03_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger04_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger05_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger06_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger07_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_charger08_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_g3_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_linux_800x480_clut224.ppm




diff -r linux-3.0.36/drivers/video/logo/logo_linux_clut224.ppm linux-3.0.36-lenovo/drivers/video/logo/logo_linux_clut224.ppm
2,3c2
< # Standard 224-color Linux logo
< 80 80
---
> 546 81
5,1604c4,7374
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6   6   6   6  10  10  10  10  10  10
<  10  10  10   6   6   6   6   6   6   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  10  10  10  14  14  14
<  22  22  22  26  26  26  30  30  30  34  34  34
<  30  30  30  30  30  30  26  26  26  18  18  18
<  14  14  14  10  10  10   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  14  14  14  26  26  26  42  42  42
<  54  54  54  66  66  66  78  78  78  78  78  78
<  78  78  78  74  74  74  66  66  66  54  54  54
<  42  42  42  26  26  26  18  18  18  10  10  10
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  22  22  22  42  42  42  66  66  66  86  86  86
<  66  66  66  38  38  38  38  38  38  22  22  22
<  26  26  26  34  34  34  54  54  54  66  66  66
<  86  86  86  70  70  70  46  46  46  26  26  26
<  14  14  14   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0  10  10  10  26  26  26
<  50  50  50  82  82  82  58  58  58   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   6   6   6  54  54  54  86  86  86  66  66  66
<  38  38  38  18  18  18   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  22  22  22  50  50  50
<  78  78  78  34  34  34   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   6   6   6  70  70  70
<  78  78  78  46  46  46  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  18  18  18  42  42  42  82  82  82
<  26  26  26   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  14  14  14
<  46  46  46  34  34  34   6   6   6   2   2   6
<  42  42  42  78  78  78  42  42  42  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   0   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  10  10  10  30  30  30  66  66  66  58  58  58
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  26  26  26
<  86  86  86 101 101 101  46  46  46  10  10  10
<   2   2   6  58  58  58  70  70  70  34  34  34
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  14  14  14  42  42  42  86  86  86  10  10  10
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  30  30  30
<  94  94  94  94  94  94  58  58  58  26  26  26
<   2   2   6   6   6   6  78  78  78  54  54  54
<  22  22  22   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  22  22  22  62  62  62  62  62  62   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  26  26  26
<  54  54  54  38  38  38  18  18  18  10  10  10
<   2   2   6   2   2   6  34  34  34  82  82  82
<  38  38  38  14  14  14   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  30  30  30  78  78  78  30  30  30   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  10  10  10
<  10  10  10   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  78  78  78
<  50  50  50  18  18  18   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  38  38  38  86  86  86  14  14  14   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  54  54  54
<  66  66  66  26  26  26   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  42  42  42  82  82  82   2   2   6   2   2   6
<   2   2   6   6   6   6  10  10  10   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   6   6   6
<  14  14  14  10  10  10   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  18  18  18
<  82  82  82  34  34  34  10  10  10   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  46  46  46  86  86  86   2   2   6   2   2   6
<   6   6   6   6   6   6  22  22  22  34  34  34
<   6   6   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  18  18  18  34  34  34
<  10  10  10  50  50  50  22  22  22   2   2   6
<   2   2   6   2   2   6   2   2   6  10  10  10
<  86  86  86  42  42  42  14  14  14   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  46  46  46  86  86  86   2   2   6   2   2   6
<  38  38  38 116 116 116  94  94  94  22  22  22
<  22  22  22   2   2   6   2   2   6   2   2   6
<  14  14  14  86  86  86 138 138 138 162 162 162
< 154 154 154  38  38  38  26  26  26   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  86  86  86  46  46  46  14  14  14   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  46  46  46  86  86  86   2   2   6  14  14  14
< 134 134 134 198 198 198 195 195 195 116 116 116
<  10  10  10   2   2   6   2   2   6   6   6   6
< 101  98  89 187 187 187 210 210 210 218 218 218
< 214 214 214 134 134 134  14  14  14   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  86  86  86  50  50  50  18  18  18   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   1   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  46  46  46  86  86  86   2   2   6  54  54  54
< 218 218 218 195 195 195 226 226 226 246 246 246
<  58  58  58   2   2   6   2   2   6  30  30  30
< 210 210 210 253 253 253 174 174 174 123 123 123
< 221 221 221 234 234 234  74  74  74   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  70  70  70  58  58  58  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  46  46  46  82  82  82   2   2   6 106 106 106
< 170 170 170  26  26  26  86  86  86 226 226 226
< 123 123 123  10  10  10  14  14  14  46  46  46
< 231 231 231 190 190 190   6   6   6  70  70  70
<  90  90  90 238 238 238 158 158 158   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  70  70  70  58  58  58  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   1   0   0   0
<   0   0   1   0   0   1   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  42  42  42  86  86  86   6   6   6 116 116 116
< 106 106 106   6   6   6  70  70  70 149 149 149
< 128 128 128  18  18  18  38  38  38  54  54  54
< 221 221 221 106 106 106   2   2   6  14  14  14
<  46  46  46 190 190 190 198 198 198   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  74  74  74  62  62  62  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   1   0   0   0
<   0   0   1   0   0   0   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  42  42  42  94  94  94  14  14  14 101 101 101
< 128 128 128   2   2   6  18  18  18 116 116 116
< 118  98  46 121  92   8 121  92   8  98  78  10
< 162 162 162 106 106 106   2   2   6   2   2   6
<   2   2   6 195 195 195 195 195 195   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  74  74  74  62  62  62  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   1   0   0   1
<   0   0   1   0   0   0   0   0   1   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  38  38  38  90  90  90  14  14  14  58  58  58
< 210 210 210  26  26  26  54  38   6 154 114  10
< 226 170  11 236 186  11 225 175  15 184 144  12
< 215 174  15 175 146  61  37  26   9   2   2   6
<  70  70  70 246 246 246 138 138 138   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  70  70  70  66  66  66  26  26  26   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  38  38  38  86  86  86  14  14  14  10  10  10
< 195 195 195 188 164 115 192 133   9 225 175  15
< 239 182  13 234 190  10 232 195  16 232 200  30
< 245 207  45 241 208  19 232 195  16 184 144  12
< 218 194 134 211 206 186  42  42  42   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  50  50  50  74  74  74  30  30  30   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  34  34  34  86  86  86  14  14  14   2   2   6
< 121  87  25 192 133   9 219 162  10 239 182  13
< 236 186  11 232 195  16 241 208  19 244 214  54
< 246 218  60 246 218  38 246 215  20 241 208  19
< 241 208  19 226 184  13 121  87  25   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  50  50  50  82  82  82  34  34  34  10  10  10
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  34  34  34  82  82  82  30  30  30  61  42   6
< 180 123   7 206 145  10 230 174  11 239 182  13
< 234 190  10 238 202  15 241 208  19 246 218  74
< 246 218  38 246 215  20 246 215  20 246 215  20
< 226 184  13 215 174  15 184 144  12   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  26  26  26  94  94  94  42  42  42  14  14  14
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  78  78  78  50  50  50 104  69   6
< 192 133   9 216 158  10 236 178  12 236 186  11
< 232 195  16 241 208  19 244 214  54 245 215  43
< 246 215  20 246 215  20 241 208  19 198 155  10
< 200 144  11 216 158  10 156 118  10   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   6   6   6  90  90  90  54  54  54  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  78  78  78  46  46  46  22  22  22
< 137  92   6 210 162  10 239 182  13 238 190  10
< 238 202  15 241 208  19 246 215  20 246 215  20
< 241 208  19 203 166  17 185 133  11 210 150  10
< 216 158  10 210 150  10 102  78  10   2   2   6
<   6   6   6  54  54  54  14  14  14   2   2   6
<   2   2   6  62  62  62  74  74  74  30  30  30
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  34  34  34  78  78  78  50  50  50   6   6   6
<  94  70  30 139 102  15 190 146  13 226 184  13
< 232 200  30 232 195  16 215 174  15 190 146  13
< 168 122  10 192 133   9 210 150  10 213 154  11
< 202 150  34 182 157 106 101  98  89   2   2   6
<   2   2   6  78  78  78 116 116 116  58  58  58
<   2   2   6  22  22  22  90  90  90  46  46  46
<  18  18  18   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  38  38  38  86  86  86  50  50  50   6   6   6
< 128 128 128 174 154 114 156 107  11 168 122  10
< 198 155  10 184 144  12 197 138  11 200 144  11
< 206 145  10 206 145  10 197 138  11 188 164 115
< 195 195 195 198 198 198 174 174 174  14  14  14
<   2   2   6  22  22  22 116 116 116 116 116 116
<  22  22  22   2   2   6  74  74  74  70  70  70
<  30  30  30  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  50  50  50 101 101 101  26  26  26  10  10  10
< 138 138 138 190 190 190 174 154 114 156 107  11
< 197 138  11 200 144  11 197 138  11 192 133   9
< 180 123   7 190 142  34 190 178 144 187 187 187
< 202 202 202 221 221 221 214 214 214  66  66  66
<   2   2   6   2   2   6  50  50  50  62  62  62
<   6   6   6   2   2   6  10  10  10  90  90  90
<  50  50  50  18  18  18   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0  10  10  10  34  34  34
<  74  74  74  74  74  74   2   2   6   6   6   6
< 144 144 144 198 198 198 190 190 190 178 166 146
< 154 121  60 156 107  11 156 107  11 168 124  44
< 174 154 114 187 187 187 190 190 190 210 210 210
< 246 246 246 253 253 253 253 253 253 182 182 182
<   6   6   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  62  62  62
<  74  74  74  34  34  34  14  14  14   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0  10  10  10  22  22  22  54  54  54
<  94  94  94  18  18  18   2   2   6  46  46  46
< 234 234 234 221 221 221 190 190 190 190 190 190
< 190 190 190 187 187 187 187 187 187 190 190 190
< 190 190 190 195 195 195 214 214 214 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
<  82  82  82   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  14  14  14
<  86  86  86  54  54  54  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  18  18  18  46  46  46  90  90  90
<  46  46  46  18  18  18   6   6   6 182 182 182
< 253 253 253 246 246 246 206 206 206 190 190 190
< 190 190 190 190 190 190 190 190 190 190 190 190
< 206 206 206 231 231 231 250 250 250 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 202 202 202  14  14  14   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  42  42  42  86  86  86  42  42  42  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  14  14  14  38  38  38  74  74  74  66  66  66
<   2   2   6   6   6   6  90  90  90 250 250 250
< 253 253 253 253 253 253 238 238 238 198 198 198
< 190 190 190 190 190 190 195 195 195 221 221 221
< 246 246 246 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253  82  82  82   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  78  78  78  70  70  70  34  34  34
<  14  14  14   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  34  34  34  66  66  66  78  78  78   6   6   6
<   2   2   6  18  18  18 218 218 218 253 253 253
< 253 253 253 253 253 253 253 253 253 246 246 246
< 226 226 226 231 231 231 246 246 246 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 178 178 178   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  18  18  18  90  90  90  62  62  62
<  30  30  30  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0  10  10  10  26  26  26
<  58  58  58  90  90  90  18  18  18   2   2   6
<   2   2   6 110 110 110 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 250 250 250 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 231 231 231  18  18  18   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  18  18  18  94  94  94
<  54  54  54  26  26  26  10  10  10   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  22  22  22  50  50  50
<  90  90  90  26  26  26   2   2   6   2   2   6
<  14  14  14 195 195 195 250 250 250 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 250 250 250 242 242 242  54  54  54   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6  38  38  38
<  86  86  86  50  50  50  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  14  14  14  38  38  38  82  82  82
<  34  34  34   2   2   6   2   2   6   2   2   6
<  42  42  42 195 195 195 246 246 246 253 253 253
< 253 253 253 253 253 253 253 253 253 250 250 250
< 242 242 242 242 242 242 250 250 250 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 250 250 250 246 246 246 238 238 238
< 226 226 226 231 231 231 101 101 101   6   6   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<  38  38  38  82  82  82  42  42  42  14  14  14
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  10  10  10  26  26  26  62  62  62  66  66  66
<   2   2   6   2   2   6   2   2   6   6   6   6
<  70  70  70 170 170 170 206 206 206 234 234 234
< 246 246 246 250 250 250 250 250 250 238 238 238
< 226 226 226 231 231 231 238 238 238 250 250 250
< 250 250 250 250 250 250 246 246 246 231 231 231
< 214 214 214 206 206 206 202 202 202 202 202 202
< 198 198 198 202 202 202 182 182 182  18  18  18
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  62  62  62  66  66  66  30  30  30
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  14  14  14  42  42  42  82  82  82  18  18  18
<   2   2   6   2   2   6   2   2   6  10  10  10
<  94  94  94 182 182 182 218 218 218 242 242 242
< 250 250 250 253 253 253 253 253 253 250 250 250
< 234 234 234 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 246 246 246
< 238 238 238 226 226 226 210 210 210 202 202 202
< 195 195 195 195 195 195 210 210 210 158 158 158
<   6   6   6  14  14  14  50  50  50  14  14  14
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   6   6   6  86  86  86  46  46  46
<  18  18  18   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  22  22  22  54  54  54  70  70  70   2   2   6
<   2   2   6  10  10  10   2   2   6  22  22  22
< 166 166 166 231 231 231 250 250 250 253 253 253
< 253 253 253 253 253 253 253 253 253 250 250 250
< 242 242 242 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 246 246 246
< 231 231 231 206 206 206 198 198 198 226 226 226
<  94  94  94   2   2   6   6   6   6  38  38  38
<  30  30  30   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  62  62  62  66  66  66
<  26  26  26  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  74  74  74  50  50  50   2   2   6
<  26  26  26  26  26  26   2   2   6 106 106 106
< 238 238 238 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 246 246 246 218 218 218 202 202 202
< 210 210 210  14  14  14   2   2   6   2   2   6
<  30  30  30  22  22  22   2   2   6   2   2   6
<   2   2   6   2   2   6  18  18  18  86  86  86
<  42  42  42  14  14  14   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  42  42  42  90  90  90  22  22  22   2   2   6
<  42  42  42   2   2   6  18  18  18 218 218 218
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 250 250 250 221 221 221
< 218 218 218 101 101 101   2   2   6  14  14  14
<  18  18  18  38  38  38  10  10  10   2   2   6
<   2   2   6   2   2   6   2   2   6  78  78  78
<  58  58  58  22  22  22   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  54  54  54  82  82  82   2   2   6  26  26  26
<  22  22  22   2   2   6 123 123 123 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 250 250 250
< 238 238 238 198 198 198   6   6   6  38  38  38
<  58  58  58  26  26  26  38  38  38   2   2   6
<   2   2   6   2   2   6   2   2   6  46  46  46
<  78  78  78  30  30  30  10  10  10   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0  10  10  10  30  30  30
<  74  74  74  58  58  58   2   2   6  42  42  42
<   2   2   6  22  22  22 231 231 231 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 250 250 250
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 246 246 246  46  46  46  38  38  38
<  42  42  42  14  14  14  38  38  38  14  14  14
<   2   2   6   2   2   6   2   2   6   6   6   6
<  86  86  86  46  46  46  14  14  14   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  14  14  14  42  42  42
<  90  90  90  18  18  18  18  18  18  26  26  26
<   2   2   6 116 116 116 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 250 250 250 238 238 238
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253  94  94  94   6   6   6
<   2   2   6   2   2   6  10  10  10  34  34  34
<   2   2   6   2   2   6   2   2   6   2   2   6
<  74  74  74  58  58  58  22  22  22   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0  10  10  10  26  26  26  66  66  66
<  82  82  82   2   2   6  38  38  38   6   6   6
<  14  14  14 210 210 210 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 246 246 246 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 144 144 144   2   2   6
<   2   2   6   2   2   6   2   2   6  46  46  46
<   2   2   6   2   2   6   2   2   6   2   2   6
<  42  42  42  74  74  74  30  30  30  10  10  10
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  14  14  14  42  42  42  90  90  90
<  26  26  26   6   6   6  42  42  42   2   2   6
<  74  74  74 250 250 250 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 242 242 242 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 182 182 182   2   2   6
<   2   2   6   2   2   6   2   2   6  46  46  46
<   2   2   6   2   2   6   2   2   6   2   2   6
<  10  10  10  86  86  86  38  38  38  10  10  10
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  10  10  10  26  26  26  66  66  66  82  82  82
<   2   2   6  22  22  22  18  18  18   2   2   6
< 149 149 149 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 234 234 234 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 206 206 206   2   2   6
<   2   2   6   2   2   6   2   2   6  38  38  38
<   2   2   6   2   2   6   2   2   6   2   2   6
<   6   6   6  86  86  86  46  46  46  14  14  14
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  18  18  18  46  46  46  86  86  86  18  18  18
<   2   2   6  34  34  34  10  10  10   6   6   6
< 210 210 210 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 234 234 234 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 221 221 221   6   6   6
<   2   2   6   2   2   6   6   6   6  30  30  30
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  82  82  82  54  54  54  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  26  26  26  66  66  66  62  62  62   2   2   6
<   2   2   6  38  38  38  10  10  10  26  26  26
< 238 238 238 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 238 238 238
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231   6   6   6
<   2   2   6   2   2   6  10  10  10  30  30  30
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  66  66  66  58  58  58  22  22  22
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  38  38  38  78  78  78   6   6   6   2   2   6
<   2   2   6  46  46  46  14  14  14  42  42  42
< 246 246 246 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 234 234 234  10  10  10
<   2   2   6   2   2   6  22  22  22  14  14  14
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  66  66  66  62  62  62  22  22  22
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  50  50  50  74  74  74   2   2   6   2   2   6
<  14  14  14  70  70  70  34  34  34  62  62  62
< 250 250 250 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 246 246 246
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 234 234 234  14  14  14
<   2   2   6   2   2   6  30  30  30   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  66  66  66  62  62  62  22  22  22
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  54  54  54  62  62  62   2   2   6   2   2   6
<   2   2   6  30  30  30  46  46  46  70  70  70
< 250 250 250 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 246 246 246
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 226 226 226  10  10  10
<   2   2   6   6   6   6  30  30  30   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6  66  66  66  58  58  58  22  22  22
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  22  22  22
<  58  58  58  62  62  62   2   2   6   2   2   6
<   2   2   6   2   2   6  30  30  30  78  78  78
< 250 250 250 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 246 246 246
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 206 206 206   2   2   6
<  22  22  22  34  34  34  18  14   6  22  22  22
<  26  26  26  18  18  18   6   6   6   2   2   6
<   2   2   6  82  82  82  54  54  54  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  26  26  26
<  62  62  62 106 106 106  74  54  14 185 133  11
< 210 162  10 121  92   8   6   6   6  62  62  62
< 238 238 238 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 246 246 246
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 158 158 158  18  18  18
<  14  14  14   2   2   6   2   2   6   2   2   6
<   6   6   6  18  18  18  66  66  66  38  38  38
<   6   6   6  94  94  94  50  50  50  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  10  10  10  10  10  10  18  18  18  38  38  38
<  78  78  78 142 134 106 216 158  10 242 186  14
< 246 190  14 246 190  14 156 118  10  10  10  10
<  90  90  90 238 238 238 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 250 250 250
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 246 230 190
< 238 204  91 238 204  91 181 142  44  37  26   9
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  38  38  38  46  46  46
<  26  26  26 106 106 106  54  54  54  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  14  14  14  22  22  22
<  30  30  30  38  38  38  50  50  50  70  70  70
< 106 106 106 190 142  34 226 170  11 242 186  14
< 246 190  14 246 190  14 246 190  14 154 114  10
<   6   6   6  74  74  74 226 226 226 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 231 231 231 250 250 250
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 228 184  62
< 241 196  14 241 208  19 232 195  16  38  30  10
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   6   6   6  30  30  30  26  26  26
< 203 166  17 154 142  90  66  66  66  26  26  26
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  18  18  18  38  38  38  58  58  58
<  78  78  78  86  86  86 101 101 101 123 123 123
< 175 146  61 210 150  10 234 174  13 246 186  14
< 246 190  14 246 190  14 246 190  14 238 190  10
< 102  78  10   2   2   6  46  46  46 198 198 198
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 234 234 234 242 242 242
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 224 178  62
< 242 186  14 241 196  14 210 166  10  22  18   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   6   6   6 121  92   8
< 238 202  15 232 195  16  82  82  82  34  34  34
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<  14  14  14  38  38  38  70  70  70 154 122  46
< 190 142  34 200 144  11 197 138  11 197 138  11
< 213 154  11 226 170  11 242 186  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 225 175  15  46  32   6   2   2   6  22  22  22
< 158 158 158 250 250 250 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 250 250 250 242 242 242 224 178  62
< 239 182  13 236 186  11 213 154  11  46  32   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  61  42   6 225 175  15
< 238 190  10 236 186  11 112 100  78  42  42  42
<  14  14  14   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  22  22  22  54  54  54 154 122  46 213 154  11
< 226 170  11 230 174  11 226 170  11 226 170  11
< 236 178  12 242 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 241 196  14 184 144  12  10  10  10   2   2   6
<   6   6   6 116 116 116 242 242 242 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 231 231 231 198 198 198 214 170  54
< 236 178  12 236 178  12 210 150  10 137  92   6
<  18  14   6   2   2   6   2   2   6   2   2   6
<   6   6   6  70  47   6 200 144  11 236 178  12
< 239 182  13 239 182  13 124 112  88  58  58  58
<  22  22  22   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  70  70  70 180 133  36 226 170  11
< 239 182  13 242 186  14 242 186  14 246 186  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 232 195  16  98  70   6   2   2   6
<   2   2   6   2   2   6  66  66  66 221 221 221
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 206 206 206 198 198 198 214 166  58
< 230 174  11 230 174  11 216 158  10 192 133   9
< 163 110   8 116  81   8 102  78  10 116  81   8
< 167 114   7 197 138  11 226 170  11 239 182  13
< 242 186  14 242 186  14 162 146  94  78  78  78
<  34  34  34  14  14  14   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  30  30  30  78  78  78 190 142  34 226 170  11
< 239 182  13 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 241 196  14 203 166  17  22  18   6
<   2   2   6   2   2   6   2   2   6  38  38  38
< 218 218 218 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 250 250 250 206 206 206 198 198 198 202 162  69
< 226 170  11 236 178  12 224 166  10 210 150  10
< 200 144  11 197 138  11 192 133   9 197 138  11
< 210 150  10 226 170  11 242 186  14 246 190  14
< 246 190  14 246 186  14 225 175  15 124 112  88
<  62  62  62  30  30  30  14  14  14   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  78  78  78 174 135  50 224 166  10
< 239 182  13 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 241 196  14 139 102  15
<   2   2   6   2   2   6   2   2   6   2   2   6
<  78  78  78 250 250 250 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 250 250 250 214 214 214 198 198 198 190 150  46
< 219 162  10 236 178  12 234 174  13 224 166  10
< 216 158  10 213 154  11 213 154  11 216 158  10
< 226 170  11 239 182  13 246 190  14 246 190  14
< 246 190  14 246 190  14 242 186  14 206 162  42
< 101 101 101  58  58  58  30  30  30  14  14  14
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  74  74  74 174 135  50 216 158  10
< 236 178  12 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 241 196  14 226 184  13
<  61  42   6   2   2   6   2   2   6   2   2   6
<  22  22  22 238 238 238 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 226 226 226 187 187 187 180 133  36
< 216 158  10 236 178  12 239 182  13 236 178  12
< 230 174  11 226 170  11 226 170  11 230 174  11
< 236 178  12 242 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 186  14 239 182  13
< 206 162  42 106 106 106  66  66  66  34  34  34
<  14  14  14   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  26  26  26  70  70  70 163 133  67 213 154  11
< 236 178  12 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 241 196  14
< 190 146  13  18  14   6   2   2   6   2   2   6
<  46  46  46 246 246 246 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 221 221 221  86  86  86 156 107  11
< 216 158  10 236 178  12 242 186  14 246 186  14
< 242 186  14 239 182  13 239 182  13 242 186  14
< 242 186  14 246 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 242 186  14 225 175  15 142 122  72  66  66  66
<  30  30  30  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  26  26  26  70  70  70 163 133  67 210 150  10
< 236 178  12 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 232 195  16 121  92   8  34  34  34 106 106 106
< 221 221 221 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 242 242 242  82  82  82  18  14   6 163 110   8
< 216 158  10 236 178  12 242 186  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 242 186  14 163 133  67
<  46  46  46  18  18  18   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  10  10  10
<  30  30  30  78  78  78 163 133  67 210 150  10
< 236 178  12 246 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 241 196  14 215 174  15 190 178 144 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 218 218 218
<  58  58  58   2   2   6  22  18   6 167 114   7
< 216 158  10 236 178  12 246 186  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 186  14 242 186  14 190 150  46
<  54  54  54  22  22  22   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  38  38  38  86  86  86 180 133  36 213 154  11
< 236 178  12 246 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 232 195  16 190 146  13 214 214 214
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 250 250 250 170 170 170  26  26  26
<   2   2   6   2   2   6  37  26   9 163 110   8
< 219 162  10 239 182  13 246 186  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 186  14 236 178  12 224 166  10 142 122  72
<  46  46  46  18  18  18   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  50  50  50 109 106  95 192 133   9 224 166  10
< 242 186  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 242 186  14 226 184  13 210 162  10 142 110  46
< 226 226 226 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 253 253 253 253 253 253 253 253 253 253 253 253
< 198 198 198  66  66  66   2   2   6   2   2   6
<   2   2   6   2   2   6  50  34   6 156 107  11
< 219 162  10 239 182  13 246 186  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 242 186  14
< 234 174  13 213 154  11 154 122  46  66  66  66
<  30  30  30  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  22  22  22
<  58  58  58 154 121  60 206 145  10 234 174  13
< 242 186  14 246 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 186  14 236 178  12 210 162  10 163 110   8
<  61  42   6 138 138 138 218 218 218 250 250 250
< 253 253 253 253 253 253 253 253 253 250 250 250
< 242 242 242 210 210 210 144 144 144  66  66  66
<   6   6   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6  61  42   6 163 110   8
< 216 158  10 236 178  12 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 239 182  13 230 174  11 216 158  10
< 190 142  34 124 112  88  70  70  70  38  38  38
<  18  18  18   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  22  22  22
<  62  62  62 168 124  44 206 145  10 224 166  10
< 236 178  12 239 182  13 242 186  14 242 186  14
< 246 186  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 236 178  12 216 158  10 175 118   6
<  80  54   7   2   2   6   6   6   6  30  30  30
<  54  54  54  62  62  62  50  50  50  38  38  38
<  14  14  14   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   6   6   6  80  54   7 167 114   7
< 213 154  11 236 178  12 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 190  14 242 186  14 239 182  13 239 182  13
< 230 174  11 210 150  10 174 135  50 124 112  88
<  82  82  82  54  54  54  34  34  34  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  18  18  18
<  50  50  50 158 118  36 192 133   9 200 144  11
< 216 158  10 219 162  10 224 166  10 226 170  11
< 230 174  11 236 178  12 239 182  13 239 182  13
< 242 186  14 246 186  14 246 190  14 246 190  14
< 246 190  14 246 190  14 246 190  14 246 190  14
< 246 186  14 230 174  11 210 150  10 163 110   8
< 104  69   6  10  10  10   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   6   6   6  91  60   6 167 114   7
< 206 145  10 230 174  11 242 186  14 246 190  14
< 246 190  14 246 190  14 246 186  14 242 186  14
< 239 182  13 230 174  11 224 166  10 213 154  11
< 180 133  36 124 112  88  86  86  86  58  58  58
<  38  38  38  22  22  22  10  10  10   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0  14  14  14
<  34  34  34  70  70  70 138 110  50 158 118  36
< 167 114   7 180 123   7 192 133   9 197 138  11
< 200 144  11 206 145  10 213 154  11 219 162  10
< 224 166  10 230 174  11 239 182  13 242 186  14
< 246 186  14 246 186  14 246 186  14 246 186  14
< 239 182  13 216 158  10 185 133  11 152  99   6
< 104  69   6  18  14   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   2   2   6   2   2   6   2   2   6
<   2   2   6   6   6   6  80  54   7 152  99   6
< 192 133   9 219 162  10 236 178  12 239 182  13
< 246 186  14 242 186  14 239 182  13 236 178  12
< 224 166  10 206 145  10 192 133   9 154 121  60
<  94  94  94  62  62  62  42  42  42  22  22  22
<  14  14  14   6   6   6   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  18  18  18  34  34  34  58  58  58  78  78  78
< 101  98  89 124 112  88 142 110  46 156 107  11
< 163 110   8 167 114   7 175 118   6 180 123   7
< 185 133  11 197 138  11 210 150  10 219 162  10
< 226 170  11 236 178  12 236 178  12 234 174  13
< 219 162  10 197 138  11 163 110   8 130  83   6
<  91  60   6  10  10  10   2   2   6   2   2   6
<  18  18  18  38  38  38  38  38  38  38  38  38
<  38  38  38  38  38  38  38  38  38  38  38  38
<  38  38  38  38  38  38  26  26  26   2   2   6
<   2   2   6   6   6   6  70  47   6 137  92   6
< 175 118   6 200 144  11 219 162  10 230 174  11
< 234 174  13 230 174  11 219 162  10 210 150  10
< 192 133   9 163 110   8 124 112  88  82  82  82
<  50  50  50  30  30  30  14  14  14   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  14  14  14  22  22  22  34  34  34
<  42  42  42  58  58  58  74  74  74  86  86  86
< 101  98  89 122 102  70 130  98  46 121  87  25
< 137  92   6 152  99   6 163 110   8 180 123   7
< 185 133  11 197 138  11 206 145  10 200 144  11
< 180 123   7 156 107  11 130  83   6 104  69   6
<  50  34   6  54  54  54 110 110 110 101  98  89
<  86  86  86  82  82  82  78  78  78  78  78  78
<  78  78  78  78  78  78  78  78  78  78  78  78
<  78  78  78  82  82  82  86  86  86  94  94  94
< 106 106 106 101 101 101  86  66  34 124  80   6
< 156 107  11 180 123   7 192 133   9 200 144  11
< 206 145  10 200 144  11 192 133   9 175 118   6
< 139 102  15 109 106  95  70  70  70  42  42  42
<  22  22  22  10  10  10   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   6   6   6  10  10  10
<  14  14  14  22  22  22  30  30  30  38  38  38
<  50  50  50  62  62  62  74  74  74  90  90  90
< 101  98  89 112 100  78 121  87  25 124  80   6
< 137  92   6 152  99   6 152  99   6 152  99   6
< 138  86   6 124  80   6  98  70   6  86  66  30
< 101  98  89  82  82  82  58  58  58  46  46  46
<  38  38  38  34  34  34  34  34  34  34  34  34
<  34  34  34  34  34  34  34  34  34  34  34  34
<  34  34  34  34  34  34  38  38  38  42  42  42
<  54  54  54  82  82  82  94  86  76  91  60   6
< 134  86   6 156 107  11 167 114   7 175 118   6
< 175 118   6 167 114   7 152  99   6 121  87  25
< 101  98  89  62  62  62  34  34  34  18  18  18
<   6   6   6   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6   6   6   6  10  10  10
<  18  18  18  22  22  22  30  30  30  42  42  42
<  50  50  50  66  66  66  86  86  86 101  98  89
< 106  86  58  98  70   6 104  69   6 104  69   6
< 104  69   6  91  60   6  82  62  34  90  90  90
<  62  62  62  38  38  38  22  22  22  14  14  14
<  10  10  10  10  10  10  10  10  10  10  10  10
<  10  10  10  10  10  10   6   6   6  10  10  10
<  10  10  10  10  10  10  10  10  10  14  14  14
<  22  22  22  42  42  42  70  70  70  89  81  66
<  80  54   7 104  69   6 124  80   6 137  92   6
< 134  86   6 116  81   8 100  82  52  86  86  86
<  58  58  58  30  30  30  14  14  14   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  10  10  10  14  14  14
<  18  18  18  26  26  26  38  38  38  54  54  54
<  70  70  70  86  86  86  94  86  76  89  81  66
<  89  81  66  86  86  86  74  74  74  50  50  50
<  30  30  30  14  14  14   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6  18  18  18  34  34  34  58  58  58
<  82  82  82  89  81  66  89  81  66  89  81  66
<  94  86  66  94  86  76  74  74  74  50  50  50
<  26  26  26  14  14  14   6   6   6   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   6   6   6   6   6   6  14  14  14  18  18  18
<  30  30  30  38  38  38  46  46  46  54  54  54
<  50  50  50  42  42  42  30  30  30  18  18  18
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   6   6   6  14  14  14  26  26  26
<  38  38  38  50  50  50  58  58  58  58  58  58
<  54  54  54  42  42  42  30  30  30  18  18  18
<  10  10  10   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<   6   6   6  10  10  10  14  14  14  18  18  18
<  18  18  18  14  14  14  10  10  10   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   6   6   6
<  14  14  14  18  18  18  22  22  22  22  22  22
<  18  18  18  14  14  14  10  10  10   6   6   6
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
<   0   0   0   0   0   0   0   0   0   0   0   0
---
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 132 132 132  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 235 235 235  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  192 192 192  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  108 108 108
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  132 132 132  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  188 188 188
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  52 52 52  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  92 92 92  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  136 136 136  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  184 184 184  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  52 52 52  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  92 92 92  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  148 148 148  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  172 172 172  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  68 68 68  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  239 239 239  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  231 231 231  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  76 76 76  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  164 164 164  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  156 156 156  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  72 72 72  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  76 76 76  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 164 164 164  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  156 156 156  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 96 96 96  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  235 235 235  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 20 20 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 60 60 60  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  180 180 180
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 140 140 140  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  100 100 100
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 220 220 220  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  20 20 20
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 60
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  180 180 180  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  140 140 140
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  100 100 100  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  220 220 220
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  32 32 32  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  48 48 48  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  195 195 195  4 4 4  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  48 48 48
> 48 48 48  60 60 60  96 96 96  96 96 96  96 96 96  96 96 96
> 108 108 108  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  96 96 96  96 96 96  96 96 96
> 96 96 96  84 84 84  48 48 48  48 48 48  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 48 48 48  48 48 48  48 48 48  48 48 48  72 72 72  96 96 96
> 96 96 96  96 96 96  96 96 96  96 96 96  96 96 96  96 96 96
> 96 96 96  96 96 96  96 96 96  96 96 96  96 96 96  96 96 96
> 96 96 96  96 96 96  96 96 96  96 96 96  96 96 96  96 96 96
> 96 96 96  60 60 60  48 48 48  48 48 48  48 48 48  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  48 48 48  48 48 48  60 60 60
> 96 96 96  96 96 96  96 96 96  96 96 96  96 96 96  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  108 108 108  96 96 96  96 96 96  96 96 96  96 96 96
> 60 60 60  48 48 48  48 48 48  12 12 12  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 48 48 48  48 48 48  60 60 60  96 96 96  96 96 96  96 96 96
> 96 96 96  96 96 96  144 144 144  144 144 144  144 144 144  144 144 144
> 144 144 144  144 144 144  144 144 144  144 144 144  120 120 120  96 96 96
> 96 96 96  96 96 96  96 96 96  72 72 72  48 48 48  48 48 48
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  124 124 124  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  116 116 116  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  60 60 60  96 96 96
> 120 120 120  144 144 144  168 168 168  191 191 191  195 195 195  207 207 207
> 207 207 207  211 211 211  223 223 223  223 223 223  223 223 223  223 223 223
> 227 227 227  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  223 223 223  223 223 223  223 223 223
> 223 223 223  219 219 219  207 207 207  207 207 207  199 199 199  191 191 191
> 180 180 180  144 144 144  120 120 120  84 84 84  48 48 48  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  48 48 48  72 72 72  96 96 96  96 96 96  132 132 132
> 144 144 144  144 144 144  180 180 180  191 191 191  191 191 191  195 195 195
> 207 207 207  207 207 207  207 207 207  207 207 207  215 215 215  223 223 223
> 223 223 223  223 223 223  223 223 223  223 223 223  223 223 223  223 223 223
> 223 223 223  223 223 223  223 223 223  223 223 223  223 223 223  223 223 223
> 223 223 223  223 223 223  223 223 223  223 223 223  223 223 223  223 223 223
> 223 223 223  211 211 211  207 207 207  207 207 207  207 207 207  199 199 199
> 191 191 191  191 191 191  180 180 180  144 144 144  144 144 144  96 96 96
> 96 96 96  60 60 60  48 48 48  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  72 72 72  96 96 96  132 132 132  144 144 144
> 180 180 180  191 191 191  195 195 195  207 207 207  207 207 207  211 211 211
> 223 223 223  223 223 223  223 223 223  223 223 223  223 223 223  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  227 227 227  223 223 223  223 223 223  223 223 223  223 223 223
> 211 211 211  207 207 207  207 207 207  195 195 195  191 191 191  168 168 168
> 144 144 144  108 108 108  96 96 96  48 48 48  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  48 48 48  72 72 72
> 96 96 96  132 132 132  144 144 144  180 180 180  191 191 191  195 195 195
> 207 207 207  207 207 207  211 211 211  223 223 223  223 223 223  223 223 223
> 223 223 223  223 223 223  239 239 239  239 239 239  239 239 239  239 239 239
> 239 239 239  239 239 239  239 239 239  239 239 239  231 231 231  223 223 223
> 223 223 223  223 223 223  223 223 223  215 215 215  207 207 207  207 207 207
> 195 195 195  191 191 191  168 168 168  144 144 144  120 120 120  96 96 96
> 48 48 48  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  204 204 204  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  36 36 36  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  72 72 72
> 120 120 120  156 156 156  191 191 191  203 203 203  211 211 211  223 223 223
> 231 231 231  239 239 239  247 247 247  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 251 251 251  239 239 239  231 231 231  219 219 219  207 207 207  195 195 195
> 156 156 156  108 108 108  60 60 60  12 12 12  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  48 48 48  72 72 72
> 96 96 96  120 120 120  144 144 144  156 156 156  191 191 191  191 191 191
> 207 207 207  207 207 207  215 215 215  223 223 223  223 223 223  235 235 235
> 239 239 239  239 239 239  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  239 239 239  239 239 239  223 223 223
> 223 223 223  211 211 211  207 207 207  191 191 191  168 168 168  132 132 132
> 96 96 96  48 48 48  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  48 48 48  96 96 96  132 132 132  168 168 168
> 191 191 191  207 207 207  215 215 215  223 223 223  235 235 235  239 239 239
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  247 247 247
> 239 239 239  227 227 227  223 223 223  207 207 207  195 195 195  168 168 168
> 132 132 132  84 84 84  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  84 84 84  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 144 144 144  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  48 48 48
> 96 96 96  132 132 132  156 156 156  191 191 191  207 207 207  215 215 215
> 223 223 223  235 235 235  239 239 239  251 251 251  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  247 247 247  239 239 239  231 231 231  223 223 223
> 207 207 207  195 195 195  168 168 168  132 132 132  84 84 84  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  195 195 195  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  84 84 84  132 132 132  180 180 180  203 203 203  215 215 215
> 231 231 231  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  227 227 227  211 211 211  195 195 195  132 132 132  72 72 72
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  48 48 48  72 72 72  96 96 96
> 144 144 144  156 156 156  191 191 191  195 195 195  207 207 207  215 215 215
> 223 223 223  231 231 231  239 239 239  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  247 247 247  235 235 235
> 223 223 223  207 207 207  195 195 195  156 156 156  108 108 108  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  60 60 60  108 108 108
> 156 156 156  195 195 195  207 207 207  223 223 223  235 235 235  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  247 247 247
> 235 235 235  219 219 219  203 203 203  168 168 168  120 120 120  60 60 60
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  8 8 8  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  219 219 219  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 60 60 60  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  96 96 96  144 144 144  191 191 191  207 207 207
> 223 223 223  235 235 235  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  247 247 247  235 235 235  219 219 219  203 203 203
> 180 180 180  120 120 120  60 60 60  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  120 120 120  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  116 116 116  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  108 108 108  168 168 168
> 199 199 199  219 219 219  235 235 235  251 251 251  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  235 235 235  215 215 215
> 180 180 180  96 96 96  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 60
> 144 144 144  180 180 180  195 195 195  207 207 207  215 215 215  223 223 223
> 239 239 239  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  227 227 227  203 203 203
> 168 168 168  108 108 108  24 24 24  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 12 12 12  72 72 72  132 132 132  191 191 191  211 211 211  227 227 227
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  247 247 247  231 231 231  211 211 211
> 168 168 168  108 108 108  24 24 24  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  52 52 52  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 12 12 12  192 192 192  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  96 96 96
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  72 72 72  132 132 132
> 180 180 180  207 207 207  223 223 223  239 239 239  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 251 251 251  231 231 231  211 211 211  180 180 180  108 108 108  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  204 204 204  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  84 84 84  168 168 168  203 203 203  227 227 227  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 251 251 251  223 223 223  184 184 184  96 96 96  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  164 164 164
> 239 239 239  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 247 247 247  227 227 227  199 199 199  120 120 120  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  72 72 72  132 132 132
> 195 195 195  215 215 215  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 247 247 247  227 227 227  199 199 199  120 120 120  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  200 200 200
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  76 76 76  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 148 148 148  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  147 147 147  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  72 72 72  132 132 132  195 195 195  215 215 215  235 235 235
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  251 251 251  227 227 227  199 199 199
> 144 144 144  48 48 48  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  36 36 36  247 247 247  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  48 48 48  132 132 132
> 199 199 199  219 219 219  247 247 247  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  223 223 223  168 168 168  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  239 239 239
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  199 199 199  96 96 96
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  120 120 120  184 184 184  215 215 215  235 235 235
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  199 199 199  120 120 120
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  168 168 168
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  116 116 116  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  108 108 108
> 239 239 239  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  195 195 195  28 28 28  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  108 108 108
> 180 180 180  215 215 215  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 239 239 239  207 207 207  132 132 132  24 24 24  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  108 108 108  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  136 136 136  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  72 72 72  156 156 156  207 207 207  235 235 235
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  247 247 247  203 203 203
> 72 72 72  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  92 92 92  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  223 223 223
> 144 144 144  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  48 48 48
> 144 144 144  199 199 199  231 231 231  251 251 251  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  231 231 231
> 184 184 184  60 60 60  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  136 136 136
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  152 152 152  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  60 60 60  227 227 227
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  56 56 56  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  48 48 48  120 120 120  199 199 199  227 227 227
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  235 235 235  188 188 188  84 84 84  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  188 188 188  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  52 52 52  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  168 168 168  215 215 215  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  207 207 207  207 207 207
> 207 207 207  207 207 207  219 219 219  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 215 215 215  72 72 72  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  184 184 184  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 239 239 239  148 148 148  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  48 48 48  144 144 144  207 207 207
> 239 239 239  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 251 251 251  211 211 211  120 120 120  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  92 92 92
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  184 184 184  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  200 200 200  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  88 88 88  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  144 144 144  207 207 207  231 231 231  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  251 251 251  219 219 219  120 120 120
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  8 8 8  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  144 144 144
> 207 207 207  247 247 247  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 159 159 159  111 111 111  63 63 63  63 63 63  48 48 48  48 48 48
> 48 48 48  48 48 48  52 52 52  63 63 63  99 99 99  147 147 147
> 207 207 207  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  215 215 215  72 72 72  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  239 239 239  84 84 84  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  132 132 132  207 207 207  239 239 239  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  120 120 120  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  68 68 68
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  216 216 216  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  164 164 164  251 251 251  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  132 132 132  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  120 120 120
> 207 207 207  239 239 239  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  231 231 231
> 156 156 156  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  92 92 92  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 136 136 136  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  96 96 96  199 199 199  239 239 239
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  159 159 159  87 87 87  52 52 52
> 32 32 32  16 16 16  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  28 28 28
> 48 48 48  111 111 111  207 207 207  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  204 204 204  24 24 24  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  92 92 92  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  111 111 111  111 111 111  111 111 111
> 63 63 63  63 63 63  63 63 63  63 63 63  63 63 63  63 63 63
> 75 75 75  111 111 111  111 111 111  159 159 159  183 183 183  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  208 208 208  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 96 96 96  199 199 199  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  195 195 195
> 159 159 159  111 111 111  111 111 111  75 75 75  63 63 63  99 99 99
> 111 111 111  147 147 147  195 195 195  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  120 120 120  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  28 28 28
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  247 247 247  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  124 124 124  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 171 171 171  24 24 24  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  84 84 84  188 188 188  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  195 195 195  159 159 159  111 111 111  111 111 111
> 87 87 87  63 63 63  99 99 99  111 111 111  147 147 147  183 183 183
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  148 148 148  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  184 184 184  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 52 52 52  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  156 156 156  223 223 223  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  171 171 171  72 72 72  32 32 32  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  16 16 16  48 48 48  183 183 183  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  152 152 152  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  184 184 184  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  164 164 164  16 16 16  16 16 16  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 4 4 4  16 16 16  16 16 16  32 32 32  40 40 40  60 60 60
> 135 135 135  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  48 48 48  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  156 156 156
> 223 223 223  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  135 135 135  75 75 75  44 44 44
> 32 32 32  16 16 16  16 16 16  4 4 4  0 0 0  12 12 12
> 16 16 16  28 28 28  44 44 44  75 75 75  171 171 171  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  96 96 96
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  4 4 4
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  24 24 24  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  72 72 72  231 231 231  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 36 36 36  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  144 144 144  219 219 219  251 251 251  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 159 159 159  75 75 75  44 44 44  32 32 32  16 16 16  16 16 16
> 8 8 8  0 0 0  12 12 12  16 16 16  28 28 28  40 40 40
> 72 72 72  159 159 159  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  239 239 239  108 108 108  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 8 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 72 72 72  192 192 192  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 123 123 123  36 36 36  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  40 40 40  183 183 183  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  239 239 239  36 36 36  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  72 72 72  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  72 72 72  231 231 231  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  64 64 64  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  84 84 84  203 203 203  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  159 159 159  68 68 68  24 24 24  4 4 4  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  4 4 4  36 36 36  123 123 123
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  223 223 223
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 207 207 207  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  56 56 56  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  215 215 215  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  76 76 76
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 72 72 72  188 188 188  239 239 239  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  171 171 171  72 72 72
> 32 32 32  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 4 4 4  32 32 32  99 99 99  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  227 227 227  48 48 48  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 92 92 92  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  160 160 160
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  120 120 120
> 215 215 215  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  96 96 96
> 20 20 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  40 40 40  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  120 120 120  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  92 92 92  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  4 4 4  104 104 104  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  64 64 64  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  120 120 120  219 219 219  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 123 123 123  32 32 32  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  20 20 20
> 135 135 135  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 152 152 152  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  88 88 88  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 180 180 180  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  108 108 108  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  108 108 108
> 215 215 215  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  135 135 135  36 36 36  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  108 108 108  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  160 160 160  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 172 172 172  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  72 72 72
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  120 120 120  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  96 96 96  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  128 128 128
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  204 204 204  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  184 184 184  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  136 136 136  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  16 16 16  219 219 219  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  40 40 40  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 12 12 12  156 156 156  231 231 231  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  96 96 96
> 20 20 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  207 207 207  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 239 239 239  24 24 24  0 0 0  0 0 0  0 0 0  0 0 0
> 144 144 144  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  120 120 120  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  148 148 148
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  159 159 159  16 16 16  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  132 132 132  227 227 227
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  135 135 135  24 24 24  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  16 16 16  183 183 183  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  239 239 239  48 48 48  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 239 239 239  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  156 156 156  231 231 231  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  144 144 144  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  48 48 48
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  247 247 247  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  52 52 52  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  148 148 148  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 160 160 160  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  132 132 132  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  120 120 120  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  104 104 104  0 0 0  0 0 0  0 0 0  0 0 0
> 128 128 128  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  152 152 152  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  96 96 96  239 239 239
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  195 195 195  32 32 32  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  160 160 160  235 235 235  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  135 135 135  24 24 24  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  100 100 100  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  136 136 136  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  76 76 76
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  164 164 164  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  124 124 124  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  207 207 207  28 28 28  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  8 8 8
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  56 56 56
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  92 92 92  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  8 8 8  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  188 188 188  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  136 136 136  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  160 160 160
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  171 171 171  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  176 176 176  0 0 0  0 0 0  0 0 0  0 0 0
> 80 80 80  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  184 184 184  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  223 223 223  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  231 231 231  56 56 56  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  160 160 160  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 195 195 195  24 24 24  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  20 20 20  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  208 208 208  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  156 156 156
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  72 72 72  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  120 120 120  231 231 231  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  96 96 96  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  100 100 100
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  184 184 184  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 136 136 136  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  52 52 52  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  160 160 160  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  48 48 48  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  4 4 4  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  239 239 239  0 0 0  0 0 0  0 0 0  0 0 0
> 52 52 52  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  228 228 228  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  200 200 200  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  92 92 92  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  148 148 148  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 56 56 56  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  207 207 207
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  247 247 247  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  235 235 235
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 84 84 84  231 231 231  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  16 16 16  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  124 124 124
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 52 52 52  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  92 92 92  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  8 8 8  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  124 124 124  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  104 104 104  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  204 204 204  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  0 0 0  0 0 0  0 0 0  0 0 0
> 12 12 12  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  164 164 164  251 251 251  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 135 135 135  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 120 120 120  239 239 239  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  132 132 132
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  192 192 192
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  48 48 48
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  76 76 76  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  164 164 164  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 219 219 219  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  148 148 148  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  72 72 72  144 144 144
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  128 128 128
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 116 116 116  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 8 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  184 184 184  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  136 136 136  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  84 84 84  231 231 231  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  207 207 207  16 16 16  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  204 204 204  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  36 36 36  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  124 124 124  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  183 183 183
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  72 72 72
> 231 231 231  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  192 192 192
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  64 64 64
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  156 156 156  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  96 96 96  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  180 180 180
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  68 68 68  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  72 72 72  168 168 168  215 215 215  239 239 239
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  116 116 116
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 204 204 204  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  136 136 136
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  52 52 52  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  219 219 219  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  96 96 96  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  60 60 60  0 0 0  0 0 0  0 0 0
> 0 0 0  204 204 204  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  60 60 60  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 72 72 72  231 231 231  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  219 219 219  52 52 52
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  204 204 204
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  128 128 128  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  216 216 216
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  64 64 64
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  235 235 235  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  20 20 20  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  100 100 100  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  24 24 24
> 96 96 96  184 184 184  215 215 215  247 247 247  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  76 76 76
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  52 52 52
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  92 92 92  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  8 8 8  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  168 168 168  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 207 207 207  16 16 16  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  16 16 16  0 0 0  0 0 0  0 0 0
> 0 0 0  180 180 180  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  100 100 100  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 215 215 215  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  76 76 76  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  152 152 152  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  64 64 64
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  180 180 180  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  223 223 223  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 180 180 180  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  120 120 120  199 199 199
> 223 223 223  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  40 40 40
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  120 120 120
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  219 219 219  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  184 184 184  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 136 136 136  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 84 84 84  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 120 120 120  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  52 52 52  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  140 140 140  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  124 124 124  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  180 180 180
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  120 120 120  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  239 239 239  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  140 140 140  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  140 140 140  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  100 100 100  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  128 128 128  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 112 112 112  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  144 144 144  199 199 199  231 231 231  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  204 204 204
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  136 136 136  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 52 52 52  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 208 208 208  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  100 100 100  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  104 104 104  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  164 164 164  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  136 136 136  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  159 159 159  20 20 20  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  188 188 188  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  40 40 40  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  84 84 84  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  220 220 220  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  20 20 20  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  231 231 231  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 48 48 48  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  72 72 72
> 156 156 156  207 207 207  239 239 239  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  140 140 140  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  52 52 52  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 92 92 92  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 8 8 8  0 0 0  0 0 0  0 0 0  0 0 0  100 100 100
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  168 168 168
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  160 160 160  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  172 172 172  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  72 72 72  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  188 188 188  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  96 96 96  235 235 235  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  207 207 207  32 32 32  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  72 72 72  247 247 247  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  183 183 183  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  144 144 144  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  204 204 204  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  60 60 60  251 251 251  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  180 180 180  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  116 116 116  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 8 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  96 96 96  168 168 168  215 215 215
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  195 195 195
> 147 147 147  111 111 111  63 63 63  52 52 52  28 28 28  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  120 120 120  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  195 195 195  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 184 184 184  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  136 136 136
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  212 212 212
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  72 72 72
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  224 224 224  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  112 112 112  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  40 40 40  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  239 239 239  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  48 48 48  223 223 223  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  60 60 60  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  192 192 192  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  100 100 100  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  208 208 208  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  144 144 144  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  140 140 140  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  100 100 100  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  216 216 216  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  160 160 160
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  108 108 108  184 184 184  223 223 223  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 207 207 207  159 159 159  123 123 123  75 75 75  56 56 56  44 44 44
> 28 28 28  16 16 16  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  204 204 204  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  116 116 116  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  24 24 24
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  52 52 52
> 0 0 0  0 0 0  0 0 0  0 0 0  72 72 72  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  48 48 48  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  24 24 24  196 196 196  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 96 96 96  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  247 247 247  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  20 20 20  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  68 68 68  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  220 220 220  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  32 32 32  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  60 60 60  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  84 84 84
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  48 48 48  120 120 120
> 199 199 199  227 227 227  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  171 171 171  135 135 135  99 99 99  60 60 60
> 48 48 48  32 32 32  20 20 20  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  36 36 36  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  92 92 92
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  219 219 219  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  156 156 156  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  164 164 164  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 108 108 108  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  8 8 8  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  219 219 219  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  48 48 48  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  164 164 164  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  147 147 147
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  136 136 136  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  180 180 180  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  92 92 92  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 195 195 195  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  140 140 140  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  60 60 60  144 144 144  207 207 207  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  195 195 195  147 147 147  111 111 111
> 63 63 63  52 52 52  36 36 36  24 24 24  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  120 120 120  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  195 195 195  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  184 184 184
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  136 136 136  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  235 235 235  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  84 84 84  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 188 188 188  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 136 136 136  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  196 196 196  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  64 64 64  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 120 120 120  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  183 183 183  28 28 28
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  220 220 220  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  112 112 112  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  184 184 184  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  164 164 164  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  124 124 124  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 116 116 116  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  220 220 220  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  192 192 192  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 72 72 72  168 168 168  211 211 211  239 239 239  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  207 207 207  159 159 159
> 123 123 123  75 75 75  56 56 56  44 44 44  28 28 28  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  204 204 204  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  116 116 116  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  52 52 52  0 0 0
> 0 0 0  0 0 0  0 0 0  76 76 76  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  16 16 16  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  24 24 24
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 40 40 40  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  156 156 156  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  112 112 112  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  72 72 72
> 231 231 231  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  52 52 52  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  36 36 36  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  60 60 60  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  204 204 204  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 36 36 36  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  116 116 116  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  96 96 96  180 180 180
> 215 215 215  247 247 247  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 171 171 171  135 135 135  99 99 99  60 60 60  48 48 48  32 32 32
> 20 20 20  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  36 36 36  247 247 247  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  92 92 92  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  144 144 144  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  192 192 192  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  104 104 104
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  180 180 180
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  132 132 132  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  128 128 128  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  204 204 204
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  88 88 88  4 4 4  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 112 112 112  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  92 92 92  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  183 183 183  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  247 247 247  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  195 195 195
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 84 84 84  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  48 48 48  0 0 0
> 0 0 0  24 24 24  120 120 120  195 195 195  223 223 223  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  195 195 195  159 159 159  111 111 111  63 63 63  52 52 52
> 36 36 36  24 24 24  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  132 132 132  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  195 195 195  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  184 184 184  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  136 136 136  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  196 196 196  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  140 140 140  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  200 200 200
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  64 64 64
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  92 92 92  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  176 176 176  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  180 180 180  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  132 132 132  12 12 12  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 176 176 176  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 160 160 160  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  184 184 184  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  64 64 64  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 120 120 120  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  116 116 116
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 132 132 132  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  8 8 8  48 48 48
> 132 132 132  199 199 199  231 231 231  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  207 207 207  159 159 159  123 123 123  87 87 87
> 56 56 56  44 44 44  32 32 32  16 16 16  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  220 220 220  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  116 116 116  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  52 52 52  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  80 80 80  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  48 48 48  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  159 159 159  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  68 68 68  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  204 204 204  0 0 0
> 0 0 0  0 0 0  0 0 0  136 136 136  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  171 171 171  24 24 24  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 216 216 216  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 108 108 108  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  183 183 183  8 8 8  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 204 204 204  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 180 180 180  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  212 212 212  156 156 156  207 207 207
> 235 235 235  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  183 183 183  135 135 135
> 99 99 99  63 63 63  48 48 48  32 32 32  20 20 20  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  60 60 60  251 251 251  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  36 36 36  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  92 92 92  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  28 28 28  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  148 148 148  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  44 44 44  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  16 16 16  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  0 0 0
> 0 0 0  0 0 0  96 96 96  235 235 235  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  36 36 36  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 72 72 72  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  132 132 132  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  52 52 52  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  219 219 219  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  195 195 195
> 159 159 159  111 111 111  63 63 63  52 52 52  40 40 40  24 24 24
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  140 140 140  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 195 195 195  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  184 184 184  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  124 124 124  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  48 48 48  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  235 235 235  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  116 116 116  4 4 4  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  12 12 12
> 0 0 0  48 48 48  223 223 223  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 64 64 64  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 16 16 16  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  231 231 231  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 144 144 144  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  120 120 120
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  136 136 136  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 207 207 207  159 159 159  123 123 123  87 87 87  56 56 56  44 44 44
> 32 32 32  16 16 16  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  24 24 24  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  220 220 220  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 116 116 116  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  64 64 64  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  128 128 128  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  171 171 171  20 20 20  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  207 207 207  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  52 52 52
> 24 24 24  196 196 196  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  108 108 108
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 116 116 116  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  195 195 195
> 28 28 28  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  192 192 192
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  52 52 52  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  183 183 183  135 135 135  99 99 99  63 63 63
> 48 48 48  32 32 32  20 20 20  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  120 120 120  195 195 195  44 44 44  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 60 60 60  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 36 36 36  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  116 116 116  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  195 195 195  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  16 16 16  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  196 196 196  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  231 231 231  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  48 48 48  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  192 192 192  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  76 76 76
> 164 164 164  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  147 147 147  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  24 24 24
> 227 227 227  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  56 56 56
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  195 195 195  159 159 159  111 111 111
> 63 63 63  52 52 52  40 40 40  24 24 24  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  84 84 84
> 168 168 168  207 207 207  231 231 231  207 207 207  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 140 140 140  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  180 180 180
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  204 204 204  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  116 116 116  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  228 228 228  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  152 152 152  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  64 64 64  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  144 144 144  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  200 200 200
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  195 195 195  28 28 28  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  140 140 140
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  92 92 92  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  92 92 92  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  136 136 136  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 192 192 192  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  108 108 108  44 44 44  32 32 32  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  60 60 60  132 132 132  195 195 195  219 219 219
> 247 247 247  255 255 255  255 255 255  120 120 120  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 220 220 220  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  100 100 100
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  247 247 247  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  36 36 36  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  219 219 219  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  84 84 84  239 239 239  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 96 96 96  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  116 116 116  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  56 56 56  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 204 204 204  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  60 60 60  235 235 235
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  96 96 96  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  48 48 48  48 48 48  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  184 184 184  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  52 52 52  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 156 156 156  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  88 88 88  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 120 120 120  180 180 180  211 211 211  235 235 235  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  24 24 24  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 60
> 251 251 251  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  20 20 20
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  120 120 120  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 195 195 195  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  160 160 160  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  60 60 60  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  208 208 208  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  96 96 96
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  76 76 76  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  92 92 92  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 132 132 132  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 80 80 80  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  200 200 200  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  96 96 96  12 12 12  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  132 132 132  191 191 191  207 207 207  207 207 207  199 199 199
> 180 180 180  108 108 108  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  24 24 24  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 96 96 96  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  168 168 168  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  36 36 36  108 108 108  168 168 168  203 203 203
> 231 231 231  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  140 140 140  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  140 140 140
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  180 180 180  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  204 204 204  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 116 116 116  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  72 72 72  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  140 140 140  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  12 12 12
> 180 180 180  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  96 96 96  12 12 12
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  52 52 52  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  132 132 132  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 52 52 52  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 168 168 168  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  168 168 168  251 251 251  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  96 96 96  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  108 108 108
> 207 207 207  188 188 188  135 135 135  87 87 87  63 63 63  99 99 99
> 156 156 156  216 216 216  184 184 184  60 60 60  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  92 92 92  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  160 160 160  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 32 32 32  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  239 239 239  72 72 72  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  60 60 60
> 120 120 120  180 180 180  203 203 203  227 227 227  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  40 40 40  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  220 220 220
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  100 100 100  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 36 36 36  247 247 247  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 36 36 36  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  207 207 207  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  48 48 48  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  160 160 160
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  219 219 219  72 72 72  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 183 183 183  24 24 24  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 8 8 8  195 195 195  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 239 239 239  60 60 60  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  160 160 160  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 96 96 96  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  120 120 120  227 227 227
> 135 135 135  48 48 48  24 24 24  8 8 8  0 0 0  12 12 12
> 32 32 32  72 72 72  192 192 192  211 211 211  48 48 48  0 0 0
> 0 0 0  0 0 0  0 0 0  184 184 184  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  72 72 72  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 4 4 4  183 183 183  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  215 215 215  132 132 132  24 24 24
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  96 96 96  144 144 144  195 195 195  211 211 211
> 231 231 231  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  156 156 156  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  60 60 60  251 251 251
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  20 20 20  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 120 120 120  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  195 195 195
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  96 96 96  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  196 196 196  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  192 192 192  243 243 243
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  183 183 183  64 64 64  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  243 243 243  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 40 40 40  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  68 68 68  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  200 200 200  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 48 48 48  184 184 184  243 243 243  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  195 195 195  64 64 64
> 12 12 12  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  72 72 72  231 231 231  135 135 135
> 24 24 24  108 108 108  144 144 144  144 144 144  144 144 144  144 144 144
> 120 120 120  40 40 40  44 44 44  207 207 207  196 196 196  12 12 12
> 0 0 0  0 0 0  12 12 12  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  231 231 231  12 12 12  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  64 64 64  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  235 235 235  199 199 199
> 120 120 120  60 60 60  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  60 60 60  96 96 96  144 144 144
> 191 191 191  207 207 207  223 223 223  239 239 239  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  44 44 44  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  140 140 140  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  180 180 180  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 204 204 204  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  116 116 116
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  16 16 16  183 183 183
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  251 251 251  192 192 192
> 72 72 72  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  36 36 36  132 132 132  211 211 211  251 251 251  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 123 123 123  40 40 40  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  204 204 204  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  76 76 76
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  159 159 159  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  251 251 251  192 192 192  84 84 84  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  24 24 24  120 120 120
> 207 207 207  251 251 251  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  147 147 147  44 44 44  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  192 192 192  207 207 207  24 24 24
> 0 0 0  180 180 180  168 168 168  96 96 96  96 96 96  108 108 108
> 196 196 196  192 192 192  12 12 12  72 72 72  251 251 251  100 100 100
> 0 0 0  0 0 0  76 76 76  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  164 164 164  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  159 159 159  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  211 211 211  191 191 191  144 144 144  108 108 108  96 96 96
> 72 72 72  48 48 48  48 48 48  48 48 48  48 48 48  48 48 48
> 48 48 48  48 48 48  48 48 48  84 84 84  96 96 96  120 120 120
> 144 144 144  191 191 191  199 199 199  211 211 211  223 223 223  239 239 239
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 183 183 183  4 4 4  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  220 220 220  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  100 100 100  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  36 36 36
> 247 247 247  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  36 36 36
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  52 52 52
> 219 219 219  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  251 251 251
> 215 215 215  168 168 168  84 84 84  48 48 48  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  12 12 12  48 48 48  96 96 96
> 156 156 156  203 203 203  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  195 195 195  84 84 84
> 20 20 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  168 168 168  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  108 108 108  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  32 32 32  207 207 207  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  251 251 251  219 219 219  168 168 168  96 96 96
> 48 48 48  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  48 48 48  84 84 84  156 156 156  199 199 199  231 231 231
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  207 207 207  84 84 84  28 28 28  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  48 48 48  247 247 247  108 108 108  0 0 0
> 0 0 0  192 192 192  136 136 136  16 16 16  16 16 16  20 20 20
> 100 100 100  251 251 251  52 52 52  8 8 8  195 195 195  200 200 200
> 0 0 0  0 0 0  156 156 156  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  72 72 72  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  32 32 32  207 207 207  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  239 239 239  227 227 227  223 223 223
> 215 215 215  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  219 219 219  223 223 223  231 231 231
> 239 239 239  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 64 64 64  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  76 76 76  251 251 251  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  20 20 20  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  120 120 120
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  195 195 195  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  4 4 4
> 64 64 64  219 219 219  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  247 247 247  219 219 219  207 207 207  191 191 191  191 191 191
> 191 191 191  191 191 191  191 191 191  195 195 195  207 207 207  223 223 223
> 243 243 243  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  123 123 123  44 44 44  8 8 8
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  136 136 136  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  159 159 159  16 16 16  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  219 219 219  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  247 247 247  223 223 223
> 207 207 207  191 191 191  191 191 191  191 191 191  191 191 191  191 191 191
> 191 191 191  207 207 207  219 219 219  243 243 243  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  231 231 231
> 135 135 135  48 48 48  8 8 8  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  112 112 112  255 255 255  32 32 32  0 0 0
> 0 0 0  192 192 192  128 128 128  0 0 0  0 0 0  0 0 0
> 124 124 124  255 255 255  40 40 40  0 0 0  140 140 140  247 247 247
> 0 0 0  12 12 12  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  60 60 60  219 219 219  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  183 183 183
> 8 8 8  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  156 156 156  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  180 180 180  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  204 204 204
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  116 116 116  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 4 4 4  64 64 64  219 219 219  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 243 243 243  147 147 147  56 56 56  20 20 20  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  104 104 104  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  207 207 207  32 32 32  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  4 4 4  64 64 64  195 195 195
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  159 159 159  68 68 68
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  128 128 128  255 255 255  4 4 4  0 0 0
> 0 0 0  192 192 192  223 223 223  191 191 191  191 191 191  191 191 191
> 227 227 227  159 159 159  8 8 8  0 0 0  92 92 92  255 255 255
> 0 0 0  76 76 76  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 164 164 164  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  4 4 4  64 64 64  195 195 195
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  88 88 88
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  235 235 235  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  100 100 100  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  36 36 36  247 247 247
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  36 36 36  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  4 4 4  52 52 52  171 171 171  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  231 231 231  147 147 147
> 72 72 72  28 28 28  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  72 72 72  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  231 231 231  60 60 60  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  4 4 4  44 44 44
> 159 159 159  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  159 159 159  72 72 72  32 32 32  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  128 128 128  255 255 255  0 0 0  0 0 0
> 0 0 0  192 192 192  183 183 183  111 111 111  195 195 195  243 243 243
> 63 63 63  32 32 32  0 0 0  0 0 0  104 104 104  255 255 255
> 0 0 0  156 156 156  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 96 96 96  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  4 4 4  44 44 44
> 147 147 147  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  207 207 207  16 16 16
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  76 76 76  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  231 231 231  20 20 20  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  120 120 120  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  195 195 195  4 4 4  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  111 111 111  219 219 219
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  207 207 207  135 135 135  56 56 56  28 28 28
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  40 40 40  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  92 92 92  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 32 32 32  99 99 99  207 207 207  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  219 219 219
> 135 135 135  60 60 60  32 32 32  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  92 92 92  255 255 255  36 36 36  0 0 0
> 0 0 0  192 192 192  136 136 136  16 16 16  56 56 56  240 240 240
> 96 96 96  0 0 0  0 0 0  0 0 0  136 136 136  243 243 243
> 12 12 12  235 235 235  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 20 20 20  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 28 28 28  84 84 84  207 207 207  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  96 96 96  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  156 156 156  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  164 164 164  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  204 204 204  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  116 116 116  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  16 16 16  52 52 52
> 135 135 135  231 231 231  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  231 231 231
> 171 171 171  87 87 87  48 48 48  24 24 24  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  8 8 8  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 135 135 135  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  48 48 48  123 123 123  231 231 231  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  243 243 243  183 183 183  99 99 99  52 52 52
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  32 32 32  255 255 255  120 120 120  0 0 0
> 0 0 0  192 192 192  128 128 128  0 0 0  4 4 4  144 144 144
> 223 223 223  36 36 36  0 0 0  0 0 0  216 216 216  180 180 180
> 76 76 76  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  180 180 180
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  48 48 48  111 111 111  195 195 195  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  219 219 219  171 171 171  99 99 99  16 16 16  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  12 12 12  235 235 235  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  72 72 72  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  36 36 36  247 247 247  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  36 36 36  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 24 24 24  56 56 56  135 135 135  207 207 207  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  231 231 231  183 183 183  123 123 123  56 56 56
> 36 36 36  8 8 8  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  219 219 219
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  183 183 183
> 24 24 24  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  20 20 20  56 56 56  111 111 111
> 195 195 195  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  243 243 243
> 183 183 183  123 123 123  60 60 60  40 40 40  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  4 4 4  183 183 183  216 216 216  24 24 24
> 0 0 0  192 192 192  128 128 128  0 0 0  0 0 0  28 28 28
> 219 219 219  168 168 168  0 0 0  96 96 96  251 251 251  88 88 88
> 144 144 144  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  100 100 100
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  16 16 16  44 44 44  87 87 87
> 171 171 171  231 231 231  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  207 207 207  171 171 171  123 123 123
> 75 75 75  52 52 52  36 36 36  12 12 12  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  76 76 76  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  120 120 120  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  195 195 195  4 4 4  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  24 24 24  48 48 48  87 87 87  147 147 147
> 219 219 219  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  207 207 207
> 147 147 147  99 99 99  56 56 56  40 40 40  20 20 20  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  196 196 196
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  219 219 219  52 52 52
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  16 16 16
> 44 44 44  87 87 87  147 147 147  219 219 219  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  207 207 207  159 159 159  99 99 99  60 60 60
> 40 40 40  20 20 20  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  52 52 52  240 240 240  164 164 164
> 12 12 12  84 84 84  56 56 56  0 0 0  0 0 0  0 0 0
> 76 76 76  100 100 100  72 72 72  223 223 223  171 171 171  16 16 16
> 220 220 220  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  243 243 243  20 20 20
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  8 8 8
> 36 36 36  56 56 56  99 99 99  159 159 159  207 207 207  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  207 207 207  159 159 159
> 135 135 135  99 99 99  63 63 63  48 48 48  36 36 36  20 20 20
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  156 156 156  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 164 164 164  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  204 204 204  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  116 116 116  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  8 8 8  28 28 28
> 52 52 52  87 87 87  135 135 135  183 183 183  231 231 231  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 231 231 231  195 195 195  147 147 147  111 111 111  63 63 63  48 48 48
> 28 28 28  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  156 156 156
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  243 243 243  76 76 76  4 4 4
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  28 28 28  52 52 52  75 75 75  135 135 135
> 183 183 183  219 219 219  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  231 231 231  195 195 195  159 159 159
> 111 111 111  63 63 63  48 48 48  32 32 32  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  4 4 4  96 96 96  232 232 232
> 184 184 184  84 84 84  8 8 8  0 0 0  0 0 0  0 0 0
> 20 20 20  112 112 112  215 215 215  183 183 183  36 36 36  0 0 0
> 108 108 108  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  96 96 96  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  12 12 12  32 32 32  48 48 48  63 63 63
> 111 111 111  159 159 159  183 183 183  219 219 219  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  243 243 243  207 207 207  207 207 207  159 159 159  159 159 159
> 111 111 111  111 111 111  63 63 63  56 56 56  48 48 48  32 32 32
> 24 24 24  12 12 12  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  92 92 92  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 48 48 48  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  104 104 104  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  36 36 36  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  8 8 8  24 24 24  40 40 40  56 56 56  75 75 75
> 111 111 111  159 159 159  183 183 183  207 207 207  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 219 219 219  207 207 207  159 159 159  147 147 147  111 111 111  63 63 63
> 56 56 56  44 44 44  28 28 28  16 16 16  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  60 60 60
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  111 111 111  111 111 111  111 111 111
> 111 111 111  111 111 111  111 111 111  84 84 84  8 8 8  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  4 4 4  24 24 24
> 40 40 40  52 52 52  75 75 75  111 111 111  159 159 159  183 183 183
> 207 207 207  243 243 243  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  255 255 255  255 255 255  255 255 255
> 255 255 255  255 255 255  255 255 255  219 219 219  207 207 207  171 171 171
> 147 147 147  111 111 111  75 75 75  56 56 56  44 44 44  32 32 32
> 16 16 16  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  12 12 12  72 72 72
> 180 180 180  215 215 215  180 180 180  144 144 144  144 144 144  144 144 144
> 195 195 195  212 212 212  147 147 147  40 40 40  0 0 0  0 0 0
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  12 12 12  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 16 16 16  32 32 32  40 40 40  52 52 52  63 63 63  87 87 87
> 111 111 111  123 123 123  159 159 159  159 159 159  183 183 183  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  195 195 195  159 159 159  159 159 159
> 159 159 159  159 159 159  111 111 111  111 111 111  111 111 111  75 75 75
> 63 63 63  60 60 60  48 48 48  48 48 48  32 32 32  32 32 32
> 16 16 16  16 16 16  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 4 4 4  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  4 4 4
> 16 16 16  32 32 32  40 40 40  48 48 48  63 63 63  63 63 63
> 111 111 111  111 111 111  147 147 147  159 159 159  159 159 159  183 183 183
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  171 171 171  159 159 159
> 159 159 159  135 135 135  111 111 111  111 111 111  75 75 75  63 63 63
> 52 52 52  48 48 48  32 32 32  28 28 28  16 16 16  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  8 8 8
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  16 16 16  16 16 16  16 16 16
> 16 16 16  16 16 16  16 16 16  8 8 8  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  4 4 4  16 16 16  32 32 32  40 40 40
> 48 48 48  60 60 60  63 63 63  111 111 111  111 111 111  135 135 135
> 159 159 159  159 159 159  171 171 171  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  207 207 207  207 207 207  207 207 207  207 207 207  207 207 207
> 207 207 207  171 171 171  159 159 159  159 159 159  147 147 147  111 111 111
> 111 111 111  75 75 75  63 63 63  52 52 52  48 48 48  36 36 36
> 28 28 28  16 16 16  4 4 4  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  0 0 0
> 0 0 0  0 0 0  0 0 0  0 0 0  0 0 0  4 4 4
> 40 40 40  87 87 87  144 144 144  144 144 144  144 144 144  144 144 144
> 123 123 123  60 60 60  28 28 28  0 0 0  0 0 0  0 0 0
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_linux_lowerpower_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_pipo_clut224.ppm
Only in linux-3.0.36-lenovo/drivers/video/logo: logo_sunset_bmp.bmp




diff -r linux-3.0.36/drivers/video/logo/Makefile linux-3.0.36-lenovo/drivers/video/logo/Makefile
6a7
> obj-$(CONFIG_LOGO_PIPO_CLUT224)	    += logo_pipo_clut224.o
17a19,25
> obj-$(CONFIG_LOGO_G3_CLUT224)		+= logo_g3_clut224.o
> obj-$(CONFIG_LOGO_LINUX_800x480_CLUT224)        += logo_linux_800x480_clut224.o
> obj-$(CONFIG_LOGO_LINUX_BMP_SUNSET)	+= logo_sunset_bmp.o
> obj-$(CONFIG_LOGO_LINUX_BMP_ANDROID)     += logo_android_bmp.o
> obj-$(CONFIG_LOGO_LOWERPOWER_WARNING)   += logo_linux_lowerpower_clut224.o
> 
> obj-$(CONFIG_LOGO_CHARGER_CLUT224)         += logo_charger00_clut224.o logo_charger01_clut224.o logo_charger02_clut224.o logo_charger03_clut224.o logo_charger04_clut224.o logo_charger05_clut224.o logo_charger06_clut224.o logo_charger07_clut224.o logo_charger08_clut224.o 
39a48,50
> extra-y += $(call logo-cfiles,_bmp,bmp)
> 
> bmptologo := scripts/bmptologo
47a59,63
> quiet_cmd_bmplogo = LOGO    $@
> 	cmd_bmplogo = $(bmptologo) \
> 			-t $(patsubst $*_%,%,$(notdir $(basename $<))) \
> 			-n $(notdir $(basename $<)) -o $@ $<
> 
59a76,78
> $(obj)/%_bmp.c: $(src)/%_bmp.bmp $(bmptologo) FORCE
> 	$(call if_changed,bmplogo)
> 
61c80
< clean-files := *.o *_mono.c *_vga16.c *_clut224.c *_gray256.c
---
> clean-files := *.o *_mono.c *_vga16.c *_clut224.c *_gray256.c *_bmp.c




diff -r linux-3.0.36/drivers/video/Makefile linux-3.0.36-lenovo/drivers/video/Makefile
8a9
> 
9a11,15
> ifdef CONFIG_MACH_RK29_2906
> fb.o: fb.uu
> 	@echo "UUDE    fb.uu"
> 	@uudecode fb.uu -o fb.o
> else
12a19
> endif
16c23
< obj-y				  += backlight/ display/
---
> obj-y				  += backlight/ display/ hdmi/
127a135,136
> obj-$(CONFIG_FB_RK29)             += rk29_fb.o
> obj-y                             += rockchip/




diff -r linux-3.0.36/drivers/video/modedb.c linux-3.0.36-lenovo/drivers/video/modedb.c
844c844
< 		mode1->yres         == mode2->yres &&
---
> 		mode1->yres         == mode2->yres);/* &&
853c853
< 		mode1->vmode        == mode2->vmode);
---
> 		mode1->vmode        == mode2->vmode);*/




diff -r linux-3.0.36/drivers/video/mxsfb.c linux-3.0.36-lenovo/drivers/video/mxsfb.c
368c368,369
< 	writel(VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4 + REG_CLR);
---
> 	reg = readl(host->base + LCDC_VDCTRL4);
> 	writel(reg & ~VDCTRL4_SYNC_SIGNALS_ON, host->base + LCDC_VDCTRL4);




diff -r linux-3.0.36/drivers/video/riva/fbdev.c linux-3.0.36-lenovo/drivers/video/riva/fbdev.c
1818a1819,1820
> 		/* get first mode in database as fallback */
> 		modedb = specs->modedb[0];
1829,1831d1830
< 		} else {
< 			/* otherwise, get first mode in database */
< 			modedb = specs->modedb[0];
Only in linux-3.0.36-lenovo/drivers/video: rk29_fb.c
Only in linux-3.0.36-lenovo/drivers/video: rk29_fb.h
Only in linux-3.0.36-lenovo/drivers/video: rockchip




diff -r linux-3.0.36/drivers/video/udlfb.c linux-3.0.36-lenovo/drivers/video/udlfb.c
616c616
< 		int start = max((int)(offset / info->fix.line_length) - 1, 0);
---
> 		int start = max((int)(offset / info->fix.line_length), 0);




diff -r linux-3.0.36/drivers/video/via/via_clock.c linux-3.0.36-lenovo/drivers/video/via/via_clock.c
27a28
> #include <asm/olpc.h>
291a293,296
> static void noop_set_clock_state(u8 state)
> {
> }
> 
347a353,366
> 	}
> 
> 	if (machine_is_olpc()) {
> 		/* The OLPC XO-1.5 cannot suspend/resume reliably if the
> 		 * IGA1/IGA2 clocks are set as on or off (memory rot
> 		 * occasionally happens during suspend under such
> 		 * configurations).
> 		 *
> 		 * The only known stable scenario is to leave this bits as-is,
> 		 * which in their default states are documented to enable the
> 		 * clock only when it is needed.
> 		 */
> 		clock->set_primary_clock_state = noop_set_clock_state;
> 		clock->set_secondary_clock_state = noop_set_clock_state;




diff -r linux-3.0.36/drivers/virtio/virtio_ring.c linux-3.0.36-lenovo/drivers/virtio/virtio_ring.c
122a123,129
> 	/*
> 	 * We require lowmem mappings for the descriptors because
> 	 * otherwise virt_to_phys will give us bogus addresses in the
> 	 * virtqueue.
> 	 */
> 	gfp &= ~(__GFP_HIGHMEM | __GFP_HIGH);
> 




diff -r linux-3.0.36/drivers/watchdog/hpwdt.c linux-3.0.36-lenovo/drivers/watchdog/hpwdt.c
775a776,778
> 	/* Make sure that timer is disabled until /dev/watchdog is opened */
> 	hpwdt_stop();
> 




diff -r linux-3.0.36/drivers/watchdog/Kconfig linux-3.0.36-lenovo/drivers/watchdog/Kconfig
75a76,99
> config RK29_WATCHDOG
> 	tristate "RK29 watchdog"
> 	help
> 	  Watchdog timer embedded into RK29xx chips. This will reboot your
> 	  system when the timeout is reached.
> 
> config RK29_FEED_DOG_BY_INTE
> 	bool "feed watchdog by interrupt"
> 	depends on RK29_WATCHDOG
> 
> config RK29_WATCHDOG_ATBOOT
> 	bool "start watchdog at system boot"
> 	depends on RK29_WATCHDOG
> 
> config RK29_WATCHDOG_DEFAULT_TIME
> 	int "set watchdog time out value (unit second)"
> 	depends on RK29_WATCHDOG
> 	help
> 	  the real time out value is two times more than the setting value
> 
> config RK29_WATCHDOG_DEBUG
> 	bool "enable watchdog debug"
> 	depends on RK29_WATCHDOG
> 




diff -r linux-3.0.36/drivers/watchdog/Makefile linux-3.0.36-lenovo/drivers/watchdog/Makefile
49a50
> obj-$(CONFIG_RK29_WATCHDOG) += rk29_wdt.o
Only in linux-3.0.36-lenovo/drivers/watchdog: rk29_wdt.c




diff -r linux-3.0.36/fs/autofs4/root.c linux-3.0.36-lenovo/fs/autofs4/root.c
395,396d394
< 		if (status)
< 			return ERR_PTR(status);
398a397,400
> 		if (status) {
> 			spin_unlock(&sbi->fs_lock);
> 			return ERR_PTR(status);
> 		}




diff -r linux-3.0.36/fs/binfmt_elf.c linux-3.0.36-lenovo/fs/binfmt_elf.c
1672c1672
< 		goto notes_free;
---
> 		return 0;
1675c1675
< 		goto psinfo_free;
---
> 		return 0;
1678c1678
< 		goto prstatus_free;
---
> 		return 0;
1682c1682
< 		goto fpu_free;
---
> 		return 0;
1685,1695d1684
< #ifdef ELF_CORE_COPY_XFPREGS
<  fpu_free:
< 	kfree(info->fpu);
< #endif
<  prstatus_free:
< 	kfree(info->prstatus);
<  psinfo_free:
< 	kfree(info->psinfo);
<  notes_free:
< 	kfree(info->notes);
< 	return 0;




diff -r linux-3.0.36/fs/binfmt_misc.c linux-3.0.36-lenovo/fs/binfmt_misc.c
179c179,182
< 	bprm->interp = iname;	/* for binfmt_script */
---
> 	/* Update interp in case binfmt_script needs it. */
> 	retval = bprm_change_interp(iname, bprm);
> 	if (retval < 0)
> 		goto _error;




diff -r linux-3.0.36/fs/binfmt_script.c linux-3.0.36-lenovo/fs/binfmt_script.c
85c85,87
< 	bprm->interp = interp;
---
> 	retval = bprm_change_interp(interp, bprm);
> 	if (retval < 0)
> 		return retval;




diff -r linux-3.0.36/fs/block_dev.c linux-3.0.36-lenovo/fs/block_dev.c
29a30,31
> #include <linux/mtd/blktrans.h>
> #include <linux/mtd/mtd.h>
1579a1582,1654
> 
> ssize_t mydo_sync_read(struct file *filp, char __user *buf, size_t len, loff_t *ppos)
> {
>     unsigned long buf_addr = (unsigned long)buf;
>     if((memcmp(filp->f_mapping->host->i_bdev->bd_disk->disk_name, "mtdblock", 8) == 0) &&(buf_addr >= 0xc0000000))// kernel mem is usb tran &&(buf_addr >= 0xc0000000)
>     {
>         struct mtd_blktrans_dev *dev;
>         struct mtd_blktrans_ops *tr;
>         struct mtd_info *mtd;
>         
>         dev = (filp->f_mapping->host->i_bdev->bd_disk->private_data);
>         mtd = dev->mtd;
>         /*if((buf_addr < 0xc0000000)&&(mtd->name[0]=='u' &&mtd->name[3]=='r' && mtd->name[4]==0)) // user part 
>         {
>             return(do_sync_read(filp, buf,len,ppos));
>         }*/
>         tr = dev->tr;
> 		if (!tr->readsect)
> 		{
> 			return(do_sync_read(filp, buf,len,ppos));
> 	    }
>         //printk("mydo_sync_read buf = 0x%lx LBA = 0x%lx len = 0x%x \n",buf, (unsigned long)(*ppos>>9),len);
>         if(tr->readsect(dev, (unsigned long)(*ppos>>9), len>>9, buf))
>         {
>             return 0 ;
>         }
>         *ppos += len;
>         return len;
>     }
> 
>     else
>     {
>         return(do_sync_read(filp, buf,len,ppos));
>     }
> }
> 
> ssize_t mydo_sync_write(struct file *filp, const char __user *buf, size_t len, loff_t *ppos)
> {
>     unsigned long buf_addr = (unsigned long)buf;
>     if((memcmp(filp->f_mapping->host->i_bdev->bd_disk->disk_name, "mtdblock", 8) == 0) &&(buf_addr >= 0xc0000000))// kernel mem is usb tran &&(buf_addr >= 0xc0000000)
>     {
>         struct mtd_blktrans_dev *dev;
>         struct mtd_blktrans_ops *tr;
>         struct mtd_info *mtd;
>         
>         dev = (filp->f_mapping->host->i_bdev->bd_disk->private_data);
>         
>         mtd = dev->mtd;
>         /*if((buf_addr < 0xc0000000)&&(mtd->name[0]=='u' &&mtd->name[3]=='r' && mtd->name[4]==0))
>         {
>             return(do_sync_write(filp, buf,len,ppos));
>         }*/
> 
>         tr = dev->tr;
> 
> 		if (!tr->writesect)
> 			return 0;
>         //printk("mydo_sync_write buf = 0x%lx LBA = 0x%lx len = 0x%x \n",buf, (unsigned long)(*ppos>>9),len);
>         if(tr->writesect(dev, (unsigned long)(*ppos>>9), len>>9, buf))
>         {
>             return 0 ;
>         }
>         *ppos += len;
>         return len;
>     }
> 
>     else
>     {
>         return(do_sync_write(filp, buf,len,ppos));
>     }
> }
> 
> 
1584,1585c1659,1660
< 	.read		= do_sync_read,
< 	.write		= do_sync_write,
---
> 	.read		= mydo_sync_read,
> 	.write		= mydo_sync_write,




diff -r linux-3.0.36/fs/btrfs/async-thread.c linux-3.0.36-lenovo/fs/btrfs/async-thread.c
215c215
< 		/* now take the lock again and call the freeing code */
---
> 		/* now take the lock again and drop our item from the list */
217a218,223
> 		spin_unlock(&workers->order_lock);
> 
> 		/*
> 		 * we don't want to call the ordered free functions
> 		 * with the lock held though
> 		 */
218a225
> 		spin_lock(&workers->order_lock);




diff -r linux-3.0.36/fs/btrfs/disk-io.c linux-3.0.36-lenovo/fs/btrfs/disk-io.c
804c804,805
< 			struct page *newpage, struct page *page)
---
> 			struct page *newpage, struct page *page,
> 			enum migrate_mode mode)
819c820
< 	return migrate_page(mapping, newpage, page);
---
> 	return migrate_page(mapping, newpage, page, mode);




diff -r linux-3.0.36/fs/btrfs/tree-log.c linux-3.0.36-lenovo/fs/btrfs/tree-log.c
693a694,695
> 
> 	btrfs_run_delayed_items(trans, root);
898a901
> 				btrfs_run_delayed_items(trans, root);
1478a1482,1484
> 
> 			btrfs_run_delayed_items(trans, root);
> 




diff -r linux-3.0.36/fs/buffer.c linux-3.0.36-lenovo/fs/buffer.c
110c110
< 	printk(KERN_ERR "Buffer I/O error on device %s, logical block %Lu\n",
---
> 	printk(KERN_DEBUG "Buffer I/O error on device %s, logical block %Lu\n",
964c964
< static void
---
> static sector_t
985a986,990
> 
> 	/*
> 	 * Caller needs to validate requested block against end of device.
> 	 */
> 	return end_block;
991c996
<  * This is user purely for blockdev mappings.
---
>  * This is used purely for blockdev mappings.
993c998
< static struct page *
---
> static int
995c1000
< 		pgoff_t index, int size)
---
> 		pgoff_t index, int size, int sizebits)
999a1005,1006
> 	sector_t end_block;
> 	int ret = 0;		/* Will call free_more_memory() */
1004c1011
< 		return NULL;
---
> 		return ret;
1011,1012c1018,1020
< 			init_page_buffers(page, bdev, block, size);
< 			return page;
---
> 			end_block = init_page_buffers(page, bdev,
> 						index << sizebits, size);
> 			goto done;
1032c1040
< 	init_page_buffers(page, bdev, block, size);
---
> 	end_block = init_page_buffers(page, bdev, index << sizebits, size);
1034c1042,1043
< 	return page;
---
> done:
> 	ret = (block < end_block) ? 1 : -ENXIO;
1037d1045
< 	BUG();
1040c1048
< 	return NULL;
---
> 	return ret;
1050d1057
< 	struct page *page;
1074c1081
< 	block = index << sizebits;
---
> 
1076,1081c1083
< 	page = grow_dev_page(bdev, block, index, size);
< 	if (!page)
< 		return 0;
< 	unlock_page(page);
< 	page_cache_release(page);
< 	return 1;
---
> 	return grow_dev_page(bdev, block, index, size, sizebits);
1100c1102
< 		struct buffer_head * bh;
---
> 		struct buffer_head *bh;
1367,1370d1368
<  *
<  * __getblk() cannot fail - it just keeps trying.  If you pass it an
<  * illegal block number, __getblk() will happily return a buffer_head
<  * which represents the non-existent block.  Very weird.




diff -r linux-3.0.36/fs/ceph/export.c linux-3.0.36-lenovo/fs/ceph/export.c
87c87
< 				     struct ceph_nfs_fh *fh)
---
> 				     struct ceph_nfs_fh *fh, int fh_len)
94a95,97
> 	if (fh_len < sizeof(*fh) / 4)
> 		return ERR_PTR(-ESTALE);
> 
139c142
< 				      struct ceph_nfs_confh *cfh)
---
> 				      struct ceph_nfs_confh *cfh, int fh_len)
146a150,152
> 	if (fh_len < sizeof(*cfh) / 4)
> 		return ERR_PTR(-ESTALE);
> 
196c202,203
< 		return __fh_to_dentry(sb, (struct ceph_nfs_fh *)fid->raw);
---
> 		return __fh_to_dentry(sb, (struct ceph_nfs_fh *)fid->raw,
> 								fh_len);
198c205,206
< 		return __cfh_to_dentry(sb, (struct ceph_nfs_confh *)fid->raw);
---
> 		return __cfh_to_dentry(sb, (struct ceph_nfs_confh *)fid->raw,
> 								fh_len);
217a226,227
> 		return ERR_PTR(-ESTALE);
> 	if (fh_len < sizeof(*cfh) / 4)




diff -r linux-3.0.36/fs/cifs/cifs_dfs_ref.c linux-3.0.36-lenovo/fs/cifs/cifs_dfs_ref.c
227a228,229
> 	kfree(*devname);
> 	*devname = NULL;




diff -r linux-3.0.36/fs/cifs/readdir.c linux-3.0.36-lenovo/fs/cifs/readdir.c
88,89c88,91
< 		/* FIXME: check for inode number changes? */
< 		if (dentry->d_inode != NULL)
---
> 		inode = dentry->d_inode;
> 		/* update inode in place if i_ino didn't change */
> 		if (inode && CIFS_I(inode)->uniqueid == fattr->cf_uniqueid) {
> 			cifs_fattr_to_inode(inode, fattr);
90a93
> 		}




diff -r linux-3.0.36/fs/compat.c linux-3.0.36-lenovo/fs/compat.c
1179a1180
> 	loff_t pos;
1184c1185,1187
< 	ret = compat_readv(file, vec, vlen, &file->f_pos);
---
> 	pos = file->f_pos;
> 	ret = compat_readv(file, vec, vlen, &pos);
> 	file->f_pos = pos;
1238a1242
> 	loff_t pos;
1243c1247,1249
< 	ret = compat_writev(file, vec, vlen, &file->f_pos);
---
> 	pos = file->f_pos;
> 	ret = compat_writev(file, vec, vlen, &pos);
> 	file->f_pos = pos;




diff -r linux-3.0.36/fs/compat_ioctl.c linux-3.0.36-lenovo/fs/compat_ioctl.c
210a211,212
> 	if (err)
> 		return -EFAULT;




diff -r linux-3.0.36/fs/cramfs/inode.c linux-3.0.36-lenovo/fs/cramfs/inode.c
342,343c342,345
< 	buf->f_bfree = 0;
< 	buf->f_bavail = 0;
---
> 	// modify by cmc for cts test
> 	buf->f_bfree = 1; // 0
> 	buf->f_bavail = 1; // 0
> 	// end modify




diff -r linux-3.0.36/fs/dcache.c linux-3.0.36-lenovo/fs/dcache.c
293c293
< 	dentry->d_flags |= DCACHE_DISCONNECTED;
---
> 	dentry->d_flags |= DCACHE_DENTRY_KILLED;
1018c1018
< 		 (old->d_flags & DCACHE_DISCONNECTED) ||
---
> 		 (old->d_flags & DCACHE_DENTRY_KILLED) ||
1103a1104,1105
> 	if (locked)
> 		goto again;
1205a1208,1209
> 	if (locked)
> 		goto again;
2992a2997,2998
> 	if (locked)
> 		goto again;




diff -r linux-3.0.36/fs/ecryptfs/inode.c linux-3.0.36-lenovo/fs/ecryptfs/inode.c
655a656
> 	struct inode *target_inode;
662a664
> 	target_inode = new_dentry->d_inode;
677a680,682
> 	if (target_inode)
> 		fsstack_copy_attr_all(target_inode,
> 				      ecryptfs_inode_to_lower(target_inode));




diff -r linux-3.0.36/fs/ecryptfs/kthread.c linux-3.0.36-lenovo/fs/ecryptfs/kthread.c
152c152
< 	if (flags & O_RDONLY) {
---
> 	if ((flags & O_ACCMODE) == O_RDONLY) {




diff -r linux-3.0.36/fs/ecryptfs/main.c linux-3.0.36-lenovo/fs/ecryptfs/main.c
281a282
> 	u8 cipher_code;
422a424,435
> 
> 	cipher_code = ecryptfs_code_for_cipher_string(
> 		mount_crypt_stat->global_default_cipher_name,
> 		mount_crypt_stat->global_default_cipher_key_size);
> 	if (!cipher_code) {
> 		ecryptfs_printk(KERN_ERR,
> 				"eCryptfs doesn't support cipher: %s",
> 				mount_crypt_stat->global_default_cipher_name);
> 		rc = -EINVAL;
> 		goto out;
> 	}
> 
508d520
< 	s->s_flags = flags;
543a556,564
> 
> 	/**
> 	 * Set the POSIX ACL flag based on whether they're enabled in the lower
> 	 * mount. Force a read-only eCryptfs mount if the lower mount is ro.
> 	 * Allow a ro eCryptfs mount even when the lower mount is rw.
> 	 */
> 	s->s_flags = flags & ~MS_POSIXACL;
> 	s->s_flags |= path.dentry->d_sb->s_flags & (MS_RDONLY | MS_POSIXACL);
> 




diff -r linux-3.0.36/fs/ecryptfs/miscdev.c linux-3.0.36-lenovo/fs/ecryptfs/miscdev.c
52c52,55
< 	BUG_ON(rc || !daemon);
---
> 	if (rc || !daemon) {
> 		mutex_unlock(&ecryptfs_daemon_hash_mux);
> 		return -EINVAL;
> 	}
124a128
> 	file->private_data = daemon;
155c159,160
< 	BUG_ON(rc || !daemon);
---
> 	if (rc || !daemon)
> 		daemon = file->private_data;
157d161
< 	BUG_ON(daemon->pid != task_pid(current));
194c198
< 	int rc = 0;
---
> 	struct ecryptfs_message *msg;
196,200c200,201
< 	mutex_lock(&msg_ctx->mux);
< 	msg_ctx->msg = kmalloc((sizeof(*msg_ctx->msg) + data_size),
< 			       GFP_KERNEL);
< 	if (!msg_ctx->msg) {
< 		rc = -ENOMEM;
---
> 	msg = kmalloc((sizeof(*msg) + data_size), GFP_KERNEL);
> 	if (!msg) {
203,204c204,205
< 		       (sizeof(*msg_ctx->msg) + data_size));
< 		goto out_unlock;
---
> 		       (sizeof(*msg) + data_size));
> 		return -ENOMEM;
205a207,209
> 
> 	mutex_lock(&msg_ctx->mux);
> 	msg_ctx->msg = msg;
211d214
< 	mutex_lock(&daemon->mux);
212a216,218
> 	mutex_unlock(&msg_ctx->mux);
> 
> 	mutex_lock(&daemon->mux);
216,218c222,223
< out_unlock:
< 	mutex_unlock(&msg_ctx->mux);
< 	return rc;
---
> 
> 	return 0;
249c254,257
< 	BUG_ON(rc || !daemon);
---
> 	if (rc || !daemon) {
> 		mutex_unlock(&ecryptfs_daemon_hash_mux);
> 		return -EINVAL;
> 	}
250a259,263
> 	if (task_pid(current) != daemon->pid) {
> 		mutex_unlock(&daemon->mux);
> 		mutex_unlock(&ecryptfs_daemon_hash_mux);
> 		return -EPERM;
> 	}
287,289d299
< 	BUG_ON(euid != daemon->euid);
< 	BUG_ON(current_user_ns() != daemon->user_ns);
< 	BUG_ON(task_pid(current) != daemon->pid);




diff -r linux-3.0.36/fs/eventpoll.c linux-3.0.36-lenovo/fs/eventpoll.c
1200c1200
< 	epi->event.events = event->events;
---
> 	epi->event.events = event->events; /* need barrier below */
1201a1202,1221
> 
> 	/*
> 	 * The following barrier has two effects:
> 	 *
> 	 * 1) Flush epi changes above to other CPUs.  This ensures
> 	 *    we do not miss events from ep_poll_callback if an
> 	 *    event occurs immediately after we call f_op->poll().
> 	 *    We need this because we did not take ep->lock while
> 	 *    changing epi above (but ep_poll_callback does take
> 	 *    ep->lock).
> 	 *
> 	 * 2) We also need to ensure we do not miss _past_ events
> 	 *    when calling f_op->poll().  This barrier also
> 	 *    pairs with the barrier in wq_has_sleeper (see
> 	 *    comments for wq_has_sleeper).
> 	 *
> 	 * This barrier will now guarantee ep_poll_callback or f_op->poll
> 	 * (or both) will notice the readiness of an item.
> 	 */
> 	smp_mb();




diff -r linux-3.0.36/fs/exec.c linux-3.0.36-lenovo/fs/exec.c
1194a1195,1197
> 	/* If a binfmt changed the interp, free it. */
> 	if (bprm->interp != bprm->filename)
> 		kfree(bprm->interp);
1196a1200,1211
> 
> int bprm_change_interp(char *interp, struct linux_binprm *bprm)
> {
> 	/* If a binfmt changed the interp, free it first. */
> 	if (bprm->interp != bprm->filename)
> 		kfree(bprm->interp);
> 	bprm->interp = kstrdup(interp, GFP_KERNEL);
> 	if (!bprm->interp)
> 		return -ENOMEM;
> 	return 0;
> }
> EXPORT_SYMBOL(bprm_change_interp);




diff -r linux-3.0.36/fs/ext3/inode.c linux-3.0.36-lenovo/fs/ext3/inode.c
3015a3016,3017
> 	int need_datasync = 0;
> 	__le32 disksize;
3053c3055,3059
< 	raw_inode->i_size = cpu_to_le32(ei->i_disksize);
---
> 	disksize = cpu_to_le32(ei->i_disksize);
> 	if (disksize != raw_inode->i_size) {
> 		need_datasync = 1;
> 		raw_inode->i_size = disksize;
> 	}
3069,3070c3075,3079
< 		raw_inode->i_size_high =
< 			cpu_to_le32(ei->i_disksize >> 32);
---
> 		disksize = cpu_to_le32(ei->i_disksize >> 32);
> 		if (disksize != raw_inode->i_size_high) {
> 			raw_inode->i_size_high = disksize;
> 			need_datasync = 1;
> 		}
3122a3132,3133
> 	if (need_datasync)
> 		atomic_set(&ei->i_datasync_tid, handle->h_transaction->t_tid);




diff -r linux-3.0.36/fs/ext4/acl.c linux-3.0.36-lenovo/fs/ext4/acl.c
453,454c453,456
< 	if (IS_ERR(handle))
< 		return PTR_ERR(handle);
---
> 	if (IS_ERR(handle)) {
> 		error = PTR_ERR(handle);
> 		goto release_and_out;
> 	}




diff -r linux-3.0.36/fs/ext4/balloc.c linux-3.0.36-lenovo/fs/ext4/balloc.c
517c517,518
< 		x = ext4_count_free(bitmap_bh, sb->s_blocksize);
---
> 		x = ext4_count_free(bitmap_bh->b_data,
> 				    EXT4_BLOCKS_PER_GROUP(sb) / 8);




diff -r linux-3.0.36/fs/ext4/bitmap.c linux-3.0.36-lenovo/fs/ext4/bitmap.c
18c18
< unsigned int ext4_count_free(struct buffer_head *map, unsigned int numchars)
---
> unsigned int ext4_count_free(char *bitmap, unsigned int numchars)
22,23d21
< 	if (!map)
< 		return 0;
25,26c23,24
< 		sum += nibblemap[map->b_data[i] & 0xf] +
< 			nibblemap[(map->b_data[i] >> 4) & 0xf];
---
> 		sum += nibblemap[bitmap[i] & 0xf] +
> 			nibblemap[(bitmap[i] >> 4) & 0xf];




diff -r linux-3.0.36/fs/ext4/ext4.h linux-3.0.36-lenovo/fs/ext4/ext4.h
1716c1716
< extern unsigned int ext4_count_free(struct buffer_head *, unsigned);
---
> extern unsigned int ext4_count_free(char *bitmap, unsigned numchars);




diff -r linux-3.0.36/fs/ext4/extents.c linux-3.0.36-lenovo/fs/ext4/extents.c
2143c2143
< 			struct ext4_ext_path *path)
---
> 			struct ext4_ext_path *path, int depth)
2149c2149,2150
< 	path--;
---
> 	depth--;
> 	path = path + depth;
2164a2166,2178
> 
> 	while (--depth >= 0) {
> 		if (path->p_idx != EXT_FIRST_INDEX(path->p_hdr))
> 			break;
> 		path--;
> 		err = ext4_ext_get_access(handle, inode, path);
> 		if (err)
> 			break;
> 		path->p_idx->ei_block = (path+1)->p_idx->ei_block;
> 		err = ext4_ext_dirty(handle, inode, path);
> 		if (err)
> 			break;
> 	}
2512c2526
< 		err = ext4_ext_rm_idx(handle, inode, path + depth);
---
> 		err = ext4_ext_rm_idx(handle, inode, path, depth);
2642c2656
< 				err = ext4_ext_rm_idx(handle, inode, path + i);
---
> 				err = ext4_ext_rm_idx(handle, inode, path, i);




diff -r linux-3.0.36/fs/ext4/ialloc.c linux-3.0.36-lenovo/fs/ext4/ialloc.c
1196c1196,1197
< 		x = ext4_count_free(bitmap_bh, EXT4_INODES_PER_GROUP(sb) / 8);
---
> 		x = ext4_count_free(bitmap_bh->b_data,
> 				    EXT4_INODES_PER_GROUP(sb) / 8);




diff -r linux-3.0.36/fs/ext4/inode.c linux-3.0.36-lenovo/fs/ext4/inode.c
1136a1137,1145
> 	if (unlikely(ei->i_allocated_meta_blocks > ei->i_reserved_meta_blocks)) {
> 		ext4_msg(inode->i_sb, KERN_NOTICE, "%s: ino %lu, allocated %d "
> 			 "with only %d reserved metadata blocks\n", __func__,
> 			 inode->i_ino, ei->i_allocated_meta_blocks,
> 			 ei->i_reserved_meta_blocks);
> 		WARN_ON(1);
> 		ei->i_allocated_meta_blocks = ei->i_reserved_meta_blocks;
> 	}
> 
2192a2202,2203
> 
> 	pagevec_init(&pvec, 0);
5144a5156
> 	int need_datasync = 0;
5193c5205,5208
< 	ext4_isize_set(raw_inode, ei->i_disksize);
---
> 	if (ei->i_disksize != ext4_isize(raw_inode)) {
> 		ext4_isize_set(raw_inode, ei->i_disksize);
> 		need_datasync = 1;
> 	}
5246c5261
< 	ext4_update_inode_fsync_trans(handle, inode, 0);
---
> 	ext4_update_inode_fsync_trans(handle, inode, need_datasync);




diff -r linux-3.0.36/fs/ext4/move_extent.c linux-3.0.36-lenovo/fs/ext4/move_extent.c
1212c1212,1217
< 
---
> 	/* TODO: This is non obvious task to swap blocks for inodes with full
> 	   jornaling enabled */
> 	if (ext4_should_journal_data(orig_inode) ||
> 	    ext4_should_journal_data(donor_inode)) {
> 		return -EINVAL;
> 	}




diff -r linux-3.0.36/fs/ext4/namei.c linux-3.0.36-lenovo/fs/ext4/namei.c
1802d1801
< #ifdef CONFIG_EXT4_FS_XATTR
1804d1802
< #endif




diff -r linux-3.0.36/fs/ext4/super.c linux-3.0.36-lenovo/fs/ext4/super.c
862a863
> 	ei->i_da_metadata_calc_last_lblock = 0;
2205a2207
> 			mutex_lock(&inode->i_mutex);
2206a2209
> 			mutex_unlock(&inode->i_mutex);
4440c4443
< 	if (sbi->s_journal == NULL)
---
> 	if (sbi->s_journal == NULL && !(old_sb_flags & MS_RDONLY))




diff -r linux-3.0.36/fs/fat/dir.c linux-3.0.36-lenovo/fs/fat/dir.c
101c101
< 		fat_msg(sb, KERN_ERR, "Directory bread(block %llu) failed",
---
> 		fat_msg(sb, KERN_DEBUG, "Directory bread(block %llu) failed",
756a757,763
> static int fat_ioctl_volume_id(struct inode *dir)
> {
> 	struct super_block *sb = dir->i_sb;
> 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
> 	return sbi->vol_id;
> }
> 
772a780,781
> 	case VFAT_IOCTL_GET_VOLUME_ID:
> 		return fat_ioctl_volume_id(inode);




diff -r linux-3.0.36/fs/fat/fatent.c linux-3.0.36-lenovo/fs/fat/fatent.c
98c98
< 	fat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)", (llu)blocknr);
---
> 	fat_msg(sb, KERN_DEBUG, "FAT read failed (blocknr %llu)", (llu)blocknr);
111c111
< 		fat_msg(sb, KERN_ERR, "FAT read failed (blocknr %llu)",
---
> 		fat_msg(sb, KERN_DEBUG, "FAT read failed (blocknr %llu)",
351c351
< 		fat_fs_error(sb, "invalid access to FAT (entry 0x%08x)", entry);
---
> 		fat_fs_error_ratelimit(sb, "invalid access to FAT (entry 0x%08x)", entry);




diff -r linux-3.0.36/fs/fat/fat.h linux-3.0.36-lenovo/fs/fat/fat.h
80a81
> 	unsigned long vol_id;        /* volume ID */




diff -r linux-3.0.36/fs/fat/inode.c linux-3.0.36-lenovo/fs/fat/inode.c
1238a1239,1251
> static unsigned long calc_fat_clusters(struct super_block *sb)
> {
> 	struct msdos_sb_info *sbi = MSDOS_SB(sb);
> 
> 	/* Divide first to avoid overflow */
> 	if (sbi->fat_bits != 12) {
> 		unsigned long ent_per_sec = sb->s_blocksize * 8 / sbi->fat_bits;
> 		return ent_per_sec * sbi->fat_length;
> 	}
> 
> 	return sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;
> }
> 
1247a1261
> 	struct fat_boot_bsx *bsx;
1284c1298
< 		fat_msg(sb, KERN_ERR, "unable to read boot sector");
---
> 		fat_msg(sb, KERN_DEBUG, "unable to read boot sector");
1350c1364
< 			fat_msg(sb, KERN_ERR, "unable to read boot sector"
---
> 			fat_msg(sb, KERN_DEBUG, "unable to read boot sector"
1392a1407,1408
> 		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT32_BSX_OFFSET);
> 
1407a1424,1425
> 	} else {
> 		bsx = (struct fat_boot_bsx *)(bh->b_data + FAT16_BSX_OFFSET);
1409a1428,1431
> 	/* interpret volume ID as a little endian 32 bit integer */
> 	sbi->vol_id = (((u32)bsx->vol_id[0]) | ((u32)bsx->vol_id[1] << 8) |
> 		((u32)bsx->vol_id[2] << 16) | ((u32)bsx->vol_id[3] << 24));
> 
1436c1458
< 	fat_clusters = sbi->fat_length * sb->s_blocksize * 8 / sbi->fat_bits;
---
> 	fat_clusters = calc_fat_clusters(sb);




diff -r linux-3.0.36/fs/fat/namei_vfat.c linux-3.0.36-lenovo/fs/fat/namei_vfat.c
517c517,518
< 		*outlen = utf8s_to_utf16s(name, len, (wchar_t *)outname);
---
> 		*outlen = utf8s_to_utf16s(name, len, UTF16_HOST_ENDIAN,
> 				(wchar_t *) outname, FAT_LFN_LEN + 2);




diff -r linux-3.0.36/fs/fifo.c linux-3.0.36-lenovo/fs/fifo.c
17c17
< static void wait_for_partner(struct inode* inode, unsigned int *cnt)
---
> static int wait_for_partner(struct inode* inode, unsigned int *cnt)
25a26
> 	return cur == *cnt ? -ERESTARTSYS : 0;
70,71c71
< 				wait_for_partner(inode, &pipe->w_counter);
< 				if(signal_pending(current))
---
> 				if (wait_for_partner(inode, &pipe->w_counter))
93,94c93
< 			wait_for_partner(inode, &pipe->r_counter);
< 			if (signal_pending(current))
---
> 			if (wait_for_partner(inode, &pipe->r_counter))




diff -r linux-3.0.36/fs/fs-writeback.c linux-3.0.36-lenovo/fs/fs-writeback.c
1050c1050
< 	if (unlikely(block_dump))
---
> 	if (unlikely(block_dump > 1))




diff -r linux-3.0.36/fs/fuse/dev.c linux-3.0.36-lenovo/fs/fuse/dev.c
21a22
> #include <linux/freezer.h>
390c391,394
< 	wait_event(req->waitq, req->state == FUSE_REQ_FINISHED);
---
> 
> 	while (req->state != FUSE_REQ_FINISHED)
> 		wait_event_freezable(req->waitq,
> 				     req->state == FUSE_REQ_FINISHED);
1526a1531
> 		offset = 0;




diff -r linux-3.0.36/fs/fuse/file.c linux-3.0.36-lenovo/fs/fuse/file.c
1713c1713
< 	for (n = 0; n < count; n++) {
---
> 	for (n = 0; n < count; n++, iov++) {




diff -r linux-3.0.36/fs/gfs2/export.c linux-3.0.36-lenovo/fs/gfs2/export.c
169a170,171
> 		if (fh_len < GFS2_SMALL_FH_SIZE)
> 			return NULL;
188a191,192
> 		if (fh_len < GFS2_LARGE_FH_SIZE)
> 			return NULL;




diff -r linux-3.0.36/fs/gfs2/lops.c linux-3.0.36-lenovo/fs/gfs2/lops.c
142,143d141
< 	lock_buffer(bd->bd_bh);
< 	gfs2_log_lock(sdp);
145c143
< 		goto out;
---
> 		return;
151c149
< 		goto out;
---
> 		return;
162,164d159
< out:
< 	gfs2_log_unlock(sdp);
< 	unlock_buffer(bd->bd_bh);
531,532d525
< 	lock_buffer(bd->bd_bh);
< 	gfs2_log_lock(sdp);
535c528
< 			goto out;
---
> 			return;
543c536
< 		goto out;
---
> 		return;
555,557d547
< out:
< 	gfs2_log_unlock(sdp);
< 	unlock_buffer(bd->bd_bh);




diff -r linux-3.0.36/fs/gfs2/trans.c linux-3.0.36-lenovo/fs/gfs2/trans.c
147a148,149
> 	lock_buffer(bh);
> 	gfs2_log_lock(sdp);
151a154,155
> 		gfs2_log_unlock(sdp);
> 		unlock_buffer(bh);
153a158,159
> 		lock_buffer(bh);
> 		gfs2_log_lock(sdp);
155a162,163
> 	gfs2_log_unlock(sdp);
> 	unlock_buffer(bh);




diff -r linux-3.0.36/fs/hugetlbfs/inode.c linux-3.0.36-lenovo/fs/hugetlbfs/inode.c
571c571,572
< 				struct page *newpage, struct page *page)
---
> 				struct page *newpage, struct page *page,
> 				enum migrate_mode mode)




diff -r linux-3.0.36/fs/isofs/export.c linux-3.0.36-lenovo/fs/isofs/export.c
182c182
< 	if (fh_type != 2)
---
> 	if (fh_len < 2 || fh_type != 2)




diff -r linux-3.0.36/fs/jbd/commit.c linux-3.0.36-lenovo/fs/jbd/commit.c
87a88
> 		WARN_ON_ONCE(buffer_dirty(bh));
88a90,93
> 		clear_buffer_mapped(bh);
> 		clear_buffer_new(bh);
> 		clear_buffer_req(bh);
> 		bh->b_bdev = NULL;
843,853c848,876
< 		/* A buffer which has been freed while still being
< 		 * journaled by a previous transaction may end up still
< 		 * being dirty here, but we want to avoid writing back
< 		 * that buffer in the future after the "add to orphan"
< 		 * operation been committed,  That's not only a performance
< 		 * gain, it also stops aliasing problems if the buffer is
< 		 * left behind for writeback and gets reallocated for another
< 		 * use in a different page. */
< 		if (buffer_freed(bh) && !jh->b_next_transaction) {
< 			clear_buffer_freed(bh);
< 			clear_buffer_jbddirty(bh);
---
> 		/*
> 		 * A buffer which has been freed while still being journaled by
> 		 * a previous transaction.
> 		 */
> 		if (buffer_freed(bh)) {
> 			/*
> 			 * If the running transaction is the one containing
> 			 * "add to orphan" operation (b_next_transaction !=
> 			 * NULL), we have to wait for that transaction to
> 			 * commit before we can really get rid of the buffer.
> 			 * So just clear b_modified to not confuse transaction
> 			 * credit accounting and refile the buffer to
> 			 * BJ_Forget of the running transaction. If the just
> 			 * committed transaction contains "add to orphan"
> 			 * operation, we can completely invalidate the buffer
> 			 * now. We are rather throughout in that since the
> 			 * buffer may be still accessible when blocksize <
> 			 * pagesize and it is attached to the last partial
> 			 * page.
> 			 */
> 			jh->b_modified = 0;
> 			if (!jh->b_next_transaction) {
> 				clear_buffer_freed(bh);
> 				clear_buffer_jbddirty(bh);
> 				clear_buffer_mapped(bh);
> 				clear_buffer_new(bh);
> 				clear_buffer_req(bh);
> 				bh->b_bdev = NULL;
> 			}




diff -r linux-3.0.36/fs/jbd/transaction.c linux-3.0.36-lenovo/fs/jbd/transaction.c
1840c1840,1841
< static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)
---
> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,
> 				int partial_page)
1845d1845
< 	int ret;
1848a1849
> retry:
1876c1877
< 	 * buffer can be reallocated and used by a different page.
---
> 	 * block can be reallocated and used by a different page.
1879a1881,1888
> 	 *
> 	 * Also we have to clear buffer_mapped flag of a truncated buffer
> 	 * because the buffer_head may be attached to the page straddling
> 	 * i_size (can happen only when blocksize < pagesize) and thus the
> 	 * buffer_head can be reused when the file is extended again. So we end
> 	 * up keeping around invalidated buffers attached to transactions'
> 	 * BJ_Forget list just to stop checkpointing code from cleaning up
> 	 * the transaction this buffer was modified in.
1906c1915
< 			ret = __dispose_buffer(jh,
---
> 			may_free = __dispose_buffer(jh,
1908,1912c1917
< 			journal_put_journal_head(jh);
< 			spin_unlock(&journal->j_list_lock);
< 			jbd_unlock_bh_state(bh);
< 			spin_unlock(&journal->j_state_lock);
< 			return ret;
---
> 			goto zap_buffer;
1920c1925
< 				ret = __dispose_buffer(jh,
---
> 				may_free = __dispose_buffer(jh,
1922,1926c1927
< 				journal_put_journal_head(jh);
< 				spin_unlock(&journal->j_list_lock);
< 				jbd_unlock_bh_state(bh);
< 				spin_unlock(&journal->j_state_lock);
< 				return ret;
---
> 				goto zap_buffer;
1947,1950c1948,1967
< 		 * it. So we just set j_next_transaction to the
< 		 * running transaction (if there is one) and mark
< 		 * buffer as freed so that commit code knows it should
< 		 * clear dirty bits when it is done with the buffer.
---
> 		 * it. If the page is straddling i_size we have to wait
> 		 * for commit and try again.
> 		 */
> 		if (partial_page) {
> 			tid_t tid = journal->j_committing_transaction->t_tid;
> 
> 			journal_put_journal_head(jh);
> 			spin_unlock(&journal->j_list_lock);
> 			jbd_unlock_bh_state(bh);
> 			spin_unlock(&journal->j_state_lock);
> 			unlock_buffer(bh);
> 			log_wait_commit(journal, tid);
> 			lock_buffer(bh);
> 			goto retry;
> 		}
> 		/*
> 		 * OK, buffer won't be reachable after truncate. We just set
> 		 * j_next_transaction to the running transaction (if there is
> 		 * one) and mark buffer as freed so that commit code knows it
> 		 * should clear dirty bits when it is done with the buffer.
1972a1990,1997
> 	/*
> 	 * This is tricky. Although the buffer is truncated, it may be reused
> 	 * if blocksize < pagesize and it is attached to the page straddling
> 	 * EOF. Since the buffer might have been added to BJ_Forget list of the
> 	 * running transaction, journal_get_write_access() won't clear
> 	 * b_modified and credit accounting gets confused. So clear b_modified
> 	 * here. */
> 	jh->b_modified = 0;
2021c2046,2047
< 			may_free &= journal_unmap_buffer(journal, bh);
---
> 			may_free &= journal_unmap_buffer(journal, bh,
> 							 offset > 0);




diff -r linux-3.0.36/fs/jbd2/transaction.c linux-3.0.36-lenovo/fs/jbd2/transaction.c
181c181,182
< 		if (!journal->j_running_transaction) {
---
> 		if (!journal->j_running_transaction &&
> 		    !journal->j_barrier_count) {




diff -r linux-3.0.36/fs/jffs2/nodemgmt.c linux-3.0.36-lenovo/fs/jffs2/nodemgmt.c
358,359c358
< 			if (ret)
< 				return ret;
---
> 
364a364,366
> 
> 			if (ret)
> 				return ret;




diff -r linux-3.0.36/fs/Kconfig linux-3.0.36-lenovo/fs/Kconfig
194a195,198
> 
> # Patched by YAFFS
> source "fs/yaffs2/Kconfig"
> 




diff -r linux-3.0.36/fs/lockd/clntxdr.c linux-3.0.36-lenovo/fs/lockd/clntxdr.c
226c226
< 	BUG_ON(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);
---
> 	WARN_ON_ONCE(be32_to_cpu(stat) > NLM_LCK_DENIED_GRACE_PERIOD);




diff -r linux-3.0.36/fs/lockd/svcproc.c linux-3.0.36-lenovo/fs/lockd/svcproc.c
70c70,71
< 		if ((error = nlm_lookup_file(rqstp, &file, &lock->fh)) != 0)
---
> 		error = cast_status(nlm_lookup_file(rqstp, &file, &lock->fh));
> 		if (error != 0)




diff -r linux-3.0.36/fs/locks.c linux-3.0.36-lenovo/fs/locks.c
318c318
< static int assign_type(struct file_lock *fl, int type)
---
> static int assign_type(struct file_lock *fl, long type)
455c455
< static int lease_init(struct file *filp, int type, struct file_lock *fl)
---
> static int lease_init(struct file *filp, long type, struct file_lock *fl)
473c473
< static struct file_lock *lease_alloc(struct file *filp, int type)
---
> static struct file_lock *lease_alloc(struct file *filp, long type)




diff -r linux-3.0.36/fs/Makefile linux-3.0.36-lenovo/fs/Makefile
126a127,129
> 
> # Patched by YAFFS
> obj-$(CONFIG_YAFFS_FS)		+= yaffs2/




diff -r linux-3.0.36/fs/nfs/client.c linux-3.0.36-lenovo/fs/nfs/client.c
676,677c676
< 	if (!(server->flags & NFS_MOUNT_LOCAL_FLOCK) ||
< 			!(server->flags & NFS_MOUNT_LOCAL_FCNTL))
---
> 	if (server->nlm_host)




diff -r linux-3.0.36/fs/nfs/dir.c linux-3.0.36-lenovo/fs/nfs/dir.c
1103c1103
< 	if (nd->flags & LOOKUP_RCU)
---
> 	if (nd && (nd->flags & LOOKUP_RCU))
1218a1219
> /* Ensure that we revalidate inode->i_nlink */
1222,1223c1223,1226
< 	if (inode->i_nlink > 0)
< 		drop_nlink(inode);
---
> 	/* drop the inode if we're reasonably sure this is the last link */
> 	if (inode->i_nlink == 1)
> 		clear_nlink(inode);
> 	NFS_I(inode)->cache_validity |= NFS_INO_INVALID_ATTR;
1238d1240
< 		drop_nlink(inode);
1239a1242
> 		nfs_drop_nlink(inode);
1501c1504
< 	if (nd->flags & LOOKUP_RCU)
---
> 	if (nd && (nd->flags & LOOKUP_RCU))
1791d1793
< 		/* The VFS may want to delete this inode */
1794d1795
< 		nfs_mark_for_revalidate(inode);




diff -r linux-3.0.36/fs/nfs/dns_resolve.c linux-3.0.36-lenovo/fs/nfs/dns_resolve.c
216c216
< 	unsigned long ttl;
---
> 	unsigned int ttl;
239c239,240
< 	ttl = get_expiry(&buf);
---
> 	if (get_uint(&buf, &ttl) < 0)
> 		goto out;




diff -r linux-3.0.36/fs/nfs/file.c linux-3.0.36-lenovo/fs/nfs/file.c
496,497c496,500
< 	/* Only do I/O if gfp is a superset of GFP_KERNEL */
< 	if (mapping && (gfp & GFP_KERNEL) == GFP_KERNEL) {
---
> 	/* Only do I/O if gfp is a superset of GFP_KERNEL, and we're not
> 	 * doing this memory reclaim for a fs-related allocation.
> 	 */
> 	if (mapping && (gfp & GFP_KERNEL) == GFP_KERNEL &&
> 	    !(current->flags & PF_FSTRANS)) {




diff -r linux-3.0.36/fs/nfs/inode.c linux-3.0.36-lenovo/fs/nfs/inode.c
153c153
< 	memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));
---
> 	memset(NFS_I(inode)->cookieverf, 0, sizeof(NFS_I(inode)->cookieverf));




diff -r linux-3.0.36/fs/nfs/internal.h linux-3.0.36-lenovo/fs/nfs/internal.h
276a277
> #define NFS_PATH_CANONICAL 1
278c279
< 		      char *buffer, ssize_t buflen);
---
> 		      char *buffer, ssize_t buflen, unsigned flags);
318c319
< 		struct page *, struct page *);
---
> 		struct page *, struct page *, enum migrate_mode);
352c353
< 	return nfs_path(&dummy, dentry, buffer, buflen);
---
> 	return nfs_path(&dummy, dentry, buffer, buflen, NFS_PATH_CANONICAL);




diff -r linux-3.0.36/fs/nfs/mount_clnt.c linux-3.0.36-lenovo/fs/nfs/mount_clnt.c
184c184
< 	status = rpc_call_sync(mnt_clnt, &msg, 0);
---
> 	status = rpc_call_sync(mnt_clnt, &msg, RPC_TASK_SOFT|RPC_TASK_TIMEOUT);




diff -r linux-3.0.36/fs/nfs/namespace.c linux-3.0.36-lenovo/fs/nfs/namespace.c
39a40
>  * @flags - options (see below)
46a48,52
>  *
>  * Supported flags:
>  * NFS_PATH_CANONICAL: ensure there is exactly one slash after
>  *		       the original device (export) name
>  *		       (if unset, the original name is returned verbatim)
48c54,55
< char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen)
---
> char *nfs_path(char **p, struct dentry *dentry, char *buffer, ssize_t buflen,
> 	       unsigned flags)
81c88
< 	if (*end != '/') {
---
> 	if ((flags & NFS_PATH_CANONICAL) && *end != '/') {
98,100c105,109
< 	/* Strip off excess slashes in base string */
< 	while (namelen > 0 && base[namelen - 1] == '/')
< 		namelen--;
---
> 	if (flags & NFS_PATH_CANONICAL) {
> 		/* Strip off excess slashes in base string */
> 		while (namelen > 0 && base[namelen - 1] == '/')
> 			namelen--;
> 	}




diff -r linux-3.0.36/fs/nfs/nfs3proc.c linux-3.0.36-lenovo/fs/nfs/nfs3proc.c
71c71
< 	if (!(info->fattr->valid & NFS_ATTR_FATTR)) {
---
> 	if (status == 0 && !(info->fattr->valid & NFS_ATTR_FATTR)) {
636c636
< 	__be32			*verf = NFS_COOKIEVERF(dir);
---
> 	__be32			*verf = NFS_I(dir)->cookieverf;




diff -r linux-3.0.36/fs/nfs/nfs4namespace.c linux-3.0.36-lenovo/fs/nfs/nfs4namespace.c
60c60,61
< 	char *path = nfs_path(&limit, dentry, buffer, buflen);
---
> 	char *path = nfs_path(&limit, dentry, buffer, buflen,
> 			      NFS_PATH_CANONICAL);




diff -r linux-3.0.36/fs/nfs/nfs4proc.c linux-3.0.36-lenovo/fs/nfs/nfs4proc.c
303,304c303
< 			exception->retry = 1;
< 			break;
---
> 			goto wait_on_recovery;
3021c3020
< 	nfs4_setup_readdir(cookie, NFS_COOKIEVERF(dir), dentry, &args);
---
> 	nfs4_setup_readdir(cookie, NFS_I(dir)->cookieverf, dentry, &args);
3025c3024
< 		memcpy(NFS_COOKIEVERF(dir), res.verifier.data, NFS4_VERIFIER_SIZE);
---
> 		memcpy(NFS_I(dir)->cookieverf, res.verifier.data, NFS4_VERIFIER_SIZE);
4118a4118
> 	nfs_release_seqid(calldata->arg.seqid);
5769,5774c5769,5770
< 	if (task->tk_status == 0) {
< 		if (lrp->res.lrs_present) {
< 			pnfs_set_layout_stateid(lo, &lrp->res.stateid, true);
< 		} else
< 			BUG_ON(!list_empty(&lo->plh_segs));
< 	}
---
> 	if (task->tk_status == 0 && lrp->res.lrs_present)
> 		pnfs_set_layout_stateid(lo, &lrp->res.stateid, true);




diff -r linux-3.0.36/fs/nfs/nfs4xdr.c linux-3.0.36-lenovo/fs/nfs/nfs4xdr.c
5748c5748,5749
< 	if (decode_getfh(xdr, &res->fh) != 0)
---
> 	status = decode_getfh(xdr, &res->fh);
> 	if (status)




diff -r linux-3.0.36/fs/nfs/super.c linux-3.0.36-lenovo/fs/nfs/super.c
766c766
< 	devname = nfs_path(&dummy, mnt->mnt_root, page, PAGE_SIZE);
---
> 	devname = nfs_path(&dummy, mnt->mnt_root, page, PAGE_SIZE, 0);
1055c1055
< 	return !option;
---
> 	return !*option;
1817a1818
> 		args->nfs_server.port = ntohs(data->addr.sin_port);
2530a2532
> 		args->nfs_server.port = ntohs(((struct sockaddr_in *)sap)->sin_port);
3097a3100,3101
> 
> MODULE_ALIAS("nfs4");




diff -r linux-3.0.36/fs/nfs/write.c linux-3.0.36-lenovo/fs/nfs/write.c
1665c1665
< 		struct page *page)
---
> 		struct page *page, enum migrate_mode mode)
1680c1680
< 	return migrate_page(mapping, newpage, page);
---
> 	return migrate_page(mapping, newpage, page, mode);




diff -r linux-3.0.36/fs/nfsd/export.c linux-3.0.36-lenovo/fs/nfsd/export.c
406c406
< 	err = get_int(mesg, &fsloc->locations_count);
---
> 	err = get_uint(mesg, &fsloc->locations_count);
464c464
< 		err = get_int(mesg, &f->pseudoflavor);
---
> 		err = get_uint(mesg, &f->pseudoflavor);
473c473
< 		err = get_int(mesg, &f->flags);
---
> 		err = get_uint(mesg, &f->flags);




diff -r linux-3.0.36/fs/nfsd/nfs4xdr.c linux-3.0.36-lenovo/fs/nfsd/nfs4xdr.c
2013c2013
< 		WRITE32(1);
---
> 		WRITE32(0);
2685c2685,2689
< 		pn = resp->rqstp->rq_resused++;
---
> 		pn = resp->rqstp->rq_resused;
> 		if (!resp->rqstp->rq_respages[pn]) { /* ran out of pages */
> 			maxcount -= len;
> 			break;
> 		}
2689a2694
> 		resp->rqstp->rq_resused++;
2736a2742,2743
> 	if (!resp->rqstp->rq_respages[resp->rqstp->rq_resused])
> 		return nfserr_resource;
2784a2792,2793
> 		return nfserr_resource;
> 	if (!resp->rqstp->rq_respages[resp->rqstp->rq_resused])




diff -r linux-3.0.36/fs/nilfs2/gcinode.c linux-3.0.36-lenovo/fs/nilfs2/gcinode.c
193a194,195
> 		truncate_inode_pages(&ii->vfs_inode.i_data, 0);
> 		nilfs_btnode_cache_clear(&ii->i_btnode_cache);




diff -r linux-3.0.36/fs/nilfs2/ioctl.c linux-3.0.36-lenovo/fs/nilfs2/ioctl.c
185c185
< 	down_read(&inode->i_sb->s_umount);
---
> 	mutex_lock(&nilfs->ns_snapshot_mount_mutex);
195c195
< 	up_read(&inode->i_sb->s_umount);
---
> 	mutex_unlock(&nilfs->ns_snapshot_mount_mutex);
664c664,666
< 	else
---
> 	else {
> 		if (nilfs_sb_need_update(nilfs))
> 			set_nilfs_discontinued(nilfs);
665a668
> 	}




diff -r linux-3.0.36/fs/nilfs2/segment.c linux-3.0.36-lenovo/fs/nilfs2/segment.c
2311a2312,2313
> 		truncate_inode_pages(&ii->vfs_inode.i_data, 0);
> 		nilfs_btnode_cache_clear(&ii->i_btnode_cache);




diff -r linux-3.0.36/fs/nilfs2/super.c linux-3.0.36-lenovo/fs/nilfs2/super.c
953a954,955
> 	mutex_lock(&nilfs->ns_snapshot_mount_mutex);
> 
977a980
> 	mutex_unlock(&nilfs->ns_snapshot_mount_mutex);




diff -r linux-3.0.36/fs/nilfs2/the_nilfs.c linux-3.0.36-lenovo/fs/nilfs2/the_nilfs.c
78a79
> 	mutex_init(&nilfs->ns_snapshot_mount_mutex);




diff -r linux-3.0.36/fs/nilfs2/the_nilfs.h linux-3.0.36-lenovo/fs/nilfs2/the_nilfs.h
49a50
>  * @ns_snapshot_mount_mutex: mutex to protect snapshot mounts
101a103
> 	struct mutex		ns_snapshot_mount_mutex;




diff -r linux-3.0.36/fs/nls/nls_base.c linux-3.0.36-lenovo/fs/nls/nls_base.c
117c117,133
< int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs)
---
> static inline void put_utf16(wchar_t *s, unsigned c, enum utf16_endian endian)
> {
> 	switch (endian) {
> 	default:
> 		*s = (wchar_t) c;
> 		break;
> 	case UTF16_LITTLE_ENDIAN:
> 		*s = __cpu_to_le16(c);
> 		break;
> 	case UTF16_BIG_ENDIAN:
> 		*s = __cpu_to_be16(c);
> 		break;
> 	}
> }
> 
> int utf8s_to_utf16s(const u8 *s, int len, enum utf16_endian endian,
> 		wchar_t *pwcs, int maxlen)
124c140
< 	while (*s && len > 0) {
---
> 	while (len > 0 && maxlen > 0 && *s) {
128a145,146
> 			s += size;
> 			len -= size;
130a149,150
> 				if (maxlen < 2)
> 					break;
132,134c152,155
< 				*op++ = (wchar_t) (SURROGATE_PAIR |
< 						((u >> 10) & SURROGATE_BITS));
< 				*op++ = (wchar_t) (SURROGATE_PAIR |
---
> 				put_utf16(op++, SURROGATE_PAIR |
> 						((u >> 10) & SURROGATE_BITS),
> 						endian);
> 				put_utf16(op++, SURROGATE_PAIR |
136c157,159
< 						(u & SURROGATE_BITS));
---
> 						(u & SURROGATE_BITS),
> 						endian);
> 				maxlen -= 2;
138c161,162
< 				*op++ = (wchar_t) u;
---
> 				put_utf16(op++, u, endian);
> 				maxlen--;
140,141d163
< 			s += size;
< 			len -= size;
143c165
< 			*op++ = *s++;
---
> 			put_utf16(op++, *s++, endian);
144a167
> 			maxlen--;




diff -r linux-3.0.36/fs/notify/fanotify/fanotify.c linux-3.0.36-lenovo/fs/notify/fanotify/fanotify.c
23a24
> 			break;




diff -r linux-3.0.36/fs/open.c linux-3.0.36-lenovo/fs/open.c
399c399
< 	int error;
---
> 	int error, fput_needed;
402c402
< 	file = fget(fd);
---
> 	file = fget_raw_light(fd, &fput_needed);
416c416
< 	fput(file);
---
> 	fput_light(file, fput_needed);
903,905c903,906
< 	if (!(flags & O_CREAT))
< 		mode = 0;
< 	op->mode = mode;
---
> 	if (flags & O_CREAT)
> 		op->mode = (mode & S_IALLUGO) | S_IFREG;
> 	else
> 		op->mode = 0;




diff -r linux-3.0.36/fs/partitions/check.c linux-3.0.36-lenovo/fs/partitions/check.c
368a369,378
> static int part_uevent(struct device *dev, struct kobj_uevent_env *env)
> {
> 	struct hd_struct *part = dev_to_part(dev);
> 
> 	add_uevent_var(env, "PARTN=%u", part->partno);
> 	if (part->info && part->info->volname[0])
> 		add_uevent_var(env, "PARTNAME=%s", part->info->volname);
> 	return 0;
> }
> 
372a383
> 	.uevent		= part_uevent,
548a560,567
> 	{
> 	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 	    if(179 == MAJOR(bdev->bd_dev))
> 	    {
> 	        printk(KERN_INFO "%s..%d.. The sdcard partition have been using.So device busy! \n",__FUNCTION__, __LINE__);
> 	    }
> 	#endif    
> 	    
549a569
> 	}
581a602,608
> 	{
> 	#if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 	    if(179 == MAJOR(bdev->bd_dev))
> 	    {
> 	        printk(KERN_INFO "%s..%d... ==== check partition fail. partitionAddr=%x.\n",__FUNCTION__, __LINE__, state);
> 	    }
> 	 #endif   	    
582a610
> 	}




diff -r linux-3.0.36/fs/partitions/msdos.c linux-3.0.36-lenovo/fs/partitions/msdos.c
433a434,436
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	const struct block_device *bdev = state->bdev;
> #endif
454a458,464
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
>     if(179 == MAJOR(bdev->bd_dev))
>     {
> 	    printk(KERN_INFO "\n%s..%d... ==== Begin to parse sdcard-partition.  [mmc0]\n",__FUNCTION__, __LINE__);
> 	}
> #endif
> 
463a474,479
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 		    if(179 == MAJOR(bdev->bd_dev))
> 		    {
> 			    printk(KERN_INFO "%s..%d... ==== The sdcard has not MBR.  [mmc0]\n",__FUNCTION__, __LINE__);
> 			}
> #endif
473a490,495
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 				if(179 == MAJOR(bdev->bd_dev))
> 				{
> 				    printk(KERN_INFO "%s..%d... ==== The DBR(slot=%d) is valid. [mmc0]\n",__FUNCTION__, __LINE__, slot);
> 				}
> #endif
476a499,504
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 				if(179 == MAJOR(bdev->bd_dev))
> 				{
> 				    printk(KERN_INFO "%s..%d... ==== The DBR is invalid. [mmc0]\n",__FUNCTION__, __LINE__);
> 				}
> #endif
499c527,532
< 
---
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
>     if(179 == MAJOR(bdev->bd_dev))
>     {
>         printk(KERN_INFO "%s..%d... ==== The sdcard has MBR. [mmc0]\n", __FUNCTION__, __LINE__);
>     }
> #endif    
505a539,545
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 	    if(179 == MAJOR(bdev->bd_dev))
> 	    {
> 		    printk(KERN_INFO "%s..%d... ==== partition-%d, size=%luKB  [mmc0]\n",\
> 		        __FUNCTION__, __LINE__, slot, size/2);
> 		}
> #endif	
514a555,560
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 			
>             if(179 == MAJOR(bdev->bd_dev))
>             {
> 			    printk(KERN_INFO "%s...%d... ==== extend partition-%d....[mmc0]\n",__FUNCTION__, __LINE__, slot);
> 			}
> #endif			
521a568,573
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD) 
> 		if(179 == MAJOR(bdev->bd_dev))
> 		{
> 		    printk(KERN_INFO "%s..%d... ==== main partition-%d....[mmc0]\n",__FUNCTION__, __LINE__, slot);
> 		}
> #endif		




diff -r linux-3.0.36/fs/proc/base.c linux-3.0.36-lenovo/fs/proc/base.c
135a136,141
> /* ANDROID is for special files in /proc. */
> #define ANDROID(NAME, MODE, OTYPE)			\
> 	NOD(NAME, (S_IFREG|(MODE)),			\
> 		&proc_##OTYPE##_inode_operations,	\
> 		&proc_##OTYPE##_operations, {})
> 
208c214,215
< 			!ptrace_may_access(task, mode)) {
---
> 			!ptrace_may_access(task, mode) &&
> 			!capable(CAP_SYS_RESOURCE)) {
849a857,860
> #define mem_write NULL
> 
> #ifndef mem_write
> /* This is a security hazard */
854a866
> #endif
1062a1075,1107
> static int oom_adjust_permission(struct inode *inode, int mask,
> 				 unsigned int flags)
> {
> 	uid_t uid;
> 	struct task_struct *p;
> 
> 	if (flags & IPERM_FLAG_RCU)
> 		return -ECHILD;
> 
> 	p = get_proc_task(inode);
> 	if(p) {
> 		uid = task_uid(p);
> 		put_task_struct(p);
> 	}
> 
> 	/*
> 	 * System Server (uid == 1000) is granted access to oom_adj of all 
> 	 * android applications (uid > 10000) as and services (uid >= 1000)
> 	 */
> 	if (p && (current_fsuid() == 1000) && (uid >= 1000)) {
> 		if (inode->i_mode >> 6 & mask) {
> 			return 0;
> 		}
> 	}
> 
> 	/* Fall back to default. */
> 	return generic_permission(inode, mask, flags, NULL);
> }
> 
> static const struct inode_operations proc_oom_adjust_inode_operations = {
> 	.permission	= oom_adjust_permission,
> };
> 
2769c2814
< 	REG("oom_adj",    S_IRUGO|S_IWUSR, proc_oom_adjust_operations),
---
> 	ANDROID("oom_adj",S_IRUGO|S_IWUSR, oom_adjust),




diff -r linux-3.0.36/fs/proc/meminfo.c linux-3.0.36-lenovo/fs/proc/meminfo.c
16a17,19
> #ifdef CONFIG_PLAT_RK
> #include <mach/ddr.h>
> #endif
107a111,117
> #ifdef CONFIG_PLAT_RK
> #ifdef CONFIG_RK29_MEM_SIZE_M
> 		(unsigned long)CONFIG_RK29_MEM_SIZE_M * 1024,
> #else
> 		(unsigned long)ddr_get_cap() >> 10,
> #endif
> #else
108a119
> #endif




diff -r linux-3.0.36/fs/ramfs/file-nommu.c linux-3.0.36-lenovo/fs/ramfs/file-nommu.c
112a113
> 		SetPageUptodate(page);




diff -r linux-3.0.36/fs/reiserfs/inode.c linux-3.0.36-lenovo/fs/reiserfs/inode.c
1571c1571
< 		fh_type = 5;
---
> 		fh_type = fh_len;
1572a1573,1574
> 	if (fh_len < 2)
> 		return NULL;
1580a1583,1584
> 	if (fh_type > fh_len)
> 		fh_type = fh_len;
1782c1786
< 	dquot_initialize(inode);
---
> 	reiserfs_write_unlock(inode->i_sb);
1783a1788
> 	reiserfs_write_lock(inode->i_sb);
1978a1984
> 	reiserfs_write_unlock(inode->i_sb);
1980a1987
> 	reiserfs_write_lock(inode->i_sb);
3104d3110
< 	depth = reiserfs_write_lock_once(inode->i_sb);
3107c3113
< 
---
> 	depth = reiserfs_write_lock_once(inode->i_sb);
3167a3174
> 		reiserfs_write_unlock_once(inode->i_sb, depth);
3168a3176
> 		depth = reiserfs_write_lock_once(inode->i_sb);




diff -r linux-3.0.36/fs/reiserfs/stree.c linux-3.0.36-lenovo/fs/reiserfs/stree.c
1970a1971
> 	reiserfs_write_unlock(inode->i_sb);
1971a1973
> 	reiserfs_write_lock(inode->i_sb);
2063a2066
> 		reiserfs_write_unlock(inode->i_sb);
2066a2070
> 		reiserfs_write_lock(inode->i_sb);




diff -r linux-3.0.36/fs/reiserfs/super.c linux-3.0.36-lenovo/fs/reiserfs/super.c
256a257
> 		reiserfs_write_unlock(s);
257a259
> 		reiserfs_write_lock(s);
1210c1212
< 		goto out_err;
---
> 		goto out_unlock;
1253c1255
< 			goto out_err;
---
> 			goto out_unlock;
1262a1265,1269
> 		/*
> 		 * Drop write lock. Quota will retake it when needed and lock
> 		 * ordering requires calling dquot_suspend() without it.
> 		 */
> 		reiserfs_write_unlock(s);
1265a1273
> 		reiserfs_write_lock(s);
1275c1283
< 			goto out_err;
---
> 			goto out_unlock;
1290c1298
< 			goto out_err;
---
> 			goto out_unlock;
1299c1307
< 			goto out_err;
---
> 			goto out_unlock;
1316c1324
< 		goto out_err;
---
> 		goto out_unlock;
1319a1328,1332
> 		/*
> 		 * Drop write lock. Quota will retake it when needed and lock
> 		 * ordering requires calling dquot_resume() without it.
> 		 */
> 		reiserfs_write_unlock(s);
1320a1334
> 		reiserfs_write_lock(s);
1329a1344,1345
> out_unlock:
> 	reiserfs_write_unlock(s);
1332d1347
< 	reiserfs_write_unlock(s);
1954a1970
> 	reiserfs_write_unlock(dquot->dq_sb);
1955a1972
> 	reiserfs_write_lock(dquot->dq_sb);
1961c1978
<       out:
---
> out:
1976a1994
> 	reiserfs_write_unlock(dquot->dq_sb);
1977a1996
> 	reiserfs_write_lock(dquot->dq_sb);
1983c2002
<       out:
---
> out:
1996a2016
> 	reiserfs_write_unlock(dquot->dq_sb);
2002a2023
> 	reiserfs_write_lock(dquot->dq_sb);
2008d2028
<       out:
2009a2030
> out:
2033a2055
> 	reiserfs_write_unlock(sb);
2034a2057
> 	reiserfs_write_lock(sb);
2038c2061
<       out:
---
> out:
2062,2063c2085,2089
< 	if (!(REISERFS_SB(sb)->s_mount_opt & (1 << REISERFS_QUOTA)))
< 		return -EINVAL;
---
> 	reiserfs_write_lock(sb);
> 	if (!(REISERFS_SB(sb)->s_mount_opt & (1 << REISERFS_QUOTA))) {
> 		err = -EINVAL;
> 		goto out;
> 	}
2105c2131,2132
< 	err = dquot_quota_on(sb, type, format_id, path);
---
> 	reiserfs_write_unlock(sb);
> 	return dquot_quota_on(sb, type, format_id, path);
2106a2134
> 	reiserfs_write_unlock(sb);
2179a2208
> 		reiserfs_write_lock(sb);
2180a2210
> 		reiserfs_write_unlock(sb);
2195a2226
> 		reiserfs_write_lock(sb);
2199a2231
> 		reiserfs_write_unlock(sb);




diff -r linux-3.0.36/fs/splice.c linux-3.0.36-lenovo/fs/splice.c
696c696,697
< 	if (sd->len < sd->total_len)
---
> 
> 	if (sd->len < sd->total_len && pipe->nrbufs > 1)
697a699
> 




diff -r linux-3.0.36/fs/squashfs/super.c linux-3.0.36-lenovo/fs/squashfs/super.c
293c293
< 	if (msblk->directory_table >= next_table) {
---
> 	if (msblk->directory_table > next_table) {




diff -r linux-3.0.36/fs/stat.c linux-3.0.36-lenovo/fs/stat.c
60c60
< 	struct file *f = fget(fd);
---
> 	struct file *f = fget_raw(fd);




diff -r linux-3.0.36/fs/sysfs/dir.c linux-3.0.36-lenovo/fs/sysfs/dir.c
407c407
<  *	@path: caller allocated buffer
---
>  *	@path: caller allocated buffer of size PATH_MAX
411,412d410
<  *
<  *	XXX: does no error checking on @path size
418c416
< 		strcat(path, "/");
---
> 		strlcat(path, "/", PATH_MAX);
420c418
< 	strcat(path, sd->s_name);
---
> 	strlcat(path, sd->s_name, PATH_MAX);
453,455c451,455
< 		     (path == NULL) ? sd->s_name :
< 		     strcat(strcat(sysfs_pathname(acxt->parent_sd, path), "/"),
< 		            sd->s_name));
---
> 		     (path == NULL) ? sd->s_name
> 				    : (sysfs_pathname(acxt->parent_sd, path),
> 				       strlcat(path, "/", PATH_MAX),
> 				       strlcat(path, sd->s_name, PATH_MAX),
> 				       path));




diff -r linux-3.0.36/fs/ubifs/find.c linux-3.0.36-lenovo/fs/ubifs/find.c
684,685c684,693
< 			ubifs_assert(c->freeable_cnt == 0);
< 			if (c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {
---
> 			/*
> 			 * The first condition means the following: go scan the
> 			 * LPT if there are uncategorized lprops, which means
> 			 * there may be freeable LEBs there (UBIFS does not
> 			 * store the information about freeable LEBs in the
> 			 * master node).
> 			 */
> 			if (c->in_a_category_cnt != c->main_lebs ||
> 			    c->lst.empty_lebs - c->lst.taken_empty_lebs > 0) {
> 				ubifs_assert(c->freeable_cnt == 0);




diff -r linux-3.0.36/fs/ubifs/lprops.c linux-3.0.36-lenovo/fs/ubifs/lprops.c
302a303
> 
304a306,307
> 	c->in_a_category_cnt += 1;
> 	ubifs_assert(c->in_a_category_cnt <= c->main_lebs);
336a340,342
> 
> 	c->in_a_category_cnt -= 1;
> 	ubifs_assert(c->in_a_category_cnt >= 0);




diff -r linux-3.0.36/fs/ubifs/sb.c linux-3.0.36-lenovo/fs/ubifs/sb.c
718,719c718,723
< 	/* Fixup the current log head */
< 	err = fixup_leb(c, c->lhead_lnum, c->lhead_offs);
---
> 	/*
> 	 * Fixup the log head which contains the only a CS node at the
> 	 * beginning.
> 	 */
> 	err = fixup_leb(c, c->lhead_lnum,
> 			ALIGN(UBIFS_CS_NODE_SZ, c->min_io_size));




diff -r linux-3.0.36/fs/ubifs/ubifs.h linux-3.0.36-lenovo/fs/ubifs/ubifs.h
1189a1190,1191
>  * @in_a_category_cnt: count of lprops which are in a certain category, which
>  *                     basically meants that they were loaded from the flash
1418a1421
> 	int in_a_category_cnt;




diff -r linux-3.0.36/fs/udf/file.c linux-3.0.36-lenovo/fs/udf/file.c
42c42
< static int udf_adinicb_readpage(struct file *file, struct page *page)
---
> static void __udf_adinicb_readpage(struct page *page)
48,49d47
< 	BUG_ON(!PageLocked(page));
< 
51d48
< 	memset(kaddr, 0, PAGE_CACHE_SIZE);
52a50
> 	memset(kaddr + inode->i_size, 0, PAGE_CACHE_SIZE - inode->i_size);
55a54,59
> }
> 
> static int udf_adinicb_readpage(struct file *file, struct page *page)
> {
> 	BUG_ON(!PageLocked(page));
> 	__udf_adinicb_readpage(page);
79a84,102
> static int udf_adinicb_write_begin(struct file *file,
> 			struct address_space *mapping, loff_t pos,
> 			unsigned len, unsigned flags, struct page **pagep,
> 			void **fsdata)
> {
> 	struct page *page;
> 
> 	if (WARN_ON_ONCE(pos >= PAGE_CACHE_SIZE))
> 		return -EIO;
> 	page = grab_cache_page_write_begin(mapping, 0, flags);
> 	if (!page)
> 		return -ENOMEM;
> 	*pagep = page;
> 
> 	if (!PageUptodate(page) && len != PAGE_CACHE_SIZE)
> 		__udf_adinicb_readpage(page);
> 	return 0;
> }
> 
101,102c124,125
< 	.write_begin = simple_write_begin,
< 	.write_end = udf_adinicb_write_end,
---
> 	.write_begin	= udf_adinicb_write_begin,
> 	.write_end	= udf_adinicb_write_end,




diff -r linux-3.0.36/fs/udf/inode.c linux-3.0.36-lenovo/fs/udf/inode.c
577a578
> 	bool isBeyondEOF;
656c657
< 
---
> 		isBeyondEOF = 1;
698a700
> 		isBeyondEOF = 0;
740a743,744
> 			brelse(cur_epos.bh);
> 			brelse(next_epos.bh);
744c748,749
< 		iinfo->i_lenExtents += inode->i_sb->s_blocksize;
---
> 		if (isBeyondEOF)
> 			iinfo->i_lenExtents += inode->i_sb->s_blocksize;
770a776,777
> 	brelse(cur_epos.bh);
> 	brelse(next_epos.bh);




diff -r linux-3.0.36/fs/udf/super.c linux-3.0.36-lenovo/fs/udf/super.c
58a59
> #include <linux/log2.h>
1246a1248,1295
> static int udf_load_sparable_map(struct super_block *sb,
> 				 struct udf_part_map *map,
> 				 struct sparablePartitionMap *spm)
> {
> 	uint32_t loc;
> 	uint16_t ident;
> 	struct sparingTable *st;
> 	struct udf_sparing_data *sdata = &map->s_type_specific.s_sparing;
> 	int i;
> 	struct buffer_head *bh;
> 
> 	map->s_partition_type = UDF_SPARABLE_MAP15;
> 	sdata->s_packet_len = le16_to_cpu(spm->packetLength);
> 	if (!is_power_of_2(sdata->s_packet_len)) {
> 		udf_error(sb, __func__, "error loading logical volume descriptor: "
> 			"Invalid packet length %u\n",
> 			(unsigned)sdata->s_packet_len);
> 		return -EIO;
> 	}
> 	if (spm->numSparingTables > 4) {
> 		udf_error(sb, __func__, "error loading logical volume descriptor: "
> 			"Too many sparing tables (%d)\n",
> 			(int)spm->numSparingTables);
> 		return -EIO;
> 	}
> 
> 	for (i = 0; i < spm->numSparingTables; i++) {
> 		loc = le32_to_cpu(spm->locSparingTable[i]);
> 		bh = udf_read_tagged(sb, loc, loc, &ident);
> 		if (!bh)
> 			continue;
> 
> 		st = (struct sparingTable *)bh->b_data;
> 		if (ident != 0 ||
> 		    strncmp(st->sparingIdent.ident, UDF_ID_SPARING,
> 			    strlen(UDF_ID_SPARING)) ||
> 		    sizeof(*st) + le16_to_cpu(st->reallocationTableLen) >
> 							sb->s_blocksize) {
> 			brelse(bh);
> 			continue;
> 		}
> 
> 		sdata->s_spar_map[i] = bh;
> 	}
> 	map->s_partition_func = udf_get_pblock_spar15;
> 	return 0;
> }
> 
1251c1300
< 	int i, j, offset;
---
> 	int i, offset;
1256a1306
> 	unsigned int table_len;
1264,1267c1314,1319
< 
< 	i = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));
< 	if (i != 0) {
< 		ret = i;
---
> 	table_len = le32_to_cpu(lvd->mapTableLength);
> 	if (sizeof(*lvd) + table_len > sb->s_blocksize) {
> 		udf_error(sb, __func__, "error loading logical volume descriptor: "
> 			"Partition table too long (%u > %lu)\n", table_len,
> 			sb->s_blocksize - sizeof(*lvd));
> 		ret = 1;
1270a1323,1326
> 	ret = udf_sb_alloc_partition_maps(sb, le32_to_cpu(lvd->numPartitionMaps));
> 	if (ret)
> 		goto out_bh;
> 
1272c1328
< 	     i < sbi->s_partitions && offset < le32_to_cpu(lvd->mapTableLength);
---
> 	     i < sbi->s_partitions && offset < table_len;
1307,1336c1363,1366
< 				uint32_t loc;
< 				struct sparingTable *st;
< 				struct sparablePartitionMap *spm =
< 					(struct sparablePartitionMap *)gpm;
< 
< 				map->s_partition_type = UDF_SPARABLE_MAP15;
< 				map->s_type_specific.s_sparing.s_packet_len =
< 						le16_to_cpu(spm->packetLength);
< 				for (j = 0; j < spm->numSparingTables; j++) {
< 					struct buffer_head *bh2;
< 
< 					loc = le32_to_cpu(
< 						spm->locSparingTable[j]);
< 					bh2 = udf_read_tagged(sb, loc, loc,
< 							     &ident);
< 					map->s_type_specific.s_sparing.
< 							s_spar_map[j] = bh2;
< 
< 					if (bh2 == NULL)
< 						continue;
< 
< 					st = (struct sparingTable *)bh2->b_data;
< 					if (ident != 0 || strncmp(
< 						st->sparingIdent.ident,
< 						UDF_ID_SPARING,
< 						strlen(UDF_ID_SPARING))) {
< 						brelse(bh2);
< 						map->s_type_specific.s_sparing.
< 							s_spar_map[j] = NULL;
< 					}
---
> 				if (udf_load_sparable_map(sb, map,
> 				    (struct sparablePartitionMap *)gpm) < 0) {
> 					ret = 1;
> 					goto out_bh;
1338d1367
< 				map->s_partition_func = udf_get_pblock_spar15;




diff -r linux-3.0.36/fs/xfs/linux-2.6/xfs_export.c linux-3.0.36-lenovo/fs/xfs/linux-2.6/xfs_export.c
197a198,200
> 	if (fh_len < xfs_fileid_length(fileid_type))
> 		return NULL;
> 




diff -r linux-3.0.36/fs/xfs/xfs_log_recover.c linux-3.0.36-lenovo/fs/xfs/xfs_log_recover.c
3515c3515
< 						bblks - split_bblks, hbp,
---
> 						bblks - split_bblks, dbp,
Only in linux-3.0.36-lenovo/fs: yaffs2
Only in linux-3.0.36: .gitignore




diff -r linux-3.0.36/include/asm-generic/gpio.h linux-3.0.36-lenovo/include/asm-generic/gpio.h
37a38
> #ifndef gpio_is_valid
41a43
> #endif
111a114,116
> 	int			(*pull_updown)(struct gpio_chip *chip,
> 						unsigned offset, unsigned value);
> 
154a160,161
> 
> extern int gpio_pull_updown(unsigned gpio, unsigned value);




diff -r linux-3.0.36/include/asm-generic/mutex-xchg.h linux-3.0.36-lenovo/include/asm-generic/mutex-xchg.h
29c29,35
< 		fail_fn(count);
---
> 		/*
> 		 * We failed to acquire the lock, so mark it contended
> 		 * to ensure that any waiting tasks are woken up by the
> 		 * unlock slow path.
> 		 */
> 		if (likely(atomic_xchg(count, -1) != 1))
> 			fail_fn(count);
46c52,53
< 		return fail_fn(count);
---
> 		if (likely(atomic_xchg(count, -1) != 1))
> 			return fail_fn(count);




diff -r linux-3.0.36/include/asm-generic/tlb.h linux-3.0.36-lenovo/include/asm-generic/tlb.h
80a81,88
> /*
>  * Limit the maximum number of mmu_gather batches to reduce a risk of soft
>  * lockups for non-preemptible kernels on huge machines when a lot of memory
>  * is zapped during unmapping.
>  * 10K pages freed at once should be safe even without a preemption point.
>  */
> #define MAX_GATHER_BATCH_COUNT	(10000UL/MAX_GATHER_BATCH)
> 
96a105
> 	unsigned int		batch_count;
Only in linux-3.0.36-lenovo/include/linux: adc.h
Only in linux-3.0.36-lenovo/include/linux: akm8963.h
Only in linux-3.0.36-lenovo/include/linux: akm8975.h




diff -r linux-3.0.36/include/linux/amba/mmci.h linux-3.0.36-lenovo/include/linux/amba/mmci.h
7a8,16
> #include <linux/mmc/card.h>
> #include <linux/mmc/sdio_func.h>
> 
> struct embedded_sdio_data {
>         struct sdio_cis cis;
>         struct sdio_cccr cccr;
>         struct sdio_embedded_func *funcs;
>         int num_funcs;
> };
57a67,69
> 	unsigned int status_irq;
> 	struct embedded_sdio_data *embedded_sdio;
> 	int (*register_status_notify)(void (*callback)(int card_present, void *dev_id), void *dev_id);
Only in linux-3.0.36-lenovo/include/linux: android_aid.h
Only in linux-3.0.36-lenovo/include/linux: android_alarm.h
Only in linux-3.0.36-lenovo/include/linux: android_pmem.h
Only in linux-3.0.36-lenovo/include/linux: anx6345.h
Only in linux-3.0.36-lenovo/include/linux: anx9805.h
Only in linux-3.0.36-lenovo/include/linux: ashmem.h
Only in linux-3.0.36-lenovo/include/linux: atmel_maxtouch.h




diff -r linux-3.0.36/include/linux/binfmts.h linux-3.0.36-lenovo/include/linux/binfmts.h
128a129
> extern int bprm_change_interp(char *interp, struct linux_binprm *bprm);
Only in linux-3.0.36-lenovo/include/linux: board-id.h
Only in linux-3.0.36-lenovo/include/linux: board-id-operator.h
Only in linux-3.0.36-lenovo/include/linux: bp-auto.h
Only in linux-3.0.36-lenovo/include/linux: capella_cm3602.h




diff -r linux-3.0.36/include/linux/cgroup.h linux-3.0.36-lenovo/include/linux/cgroup.h
87,92d86
< /* Caller must verify that the css is not for root cgroup */
< static inline void __css_get(struct cgroup_subsys_state *css, int count)
< {
< 	atomic_add(count, &css->refcnt);
< }
< 
99a94
> extern void __css_get(struct cgroup_subsys_state *css, int count);
146,149c141
< 	/*
< 	 * Control Group has previously had a child cgroup or a task,
< 	 * but no longer (only if CGRP_NOTIFY_ON_RELEASE is set)
< 	 */
---
> 	/* Control Group has ever had a child cgroup or a task */
289a282
> 	struct work_struct work;
468a462
> 	int (*allow_attach)(struct cgroup *cgrp, struct task_struct *tsk);




diff -r linux-3.0.36/include/linux/compiler-gcc.h linux-3.0.36-lenovo/include/linux/compiler-gcc.h
52a53,57
> #else
> /* A lot of inline functions can cause havoc with function tracing */
> # define inline		inline		notrace
> # define __inline__	__inline__	notrace
> # define __inline	__inline	notrace
Only in linux-3.0.36-lenovo/include/linux: cpuacct.h




diff -r linux-3.0.36/include/linux/cpufreq.h linux-3.0.36-lenovo/include/linux/cpufreq.h
360a361,363
> #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
> extern struct cpufreq_governor cpufreq_gov_interactive;
> #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)




diff -r linux-3.0.36/include/linux/cpu.h linux-3.0.36-lenovo/include/linux/cpu.h
69,70c69,71
< 	/* prepare workqueues for other notifiers */
< 	CPU_PRI_WORKQUEUE	= 5,
---
> 	/* bring up workqueues before normal notifiers and down after */
> 	CPU_PRI_WORKQUEUE_UP	= 5,
> 	CPU_PRI_WORKQUEUE_DOWN	= -5,
175a177,183
> 
> #define IDLE_START 1
> #define IDLE_END 2
> 
> void idle_notifier_register(struct notifier_block *n);
> void idle_notifier_unregister(struct notifier_block *n);
> void idle_notifier_call_chain(unsigned long val);
Only in linux-3.0.36-lenovo/include/linux: cpu_pm.h




diff -r linux-3.0.36/include/linux/cpuset.h linux-3.0.36-lenovo/include/linux/cpuset.h
92,93c92,96
<  * reading current mems_allowed and mempolicy in the fastpath must protected
<  * by get_mems_allowed()
---
>  * get_mems_allowed is required when making decisions involving mems_allowed
>  * such as during page allocation. mems_allowed can be updated in parallel
>  * and depending on the new value an operation can fail potentially causing
>  * process failure. A retry loop with get_mems_allowed and put_mems_allowed
>  * prevents these artificial failures.
95c98
< static inline void get_mems_allowed(void)
---
> static inline unsigned int get_mems_allowed(void)
97c100,101
< 	current->mems_allowed_change_disable++;
---
> 	return read_seqcount_begin(&current->mems_allowed_seq);
> }
99,121c103,110
< 	/*
< 	 * ensure that reading mems_allowed and mempolicy happens after the
< 	 * update of ->mems_allowed_change_disable.
< 	 *
< 	 * the write-side task finds ->mems_allowed_change_disable is not 0,
< 	 * and knows the read-side task is reading mems_allowed or mempolicy,
< 	 * so it will clear old bits lazily.
< 	 */
< 	smp_mb();
< }
< 
< static inline void put_mems_allowed(void)
< {
< 	/*
< 	 * ensure that reading mems_allowed and mempolicy before reducing
< 	 * mems_allowed_change_disable.
< 	 *
< 	 * the write-side task will know that the read-side task is still
< 	 * reading mems_allowed or mempolicy, don't clears old bits in the
< 	 * nodemask.
< 	 */
< 	smp_mb();
< 	--ACCESS_ONCE(current->mems_allowed_change_disable);
---
> /*
>  * If this returns false, the operation that took place after get_mems_allowed
>  * may have failed. It is up to the caller to retry the operation if
>  * appropriate.
>  */
> static inline bool put_mems_allowed(unsigned int seq)
> {
> 	return !read_seqcount_retry(&current->mems_allowed_seq, seq);
126a116
> 	write_seqcount_begin(&current->mems_allowed_seq);
127a118
> 	write_seqcount_end(&current->mems_allowed_seq);
237c228
< static inline void get_mems_allowed(void)
---
> static inline unsigned int get_mems_allowed(void)
238a230
> 	return 0;
241c233
< static inline void put_mems_allowed(void)
---
> static inline bool put_mems_allowed(unsigned int seq)
242a235
> 	return true;
Only in linux-3.0.36-lenovo/include/linux: ct36x.h




diff -r linux-3.0.36/include/linux/dcache.h linux-3.0.36-lenovo/include/linux/dcache.h
222a223,224
> #define DCACHE_DENTRY_KILLED	0x100000
> 
Only in linux-3.0.36-lenovo/include/linux: display-sys.h




diff -r linux-3.0.36/include/linux/dm9000.h linux-3.0.36-lenovo/include/linux/dm9000.h
31a32,37
> 	//gpio init&deinit	
>     int (*io_init)(void);
>     int (*io_deinit)(void);
> 	int irq_pin;
> 	int irq_pin_value;
> 		
Only in linux-3.0.36-lenovo/include/linux: dp501.h
Only in linux-3.0.36-lenovo/include/linux: earlysuspend.h
Only in linux-3.0.36-lenovo/include/linux: ec-dev.h
Only in linux-3.0.36-lenovo/include/linux: export.h




diff -r linux-3.0.36/include/linux/fb.h linux-3.0.36-lenovo/include/linux/fb.h
21a22,30
> #define FBIOPUT_16OR32      0x4607
> #define FBIOPUT_FBPHYADD    0x4608
> #define FBIOPUT_SET_CURSOR_EN    0x4609
> #define FBIOPUT_SET_CURSOR_IMG    0x460a
> #define FBIOPUT_SET_CURSOR_POS    0x460b
> #define FBIOPUT_SET_CURSOR_CMAP    0x460c
> #define FBIOPUT_GET_CURSOR_RESOLUTION    0x460d
> #define FBIOPUT_GET_CURSOR_EN    0x460e
> 
41a51,52
> 
> 




diff -r linux-3.0.36/include/linux/fs.h linux-3.0.36-lenovo/include/linux/fs.h
525a526
> enum migrate_mode;
610c611,614
< 	/* migrate the contents of a page to the specified target */
---
> 	/*
> 	 * migrate the contents of a page to the specified target. If sync
> 	 * is false, it must not block.
> 	 */
612c616
< 			struct page *, struct page *);
---
> 			struct page *, struct page *, enum migrate_mode);
2481c2485,2486
< 				struct page *, struct page *);
---
> 				struct page *, struct page *,
> 				enum migrate_mode);
Only in linux-3.0.36-lenovo/include/linux: goodix_queue.h
Only in linux-3.0.36-lenovo/include/linux: goodix_touch_82x.h
Only in linux-3.0.36-lenovo/include/linux: goodix_touch.h
Only in linux-3.0.36-lenovo/include/linux: gpio_event.h
Only in linux-3.0.36-lenovo/include/linux: gps.h
Only in linux-3.0.36-lenovo/include/linux: gt8110.h
Only in linux-3.0.36-lenovo/include/linux: hdmi.h




diff -r linux-3.0.36/include/linux/hid.h linux-3.0.36-lenovo/include/linux/hid.h
599a600,601
>  * @input_register: called just before input device is registered after reports
>  * 		    are parsed.
645a648,649
> 	int (*input_register)(struct hid_device *hdev, struct hid_input
> 			*hidinput);




diff -r linux-3.0.36/include/linux/hrtimer.h linux-3.0.36-lenovo/include/linux/hrtimer.h
167a168
>  * @clock_was_set:	Indicates that clock was set from irq context.
180c181,182
< 	unsigned long			active_bases;
---
> 	unsigned int			active_bases;
> 	unsigned int			clock_was_set;
288a291,292
> extern void clock_was_set_delayed(void);
> 
308a313,315
> 
> static inline void clock_was_set_delayed(void) { }
> 
322a330
> extern ktime_t ktime_get_update_offsets(ktime_t *offs_real, ktime_t *offs_boot);
Only in linux-3.0.36-lenovo/include/linux/i2c: bq2415x.h
Only in linux-3.0.36-lenovo/include/linux/i2c: tca6424.h
Only in linux-3.0.36-lenovo/include/linux/i2c: twl6030-gpadc.h
Only in linux-3.0.36-lenovo/include/linux/i2c: twl6030-madc.h




diff -r linux-3.0.36/include/linux/i2c/twl.h linux-3.0.36-lenovo/include/linux/i2c/twl.h
41a42,101
> #define PREQ1_RES_ASS_A 0x2a
> #define PREQ1_RES_ASS_B 0x2b
> #define PREQ1_RES_ASS_C 0x2c
> #define PREQ2_RES_ASS_A 0x2d
> #define PREQ3_RES_ASS_A 0x30
> #define PHOENIX_MSK_TRANSITION 0x01
> #define PHOENIX_SENS_TRANSITION 0x0b
> #define SMPS4_CFG_TRANS 0x11
> #define SMPS4_CFG_STATE 0x12
> #define SMPS4_CFG_VOLTAGE 0x14
> #define SMPS5_CFG_TRANS 0x17
> #define SMPS5_CFG_STATE 0x18
> #define SMPS5_CFG_FORCE 0x19
> #define SMPS5_CFG_VOLTAGE 0x1A
> #define SMPS5_CFG_STEP 0x1B
> #define SMPS1_CFG_TRANS 0x23
> #define SMPS1_CFG_STATE 0x24
> #define SMPS1_CFG_FORCE 0x25
> #define SMPS1_CFG_VOLTAGE 0x26
> #define SMPS1_CFG_STEP 0x27
> #define SMPS2_CFG_TRANS 0x29
> #define SMPS2_CFG_STATE 0x2a
> #define SMPS2_CFG_FORCE 0x2b
> #define SMPS2_CFG_VOLTAGE 0x2c
> #define SMPS2_CFG_STEP 0x2d
> #define VANA_CFG_TRANS 0x51
> #define VANA_CFG_STATE 0x52
> #define VANA_CFG_VOLTAGE 0x53
> #define LDO2_CFG_TRANS 0x55
> #define LDO2_CFG_STATE 0x56
> #define LDO2_CFG_VOLTAGE 0x57
> #define LDO4_CFG_TRANS 0x59
> #define LDO4_CFG_STATE 0x5a
> #define LDO4_CFG_VOLTAGE 0x5b
> #define LDO3_CFG_TRANS 0x5d
> #define LDO3_CFG_STATE 0x5e
> #define LDO3_CFG_VOLTAGE 0x5f
> #define LDO6_CFG_TRANS 0x61
> #define LDO6_CFG_STATE 0x62
> #define LDO6_CFG_VOLTAGE 0x63
> #define LDOLN_CFG_TRANS 0x65
> #define LDOLN_CFG_STATE 0x66
> #define LDOLN_CFG_VOLTAGE 0x67
> #define LDO5_CFG_TRANS 0x69
> #define LDO5_CFG_STATE 0x6A
> #define LDO5_CFG_VOLTAGE 0x6B
> #define LDO1_CFG_TRANS 0x6D
> #define LDO1_CFG_STATE 0x6E
> #define LDO1_CFG_VOLTAGE 0x6F
> #define LDOUSB_CFG_TRANS 0x71
> #define LDOUSB_CFG_STATE 0x72
> #define LDOUSB_CFG_VOLTAGE 0x73
> #define LDO7_CFG_TRANS 0x75
> #define LDO7_CFG_STATE 0x76
> #define LDO7_CFG_VOLTAGE 0x77
> #define CLK32KG_CFG_STATE  0x11
> #define CLK32KAUDIO_CFG_STATE 0x14
> #define CHARGERUSB_CTRLLIMIT2	0x10
> 
> 
73a134,135
> #define TWL6032_MODULE_CHARGER		0x18
> #define TWL6030_MODULE_SLAVE_RES	0x19
83a146,148
> #define TWL6030_MODULE_CHARGER TWL4030_MODULE_MAIN_CHARGE
> #define TWL_MODULE_PM_SLAVE_RES	TWL6030_MODULE_SLAVE_RES
> #define TWL_MODULE_PM_DVS                   0x1A  //add
84a150
> #define TWL6030_MODULE_GASGAUGE 0x0B
102a169
> #define TWL_VLOW_INTR_OFFSET	6
110a178
> #define GPADCSW_INTR_OFFSET	1
149a218,222
> #define TWL6030_MMCDEBOUNCING	0xED
> #define MMC_DEB_BYPASS			(0x1 << 7)
> #define MMC_MINS_DEB_MASK			(0xF << 3)
> #define MMC_MEXT_DEB_MASK			(0x7 << 0)
> 
153a227,228
> #define VLOW_INT_MASK			(0x1 << 2)
> 
174c249
< #define TWL6025_SUBCLASS	BIT(4)  /* TWL6025 has changed registers */
---
> #define TWL6032_SUBCLASS	BIT(4)  /* Phoenix Lite is a varient*/
190a266,267
> void twl6030_poweroff(void);
> 
217a295,317
> 
> /******************gpadc channels*************************/
> #define GPADC_CH0 0  //Battery type, resistor value
> #define GPADC_CH1 1   //Battery temperature, NTC resistor value
> #define GPADC_CH2 2   //Audio accessory/general purpose
> #define GPADC_CH3 3   //Temperature with external diode/general
> #define GPADC_CH4 4   //Temperature measurement/general purpose
> #define GPADC_CH5 5   //General purpose
> #define GPADC_CH6 6   //General purpose
> #define GPADC_CH7 7    //System supply
> #define GPADC_CH8 8    //Backup battery
> #define GPADC_CH9 9   //External charger input
> #define GPADC_CH10 10  //VBUS
> #define GPADC_CH11 11   //VBUS DCDC output current
> #define GPADC_CH12 12    //Die temperature
> #define GPADC_CH13 13    //Die temperature
> #define GPADC_CH14 14    //USB ID line
> #define GPADC_CH15 15   //Test network
> #define GPADC_CH16 16    //Test network
> #define GPADC_CH17 17   //Battery charging current
> #define GPADC_CH18 18   //BATTERY VOLTAGE
> /*********************************************************/
> 
232a333,337
> int twl6030_register_notifier(struct notifier_block *nb,
> 				unsigned int events);
> int twl6030_unregister_notifier(struct notifier_block *nb,
> 				unsigned int events);
> 
452a558,574
> #define TWL6030_PHOENIX_DEV_ON			0x06
> 
> /*
>  * TWL6030 PM Master module register offsets (use TWL_MODULE_PM_MASTER)
>  */
> 
> #define TWL6030_PM_MASTER_MSK_TRANSITION	0x01
> #define TWL6030_VBATMIN_HI_THRESHOLD		0x05
> 
> /*
>  * PM Slave resource module register offsets (use TWL6030_MODULE_SLAVE_RES)
>  */
> 
> #define REG_VBATMIN_HI_CFG_STATE		0x1D
> 
> #define VBATMIN_VLOW_EN				0x21
> 
524a647,683
> /* 6030 extra resources */
> #define RES_V1V29		29
> #define RES_V1V8		30
> #define RES_V2V1		31
> #define RES_VDD3		32
> #define RES_VMEM		33
> #define RES_VANA		34
> #define RES_VUAX1		35
> #define RES_VCXIO		36
> #define RES_VPP			37
> #define RES_VRTC		38
> #define RES_REGEN2		39
> #define RES_32KCLKAO		40
> #define RES_32KCLKG		41
> #define RES_32KCLKAUDIO		42
> #define RES_BIAS		43
> #define RES_VBATMIN_HI		44
> #define RES_RC6MHZ		45
> #define RES_TEMP		46
> 
> /* 6032 extra resources */
> #define RES_LDOUSB		47
> #define RES_SMPS5		48
> #define RES_SMPS4		49
> #define RES_SMPS3		50
> #define RES_SMPS2		51
> #define RES_SMPS1		52
> #define RES_LDOLN		53
> #define RES_LDO7		54
> #define RES_LDO6		55
> #define RES_LDO5		56
> #define RES_LDO4		57
> #define RES_LDO3		58
> #define RES_LDO2		59
> #define RES_LDO1		60
> #define RES_VSYSMIN_HI	61
> 
559a719,732
> 
> 	unsigned int monitoring_interval;
> 
> 	unsigned int max_charger_currentmA;
> 	unsigned int max_charger_voltagemV;
> 	unsigned int termination_currentmA;
> 
> 	unsigned int max_bat_voltagemV;
> 	unsigned int low_bat_voltagemV;
> 
> 	unsigned int sense_resistor_mohm;
> 
> 	/* twl6032 */
> 	unsigned long features;
591a765
> 	int		features;
643a818
> 	/* The following are used by TWL4030 only */
649a825,829
> struct twl4030_system_config {
> 	char *name;
> 	u8 group;
> };
> 
651,652c831,832
< 	struct twl4030_script **scripts;
< 	unsigned num;
---
> 	struct twl4030_script **scripts;	/* used in TWL4030 only */
> 	unsigned num;				/* used in TWL4030 only */
653a834
> 	struct twl4030_system_config *sys_config; /*system resources*/
656a838
> #ifdef CONFIG_TWL4030_POWER
658a841,852
> #else
> static inline void twl4030_power_init(struct twl4030_power_data *triton2_scripts) { }
> static inline int twl4030_remove_script(u8 flags) { return -EINVAL; }
> #endif
> 
> #ifdef CONFIG_TWL6030_POWER
> extern void twl6030_power_init(struct twl4030_power_data *power_data,\
> 					unsigned long features);
> #else
> extern inline void twl6030_power_init(struct twl4030_power_data *power_data,\
> 					unsigned long features) { }
> #endif
666a861,865
> 	u16 hs_left_step;
> 	u16 hs_right_step;
> 	u16 hf_left_step;
> 	u16 hf_right_step;
> 	u16 ep_step;
667a867,869
> 
> 	/* twl6040 */
> 	int vddhf_uV;
671a874,880
> 
> 	/* timed-output based implementations */
> 	int max_timeout;
> 	int initial_vibrate;
> 	int (*init)(void);
> 	void (*exit)(void);
> 	u8  voltage_raise_speed;
678a888,890
> 	int (*init)(void);
> 	void (*exit)(void);
> 
681a894,897
> 	unsigned int irq_base;
> 	int (*get_ext_clk32k)(void);
> 	void (*put_ext_clk32k)(void);
> 	int (*set_ext_clk32k)(bool on);
685a902,903
> 	int(*pre_init)(void);
> 	int(*set_init)(void);
712a931,934
> 	/* TWL6030 DCDC regulators */
> 	struct regulator_init_data		*vdd3;
> 	struct regulator_init_data		*vmem;
> 	struct regulator_init_data		*v2v1;
721c943,944
< 	/* TWL6025 LDO regulators */
---
> 	struct regulator_init_data              *clk32kaudio;
> 	/* TWL6032 LDO regulators */
731c954
< 	/* TWL6025 DCDC regulators */
---
> 	/* TWL6032 DCDC regulators */
734c957,968
< 	struct regulator_init_data		*vio6025;
---
> 	struct regulator_init_data		*vio6032;
> 	
> 	struct regulator_init_data            *smps1; //add 
> 	struct regulator_init_data            *smps2; //add 
> 	struct regulator_init_data            *smps5; //add 
> 	
> 	/* External control pins */
> 	struct regulator_init_data		*sysen;
> 	struct regulator_init_data		*regen1;
> 
> 
> 	
816,830c1050,1076
< /* LDOs on 6025 have different names */
< #define TWL6025_REG_LDO2	49
< #define TWL6025_REG_LDO4	50
< #define TWL6025_REG_LDO3	51
< #define TWL6025_REG_LDO5	52
< #define TWL6025_REG_LDO1	53
< #define TWL6025_REG_LDO7	54
< #define TWL6025_REG_LDO6	55
< #define TWL6025_REG_LDOLN	56
< #define TWL6025_REG_LDOUSB	57
< 
< /* 6025 DCDC supplies */
< #define TWL6025_REG_SMPS3	58
< #define TWL6025_REG_SMPS4	59
< #define TWL6025_REG_VIO		60
---
> /* LDOs on 6032 have different names */
> #define TWL6032_REG_LDO2	49
> #define TWL6032_REG_LDO4	50
> #define TWL6032_REG_LDO3	51
> #define TWL6032_REG_LDO5	52
> #define TWL6032_REG_LDO1	53
> #define TWL6032_REG_LDO7	54
> #define TWL6032_REG_LDO6	55
> #define TWL6032_REG_LDOLN	56
> #define TWL6032_REG_LDOUSB	57
> 
> /* 6032 DCDC supplies */
> #define TWL6032_REG_SMPS3	58
> #define TWL6032_REG_SMPS4	59
> #define TWL6032_REG_VIO		60
> 
> #define TWL6030_REG_CLK32KAUDIO	61
> 
> /* External control pins */
> #define TWL6030_REG_SYSEN	62
> #define TWL6030_REG_REGEN1	63
> 
> #define TWL6032_REG_SMPS1 64  //add 
> #define TWL6032_REG_SMPS2 65  //add 
> #define TWL6032_REG_SMPS5 66 //add 
> 
> #define TWL6032_PREQ1_RES_ASS_A	0xd7




diff -r linux-3.0.36/include/linux/i2c-gpio.h linux-3.0.36-lenovo/include/linux/i2c-gpio.h
35a36,37
> 	int bus_num;
> 	int (*io_init)(void);




diff -r linux-3.0.36/include/linux/i2c.h linux-3.0.36-lenovo/include/linux/i2c.h
63a64,76
> #ifdef CONFIG_PLAT_RK
> /* If everything went ok, return 'count' transmitted, else error code. */
> extern int i2c_master_normal_send(const struct i2c_client *client, const char *buf, int count, int scl_rate);
> extern int i2c_master_normal_recv(const struct i2c_client *client, char *buf, int count, int scl_rate);
> extern int i2c_master_reg8_send(const struct i2c_client *client, const char reg, const char *buf, int count, int scl_rate);
> extern int i2c_master_reg8_recv(const struct i2c_client *client, const char reg, char *buf, int count, int scl_rate);
> extern int i2c_master_reg16_send(const struct i2c_client *client, const short regs, const short *buf, int count, int scl_rate);
> extern int i2c_master_reg16_recv(const struct i2c_client *client, const short regs, short *buf, int count, int scl_rate);
> extern int i2c_suspended(struct i2c_adapter *adap);
> extern int i2c_add_device(int nr, struct i2c_board_info const *info);
> extern int i2c_check_rk610_ex(int nr);
> #endif
> 
210a224
> 	int udelay;
261a276
> 	int		udelay;   //add by kfx	
519a535,536
> #define I2C_M_NEED_DELAY	0x0020  // add by kfx
> #define I2C_M_REG8_DIRECT	0x0040	// add by kfx
521a539,541
> 	__u32 scl_rate;  // add by kfx
> 	int udelay;		//add by kfx
> 	__u16 read_type;




diff -r linux-3.0.36/include/linux/if_link.h linux-3.0.36-lenovo/include/linux/if_link.h
139a140
> 	IFLA_EXT_MASK,		/* Extended info mask, VFs, etc */
Only in linux-3.0.36-lenovo/include/linux: if_pppolac.h
Only in linux-3.0.36-lenovo/include/linux: if_pppopns.h




diff -r linux-3.0.36/include/linux/if_pppox.h linux-3.0.36-lenovo/include/linux/if_pppox.h
29a30,31
> #include <linux/if_pppolac.h>
> #include <linux/if_pppopns.h>
63c65,67
< #define PX_MAX_PROTO   3
---
> #define PX_PROTO_OLAC  3
> #define PX_PROTO_OPNS  4
> #define PX_MAX_PROTO   5
169a174,192
> 
> struct pppolac_opt {
> 	__u32		local;
> 	__u32		remote;
> 	__u32		recv_sequence;
> 	__u32		xmit_sequence;
> 	atomic_t	sequencing;
> 	int		(*backlog_rcv)(struct sock *sk_udp, struct sk_buff *skb);
> };
> 
> struct pppopns_opt {
> 	__u16		local;
> 	__u16		remote;
> 	__u32		recv_sequence;
> 	__u32		xmit_sequence;
> 	void		(*data_ready)(struct sock *sk_raw, int length);
> 	int		(*backlog_rcv)(struct sock *sk_raw, struct sk_buff *skb);
> };
> 
179a203,204
> 		struct pppolac_opt lac;
> 		struct pppopns_opt pns;




diff -r linux-3.0.36/include/linux/init_task.h linux-3.0.36-lenovo/include/linux/init_task.h
32a33,39
> #ifdef CONFIG_CPUSETS
> #define INIT_CPUSET_SEQ							\
> 	.mems_allowed_seq = SEQCNT_ZERO,
> #else
> #define INIT_CPUSET_SEQ
> #endif
> 
119a127,135
> extern struct task_group root_task_group;
> 
> #ifdef CONFIG_CGROUP_SCHED
> # define INIT_CGROUP_SCHED(tsk)						\
> 	.sched_task_group = &root_task_group,
> #else
> # define INIT_CGROUP_SCHED(tsk)
> #endif
> 
121c137
< # define INIT_PERF_EVENTS(tsk)					\
---
> # define INIT_PERF_EVENTS(tsk)						\
155a172
> 	INIT_CGROUP_SCHED(tsk)						\
195a213
> 	INIT_CPUSET_SEQ							\
Only in linux-3.0.36-lenovo/include/linux/input: kionix_accel.h




diff -r linux-3.0.36/include/linux/input.h linux-3.0.36-lenovo/include/linux/input.h
131a132,134
> #define EVIOCGSUSPENDBLOCK	_IOR('E', 0x91, int)			/* get suspend block enable */
> #define EVIOCSSUSPENDBLOCK	_IOW('E', 0x91, int)			/* set suspend block enable */
> 
Only in linux-3.0.36-lenovo/include/linux: ion.h




diff -r linux-3.0.36/include/linux/irqdesc.h linux-3.0.36-lenovo/include/linux/irqdesc.h
41d40
< 	struct timer_rand_state *timer_rand_state;




diff -r linux-3.0.36/include/linux/Kbuild linux-3.0.36-lenovo/include/linux/Kbuild
368a369
> header-y += uhid.h




diff -r linux-3.0.36/include/linux/kernel.h linux-3.0.36-lenovo/include/linux/kernel.h
751a752,754
> /* To identify board information in panic logs, set this */
> extern char *mach_panic_string;
> 
Only in linux-3.0.36-lenovo/include/linux: keychord.h
Only in linux-3.0.36-lenovo/include/linux: keyreset.h




diff -r linux-3.0.36/include/linux/kobject.h linux-3.0.36-lenovo/include/linux/kobject.h
231c231
< { return 0; }
---
> { return -ENOMEM; }




diff -r linux-3.0.36/include/linux/ktime.h linux-3.0.36-lenovo/include/linux/ktime.h
61,67d60
< #define KTIME_MAX			((s64)~((u64)1 << 63))
< #if (BITS_PER_LONG == 64)
< # define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
< #else
< # define KTIME_SEC_MAX			LONG_MAX
< #endif
< 
Only in linux-3.0.36-lenovo/include/linux: kxtf9.h
Only in linux-3.0.36-lenovo/include/linux: kxtik.h
Only in linux-3.0.36-lenovo/include/linux: l3g4200d.h
Only in linux-3.0.36-lenovo/include/linux: leds-att1272.h




diff -r linux-3.0.36/include/linux/linux_logo.h linux-3.0.36-lenovo/include/linux/linux_logo.h
23a24
> #define LINUX_LOGO_bmp      5  /* truecolours*/
34c35
< 
---
> extern const struct linux_logo logo_linux_lowerpower_clut224;
37a39,42
> 
> #ifdef CONFIG_LOGO_PIPO_CLUT224
> extern const struct linux_logo logo_pipo_clut224;
> #endif
49a55,58
> extern const struct linux_logo logo_g3_clut224;
> extern const struct linux_logo logo_sunset_bmp;
> extern const struct linux_logo logo_android_bmp;
> extern const struct linux_logo logo_linux_800x480_clut224;




diff -r linux-3.0.36/include/linux/memcontrol.h linux-3.0.36-lenovo/include/linux/memcontrol.h
38c38,39
< 					int mode, struct zone *z,
---
> 					isolate_mode_t mode,
> 					struct zone *z,




diff -r linux-3.0.36/include/linux/memory.h linux-3.0.36-lenovo/include/linux/memory.h
23c23
< #define MIN_MEMORY_BLOCK_SIZE     (1 << SECTION_SIZE_BITS)
---
> #define MIN_MEMORY_BLOCK_SIZE     (1UL << SECTION_SIZE_BITS)




diff -r linux-3.0.36/include/linux/mempolicy.h linux-3.0.36-lenovo/include/linux/mempolicy.h
140,149d139
< extern struct mempolicy *__mpol_cond_copy(struct mempolicy *tompol,
< 					  struct mempolicy *frompol);
< static inline struct mempolicy *mpol_cond_copy(struct mempolicy *tompol,
< 						struct mempolicy *frompol)
< {
< 	if (!frompol)
< 		return frompol;
< 	return __mpol_cond_copy(tompol, frompol);
< }
< 
191c181
< 	spinlock_t lock;
---
> 	struct mutex mutex;
271,276d260
< }
< 
< static inline struct mempolicy *mpol_cond_copy(struct mempolicy *to,
< 						struct mempolicy *from)
< {
< 	return from;




diff -r linux-3.0.36/include/linux/mfd/ezx-pcap.h linux-3.0.36-lenovo/include/linux/mfd/ezx-pcap.h
18a19
> 	int gpio;
Only in linux-3.0.36-lenovo/include/linux/mfd: rk610_core.h
Only in linux-3.0.36-lenovo/include/linux/mfd: rk616.h
Only in linux-3.0.36-lenovo/include/linux/mfd: rk808.h
Only in linux-3.0.36-lenovo/include/linux/mfd: tlv320aic3262-core.h
Only in linux-3.0.36-lenovo/include/linux/mfd: tlv320aic3262-registers.h




diff -r linux-3.0.36/include/linux/mfd/tps65910.h linux-3.0.36-lenovo/include/linux/mfd/tps65910.h
19a20,22
> #include <linux/gpio.h>
> #include <linux/wakelock.h>
> 
27a31,34
> /* I2C Slave Address 7-bit */
> #define TPS65910_I2C_ID0        0x2D /* general-purpose */
> #define TPS65910_I2C_ID1        0x12 /* Smart Reflex */
> 
246c253,254
< #define VDD1_2_NUM_VOLTS				73
---
> #define VDD1_2_NUM_VOLT_FINE				73
> #define VDD1_2_NUM_VOLT_COARSE				3
272c280
< #define LDO_MAX_VOLT					3300;
---
> #define LDO_MAX_VOLT					3300
364c372
< /*Register DEVCTRL  (0x80) register.RegisterDescription */
---
> /*Register DEVCTRL  (0x3F) register.RegisterDescription */
381c389
< /*Register DEVCTRL2  (0x80) register.RegisterDescription */
---
> /*Register DEVCTRL2  (0x40) register.RegisterDescription */
658a667,668
> #define GPIO_SLEEP_MASK                         0x80
> #define GPIO_SLEEP_SHIFT                        7
742,745c752,794
< /**
<  * struct tps65910_board
<  * Board platform data may be used to initialize regulators.
<  */
---
> /* Max number of TPS65910/11 GPIOs */
> #define TPS65910_NUM_GPIO				6
> #define TPS65911_NUM_GPIO				9
> #define TPS6591X_MAX_NUM_GPIO				9
> 
> /* Regulator Index Definitions */
> #define TPS65910_REG_VRTC				0
> #define TPS65910_REG_VIO				1
> #define TPS65910_REG_VDD1				2
> #define TPS65910_REG_VDD2				3
> #define TPS65910_REG_VDD3				4
> #define TPS65910_REG_VDIG1				5
> #define TPS65910_REG_VDIG2				6
> #define TPS65910_REG_VPLL				7
> #define TPS65910_REG_VDAC				8
> #define TPS65910_REG_VAUX1				9
> #define TPS65910_REG_VAUX2				10
> #define TPS65910_REG_VAUX33				11
> #define TPS65910_REG_VMMC				12
> 
> #define TPS65911_REG_VDDCTRL				4
> #define TPS65911_REG_LDO1				5
> #define TPS65911_REG_LDO2				6
> #define TPS65911_REG_LDO3				7
> #define TPS65911_REG_LDO4				8
> #define TPS65911_REG_LDO5				9
> #define TPS65911_REG_LDO6				10
> #define TPS65911_REG_LDO7				11
> #define TPS65911_REG_LDO8				12
> 
> /* Max number of TPS65910/11 regulators */
> #define TPS65910_NUM_REGS				13
> 
> /* External sleep controls through EN1/EN2/EN3/SLEEP inputs */
> #define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN1		0x1
> #define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN2		0x2
> #define TPS65910_SLEEP_CONTROL_EXT_INPUT_EN3		0x4
> #define TPS65911_SLEEP_CONTROL_EXT_INPUT_SLEEP		0x8
> 
> 
> 
> 
> 
747,754d795
< struct tps65910_board {
< 	int gpio_base;
< 	int irq;
< 	int irq_base;
< 	int vmbch_threshold;
< 	int vmbch2_threshold;
< 	struct regulator_init_data *tps65910_pmic_init_data;
< };
762a804
> 	struct regmap *regmap;
763a806
> 	struct wake_lock 	irq_wake;
769,771c812,814
< 	struct tps65910_pmic *pmic;
< 	struct tps65910_rtc *rtc;
< 	struct tps65910_power *power;
---
> 	//struct tps65910_pmic *pmic;
> 	//struct tps65910_rtc *rtc;
> 	//struct tps65910_power *power;
788a832,856
> 
> /**
>  * struct tps65910_board
>  * Board platform data may be used to initialize regulators.
>  */
> 
> struct tps65910_board {
> 	int gpio_base;
> 	int irq;
> 	int irq_base;
> 	int vmbch_threshold;
> 	int vmbch2_threshold;
> 	bool en_gpio_sleep[TPS6591X_MAX_NUM_GPIO];
> 	unsigned long regulator_ext_sleep_control[TPS65910_NUM_REGS];
> 	struct regulator_init_data *tps65910_pmic_init_data[TPS65910_NUM_REGS];
> 
> 	/** Called before subdevices are set up */
> 	int (*pre_init)(struct tps65910 *tps65910);
> 	/** Called after subdevices are set up */
> 	int (*post_init)(struct tps65910 *tps65910);
> 	/** Called before subdevices are power down */
> 	int (*last_deinit)(struct tps65910 *tps65910);
> };
> 
> 
793a862,870
> int tps65910_irq_exit(struct tps65910 *tps65910);
> int tps65910_reg_read(struct tps65910 *tps65910, u8 reg);
> int tps65910_reg_write(struct tps65910 *tps65910, u8 reg, u8 val);
> int tps65910_bulk_read(struct tps65910 *tps65910, u8 reg,
> 		     int count, u8 *buf);
> int tps65910_bulk_write(struct tps65910 *tps65910, u8 reg,
> 		     int count, u8 *buf);
> int tps65910_device_shutdown(void);
> 
Only in linux-3.0.36-lenovo/include/linux/mfd: tps65912.h




diff -r linux-3.0.36/include/linux/mfd/wm831x/core.h linux-3.0.36-lenovo/include/linux/mfd/wm831x/core.h
19a20,21
> #include <linux/wakelock.h>
> #include <linux/regulator/driver.h>
239a242
> #define WM831X_IRQ_LIST	1
262a266,267
> 	int flag_suspend;
> 	spinlock_t		flag_lock;
263a269,278
> 	struct workqueue_struct *irq_wq;
> 	struct delayed_work irq_work;
> 	struct wake_lock 	irq_wake;
> 	struct wake_lock 	handle_wake;
> #if WM831X_IRQ_LIST
> 	struct workqueue_struct *handle_wq;
> 	struct work_struct handle_work;
> 	spinlock_t		work_lock;
> 	struct list_head	handle_queue;
> #endif
286a302,334
> #define WM831X_DCDC_MAX_NAME 6
> #define WM831X_LDO_MAX_NAME 6
> #define WM831X_ISINK_MAX_NAME 7
> 
> struct wm831x_dcdc {
>         char name[WM831X_DCDC_MAX_NAME];
>         struct regulator_desc desc;
>         int base;
>         struct wm831x *wm831x;
>         struct regulator_dev *regulator;
>         int dvs_gpio;
>         int dvs_gpio_state;
>         int on_vsel;
>         int dvs_vsel;
> };
> 
> struct wm831x_ldo {
>         char name[WM831X_LDO_MAX_NAME];
>         struct regulator_desc desc;
>         int base;
>         struct wm831x *wm831x;
>         struct regulator_dev *regulator;
> };
> 
> struct wm831x_isink {
>         char name[WM831X_ISINK_MAX_NAME];
>         struct regulator_desc desc;
>         int reg;
>         struct wm831x *wm831x;
>         struct regulator_dev *regulator;
> };
> 
> 
300a349,352
> int wm831x_device_resume(struct wm831x *wm831x);
> int wm831x_device_shutdown(struct wm831x *wm831x);
> int wm831x_read_usb(struct wm831x *wm831x);
> int wm831x_device_restart(struct wm831x *wm831x);
302a355,380
> 
> static inline int __must_check wm831x_request_irq(struct wm831x *wm831x,
> 						  unsigned int irq,
> 						  irq_handler_t handler,
> 						  unsigned long flags,
> 						  const char *name,
> 						  void *dev)
> {
> 	return request_threaded_irq(irq, NULL, handler, flags, name, dev);
> }
> 
> static inline void wm831x_free_irq(struct wm831x *wm831x,
> 				   unsigned int irq, void *dev)
> {
> 	free_irq(irq, dev);
> }
> 
> static inline void wm831x_disable_irq(struct wm831x *wm831x, int irq)
> {
> 	disable_irq(irq);
> }
> 
> static inline void wm831x_enable_irq(struct wm831x *wm831x, int irq)
> {
> 	enable_irq(irq);
> }




diff -r linux-3.0.36/include/linux/mfd/wm831x/irq.h linux-3.0.36-lenovo/include/linux/mfd/wm831x/irq.h
414a415
> 
416c417
<  * R16407 (0x4017) - IRQ Config
---
>  * Reg (0x4017) - IRQ Config
418,425c419,425
< #define WM831X_IRQ_OD                           0x0002  /* IRQ_OD */
< #define WM831X_IRQ_OD_MASK                      0x0002  /* IRQ_OD */
< #define WM831X_IRQ_OD_SHIFT                          1  /* IRQ_OD */
< #define WM831X_IRQ_OD_WIDTH                          1  /* IRQ_OD */
< #define WM831X_IM_IRQ                           0x0001  /* IM_IRQ */
< #define WM831X_IM_IRQ_MASK                      0x0001  /* IM_IRQ */
< #define WM831X_IM_IRQ_SHIFT                          0  /* IM_IRQ */
< #define WM831X_IM_IRQ_WIDTH                          1  /* IM_IRQ */
---
>  #define WM831X_IRQ_OD_ENABLE                         0x0002  /* CMOS/open drain */
> #define WM831X_IRQ_OD_MASK                     0x0002  /* CMOS/open drain */
> #define WM831X_IRQ_OD_SHIFT                        2 /* CMOS/open drain */
> #define WM831X_IRQ_IM_EANBLE                          0x0001  /* IM_IRQ */
> #define WM831X_IRQ_IM_MASK                     0x0001  /* IM_IRQ */
> #define WM831X_IRQ_IM_SHIFT                        0   /* IM_IRQ */
> 




diff -r linux-3.0.36/include/linux/mfd/wm831x/pdata.h linux-3.0.36-lenovo/include/linux/mfd/wm831x/pdata.h
41a42,43
> 	int syslo;          /** syslo threshold, in mV**/
> 	int sysok;          /** sysok threshold, in mV**/
101a104,120
> struct wm831x_gpio_keys_button {
> 	/* Configuration parameters */
> 	int code;		/* input event code (KEY_*, SW_*) */
> 	int gpio;
> 	int active_low;
> 	char *desc;
> 	int type;		/* input event type (EV_KEY, EV_SW) */
> 	int wakeup;		/* configure the button as a wake-up source */
> 	int debounce_interval;	/* debounce ticks interval in msecs */
> };
> 
> struct wm831x_gpio_keys_pdata {
> 	struct wm831x_gpio_keys_button *buttons;
> 	int nbuttons;
> 	unsigned int rep:1;		/* enable input subsystem auto repeat */
> };
> 
118a138,145
> 	/** Called before subdevices are power down */
> 	int (*last_deinit)(struct wm831x *wm831x);
> 	//add by sxj
> 	unsigned int gpio_pin_num;
> 	void *settinginfo;
> 	int settinginfolen;
> 	int (*pin_type_init)(struct wm831x *wm831x);
> 	//above add by sxj
130a158,160
> 	//add by srt
> 	struct wm831x_gpio_keys_pdata *gpio_keys;
> 	//end by srt




diff -r linux-3.0.36/include/linux/mfd/wm831x/pmu.h linux-3.0.36-lenovo/include/linux/mfd/wm831x/pmu.h
17c17,18
< 
---
> /*    rtc cntrol (0x4025) */
> #define WM831X_RTC_ALAM_ENA_MASK 0x0400




diff -r linux-3.0.36/include/linux/mfd/wm8994/pdata.h linux-3.0.36-lenovo/include/linux/mfd/wm8994/pdata.h
26a27,30
> 
> 	//wm8994 LDO1_ENA and LDO2_ENA
> 	char	iomux_name[50];
> 	int		iomux_mode;	
118d121
< 
124d126
< 
126,133c128,151
< 
< 	int irq_base;  /** Base IRQ number for WM8994, required for IRQs */
< 
<         int num_drc_cfgs;
<         struct wm8994_drc_cfg *drc_cfgs;
< 
<         int num_retune_mobile_cfgs;
<         struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
---
> 	
> 	int num_drc_cfgs;
> 	struct wm8994_drc_cfg *drc_cfgs;
> 	int num_retune_mobile_cfgs;
> 	struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
> 	
> 	/* LINEOUT can be differential or single ended */
> 	unsigned int lineout1_diff:1;
> 	unsigned int lineout2_diff:1;//do not use	
> 	/* Common mode feedback */
> 	unsigned int lineout1fb:1;
> 	unsigned int lineout2fb:1;//do not use
> 
> 	//If an external amplifier speakers wm8994		enable>0 disable=0
> 	unsigned int PA_control_pin;
> 	char	PA_iomux_name[50];
> 	int		PA_iomux_mode;		
> 
> 
> 	
> 
> 	
> 	/** Base IRQ number for WM8994, required for IRQs */
> 	int irq_base;  	//do not use
147,154d164
<         /* LINEOUT can be differential or single ended */
<         unsigned int lineout1_diff:1;
<         unsigned int lineout2_diff:1;
< 
<         /* Common mode feedback */
<         unsigned int lineout1fb:1;
<         unsigned int lineout2fb:1;
< 
158c168
< 	int micdet_irq;
---
> 	int micdet_irq;//do not use
160,166c170,176
<         /* WM8994 microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
<         unsigned int micbias1_lvl:1;
<         unsigned int micbias2_lvl:1;
< 
<         /* WM8994 jack detect threashold levels, see datasheet for values */
<         unsigned int jd_scthr:2;
<         unsigned int jd_thr:2;
---
> 	/* WM8994 microphone biases: 0=0.9*AVDD1 1=0.65*AVVD1 */
> 	unsigned int micbias1_lvl:1;//default 0	Do not set
> 	unsigned int micbias2_lvl:1;//default 0	Do not set
> 
> 	/* WM8994 jack detect threashold levels, see datasheet for values */
> 	unsigned int jd_scthr:2;//do not use
> 	unsigned int jd_thr:2;//do not use
Only in linux-3.0.36-lenovo/include/linux: mi700.h




diff -r linux-3.0.36/include/linux/migrate.h linux-3.0.36-lenovo/include/linux/migrate.h
8a9,21
> /*
>  * MIGRATE_ASYNC means never block
>  * MIGRATE_SYNC_LIGHT in the current implementation means to allow blocking
>  *	on most operations but not ->writepage as the potential stall time
>  *	is too significant
>  * MIGRATE_SYNC will block when migrating pages
>  */
> enum migrate_mode {
> 	MIGRATE_ASYNC,
> 	MIGRATE_SYNC_LIGHT,
> 	MIGRATE_SYNC,
> };
> 
14c27
< 			struct page *, struct page *);
---
> 			struct page *, struct page *, enum migrate_mode);
17c30
< 			bool sync);
---
> 			enum migrate_mode mode);
20c33
< 			bool sync);
---
> 			enum migrate_mode mode);
39c52
< 		bool sync) { return -ENOSYS; }
---
> 		enum migrate_mode mode) { return -ENOSYS; }
42c55
< 		bool sync) { return -ENOSYS; }
---
> 		enum migrate_mode mode) { return -ENOSYS; }
Only in linux-3.0.36-lenovo/include/linux: mma7660.h
Only in linux-3.0.36-lenovo/include/linux: mma8452.h




diff -r linux-3.0.36/include/linux/mmc/card.h linux-3.0.36-lenovo/include/linux/mmc/card.h
318a319,320
> #define mmc_card_clr_present(c)	((c)->state &= ~MMC_STATE_PRESENT)
> 




diff -r linux-3.0.36/include/linux/mmc/host.h linux-3.0.36-lenovo/include/linux/mmc/host.h
14a15
> #include <linux/wakelock.h>
263a265
> 	struct wake_lock	detect_wake_lock;
267a270,279
> #if defined(CONFIG_SDMMC_RK29) && !defined(CONFIG_SDMMC_RK29_OLD)
> 	unsigned int		re_initialized_flags; //in order to begin the rescan ;  added by xbw@2011-04-07
> 	unsigned int		doneflag; //added by xbw at 2011-08-27
> 	int			(*sdmmc_host_hw_init)(void *data);
> #endif
> 
> 	unsigned int		bus_resume_flags;
> #define MMC_BUSRESUME_MANUAL_RESUME	(1 << 0)
> #define MMC_BUSRESUME_NEEDS_RESUME	(1 << 1)
> 
284a297,305
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> 	struct {
> 		struct sdio_cis			*cis;
> 		struct sdio_cccr		*cccr;
> 		struct sdio_embedded_func	*funcs;
> 		int				num_funcs;
> 	} embedded_sdio_data;
> #endif
> 
292a314,321
> #ifdef CONFIG_MMC_EMBEDDED_SDIO
> extern void mmc_set_embedded_sdio_data(struct mmc_host *host,
> 				       struct sdio_cis *cis,
> 				       struct sdio_cccr *cccr,
> 				       struct sdio_embedded_func *funcs,
> 				       int num_funcs);
> #endif
> 
302a332,343
> #define mmc_bus_needs_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_NEEDS_RESUME)
> #define mmc_bus_manual_resume(host) ((host)->bus_resume_flags & MMC_BUSRESUME_MANUAL_RESUME)
> 
> static inline void mmc_set_bus_resume_policy(struct mmc_host *host, int manual)
> {
> 	if (manual)
> 		host->bus_resume_flags |= MMC_BUSRESUME_MANUAL_RESUME;
> 	else
> 		host->bus_resume_flags &= ~MMC_BUSRESUME_MANUAL_RESUME;
> }
> 
> extern int mmc_resume_bus(struct mmc_host *host);
316a358
> 	if(host && host->sdio_irq_thread)




diff -r linux-3.0.36/include/linux/mmc/mmc.h linux-3.0.36-lenovo/include/linux/mmc/mmc.h
142a143,152
> #define R1_STATE_IDLE	0
> #define R1_STATE_READY	1
> #define R1_STATE_IDENT	2
> #define R1_STATE_STBY	3
> #define R1_STATE_TRAN	4
> #define R1_STATE_DATA	5
> #define R1_STATE_RCV	6
> #define R1_STATE_PRG	7
> #define R1_STATE_DIS	8
> 
328a339,357
> 
> 
> /*
> * some limit value of SDMMC about protocol  ; Added by xbw at 2011-03-21
> */
> #define FOD_FREQ              (300000)    //  in the identify stage, unit: hz,  max is 400Khz,
>                                        //  the least frequency is FREQ_HCLK_MAX/8
> #define SD_FPP_FREQ           (24000000)  //   normal sd freq,  25Mhz
> 
> #if defined(CONFIG_ARCH_RK2928)
> //In rk2926 machine,very prone to occur data-timeout-error,the machine reduces the frequency.
> #define SDHC_FPP_FREQ         (39500000)  // SDHC in the highspeed. unit is hz,  max is 50Mhz.
> #else
> #define SDHC_FPP_FREQ         (49500000)  // SDHC in the highspeed. unit is hz,  max is 50Mhz.
> #endif
> #define MMC_FPP_FREQ          (19000000)  // MMC freq, unit is hz,   max is 20MHz
> #define MMCHS_26_FPP_FREQ     (24000000)  //  highspeed mode support 26M  HS-MMC, unit is hz, max is 26Mhz, 
> #define MMCHS_52_FPP_FREQ     (49500000)  //  highspeed support 52M HS-MMC,   unit is hz,   max is 52Mhz,
> 




diff -r linux-3.0.36/include/linux/mmc/pm.h linux-3.0.36-lenovo/include/linux/mmc/pm.h
28a29
> #define MMC_PM_IGNORE_PM_NOTIFY	(1 << 2)	/* ignore mmc pm notify */




diff -r linux-3.0.36/include/linux/mmc/sdio_func.h linux-3.0.36-lenovo/include/linux/mmc/sdio_func.h
25a26,33
>  * Structure used to hold embedded SDIO device data from platform layer
>  */
> struct sdio_embedded_func {
> 	uint8_t f_class;
> 	uint32_t f_maxblksize;
> };
> 
> /*
132a141,142
> extern u8 sdio_readb_ext(struct sdio_func *func, unsigned int addr, int *err_ret,
> 	unsigned in);




diff -r linux-3.0.36/include/linux/mm.h linux-3.0.36-lenovo/include/linux/mm.h
872a873
> void shmem_set_file(struct vm_area_struct *vma, struct file *file);




diff -r linux-3.0.36/include/linux/mmzone.h linux-3.0.36-lenovo/include/linux/mmzone.h
160a161,174
> /* Isolate inactive pages */
> #define ISOLATE_INACTIVE	((__force isolate_mode_t)0x1)
> /* Isolate active pages */
> #define ISOLATE_ACTIVE		((__force isolate_mode_t)0x2)
> /* Isolate clean file */
> #define ISOLATE_CLEAN		((__force isolate_mode_t)0x4)
> /* Isolate unmapped file */
> #define ISOLATE_UNMAPPED	((__force isolate_mode_t)0x8)
> /* Isolate for asynchronous migration */
> #define ISOLATE_ASYNC_MIGRATE	((__force isolate_mode_t)0x10)
> 
> /* LRU Isolation modes. */
> typedef unsigned __bitwise__ isolate_mode_t;
> 
636c650
< 	struct task_struct *kswapd;
---
> 	struct task_struct *kswapd;	/* Protected by lock_memory_hotplug() */




diff -r linux-3.0.36/include/linux/module.h linux-3.0.36-lenovo/include/linux/module.h
18a19
> #include <linux/export.h>
28,34d28
< /* Some toolchains use a `_' prefix for all user symbols. */
< #ifdef CONFIG_SYMBOL_PREFIX
< #define MODULE_SYMBOL_PREFIX CONFIG_SYMBOL_PREFIX
< #else
< #define MODULE_SYMBOL_PREFIX ""
< #endif
< 
37,42d30
< struct kernel_symbol
< {
< 	unsigned long value;
< 	const char *name;
< };
< 
99,100d86
< extern struct module __this_module;
< #define THIS_MODULE (&__this_module)
103d88
< #define THIS_MODULE ((struct module *)0)
219,264d203
< #ifndef __GENKSYMS__
< #ifdef CONFIG_MODVERSIONS
< /* Mark the CRC weak since genksyms apparently decides not to
<  * generate a checksums for some symbols */
< #define __CRC_SYMBOL(sym, sec)					\
< 	extern void *__crc_##sym __attribute__((weak));		\
< 	static const unsigned long __kcrctab_##sym		\
< 	__used							\
< 	__attribute__((section("___kcrctab" sec "+" #sym), unused))	\
< 	= (unsigned long) &__crc_##sym;
< #else
< #define __CRC_SYMBOL(sym, sec)
< #endif
< 
< /* For every exported symbol, place a struct in the __ksymtab section */
< #define __EXPORT_SYMBOL(sym, sec)				\
< 	extern typeof(sym) sym;					\
< 	__CRC_SYMBOL(sym, sec)					\
< 	static const char __kstrtab_##sym[]			\
< 	__attribute__((section("__ksymtab_strings"), aligned(1))) \
< 	= MODULE_SYMBOL_PREFIX #sym;                    	\
< 	static const struct kernel_symbol __ksymtab_##sym	\
< 	__used							\
< 	__attribute__((section("___ksymtab" sec "+" #sym), unused))	\
< 	= { (unsigned long)&sym, __kstrtab_##sym }
< 
< #define EXPORT_SYMBOL(sym)					\
< 	__EXPORT_SYMBOL(sym, "")
< 
< #define EXPORT_SYMBOL_GPL(sym)					\
< 	__EXPORT_SYMBOL(sym, "_gpl")
< 
< #define EXPORT_SYMBOL_GPL_FUTURE(sym)				\
< 	__EXPORT_SYMBOL(sym, "_gpl_future")
< 
< 
< #ifdef CONFIG_UNUSED_SYMBOLS
< #define EXPORT_UNUSED_SYMBOL(sym) __EXPORT_SYMBOL(sym, "_unused")
< #define EXPORT_UNUSED_SYMBOL_GPL(sym) __EXPORT_SYMBOL(sym, "_unused_gpl")
< #else
< #define EXPORT_UNUSED_SYMBOL(sym)
< #define EXPORT_UNUSED_SYMBOL_GPL(sym)
< #endif
< 
< #endif
< 
585,589d523
< #define EXPORT_SYMBOL(sym)
< #define EXPORT_SYMBOL_GPL(sym)
< #define EXPORT_SYMBOL_GPL_FUTURE(sym)
< #define EXPORT_UNUSED_SYMBOL(sym)
< #define EXPORT_UNUSED_SYMBOL_GPL(sym)
Only in linux-3.0.36-lenovo/include/linux: mpu3050.h
Only in linux-3.0.36-lenovo/include/linux: mpu6000.h
Only in linux-3.0.36-lenovo/include/linux: mpu.h




diff -r linux-3.0.36/include/linux/msdos_fs.h linux-3.0.36-lenovo/include/linux/msdos_fs.h
103a104
> #define VFAT_IOCTL_GET_VOLUME_ID	_IOR('r', 0x12, __u32)
139a141,151
> 
> struct fat_boot_bsx {
> 	__u8     drive;		    /* drive number */
> 	__u8     reserved1;
> 	__u8     signature;	    /* extended boot signature */
> 	__u8     vol_id[4];     /* volume ID */
> 	__u8     vol_label[11]; /* volume label */
> 	__u8     type[8];       /* file system type */
> };
> #define FAT16_BSX_OFFSET	36 /* offset of fat_boot_bsx in FAT12 and FAT16 */
> #define FAT32_BSX_OFFSET	64 /* offset of fat_boot_bsx in FAT32 */
Only in linux-3.0.36-lenovo/include/linux: mt6229.h




diff -r linux-3.0.36/include/linux/mtd/blktrans.h linux-3.0.36-lenovo/include/linux/mtd/blktrans.h
61c61
< 		    unsigned long block, char *buffer);
---
> 		    unsigned long block,unsigned long nsect, char *buffer);
63c63
< 		     unsigned long block, char *buffer);
---
> 		     unsigned long block,unsigned long nsect, char *buffer);




diff -r linux-3.0.36/include/linux/mtd/nand.h linux-3.0.36-lenovo/include/linux/mtd/nand.h
50a51,54
> #ifdef CONFIG_MTD_NAND_RK29
> #define RK29_RESERVE_BLOCK_NUM    5
> #endif
> 
Only in linux-3.0.36-lenovo/include/linux: mtk23d.h
Only in linux-3.0.36-lenovo/include/linux: mu509.h
Only in linux-3.0.36-lenovo/include/linux: mw100.h




diff -r linux-3.0.36/include/linux/netdevice.h linux-3.0.36-lenovo/include/linux/netdevice.h
1331a1332,1333
> #define GSO_MAX_SEGS		65535
> 	u16			gso_max_segs;




diff -r linux-3.0.36/include/linux/netfilter/xt_IDLETIMER.h linux-3.0.36-lenovo/include/linux/netfilter/xt_IDLETIMER.h
6a7
>  *
34a36,39
> #define NLMSG_MAX_SIZE 64
> 
> #define NL_EVENT_TYPE_INACTIVE 0
> #define NL_EVENT_TYPE_ACTIVE 1
39a45,47
> 
> 	/* Use netlink messages for notification in addition to sysfs */
> 	__u8 send_nl_msg;
Only in linux-3.0.36-lenovo/include/linux/netfilter: xt_qtaguid.h
Only in linux-3.0.36-lenovo/include/linux/netfilter: xt_quota2.h




diff -r linux-3.0.36/include/linux/netfilter/xt_socket.h linux-3.0.36-lenovo/include/linux/netfilter/xt_socket.h
13a14,19
> void xt_socket_put_sk(struct sock *sk);
> struct sock *xt_socket_get4_sk(const struct sk_buff *skb,
> 			       struct xt_action_param *par);
> struct sock *xt_socket_get6_sk(const struct sk_buff *skb,
> 			       struct xt_action_param *par);
> 




diff -r linux-3.0.36/include/linux/netlink.h linux-3.0.36-lenovo/include/linux/netlink.h
28a29
> 
224c225,226
< 	int			family;
---
> 	u16			family;
> 	u16			min_dump_alloc;
262c264,265
< 			      int (*done)(struct netlink_callback*));
---
> 			      int (*done)(struct netlink_callback*),
> 			      u16 min_dump_alloc);




diff -r linux-3.0.36/include/linux/nfs_fs.h linux-3.0.36-lenovo/include/linux/nfs_fs.h
264,268d263
< static inline __be32 *NFS_COOKIEVERF(const struct inode *inode)
< {
< 	return NFS_I(inode)->cookieverf;
< }
< 




diff -r linux-3.0.36/include/linux/nl80211.h linux-3.0.36-lenovo/include/linux/nl80211.h
485a486,522
>  * @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver
>  *	the necessary information for supporting GTK rekey offload. This
>  *	feature is typically used during WoWLAN. The configuration data
>  *	is contained in %NL80211_ATTR_REKEY_DATA (which is nested and
>  *	contains the data in sub-attributes). After rekeying happened,
>  *	this command may also be sent by the driver as an MLME event to
>  *	inform userspace of the new replay counter.
>  *
>  * @NL80211_CMD_PMKSA_CANDIDATE: This is used as an event to inform userspace
>  *	of PMKSA caching dandidates.
>  *
>  * @NL80211_CMD_TDLS_OPER: Perform a high-level TDLS command (e.g. link setup).
>  * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame.
>  *
>  * @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP
>  *	(or GO) interface (i.e. hostapd) to ask for unexpected frames to
>  *	implement sending deauth to stations that send unexpected class 3
>  *	frames. Also used as the event sent by the kernel when such a frame
>  *	is received.
>  *	For the event, the %NL80211_ATTR_MAC attribute carries the TA and
>  *	other attributes like the interface index are present.
>  *	If used as the command it must have an interface index and you can
>  *	only unsubscribe from the event by closing the socket.
>  *
>  * @NL80211_CMD_PROBE_CLIENT: Probe an associated station on an AP interface
>  *	by sending a null data frame to it and reporting when the frame is
>  *	acknowleged. This is used to allow timing out inactive clients. Uses
>  *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_MAC. The command returns a
>  *	direct reply with an %NL80211_ATTR_COOKIE that is later used to match
>  *	up the event with the request. The event includes the same data and
>  *	has %NL80211_ATTR_ACK set if the frame was ACKed.
>  *
>  * @NL80211_CMD_REGISTER_BEACONS: Register this socket to receive beacons from
>  *	other BSSes when any interfaces are in AP mode. This helps implement
>  *	OLBC handling in hostapd. Beacons are reported in %NL80211_CMD_FRAME
>  *	messages. Note that per PHY only one application may register.
>  *
607a645,657
> 	NL80211_CMD_SET_REKEY_OFFLOAD,
> 
> 	NL80211_CMD_PMKSA_CANDIDATE,
> 
> 	NL80211_CMD_TDLS_OPER,
> 	NL80211_CMD_TDLS_MGMT,
> 
> 	NL80211_CMD_UNEXPECTED_FRAME,
> 
> 	NL80211_CMD_PROBE_CLIENT,
> 
> 	NL80211_CMD_REGISTER_BEACONS,
> 
747a798,799
>  * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: number of SSIDs you can
>  *	scan with a single scheduled scan request, a wiphy attribute.
749a802,805
>  * @NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: maximum length of information
>  *	elements that can be added to a scheduled scan request
>  * @NL80211_ATTR_MAX_MATCH_SETS: maximum number of sets that can be
>  *	used with @NL80211_ATTR_SCHED_SCAN_MATCH, a wiphy attribute.
981,982c1037,1038
<  * @NL80211_ATTR_WOWLAN_SUPPORTED: indicates, as part of the wiphy capabilities,
<  *	the supported WoWLAN triggers
---
>  * @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy
>  *	capabilities, the supported WoWLAN triggers
989a1046,1063
> 
>  * @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more
>  *	sets of attributes to match during scheduled scans.  Only BSSs
>  *	that match any of the sets will be reported.  These are
>  *	pass-thru filter rules.
>  *	For a match to succeed, the BSS must match all attributes of a
>  *	set.  Since not every hardware supports matching all types of
>  *	attributes, there is no guarantee that the reported BSSs are
>  *	fully complying with the match sets and userspace needs to be
>  *	able to ignore them by itself.
>  *	Thus, the implementation is somewhat hardware-dependent, but
>  *	this is only an optimization and the userspace application
>  *	needs to handle all the non-filtered results anyway.
>  *	If the match attributes don't make sense when combined with
>  *	the values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID
>  *	is included in the probe request, but the match attributes
>  *	will never let it go through), -EINVAL may be returned.
>  *	If ommited, no filtering is done.
998a1073,1131
>  * @%NL80211_ATTR_REKEY_DATA: nested attribute containing the information
>  *	necessary for GTK rekeying in the device, see &enum nl80211_rekey_data.
>  *
>  * @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,
>  *	nested array attribute containing an entry for each band, with the entry
>  *	being a list of supported rates as defined by IEEE 802.11 7.3.2.2 but
>  *	without the length restriction (at most %NL80211_MAX_SUPP_RATES).
>  *
>  * @NL80211_ATTR_HIDDEN_SSID: indicates whether SSID is to be hidden from Beacon
>  *	and Probe Response (when response to wildcard Probe Request); see
>  *	&enum nl80211_hidden_ssid, represented as a u32
>  *
>  * @NL80211_ATTR_IE_PROBE_RESP: Information element(s) for Probe Response frame.
>  *	This is used with %NL80211_CMD_NEW_BEACON and %NL80211_CMD_SET_BEACON to
>  *	provide extra IEs (e.g., WPS/P2P IE) into Probe Response frames when the
>  *	driver (or firmware) replies to Probe Request frames.
>  * @NL80211_ATTR_IE_ASSOC_RESP: Information element(s) for (Re)Association
>  *	Response frames. This is used with %NL80211_CMD_NEW_BEACON and
>  *	%NL80211_CMD_SET_BEACON to provide extra IEs (e.g., WPS/P2P IE) into
>  *	(Re)Association Response frames when the driver (or firmware) replies to
>  *	(Re)Association Request frames.
>  *
>  * @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration
>  *	of the station, see &enum nl80211_sta_wme_attr.
>  * @NL80211_ATTR_SUPPORT_AP_UAPSD: the device supports uapsd when working
>  *	as AP.
>  *
>  * @NL80211_ATTR_ROAM_SUPPORT: Indicates whether the firmware is capable of
>  *	roaming to another AP in the same ESS if the signal lever is low.
>  *
>  * @NL80211_ATTR_PMKSA_CANDIDATE: Nested attribute containing the PMKSA caching
>  *	candidate information, see &enum nl80211_pmksa_candidate_attr.
>  *
>  * @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not
>  *	for management frames transmission. In order to avoid p2p probe/action
>  *	frames are being transmitted at CCK rate in 2GHz band, the user space
>  *	applications use this attribute.
>  *	This attribute is used with %NL80211_CMD_TRIGGER_SCAN and
>  *	%NL80211_CMD_FRAME commands.
>  *
>  * @NL80211_ATTR_TDLS_ACTION: Low level TDLS action code (e.g. link setup
>  *	request, link setup confirm, link teardown, etc.). Values are
>  *	described in the TDLS (802.11z) specification.
>  * @NL80211_ATTR_TDLS_DIALOG_TOKEN: Non-zero token for uniquely identifying a
>  *	TDLS conversation between two devices.
>  * @NL80211_ATTR_TDLS_OPERATION: High level TDLS operation; see
>  *	&enum nl80211_tdls_operation, represented as a u8.
>  * @NL80211_ATTR_TDLS_SUPPORT: A flag indicating the device can operate
>  *	as a TDLS peer sta.
>  * @NL80211_ATTR_TDLS_EXTERNAL_SETUP: The TDLS discovery/setup and teardown
>  *	procedures should be performed by sending TDLS packets via
>  *	%NL80211_CMD_TDLS_MGMT. Otherwise %NL80211_CMD_TDLS_OPER should be
>  *	used for asking the driver to perform a TDLS operation.
>  *
>  * @NL80211_ATTR_DEVICE_AP_SME: This u32 attribute may be listed for devices
>  *	that have AP support to indicate that they have the AP SME integrated
>  *	with support for the features listed in this attribute, see
>  *	&enum nl80211_ap_sme_features.
>  *
1196a1330,1361
> 	NL80211_ATTR_REKEY_DATA,
> 
> 	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
> 	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
> 
> 	NL80211_ATTR_SCAN_SUPP_RATES,
> 
> 	NL80211_ATTR_HIDDEN_SSID,
> 
> 	NL80211_ATTR_IE_PROBE_RESP,
> 	NL80211_ATTR_IE_ASSOC_RESP,
> 
> 	NL80211_ATTR_STA_WME,
> 	NL80211_ATTR_SUPPORT_AP_UAPSD,
> 
> 	NL80211_ATTR_ROAM_SUPPORT,
> 
> 	NL80211_ATTR_SCHED_SCAN_MATCH,
> 	NL80211_ATTR_MAX_MATCH_SETS,
> 
> 	NL80211_ATTR_PMKSA_CANDIDATE,
> 
> 	NL80211_ATTR_TX_NO_CCK_RATE,
> 
> 	NL80211_ATTR_TDLS_ACTION,
> 	NL80211_ATTR_TDLS_DIALOG_TOKEN,
> 	NL80211_ATTR_TDLS_OPERATION,
> 	NL80211_ATTR_TDLS_SUPPORT,
> 	NL80211_ATTR_TDLS_EXTERNAL_SETUP,
> 
> 	NL80211_ATTR_DEVICE_AP_SME,
> 
1655a1821,1840
>  * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
>  * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
>  * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
>  * only report BSS with matching SSID.
>  * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
>  *	attribute number currently defined
>  * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
>  */
> enum nl80211_sched_scan_match_attr {
> 	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID,
> 
> 	NL80211_ATTR_SCHED_SCAN_MATCH_SSID,
> 
> 	/* keep last */
> 	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST,
> 	NL80211_SCHED_SCAN_MATCH_ATTR_MAX =
> 		__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST - 1
> };
> 
> /**
2241a2427,2436
>  * @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be
>  *	used when setting, used only to indicate that GTK rekeying is supported
>  *	by the device (flag)
>  * @NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: wake up on GTK rekey failure (if
>  *	done by the device) (flag)
>  * @NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: wake up on EAP Identity Request
>  *	packet (flag)
>  * @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)
>  * @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released
>  *	(on devices that have rfkill in the device) (flag)
2250a2446,2450
> 	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED,
> 	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE,
> 	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST,
> 	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE,
> 	NL80211_WOWLAN_TRIG_RFKILL_RELEASE,
2362a2563,2668
> 
> #define NL80211_KCK_LEN			16
> #define NL80211_KEK_LEN			16
> #define NL80211_REPLAY_CTR_LEN		8
> 
> /**
>  * enum nl80211_rekey_data - attributes for GTK rekey offload
>  * @__NL80211_REKEY_DATA_INVALID: invalid number for nested attributes
>  * @NL80211_REKEY_DATA_KEK: key encryption key (binary)
>  * @NL80211_REKEY_DATA_KCK: key confirmation key (binary)
>  * @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)
>  * @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)
>  * @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)
>  */
> enum nl80211_rekey_data {
> 	__NL80211_REKEY_DATA_INVALID,
> 	NL80211_REKEY_DATA_KEK,
> 	NL80211_REKEY_DATA_KCK,
> 	NL80211_REKEY_DATA_REPLAY_CTR,
> 
> 	/* keep last */
> 	NUM_NL80211_REKEY_DATA,
> 	MAX_NL80211_REKEY_DATA = NUM_NL80211_REKEY_DATA - 1
> };
> 
> /**
>  * enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID
>  * @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in
>  *	Beacon frames)
>  * @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element
>  *	in Beacon frames
>  * @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID
>  *	element in Beacon frames but zero out each byte in the SSID
>  */
> enum nl80211_hidden_ssid {
> 	NL80211_HIDDEN_SSID_NOT_IN_USE,
> 	NL80211_HIDDEN_SSID_ZERO_LEN,
> 	NL80211_HIDDEN_SSID_ZERO_CONTENTS
> };
> 
> /**
>  * enum nl80211_sta_wme_attr - station WME attributes
>  * @__NL80211_STA_WME_INVALID: invalid number for nested attribute
>  * @NL80211_STA_WME_UAPSD_QUEUES: bitmap of uapsd queues. the format
>  *	is the same as the AC bitmap in the QoS info field.
>  * @NL80211_STA_WME_MAX_SP: max service period. the format is the same
>  *	as the MAX_SP field in the QoS info field (but already shifted down).
>  * @__NL80211_STA_WME_AFTER_LAST: internal
>  * @NL80211_STA_WME_MAX: highest station WME attribute
>  */
> enum nl80211_sta_wme_attr {
> 	__NL80211_STA_WME_INVALID,
> 	NL80211_STA_WME_UAPSD_QUEUES,
> 	NL80211_STA_WME_MAX_SP,
> 
> 	/* keep last */
> 	__NL80211_STA_WME_AFTER_LAST,
> 	NL80211_STA_WME_MAX = __NL80211_STA_WME_AFTER_LAST - 1
> };
> 
> /**
>  * enum nl80211_pmksa_candidate_attr - attributes for PMKSA caching candidates
>  * @__NL80211_PMKSA_CANDIDATE_INVALID: invalid number for nested attributes
>  * @NL80211_PMKSA_CANDIDATE_INDEX: candidate index (u32; the smaller, the higher
>  *	priority)
>  * @NL80211_PMKSA_CANDIDATE_BSSID: candidate BSSID (6 octets)
>  * @NL80211_PMKSA_CANDIDATE_PREAUTH: RSN pre-authentication supported (flag)
>  * @NUM_NL80211_PMKSA_CANDIDATE: number of PMKSA caching candidate attributes
>  *	(internal)
>  * @MAX_NL80211_PMKSA_CANDIDATE: highest PMKSA caching candidate attribute
>  *	(internal)
>  */
> enum nl80211_pmksa_candidate_attr {
> 	__NL80211_PMKSA_CANDIDATE_INVALID,
> 	NL80211_PMKSA_CANDIDATE_INDEX,
> 	NL80211_PMKSA_CANDIDATE_BSSID,
> 	NL80211_PMKSA_CANDIDATE_PREAUTH,
> 
> 	/* keep last */
> 	NUM_NL80211_PMKSA_CANDIDATE,
> 	MAX_NL80211_PMKSA_CANDIDATE = NUM_NL80211_PMKSA_CANDIDATE - 1
> };
> 
> /**
>  * enum nl80211_tdls_operation - values for %NL80211_ATTR_TDLS_OPERATION
>  * @NL80211_TDLS_DISCOVERY_REQ: Send a TDLS discovery request
>  * @NL80211_TDLS_SETUP: Setup TDLS link
>  * @NL80211_TDLS_TEARDOWN: Teardown a TDLS link which is already established
>  * @NL80211_TDLS_ENABLE_LINK: Enable TDLS link
>  * @NL80211_TDLS_DISABLE_LINK: Disable TDLS link
>  */
> enum nl80211_tdls_operation {
> 	NL80211_TDLS_DISCOVERY_REQ,
> 	NL80211_TDLS_SETUP,
> 	NL80211_TDLS_TEARDOWN,
> 	NL80211_TDLS_ENABLE_LINK,
> 	NL80211_TDLS_DISABLE_LINK,
> };
> 
> /*
>  * enum nl80211_ap_sme_features - device-integrated AP features
>  * Reserved for future use, no bits are defined in
>  * NL80211_ATTR_DEVICE_AP_SME yet.
> enum nl80211_ap_sme_features {
> };
>  */




diff -r linux-3.0.36/include/linux/nls.h linux-3.0.36-lenovo/include/linux/nls.h
46c46
< /* nls.c */
---
> /* nls_base.c */
55c55,56
< extern int utf8s_to_utf16s(const u8 *s, int len, wchar_t *pwcs);
---
> extern int utf8s_to_utf16s(const u8 *s, int len,
> 		enum utf16_endian endian, wchar_t *pwcs, int maxlen);




diff -r linux-3.0.36/include/linux/page-flags.h linux-3.0.36-lenovo/include/linux/page-flags.h
368c368
< __PAGEFLAG(Head, compound)
---
> __SETPAGEFLAG(Head, compound)  __CLEARPAGEFLAG(Head, compound)
379a380
> #define PG_head_mask ((1L << PG_compound))
380a382,386
> 
> static inline int PageHead(struct page *page)
> {
> 	return ((page->flags & PG_head_tail_mask) == PG_head_mask);
> }




diff -r linux-3.0.36/include/linux/pci.h linux-3.0.36-lenovo/include/linux/pci.h
177,178d176
< 	/* Device causes system crash if in D3 during S3 sleep */
< 	PCI_DEV_FLAGS_NO_D3_DURING_SLEEP = (__force pci_dev_flags_t) 8,
804a803
> int __must_check pci_reassign_resource(struct pci_dev *dev, int i, resource_size_t add_size, resource_size_t align);




diff -r linux-3.0.36/include/linux/pci_ids.h linux-3.0.36-lenovo/include/linux/pci_ids.h
1539a1540
> #define PCI_DEVICE_ID_RICOH_R5CE822	0xe822
1821d1821
< #define PCI_SUBDEVICE_ID_SIIG_DUAL_SERIAL	0x2530
2391a2392,2393
> 
> #define PCI_VENDOR_ID_ASMEDIA		0x1b21




diff -r linux-3.0.36/include/linux/pda_power.h linux-3.0.36-lenovo/include/linux/pda_power.h
37a38,39
> 
> 	bool use_otg_notifier;




diff -r linux-3.0.36/include/linux/perf_event.h linux-3.0.36-lenovo/include/linux/perf_event.h
810c810
< 	struct file			*filp;
---
> 	atomic_long_t			refcount;
Only in linux-3.0.36-lenovo/include/linux/platform_data: leds-lm2759.h
Only in linux-3.0.36-lenovo/include/linux/platform_data: leds-lm3642.h
Only in linux-3.0.36-lenovo/include/linux/platform_data: ram_console.h




diff -r linux-3.0.36/include/linux/plist.h linux-3.0.36-lenovo/include/linux/plist.h
80d79
< #include <linux/spinlock_types.h>
84,87d82
< #ifdef CONFIG_DEBUG_PI_LIST
< 	raw_spinlock_t *rawlock;
< 	spinlock_t *spinlock;
< #endif
96,106d90
< #ifdef CONFIG_DEBUG_PI_LIST
< # define PLIST_HEAD_LOCK_INIT(_lock)		.spinlock = _lock
< # define PLIST_HEAD_LOCK_INIT_RAW(_lock)	.rawlock = _lock
< #else
< # define PLIST_HEAD_LOCK_INIT(_lock)
< # define PLIST_HEAD_LOCK_INIT_RAW(_lock)
< #endif
< 
< #define _PLIST_HEAD_INIT(head)				\
< 	.node_list = LIST_HEAD_INIT((head).node_list)
< 
110,121d93
<  * @_lock:	lock to initialize for this list
<  */
< #define PLIST_HEAD_INIT(head, _lock)			\
< {							\
< 	_PLIST_HEAD_INIT(head),				\
< 	PLIST_HEAD_LOCK_INIT(&(_lock))			\
< }
< 
< /**
<  * PLIST_HEAD_INIT_RAW - static struct plist_head initializer
<  * @head:	struct plist_head variable name
<  * @_lock:	lock to initialize for this list
123c95
< #define PLIST_HEAD_INIT_RAW(head, _lock)		\
---
> #define PLIST_HEAD_INIT(head)				\
125,126c97
< 	_PLIST_HEAD_INIT(head),				\
< 	PLIST_HEAD_LOCK_INIT_RAW(&(_lock))		\
---
> 	.node_list = LIST_HEAD_INIT((head).node_list)	\
144,159d114
<  * @lock:	spinlock protecting the list (debugging)
<  */
< static inline void
< plist_head_init(struct plist_head *head, spinlock_t *lock)
< {
< 	INIT_LIST_HEAD(&head->node_list);
< #ifdef CONFIG_DEBUG_PI_LIST
< 	head->spinlock = lock;
< 	head->rawlock = NULL;
< #endif
< }
< 
< /**
<  * plist_head_init_raw - dynamic struct plist_head initializer
<  * @head:	&struct plist_head pointer
<  * @lock:	raw_spinlock protecting the list (debugging)
162c117
< plist_head_init_raw(struct plist_head *head, raw_spinlock_t *lock)
---
> plist_head_init(struct plist_head *head)
165,168d119
< #ifdef CONFIG_DEBUG_PI_LIST
< 	head->rawlock = lock;
< 	head->spinlock = NULL;
< #endif
Only in linux-3.0.36-lenovo/include/linux/power: bq24195_charger.h
Only in linux-3.0.36-lenovo/include/linux/power: cw2015_battery.h




diff -r linux-3.0.36/include/linux/power_supply.h linux-3.0.36-lenovo/include/linux/power_supply.h
16a17
> #include <linux/wakelock.h>
165a167,169
> 	spinlock_t changed_lock;
> 	bool changed;
> 	struct wake_lock work_wake_lock;




diff -r linux-3.0.36/include/linux/random.h linux-3.0.36-lenovo/include/linux/random.h
51,52c51
< extern void rand_initialize_irq(int irq);
< 
---
> extern void add_device_randomness(const void *, unsigned int);
55c54
< extern void add_interrupt_randomness(int irq);
---
> extern void add_interrupt_randomness(int irq, int irq_flags);
57a57
> extern void get_random_bytes_arch(void *buf, int nbytes);
92a93,105
> 
> #ifdef CONFIG_ARCH_RANDOM
> # include <asm/archrandom.h>
> #else
> static inline int arch_get_random_long(unsigned long *v)
> {
> 	return 0;
> }
> static inline int arch_get_random_int(unsigned int *v)
> {
> 	return 0;
> }
> #endif
Only in linux-3.0.36-lenovo/include/linux/regulator: act8846.h
Only in linux-3.0.36-lenovo/include/linux/regulator: act8891.h
Only in linux-3.0.36-lenovo/include/linux/regulator: act8931.h
Only in linux-3.0.36-lenovo/include/linux/regulator: charge-regulator.h




diff -r linux-3.0.36/include/linux/regulator/consumer.h linux-3.0.36-lenovo/include/linux/regulator/consumer.h
155a156,158
> #ifdef CONFIG_PLAT_RK
> int regulator_set_suspend_voltage(struct regulator *regulator, int uV);
> #endif
244a248,254
> 
> #ifdef CONFIG_PLAT_RK
> static inline int regulator_set_suspend_voltage(struct regulator *regulator, int uV)
> {
> 	return 0;
> }
> #endif
Only in linux-3.0.36-lenovo/include/linux/regulator: rk29-pwm-regulator.h
Only in linux-3.0.36-lenovo/include/linux: rfkill-rk.h
Only in linux-3.0.36-lenovo/include/linux: rk_board_id.h
Only in linux-3.0.36-lenovo/include/linux: rk_fb.h
Only in linux-3.0.36-lenovo/include/linux: rk_screen.h
Only in linux-3.0.36-lenovo/include/linux: rmi.h




diff -r linux-3.0.36/include/linux/rtmutex.h linux-3.0.36-lenovo/include/linux/rtmutex.h
69c69
< 	, .wait_list = PLIST_HEAD_INIT_RAW(mutexname.wait_list, mutexname.wait_lock) \
---
> 	, .wait_list = PLIST_HEAD_INIT(mutexname.wait_list) \
103c103
< 	.pi_waiters	= PLIST_HEAD_INIT(tsk.pi_waiters, tsk.pi_lock),	\
---
> 	.pi_waiters	= PLIST_HEAD_INIT(tsk.pi_waiters),	\




diff -r linux-3.0.36/include/linux/rtnetlink.h linux-3.0.36-lenovo/include/linux/rtnetlink.h
602a603,605
> /* New extended info filters for IFLA_EXT_MASK */
> #define RTEXT_FILTER_VF		(1 << 0)
> 
Only in linux-3.0.36-lenovo/include/linux: sc6610.h




diff -r linux-3.0.36/include/linux/sched.h linux-3.0.36-lenovo/include/linux/sched.h
1237a1238,1240
> #ifdef CONFIG_CGROUP_SCHED
> 	struct task_group *sched_task_group;
> #endif
1487c1490
< 	int mems_allowed_change_disable;
---
> 	seqcount_t mems_allowed_seq;	/* Seqence no to catch updates */
1756a1760,1762
> extern int task_free_register(struct notifier_block *n);
> extern int task_free_unregister(struct notifier_block *n);
> 
2616c2622
< #endif
---
> #endif /* CONFIG_CGROUP_SCHED */
Only in linux-3.0.36-lenovo/include/linux: sensor-dev.h




diff -r linux-3.0.36/include/linux/serial_core.h linux-3.0.36-lenovo/include/linux/serial_core.h
183a184,187
> #define PORT_RK2818	90
> 
> #define PORT_RK29	90
> 
247a252
> 	void		(*wake_peer)(struct uart_port *);
Only in linux-3.0.36-lenovo/include/linux: sew868.h




diff -r linux-3.0.36/include/linux/snmp.h linux-3.0.36-lenovo/include/linux/snmp.h
212d211
< 	LINUX_MIB_TCPABORTONSYN,		/* TCPAbortOnSyn */
233a233,234
> 	LINUX_MIB_TCPCHALLENGEACK,		/* TCPChallengeACK */
> 	LINUX_MIB_TCPSYNCHALLENGE,		/* TCPSYNChallenge */




diff -r linux-3.0.36/include/linux/sockios.h linux-3.0.36-lenovo/include/linux/sockios.h
67a68
> #define SIOCKILLADDR	0x8939		/* kill sockets with this local addr */




diff -r linux-3.0.36/include/linux/spi/spi.h linux-3.0.36-lenovo/include/linux/spi/spi.h
446a447
> 	void			*state;
753a755
> 	 
Only in linux-3.0.36-lenovo/include/linux: ste.h




diff -r linux-3.0.36/include/linux/sunrpc/cache.h linux-3.0.36-lenovo/include/linux/sunrpc/cache.h
226a227,242
> static inline int get_uint(char **bpp, unsigned int *anint)
> {
> 	char buf[50];
> 	int len = qword_get(bpp, buf, sizeof(buf));
> 
> 	if (len < 0)
> 		return -EINVAL;
> 	if (len == 0)
> 		return -ENOENT;
> 
> 	if (kstrtouint(buf, 0, anint))
> 		return -EINVAL;
> 
> 	return 0;
> }
> 




diff -r linux-3.0.36/include/linux/swap.h linux-3.0.36-lenovo/include/linux/swap.h
246,250d245
< /* LRU Isolation modes. */
< #define ISOLATE_INACTIVE 0	/* Isolate inactive pages. */
< #define ISOLATE_ACTIVE 1	/* Isolate active pages. */
< #define ISOLATE_BOTH 2		/* Isolate both active and inactive pages. */
< 
262c257
< extern int __isolate_lru_page(struct page *page, int mode, int file);
---
> extern int __isolate_lru_page(struct page *page, isolate_mode_t mode, int file);
Only in linux-3.0.36-lenovo/include/linux: switch.h
Only in linux-3.0.36-lenovo/include/linux: sw_sync.h
Only in linux-3.0.36-lenovo/include/linux: synaptics_i2c_rmi.h
Only in linux-3.0.36-lenovo/include/linux: sync.h




diff -r linux-3.0.36/include/linux/syslog.h linux-3.0.36-lenovo/include/linux/syslog.h
49a50,55
> /*
>  * Syslog priority (PRI) maximum length in char : '<[0-9]{1,3}>'
>  * See RFC5424 for details
> */
> #define SYSLOG_PRI_MAX_LENGTH 5
> 




diff -r linux-3.0.36/include/linux/time.h linux-3.0.36-lenovo/include/linux/time.h
109a110,116
> #define KTIME_MAX			((s64)~((u64)1 << 63))
> #if (BITS_PER_LONG == 64)
> # define KTIME_SEC_MAX			(KTIME_MAX / NSEC_PER_SEC)
> #else
> # define KTIME_SEC_MAX			LONG_MAX
> #endif
> 
113,114c120,139
< #define timespec_valid(ts) \
< 	(((ts)->tv_sec >= 0) && (((unsigned long) (ts)->tv_nsec) < NSEC_PER_SEC))
---
> static inline bool timespec_valid(const struct timespec *ts)
> {
> 	/* Dates before 1970 are bogus */
> 	if (ts->tv_sec < 0)
> 		return false;
> 	/* Can't have more nanoseconds then a second */
> 	if ((unsigned long)ts->tv_nsec >= NSEC_PER_SEC)
> 		return false;
> 	return true;
> }
> 
> static inline bool timespec_valid_strict(const struct timespec *ts)
> {
> 	if (!timespec_valid(ts))
> 		return false;
> 	/* Disallow values that could overflow ktime_t */
> 	if ((unsigned long long)ts->tv_sec >= KTIME_SEC_MAX)
> 		return false;
> 	return true;
> }




diff -r linux-3.0.36/include/linux/timex.h linux-3.0.36-lenovo/include/linux/timex.h
269c269
< extern void second_overflow(void);
---
> extern int second_overflow(unsigned long secs);
Only in linux-3.0.36-lenovo/include/linux: ts-auto.h
Only in linux-3.0.36-lenovo/include/linux: uhid.h
Only in linux-3.0.36-lenovo/include/linux: uid_stat.h
Only in linux-3.0.36-lenovo/include/linux/usb: android_composite.h




diff -r linux-3.0.36/include/linux/usb/composite.h linux-3.0.36-lenovo/include/linux/usb/composite.h
242a243,245
> int usb_remove_config(struct usb_composite_dev *,
> 		struct usb_configuration *);
> 
Only in linux-3.0.36-lenovo/include/linux/usb: f_accessory.h
Only in linux-3.0.36-lenovo/include/linux/usb: f_mtp.h




diff -r linux-3.0.36/include/linux/usb/otg.h linux-3.0.36-lenovo/include/linux/usb/otg.h
99a100,103
> 	/* set/reset USB charger in High impedence mode on VBUS */
> 	int	(*set_hz_mode)(struct otg_transceiver *otg,
> 				bool enabled);
> 
192a197,206
> }
> 
> /* Context: can sleep */
> static inline int
> otg_set_hz_mode(struct otg_transceiver *otg, bool enabled)
> {
> 	if (otg->set_hz_mode)
> 		return otg->set_hz_mode(otg, enabled);
> 
> 	return -EINVAL;
Only in linux-3.0.36-lenovo/include/linux/usb: otg_id.h




diff -r linux-3.0.36/include/linux/usb/usbnet.h linux-3.0.36-lenovo/include/linux/usb/usbnet.h
231a232,249
> 
> #ifdef DEBUG
> #define devdbg(usbnet, fmt, arg...) \
>         printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
> #else
> #define devdbg(usbnet, fmt, arg...) \
>         ({ if (0) printk(KERN_DEBUG "%s: " fmt "\n" , (usbnet)->net->name , \
>                 ## arg); 0; })
> #endif
> 
> #define deverr(usbnet, fmt, arg...) \
>         printk(KERN_ERR "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
> #define devwarn(usbnet, fmt, arg...) \
>         printk(KERN_WARNING "%s: " fmt "\n" , (usbnet)->net->name , ## arg)
> 
> #define devinfo(usbnet, fmt, arg...) \
>         printk(KERN_INFO "%s: " fmt "\n" , (usbnet)->net->name , ## arg); 
> 




diff -r linux-3.0.36/include/linux/usb.h linux-3.0.36-lenovo/include/linux/usb.h
759a760,780
> /**
>  * USB_VENDOR_AND_INTERFACE_INFO - describe a specific usb vendor with a class of usb interfaces
>  * @vend: the 16 bit USB Vendor ID
>  * @cl: bInterfaceClass value
>  * @sc: bInterfaceSubClass value
>  * @pr: bInterfaceProtocol value
>  *
>  * This macro is used to create a struct usb_device_id that matches a
>  * specific vendor with a specific class of interfaces.
>  *
>  * This is especially useful when explicitly matching devices that have
>  * vendor specific bDeviceClass values, but standards-compliant interfaces.
>  */
> #define USB_VENDOR_AND_INTERFACE_INFO(vend, cl, sc, pr) \
> 	.match_flags = USB_DEVICE_ID_MATCH_INT_INFO \
> 		| USB_DEVICE_ID_MATCH_VENDOR, \
> 	.idVendor = (vend), \
> 	.bInterfaceClass = (cl), \
> 	.bInterfaceSubClass = (sc), \
> 	.bInterfaceProtocol = (pr)
> 




diff -r linux-3.0.36/include/linux/videodev2.h linux-3.0.36-lenovo/include/linux/videodev2.h
1013a1014
> 	__s32 rect[4];
1396a1398,1406
> 
> /* ddl@rock-chips.com : Add ioctrl -  V4L2_CID_SCENE for camera scene control */
> #define V4L2_CID_CAMERA_CLASS_BASE_ROCK		(V4L2_CID_CAMERA_CLASS_BASE + 30)
> #define V4L2_CID_SCENE				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+1)
> #define V4L2_CID_EFFECT				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+2)
> #define V4L2_CID_FLASH				(V4L2_CID_CAMERA_CLASS_BASE_ROCK+3)
> #define V4L2_CID_FOCUS_CONTINUOUS		(V4L2_CID_CAMERA_CLASS_BASE_ROCK+4)
> #define V4L2_CID_FOCUSZONE       (V4L2_CID_CAMERA_CLASS_BASE_ROCK+5)
> #define V4L2_CID_FACEDETECT (V4L2_CID_CAMERA_CLASS_BASE_ROCK+6)




diff -r linux-3.0.36/include/linux/wait.h linux-3.0.36-lenovo/include/linux/wait.h
235a236,237
> 	if (!ret && (condition))					\
> 		ret = 1;						\
252,253c254,256
<  * The function returns 0 if the @timeout elapsed, and the remaining
<  * jiffies if the condition evaluated to true before the timeout elapsed.
---
>  * The function returns 0 if the @timeout elapsed, or the remaining
>  * jiffies (at least 1) if the @condition evaluated to %true before
>  * the @timeout elapsed.
320a324,325
> 	if (!ret && (condition))					\
> 		ret = 1;						\
337,339c342,345
<  * The function returns 0 if the @timeout elapsed, -ERESTARTSYS if it
<  * was interrupted by a signal, and the remaining jiffies otherwise
<  * if the condition evaluated to true before the timeout elapsed.
---
>  * Returns:
>  * 0 if the @timeout elapsed, -%ERESTARTSYS if it was interrupted by
>  * a signal, or the remaining jiffies (at least 1) if the @condition
>  * evaluated to %true before the @timeout elapsed.
Only in linux-3.0.36-lenovo/include/linux: wakelock.h
Only in linux-3.0.36-lenovo/include/linux: wifi_tiwlan.h
Only in linux-3.0.36-lenovo/include/linux: wimo.h
Only in linux-3.0.36-lenovo/include/linux: wl127x-rfkill.h
Only in linux-3.0.36-lenovo/include/linux: wlan_plat.h




diff -r linux-3.0.36/include/linux/xfrm.h linux-3.0.36-lenovo/include/linux/xfrm.h
86a87,88
> #define XFRMA_REPLAY_ESN_MAX	4096
> 




diff -r linux-3.0.36/include/media/soc_camera.h linux-3.0.36-lenovo/include/media/soc_camera.h
70a71
>     int (*enum_frameinervals)(struct soc_camera_device *, struct v4l2_frmivalenum *);/* ddl@rock-chips.com :Add ioctrl - VIDIOC_ENUM_FRAMEINTERVALS for soc-camera */
104a106,108
> 
>     int (*s_stream)(struct soc_camera_device *, int enable);	/* ddl@rock-chips.com : Add stream control for host */
> 
144a149
> 	int (*powerdown)(struct device *, int);		/* ddl@rock-chisp.com : support sensor powerdown  */
214a220
> 
215a222
> 	const struct v4l2_querymenu *menus;                /* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
216a224
> 	int num_menus;      /* ddl@rock-chips.com : Add ioctrl -VIDIOC_QUERYMENU */
272a281,284
> 
> #define SOCAM_MCLK_24MHZ   (1<<29)                                      /* ddl@rock-chips.com : add  */
> #define SOCAM_MCLK_27MHZ   (1<<30)
> #define SOCAM_MCLK_48MHZ   (1<<31)




diff -r linux-3.0.36/include/media/v4l2-chip-ident.h linux-3.0.36-lenovo/include/media/v4l2-chip-ident.h
75,78c75,86
< 	V4L2_IDENT_OV9640 = 257,
< 	V4L2_IDENT_OV6650 = 258,
< 	V4L2_IDENT_OV2640 = 259,
< 	V4L2_IDENT_OV9740 = 260,
---
> 	V4L2_IDENT_OV2655 = 257,                            /* ddl@rock-chips.com : ov2655 support */
> 	V4L2_IDENT_OV2659 = 258,
> 	V4L2_IDENT_OV3640 = 259,
> 	V4L2_IDENT_OV5640 = 260,
> 	V4L2_IDENT_OV5642 = 261,
> 	V4L2_IDENT_OV7675 = 262,
> 	V4L2_IDENT_OV2640 = 263,
> 	V4L2_IDENT_OV9640 = 264,
> 	V4L2_IDENT_OV6650 = 265,
> 	V4L2_IDENT_OV9740 = 266,
> 	V4L2_IDENT_OV7690 = 267,
> 	V4L2_IDENT_OV3660 = 268,
82a91,96
> 	/* Samsung sensors: reserved range 310-319 */
> 	V4L2_IDENT_S5K66A = 310,							/* ddl@rock-chips.com : s5k66a support */
> 	V4L2_IDENT_S5K5CA = 311,							/* ddl@rock-chips.com : s5k5ca support */
> 
> 	V4L2_IDENT_MTK9335ISP = 320,							/* ddl@rock-chips.com : MTK9335ISP support */
> 
292a307
> 	V4L2_IDENT_MT9D112		= 45009,		/* ddl@rock-chips.com : MT9D112 support */
300a316,318
> 	V4L2_IDENT_MT9P111		= 45033,     /* ddl@rock-chips.com : MT9P111 support */
> 	V4L2_IDENT_MT9D113      = 45034,     /* ddl@rock-chips.com : MT9D113 support */
> 
322a341,362
> 
> 
>     V4L2_IDENT_NT99250 = 64100,    /* ddl@rock-chips.com : nt99250 support */
>     V4L2_IDENT_SID130B = 64101,      /* ddl@rock-chips.com : sid130B support */
> 
>     V4L2_IDENT_GT2005 = 64110,       /* ddl@rock-chips.com : GT2005 support */
>     V4L2_IDENT_GC0307 = 64111,      /* ddl@rock-chips.com : GC0308 support */
>     V4L2_IDENT_GC0308 = 64112,      /* ddl@rock-chips.com : GC0308 support */
>     V4L2_IDENT_GC0309 = 64113,      /* ddl@rock-chips.com : GC0309 support */
>     V4L2_IDENT_GC2015 = 64114,      /* ddl@rock-chips.com : gc2015 support */
>     V4L2_IDENT_GC0329 = 64115,      /* ddl@rock-chips.com : GC0329 support */
>     V4L2_IDENT_GC2035= 64116,      /* ddl@rock-chips.com : GC0329 support */
>     V4L2_IDENT_SP0838 = 64120,      /* ddl@rock-chips.com : SP0838 support */
>     V4L2_IDENT_SP2518 = 64121,      /* ddl@rock-chips.com : SP2518 support */
> 
>     V4L2_IDENT_HI253 = 64130,      /* ddl@rock-chips.com : hi253 support */
>     V4L2_IDENT_HI704 = 64131,      /* ddl@rock-chips.com : hi704 support */    
>     
>     V4L2_IDENT_SIV120B = 64140,      /* ddl@rock-chips.com : siv120b support */
>     V4L2_IDENT_SIV121D= 64141,      /* ddl@rock-chips.com : sid130B support */
>     
> 




diff -r linux-3.0.36/include/media/videobuf-core.h linux-3.0.36-lenovo/include/media/videobuf-core.h
64a65,71
> #ifdef CONFIG_VIDEO_RK29XX_VOUT
> struct rk29_vaddr {
> 	dma_addr_t 				base[2];
> 	size_t 					len[2];
> };
> 
> #endif
102a110,112
> #ifdef CONFIG_VIDEO_RK29XX_VOUT
> 	struct rk29_vaddr		vaddr;
> #endif
Only in linux-3.0.36-lenovo/include/net: activity_stats.h




diff -r linux-3.0.36/include/net/addrconf.h linux-3.0.36-lenovo/include/net/addrconf.h
11c11
< #define REGEN_MAX_RETRY			(5)
---
> #define REGEN_MAX_RETRY			(3)




diff -r linux-3.0.36/include/net/bluetooth/bluetooth.h linux-3.0.36-lenovo/include/net/bluetooth/bluetooth.h
58a59
> 	__u8 key_size;
72,74c73,85
< #define BT_INFO(fmt, arg...) printk(KERN_INFO "Bluetooth: " fmt "\n" , ## arg)
< #define BT_ERR(fmt, arg...)  printk(KERN_ERR "%s: " fmt "\n" , __func__ , ## arg)
< #define BT_DBG(fmt, arg...)  pr_debug("%s: " fmt "\n" , __func__ , ## arg)
---
> #define BT_POWER	9
> struct bt_power {
> 	__u8 force_active;
> };
> #define BT_POWER_FORCE_ACTIVE_OFF 0
> #define BT_POWER_FORCE_ACTIVE_ON  1
> 
> __attribute__((format (printf, 2, 3)))
> int bt_printk(const char *level, const char *fmt, ...);
> 
> #define BT_INFO(fmt, arg...)   bt_printk(KERN_INFO, pr_fmt(fmt), ##arg)
> #define BT_ERR(fmt, arg...)    bt_printk(KERN_ERR, pr_fmt(fmt), ##arg)
> #define BT_DBG(fmt, arg...)    pr_debug(fmt "\n", ##arg)
133c144,145
< int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg, size_t len, int flags);
---
> int  bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,
> 				struct msghdr *msg, size_t len, int flags);
152a165
> 	__u8 force_active;
167,168c180,181
< static inline struct sk_buff *bt_skb_send_alloc(struct sock *sk, unsigned long len, 
< 							int nb, int *err)
---
> static inline struct sk_buff *bt_skb_send_alloc(struct sock *sk,
> 					unsigned long len, int nb, int *err)
198c211
< int bt_err(__u16 code);
---
> int bt_to_errno(__u16 code);




diff -r linux-3.0.36/include/net/bluetooth/hci_core.h linux-3.0.36-lenovo/include/net/bluetooth/hci_core.h
76a77,90
> struct key_master_id {
> 	__le16 ediv;
> 	u8 rand[8];
> } __packed;
> 
> struct link_key_data {
> 	bdaddr_t bdaddr;
> 	u8 type;
> 	u8 val[16];
> 	u8 pin_len;
> 	u8 dlen;
> 	u8 data[0];
> } __packed;
> 
82a97,98
> 	u8 dlen;
> 	u8 data[0];
91a108,113
> struct adv_entry {
> 	struct list_head list;
> 	bdaddr_t bdaddr;
> 	u8 bdaddr_type;
> };
> 
109a132
> 	__u8		extfeatures[8];
173a197,198
> 	struct crypto_blkcipher	*tfm;
> 
183a209,211
> 	struct list_head	adv_entries;
> 	struct timer_list	adv_timer;
> 
215d242
< 	spinlock_t	lock;
217a245
> 	__u8		dst_type;
235a264
> 	__u8		enc_key_size;
262d290
< 	void		*priv;
310c338,339
< struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr);
---
> struct inquiry_entry *hci_inquiry_cache_lookup(struct hci_dev *hdev,
> 							bdaddr_t *bdaddr);
315a345
> 	HCI_CONN_REAUTH_PEND,
418c448,449
< struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst);
---
> struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
> 					__u16 pkt_type, bdaddr_t *dst);
423c454,456
< struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type);
---
> struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
> 						__u16 pkt_type, bdaddr_t *dst,
> 						__u8 sec_level, __u8 auth_type);
430c463
< void hci_conn_enter_active_mode(struct hci_conn *conn);
---
> void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active);
451,452c484,485
< 					timeo *= 2;
< 			} else
---
> 					timeo *= 20;
> 			} else {
454c487,488
< 		} else
---
> 			}
> 		} else {
455a490
> 		}
513a549,550
> int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr);
> int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr);
520a558,562
> struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8]);
> struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
> 					bdaddr_t *bdaddr, u8 type);
> int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
> 			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16]);
529a572,577
> #define ADV_CLEAR_TIMEOUT (3*60*HZ) /* Three minutes */
> int hci_adv_entries_clear(struct hci_dev *hdev);
> struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr);
> int hci_add_adv_entry(struct hci_dev *hdev,
> 					struct hci_ev_le_advertising_info *ev);
> 
555a604,606
> /* ----- Extended LMP capabilities ----- */
> #define lmp_host_le_capable(dev)   ((dev)->extfeatures[0] & LMP_HOST_LE)
> 
564c615,616
< 	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type);
---
> 	int (*connect_ind)	(struct hci_dev *hdev, bdaddr_t *bdaddr,
> 								__u8 type);
568c620,621
< 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb, __u16 flags);
---
> 	int (*recv_acldata)	(struct hci_conn *conn, struct sk_buff *skb,
> 								__u16 flags);
570c623,624
< 	int (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
---
> 	int (*security_cfm)	(struct hci_conn *conn, __u8 status,
> 								__u8 encrypt);
573c627,628
< static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr, __u8 type)
---
> static inline int hci_proto_connect_ind(struct hci_dev *hdev, bdaddr_t *bdaddr,
> 								__u8 type)
659c714,715
< static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
---
> static inline void hci_proto_encrypt_cfm(struct hci_conn *conn, __u8 status,
> 								__u8 encrypt)
684c740,741
< 	void (*security_cfm)	(struct hci_conn *conn, __u8 status, __u8 encrypt);
---
> 	void (*security_cfm)	(struct hci_conn *conn, __u8 status,
> 								__u8 encrypt);
710c767,768
< static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status, __u8 encrypt)
---
> static inline void hci_encrypt_cfm(struct hci_conn *conn, __u8 status,
> 								__u8 encrypt)
716a775,777
> 	if (conn->pending_sec_level > conn->sec_level)
> 		conn->sec_level = conn->pending_sec_level;
> 
741c802,803
< static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status, __u8 role)
---
> static inline void hci_role_switch_cfm(struct hci_conn *conn, __u8 status,
> 								__u8 role)
832a895,899
> void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
> 							__u8 ltk[16]);
> void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16]);
> void hci_le_ltk_neg_reply(struct hci_conn *conn);
> 




diff -r linux-3.0.36/include/net/bluetooth/hci.h linux-3.0.36-lenovo/include/net/bluetooth/hci.h
161,162c161,164
< #define SCO_ESCO_MASK  (ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
< #define EDR_ESCO_MASK  (ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
---
> #define SCO_ESCO_MASK	(ESCO_HV1 | ESCO_HV2 | ESCO_HV3)
> #define EDR_ESCO_MASK	(ESCO_2EV3 | ESCO_3EV3 | ESCO_2EV5 | ESCO_3EV5)
> #define ALL_ESCO_MASK	(SCO_ESCO_MASK | ESCO_EV3 | ESCO_EV4 | ESCO_EV5 | \
> 			EDR_ESCO_MASK)
214a217
> #define LMP_SIMUL_LE_BR	0x02
219a223,226
> #define LMP_EXTFEATURES	0x80
> 
> /* Extended LMP features */
> #define LMP_HOST_LE	0x02
257a265,268
> /* The spec doesn't define types for SMP keys */
> #define HCI_LK_SMP_LTK			0x81
> #define HCI_LK_SMP_IRK			0x82
> #define HCI_LK_SMP_CSRK			0x83
656a668,673
> #define HCI_OP_WRITE_LE_HOST_SUPPORTED	0x0c6d
> struct hci_cp_write_le_host_supported {
> 	__u8 le;
> 	__u8 simul;
> } __packed;
> 
679a697,699
> struct hci_cp_read_local_ext_features {
> 	__u8     page;
> } __packed;
713a734,739
> #define HCI_OP_LE_SET_SCAN_ENABLE	0x200c
> struct hci_cp_le_set_scan_enable {
> 	__u8     enable;
> 	__u8     filter_dup;
> } __packed;
> 
742a769,795
> #define HCI_OP_LE_START_ENC		0x2019
> struct hci_cp_le_start_enc {
> 	__le16	handle;
> 	__u8	rand[8];
> 	__le16	ediv;
> 	__u8	ltk[16];
> } __packed;
> 
> #define HCI_OP_LE_LTK_REPLY		0x201a
> struct hci_cp_le_ltk_reply {
> 	__le16	handle;
> 	__u8	ltk[16];
> } __packed;
> struct hci_rp_le_ltk_reply {
> 	__u8	status;
> 	__le16	handle;
> } __packed;
> 
> #define HCI_OP_LE_LTK_NEG_REPLY		0x201b
> struct hci_cp_le_ltk_neg_reply {
> 	__le16	handle;
> } __packed;
> struct hci_rp_le_ltk_neg_reply {
> 	__u8	status;
> 	__le16	handle;
> } __packed;
> 
1032a1086,1111
> #define HCI_EV_LE_LTK_REQ		0x05
> struct hci_ev_le_ltk_req {
> 	__le16	handle;
> 	__u8	random[8];
> 	__le16	ediv;
> } __packed;
> 
> /* Advertising report event types */
> #define ADV_IND		0x00
> #define ADV_DIRECT_IND	0x01
> #define ADV_SCAN_IND	0x02
> #define ADV_NONCONN_IND	0x03
> #define ADV_SCAN_RSP	0x04
> 
> #define ADDR_LE_DEV_PUBLIC	0x00
> #define ADDR_LE_DEV_RANDOM	0x01
> 
> #define HCI_EV_LE_ADVERTISING_REPORT	0x02
> struct hci_ev_le_advertising_info {
> 	__u8	 evt_type;
> 	__u8	 bdaddr_type;
> 	bdaddr_t bdaddr;
> 	__u8	 length;
> 	__u8	 data[0];
> } __packed;
> 
1187a1267,1269
> 	__u32    mtu;
> 	__u32    cnt;
> 	__u32    pkts;




diff -r linux-3.0.36/include/net/bluetooth/l2cap.h linux-3.0.36-lenovo/include/net/bluetooth/l2cap.h
40d39
< #define L2CAP_LOCAL_BUSY_TRIES		12
289a289,292
> 	__u8		state;
> 
> 	atomic_t	refcnt;
> 
297a301
> 	__u8		chan_type;
304a309
> 	__u8		force_active;
321,322c326,327
< 	__u8		conf_state;
< 	__u16		conn_state;
---
> 	unsigned long	conf_state;
> 	unsigned long	conn_state;
341a347
> 	struct timer_list	chan_timer;
348,349d353
< 	struct sk_buff_head	busy_q;
< 	struct work_struct	busy_work;
353a358,369
> 
> 	void		*data;
> 	struct l2cap_ops *ops;
> };
> 
> struct l2cap_ops {
> 	char		*name;
> 
> 	struct l2cap_chan	*(*new_connection) (void *data);
> 	int			(*recv) (void *data, struct sk_buff *skb);
> 	void			(*close) (void *data);
> 	void			(*state_change) (void *data, int state);
378a395,403
> 	__u8		preq[7]; /* SMP Pairing Request */
> 	__u8		prsp[7]; /* SMP Pairing Response */
> 	__u8		prnd[16]; /* SMP Pairing Random */
> 	__u8		pcnf[16]; /* SMP Pairing Confirm */
> 	__u8		tk[16]; /* SMP Temporary Key */
> 	__u8		smp_key_size;
> 
> 	struct timer_list security_timer;
> 
386a412,415
> #define L2CAP_CHAN_RAW			1
> #define L2CAP_CHAN_CONN_LESS		2
> #define L2CAP_CHAN_CONN_ORIENTED	3
> 
392a422
> 	struct sk_buff	*rx_busy_skb;
395,402c425,434
< #define L2CAP_CONF_REQ_SENT       0x01
< #define L2CAP_CONF_INPUT_DONE     0x02
< #define L2CAP_CONF_OUTPUT_DONE    0x04
< #define L2CAP_CONF_MTU_DONE       0x08
< #define L2CAP_CONF_MODE_DONE      0x10
< #define L2CAP_CONF_CONNECT_PEND   0x20
< #define L2CAP_CONF_NO_FCS_RECV    0x40
< #define L2CAP_CONF_STATE2_DEVICE  0x80
---
> enum {
> 	CONF_REQ_SENT,
> 	CONF_INPUT_DONE,
> 	CONF_OUTPUT_DONE,
> 	CONF_MTU_DONE,
> 	CONF_MODE_DONE,
> 	CONF_CONNECT_PEND,
> 	CONF_NO_FCS_RECV,
> 	CONF_STATE2_DEVICE,
> };
407,424c439,462
< #define L2CAP_CONN_SAR_SDU         0x0001
< #define L2CAP_CONN_SREJ_SENT       0x0002
< #define L2CAP_CONN_WAIT_F          0x0004
< #define L2CAP_CONN_SREJ_ACT        0x0008
< #define L2CAP_CONN_SEND_PBIT       0x0010
< #define L2CAP_CONN_REMOTE_BUSY     0x0020
< #define L2CAP_CONN_LOCAL_BUSY      0x0040
< #define L2CAP_CONN_REJ_ACT         0x0080
< #define L2CAP_CONN_SEND_FBIT       0x0100
< #define L2CAP_CONN_RNR_SENT        0x0200
< #define L2CAP_CONN_SAR_RETRY       0x0400
< 
< #define __mod_retrans_timer() mod_timer(&chan->retrans_timer, \
< 		jiffies +  msecs_to_jiffies(L2CAP_DEFAULT_RETRANS_TO));
< #define __mod_monitor_timer() mod_timer(&chan->monitor_timer, \
< 		jiffies + msecs_to_jiffies(L2CAP_DEFAULT_MONITOR_TO));
< #define __mod_ack_timer() mod_timer(&chan->ack_timer, \
< 		jiffies + msecs_to_jiffies(L2CAP_DEFAULT_ACK_TO));
---
> enum {
> 	CONN_SAR_SDU,
> 	CONN_SREJ_SENT,
> 	CONN_WAIT_F,
> 	CONN_SREJ_ACT,
> 	CONN_SEND_PBIT,
> 	CONN_REMOTE_BUSY,
> 	CONN_LOCAL_BUSY,
> 	CONN_REJ_ACT,
> 	CONN_SEND_FBIT,
> 	CONN_RNR_SENT,
> };
> 
> #define __set_chan_timer(c, t) l2cap_set_timer(c, &c->chan_timer, (t))
> #define __clear_chan_timer(c) l2cap_clear_timer(c, &c->chan_timer)
> #define __set_retrans_timer(c) l2cap_set_timer(c, &c->retrans_timer, \
> 		L2CAP_DEFAULT_RETRANS_TO);
> #define __clear_retrans_timer(c) l2cap_clear_timer(c, &c->retrans_timer)
> #define __set_monitor_timer(c) l2cap_set_timer(c, &c->monitor_timer, \
> 		L2CAP_DEFAULT_MONITOR_TO);
> #define __clear_monitor_timer(c) l2cap_clear_timer(c, &c->monitor_timer)
> #define __set_ack_timer(c) l2cap_set_timer(c, &chan->ack_timer, \
> 		L2CAP_DEFAULT_ACK_TO);
> #define __clear_ack_timer(c) l2cap_clear_timer(c, &c->ack_timer)
449d486
< void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data);
453,460d489
< struct sk_buff *l2cap_create_connless_pdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len);
< struct sk_buff *l2cap_create_basic_pdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len);
< struct sk_buff *l2cap_create_iframe_pdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len, u16 control, u16 sdulen);
< int l2cap_sar_segment_sdu(struct l2cap_chan *chan, struct msghdr *msg, size_t len);
< void l2cap_do_send(struct l2cap_chan *chan, struct sk_buff *skb);
< void l2cap_streaming_send(struct l2cap_chan *chan);
< int l2cap_ertm_send(struct l2cap_chan *chan);
< 
464,471d492
< void l2cap_sock_set_timer(struct sock *sk, long timeout);
< void l2cap_sock_clear_timer(struct sock *sk);
< void __l2cap_sock_close(struct sock *sk, int reason);
< void l2cap_sock_kill(struct sock *sk);
< void l2cap_sock_init(struct sock *sk, struct sock *parent);
< struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,
< 							int proto, gfp_t prio);
< void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err);
473c494
< void l2cap_chan_del(struct l2cap_chan *chan, int err);
---
> void l2cap_chan_close(struct l2cap_chan *chan, int reason);
475a497,498
> int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len);
> void l2cap_chan_busy(struct l2cap_chan *chan, int busy);




diff -r linux-3.0.36/include/net/bluetooth/mgmt.h linux-3.0.36-lenovo/include/net/bluetooth/mgmt.h
103a104,105
> 	u8 dlen;
> 	u8 data[0];
200a203,212
> 
> #define MGMT_OP_BLOCK_DEVICE		0x001D
> struct mgmt_cp_block_device {
> 	bdaddr_t bdaddr;
> } __packed;
> 
> #define MGMT_OP_UNBLOCK_DEVICE		0x001E
> struct mgmt_cp_unblock_device {
> 	bdaddr_t bdaddr;
> } __packed;




diff -r linux-3.0.36/include/net/bluetooth/rfcomm.h linux-3.0.36-lenovo/include/net/bluetooth/rfcomm.h
237c237,238
< int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst, u8 channel);
---
> int  rfcomm_dlc_open(struct rfcomm_dlc *d, bdaddr_t *src, bdaddr_t *dst,
> 								u8 channel);
274c275,276
< void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src, bdaddr_t *dst);
---
> void   rfcomm_session_getaddr(struct rfcomm_session *s, bdaddr_t *src,
> 								bdaddr_t *dst);
315c317,318
< int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel, struct rfcomm_dlc **d);
---
> int  rfcomm_connect_ind(struct rfcomm_session *s, u8 channel,
> 							struct rfcomm_dlc **d);




diff -r linux-3.0.36/include/net/bluetooth/sco.h linux-3.0.36-lenovo/include/net/bluetooth/sco.h
39a40
> 	__u16		sco_pkt_type;
75c76,77
< 	__u32		flags;
---
> 	__u16		pkt_type;
> 




diff -r linux-3.0.36/include/net/bluetooth/smp.h linux-3.0.36-lenovo/include/net/bluetooth/smp.h
0a1,22
> /*
>    BlueZ - Bluetooth protocol stack for Linux
>    Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).
> 
>    This program is free software; you can redistribute it and/or modify
>    it under the terms of the GNU General Public License version 2 as
>    published by the Free Software Foundation;
> 
>    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
>    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
>    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
>    IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
>    CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
>    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
>    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
>    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
> 
>    ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
>    COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
>    SOFTWARE IS DISCLAIMED.
> */
> 
18a41,57
> #define SMP_IO_DISPLAY_ONLY	0x00
> #define SMP_IO_DISPLAY_YESNO	0x01
> #define SMP_IO_KEYBOARD_ONLY	0x02
> #define SMP_IO_NO_INPUT_OUTPUT	0x03
> #define SMP_IO_KEYBOARD_DISPLAY	0x04
> 
> #define SMP_OOB_NOT_PRESENT	0x00
> #define SMP_OOB_PRESENT		0x01
> 
> #define SMP_DIST_ENC_KEY	0x01
> #define SMP_DIST_ID_KEY		0x02
> #define SMP_DIST_SIGN		0x04
> 
> #define SMP_AUTH_NONE		0x00
> #define SMP_AUTH_BONDING	0x01
> #define SMP_AUTH_MITM		0x04
> 
74a114,121
> 
> #define SMP_MIN_ENC_KEY_SIZE		7
> #define SMP_MAX_ENC_KEY_SIZE		16
> 
> /* SMP Commands */
> int smp_conn_security(struct l2cap_conn *conn, __u8 sec_level);
> int smp_sig_channel(struct l2cap_conn *conn, struct sk_buff *skb);
> int smp_distribute_keys(struct l2cap_conn *conn, __u8 force);




diff -r linux-3.0.36/include/net/cfg80211.h linux-3.0.36-lenovo/include/net/cfg80211.h
428a429
>  * @STATION_INFO_ASSOC_REQ_IES: @assoc_req_ies filled
447c448,449
< 	STATION_INFO_CONNECTED_TIME	= 1<<16
---
> 	STATION_INFO_CONNECTED_TIME	= 1<<16,
> 	STATION_INFO_ASSOC_REQ_IES	= 1<<17
538a541,545
>  * @assoc_req_ies: IEs from (Re)Association Request.
>  *	This is used only when in AP mode with drivers that do not use
>  *	user space MLME/SME implementation. The information is provided for
>  *	the cfg80211_new_sta() calls to notify user space of the IEs.
>  * @assoc_req_ies_len: Length of assoc_req_ies buffer in octets.
560a568,575
> 
> 	const u8 *assoc_req_ies;
> 	size_t assoc_req_ies_len;
> 
> 	/*
> 	 * Note: Add a new enum station_info_flags value for each new field and
> 	 * use it to check which fields are initialized.
> 	 */
800a816,824
>  * struct cfg80211_match_set - sets of attributes to match
>  *
>  * @ssid: SSID to be matched
>  */
> struct cfg80211_match_set {
> 	struct cfg80211_ssid ssid;
> };
> 
> /**
808a833,837
>  * @match_sets: sets of parameters to be matched for a scan result
>  * 	entry to be considered valid and to be passed to the host
>  * 	(others are filtered out).
>  *	If ommited, all results are passed.
>  * @n_match_sets: number of match sets
819a849,850
> 	struct cfg80211_match_set *match_sets;
> 	int n_match_sets;
1148a1180,1183
>  * @gtk_rekey_failure: wake up on GTK rekey failure
>  * @eap_identity_req: wake up on EAP identity request packet
>  * @four_way_handshake: wake up on 4-way handshake
>  * @rfkill_release: wake up when rfkill is released
1151c1186,1188
< 	bool any, disconnect, magic_pkt;
---
> 	bool any, disconnect, magic_pkt, gtk_rekey_failure,
> 	     eap_identity_req, four_way_handshake,
> 	     rfkill_release;
1156a1194,1205
>  * struct cfg80211_gtk_rekey_data - rekey data
>  * @kek: key encryption key
>  * @kck: key confirmation key
>  * @replay_ctr: replay counter
>  */
> struct cfg80211_gtk_rekey_data {
> 	u8 kek[NL80211_KEK_LEN];
> 	u8 kck[NL80211_KCK_LEN];
> 	u8 replay_ctr[NL80211_REPLAY_CTR_LEN];
> };
> 
> /**
1199a1249,1250
>  * @set_rekey_data: give the data necessary for GTK rekeying to the driver
>  *
1316a1368,1373
>  *
>  * @tdls_mgmt: Transmit a TDLS management frame.
>  * @tdls_oper: Perform a high-level TDLS operation (e.g. TDLS link setup).
>  *
>  * @probe_client: probe an associated client, must return a cookie that it
>  *	later passes to cfg80211_probe_status().
1492a1550,1561
> 
> 	int	(*set_rekey_data)(struct wiphy *wiphy, struct net_device *dev,
> 				  struct cfg80211_gtk_rekey_data *data);
> 
> 	int	(*tdls_mgmt)(struct wiphy *wiphy, struct net_device *dev,
> 			     u8 *peer, u8 action_code,  u8 dialog_token,
> 			     u16 status_code, const u8 *buf, size_t len);
> 	int	(*tdls_oper)(struct wiphy *wiphy, struct net_device *dev,
> 			     u8 *peer, enum nl80211_tdls_operation oper);
> 
> 	int	(*probe_client)(struct wiphy *wiphy, struct net_device *dev,
> 				const u8 *peer, u64 *cookie);
1541a1611,1623
>  * @WIPHY_FLAG_SUPPORTS_FW_ROAM: The device supports roaming feature in the
>  *	firmware.
>  * @WIPHY_FLAG_AP_UAPSD: The device supports uapsd on AP.
>  * @WIPHY_FLAG_SUPPORTS_TDLS: The device supports TDLS (802.11z) operation.
>  * @WIPHY_FLAG_TDLS_EXTERNAL_SETUP: The device does not handle TDLS (802.11z)
>  *	link setup/discovery operations internally. Setup, discovery and
>  *	teardown packets should be sent through the @NL80211_CMD_TDLS_MGMT
>  *	command. When this flag is not set, @NL80211_CMD_TDLS_OPER should be
>  *	used for asking the driver/firmware to perform a TDLS operation.
>  * @WIPHY_FLAG_HAVE_AP_SME: device integrates AP SME
>  * @WIPHY_FLAG_REPORTS_OBSS: the device will report beacons from other BSSes
>  *	when there are virtual interfaces in AP mode by calling
>  *	cfg80211_report_obss_beacon().
1555a1638,1643
> 	WIPHY_FLAG_SUPPORTS_FW_ROAM		= BIT(13),
> 	WIPHY_FLAG_AP_UAPSD			= BIT(14),
> 	WIPHY_FLAG_SUPPORTS_TDLS		= BIT(15),
> 	WIPHY_FLAG_TDLS_EXTERNAL_SETUP		= BIT(16),
> 	WIPHY_FLAG_HAVE_AP_SME			= BIT(17),
> 	WIPHY_FLAG_REPORTS_OBSS			= BIT(18),
1649a1738,1742
>  * @WIPHY_WOWLAN_SUPPORTS_GTK_REKEY: supports GTK rekeying while asleep
>  * @WIPHY_WOWLAN_GTK_REKEY_FAILURE: supports wakeup on GTK rekey failure
>  * @WIPHY_WOWLAN_EAP_IDENTITY_REQ: supports wakeup on EAP identity request
>  * @WIPHY_WOWLAN_4WAY_HANDSHAKE: supports wakeup on 4-way handshake failure
>  * @WIPHY_WOWLAN_RFKILL_RELEASE: supports wakeup on RF-kill release
1652,1654c1745,1752
< 	WIPHY_WOWLAN_ANY	= BIT(0),
< 	WIPHY_WOWLAN_MAGIC_PKT	= BIT(1),
< 	WIPHY_WOWLAN_DISCONNECT	= BIT(2),
---
> 	WIPHY_WOWLAN_ANY		= BIT(0),
> 	WIPHY_WOWLAN_MAGIC_PKT		= BIT(1),
> 	WIPHY_WOWLAN_DISCONNECT		= BIT(2),
> 	WIPHY_WOWLAN_SUPPORTS_GTK_REKEY	= BIT(3),
> 	WIPHY_WOWLAN_GTK_REKEY_FAILURE	= BIT(4),
> 	WIPHY_WOWLAN_EAP_IDENTITY_REQ	= BIT(5),
> 	WIPHY_WOWLAN_4WAY_HANDSHAKE	= BIT(6),
> 	WIPHY_WOWLAN_RFKILL_RELEASE	= BIT(7),
1718a1817,1821
>  * @max_sched_scan_ssids: maximum number of SSIDs the device can scan
>  *	for in any given scheduled scan
>  * @max_match_sets: maximum number of match sets the device can handle
>  *	when performing a scheduled scan, 0 if filtering is not
>  *	supported.
1721a1825,1826
>  * @max_sched_scan_ie_len: same as max_scan_ie_len, but for scheduled
>  *	scans
1745a1851,1852
>  *
>  * @ap_sme_capa: AP SME capabilities, flags from &enum nl80211_ap_sme_features.
1768a1876,1877
> 	u32 ap_sme_capa;
> 
1772a1882,1883
> 	u8 max_sched_scan_ssids;
> 	u8 max_match_sets;
1773a1885
> 	u16 max_sched_scan_ie_len;
2015a2128,2129
> 	u32 ap_unexpected_nlpid;
> 
3023a3138,3199
> 
> /**
>  * cfg80211_gtk_rekey_notify - notify userspace about driver rekeying
>  * @dev: network device
>  * @bssid: BSSID of AP (to avoid races)
>  * @replay_ctr: new replay counter
>  */
> void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
> 			       const u8 *replay_ctr, gfp_t gfp);
> 
> /**
>  * cfg80211_pmksa_candidate_notify - notify about PMKSA caching candidate
>  * @dev: network device
>  * @index: candidate index (the smaller the index, the higher the priority)
>  * @bssid: BSSID of AP
>  * @preauth: Whether AP advertises support for RSN pre-authentication
>  * @gfp: allocation flags
>  */
> void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
> 				     const u8 *bssid, bool preauth, gfp_t gfp);
> 
> /**
>  * cfg80211_rx_spurious_frame - inform userspace about a spurious frame
>  * @dev: The device the frame matched to
>  * @addr: the transmitter address
>  * @gfp: context flags
>  *
>  * This function is used in AP mode (only!) to inform userspace that
>  * a spurious class 3 frame was received, to be able to deauth the
>  * sender.
>  * Returns %true if the frame was passed to userspace (or this failed
>  * for a reason other than not having a subscription.)
>  */
> bool cfg80211_rx_spurious_frame(struct net_device *dev,
> 				const u8 *addr, gfp_t gfp);
> 
> /**
>  * cfg80211_probe_status - notify userspace about probe status
>  * @dev: the device the probe was sent on
>  * @addr: the address of the peer
>  * @cookie: the cookie filled in @probe_client previously
>  * @acked: indicates whether probe was acked or not
>  * @gfp: allocation flags
>  */
> void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
> 			   u64 cookie, bool acked, gfp_t gfp);
> 
> /**
>  * cfg80211_report_obss_beacon - report beacon from other APs
>  * @wiphy: The wiphy that received the beacon
>  * @frame: the frame
>  * @len: length of the frame
>  * @freq: frequency the frame was received on
>  * @gfp: allocation flags
>  *
>  * Use this function to report to userspace when a beacon was
>  * received. It is not useful to call this when there is no
>  * netdev that is in AP/GO mode.
>  */
> void cfg80211_report_obss_beacon(struct wiphy *wiphy,
> 				 const u8 *frame, size_t len,
> 				 int freq, gfp_t gfp);




diff -r linux-3.0.36/include/net/cipso_ipv4.h linux-3.0.36-lenovo/include/net/cipso_ipv4.h
44a45
> #include <asm/unaligned.h>
288c289,315
< 	return -ENOSYS;
---
> 	unsigned char *opt = *option;
> 	unsigned char err_offset = 0;
> 	u8 opt_len = opt[1];
> 	u8 opt_iter;
> 
> 	if (opt_len < 8) {
> 		err_offset = 1;
> 		goto out;
> 	}
> 
> 	if (get_unaligned_be32(&opt[2]) == 0) {
> 		err_offset = 2;
> 		goto out;
> 	}
> 
> 	for (opt_iter = 6; opt_iter < opt_len;) {
> 		if (opt[opt_iter + 1] > (opt_len - opt_iter)) {
> 			err_offset = opt_iter + 1;
> 			goto out;
> 		}
> 		opt_iter += opt[opt_iter + 1];
> 	}
> 
> out:
> 	*option = opt + err_offset;
> 	return err_offset;
> 




diff -r linux-3.0.36/include/net/if_inet6.h linux-3.0.36-lenovo/include/net/if_inet6.h
43a44
> 	/* In seconds, relative to tstamp. Expiry is at tstamp + HZ * lft. */




diff -r linux-3.0.36/include/net/ip_vs.h linux-3.0.36-lenovo/include/net/ip_vs.h
1364c1364
< 		nf_reset(skb);
---
> 		nf_conntrack_put(skb->nfct);




diff -r linux-3.0.36/include/net/netfilter/nf_conntrack_ecache.h linux-3.0.36-lenovo/include/net/netfilter/nf_conntrack_ecache.h
20a21
> 	struct timer_list timeout;




diff -r linux-3.0.36/include/net/rtnetlink.h linux-3.0.36-lenovo/include/net/rtnetlink.h
8a9
> typedef u16 (*rtnl_calcit_func)(struct sk_buff *, struct nlmsghdr *);
11c12,13
< 				rtnl_doit_func, rtnl_dumpit_func);
---
> 				rtnl_doit_func, rtnl_dumpit_func,
> 				rtnl_calcit_func);
13c15,16
< 			      rtnl_doit_func, rtnl_dumpit_func);
---
> 			      rtnl_doit_func, rtnl_dumpit_func,
> 			      rtnl_calcit_func);




diff -r linux-3.0.36/include/net/sch_generic.h linux-3.0.36-lenovo/include/net/sch_generic.h
222c222,224
< 	unsigned char		data[24];
---
> 	u16			bond_queue_mapping;
> 	u16			_pad;
> 	unsigned char		data[20];
228c230,231
< 	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(unsigned int) + sz);
---
> 
> 	BUILD_BUG_ON(sizeof(skb->cb) < offsetof(struct qdisc_skb_cb, data) + sz);




diff -r linux-3.0.36/include/net/sock.h linux-3.0.36-lenovo/include/net/sock.h
196a197
>   *	@sk_gso_max_segs: Maximum number of GSO segments
312a314
> 	u16			sk_gso_max_segs;




diff -r linux-3.0.36/include/net/tcp.h linux-3.0.36-lenovo/include/net/tcp.h
248a249
> extern int sysctl_tcp_challenge_ack_limit;
1405a1407,1408
> 
> extern int tcp_nuke_addr(struct net *net, struct sockaddr *addr);




diff -r linux-3.0.36/include/net/xfrm.h linux-3.0.36-lenovo/include/net/xfrm.h
271a272,274
> 	int	(*recheck)(struct xfrm_state *x,
> 			   struct sk_buff *skb,
> 			   __be32 net_seq);




diff -r linux-3.0.36/include/sound/asound.h linux-3.0.36-lenovo/include/sound/asound.h
489a490
> #define SNDRV_PCM_IOCTL_VOL		_IOW('A', 0x62, int)




diff -r linux-3.0.36/include/sound/core.h linux-3.0.36-lenovo/include/sound/core.h
134a135
> 	atomic_t refcount;		/* refcount for disconnection */
191a193
> 	struct snd_card *card_ptr;	/* assigned card instance */
297a300
> void snd_card_unref(struct snd_card *card);




diff -r linux-3.0.36/include/sound/pcm.h linux-3.0.36-lenovo/include/sound/pcm.h
109a110,111
> //add by qiuen for volume
> #define SNDRV_PCM_TRIGGER_VOLUME        7




diff -r linux-3.0.36/include/sound/soc-dai.h linux-3.0.36-lenovo/include/sound/soc-dai.h
174a175,178
> 
> 	/* set volume,add by qiuen*/
> 	void (*set_volume)(unsigned char mode,unsigned char volume);
> 




diff -r linux-3.0.36/include/sound/soc.h linux-3.0.36-lenovo/include/sound/soc.h
260a261,265
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
> int snd_soc_incall_status(int read_or_write, int status);
> #endif	
> 
> 
498a504,505
>     /* set volume,add by qiuen*/
> 	void (*set_volume)(unsigned char mode,unsigned char volume);
Only in linux-3.0.36-lenovo/include/trace/events: cpufreq_interactive.h




diff -r linux-3.0.36/include/trace/events/kmem.h linux-3.0.36-lenovo/include/trace/events/kmem.h
217c217
< 		page_to_pfn(__entry->page),
---
> 		__entry->page ? page_to_pfn(__entry->page) : 0,
243c243
< 		page_to_pfn(__entry->page),
---
> 		__entry->page ? page_to_pfn(__entry->page) : 0,
Only in linux-3.0.36-lenovo/include/trace/events: random.h
Only in linux-3.0.36-lenovo/include/trace/events: sync.h




diff -r linux-3.0.36/include/trace/events/vmscan.h linux-3.0.36-lenovo/include/trace/events/vmscan.h
181a182,258
> TRACE_EVENT(mm_shrink_slab_start,
> 	TP_PROTO(struct shrinker *shr, struct shrink_control *sc,
> 		long nr_objects_to_shrink, unsigned long pgs_scanned,
> 		unsigned long lru_pgs, unsigned long cache_items,
> 		unsigned long long delta, unsigned long total_scan),
> 
> 	TP_ARGS(shr, sc, nr_objects_to_shrink, pgs_scanned, lru_pgs,
> 		cache_items, delta, total_scan),
> 
> 	TP_STRUCT__entry(
> 		__field(struct shrinker *, shr)
> 		__field(void *, shrink)
> 		__field(long, nr_objects_to_shrink)
> 		__field(gfp_t, gfp_flags)
> 		__field(unsigned long, pgs_scanned)
> 		__field(unsigned long, lru_pgs)
> 		__field(unsigned long, cache_items)
> 		__field(unsigned long long, delta)
> 		__field(unsigned long, total_scan)
> 	),
> 
> 	TP_fast_assign(
> 		__entry->shr = shr;
> 		__entry->shrink = shr->shrink;
> 		__entry->nr_objects_to_shrink = nr_objects_to_shrink;
> 		__entry->gfp_flags = sc->gfp_mask;
> 		__entry->pgs_scanned = pgs_scanned;
> 		__entry->lru_pgs = lru_pgs;
> 		__entry->cache_items = cache_items;
> 		__entry->delta = delta;
> 		__entry->total_scan = total_scan;
> 	),
> 
> 	TP_printk("%pF %p: objects to shrink %ld gfp_flags %s pgs_scanned %ld lru_pgs %ld cache items %ld delta %lld total_scan %ld",
> 		__entry->shrink,
> 		__entry->shr,
> 		__entry->nr_objects_to_shrink,
> 		show_gfp_flags(__entry->gfp_flags),
> 		__entry->pgs_scanned,
> 		__entry->lru_pgs,
> 		__entry->cache_items,
> 		__entry->delta,
> 		__entry->total_scan)
> );
> 
> TRACE_EVENT(mm_shrink_slab_end,
> 	TP_PROTO(struct shrinker *shr, int shrinker_retval,
> 		long unused_scan_cnt, long new_scan_cnt),
> 
> 	TP_ARGS(shr, shrinker_retval, unused_scan_cnt, new_scan_cnt),
> 
> 	TP_STRUCT__entry(
> 		__field(struct shrinker *, shr)
> 		__field(void *, shrink)
> 		__field(long, unused_scan)
> 		__field(long, new_scan)
> 		__field(int, retval)
> 		__field(long, total_scan)
> 	),
> 
> 	TP_fast_assign(
> 		__entry->shr = shr;
> 		__entry->shrink = shr->shrink;
> 		__entry->unused_scan = unused_scan_cnt;
> 		__entry->new_scan = new_scan_cnt;
> 		__entry->retval = shrinker_retval;
> 		__entry->total_scan = new_scan_cnt - unused_scan_cnt;
> 	),
> 
> 	TP_printk("%pF %p: unused scan count %ld new scan count %ld total_scan %ld last shrinker return val %d",
> 		__entry->shrink,
> 		__entry->shr,
> 		__entry->unused_scan,
> 		__entry->new_scan,
> 		__entry->total_scan,
> 		__entry->retval)
> );
192c269
< 		int isolate_mode),
---
> 		isolate_mode_t isolate_mode),
204c281
< 		__field(int, isolate_mode)
---
> 		__field(isolate_mode_t, isolate_mode)
238c315
< 		int isolate_mode),
---
> 		isolate_mode_t isolate_mode),
253c330
< 		int isolate_mode),
---
> 		isolate_mode_t isolate_mode),




diff -r linux-3.0.36/init/initramfs.c linux-3.0.36-lenovo/init/initramfs.c
463a464,465
> 		else
> 			break;




diff -r linux-3.0.36/init/Kconfig linux-3.0.36-lenovo/init/Kconfig
134a135
> 	default KERNEL_LZO if ARCH_RK29
917a919,924
> config PANIC_TIMEOUT
> 	int "Default panic timeout"
> 	default 0
> 	help
> 	  Set default panic timeout.
> 
1082a1090,1098
> 
> config ASHMEM
> 	bool "Enable the Anonymous Shared Memory Subsystem"
> 	default n
> 	depends on SHMEM || TINY_SHMEM
> 	help
> 	  The ashmem subsystem is a new shared memory allocator, similar to
> 	  POSIX SHM but with different behavior and sporting a simpler
> 	  file-based API.




diff -r linux-3.0.36/kernel/async.c linux-3.0.36-lenovo/kernel/async.c
89a90,96
> 	if (!running) { /* just check the entry count */
> 		if (atomic_read(&entry_count))
> 			return 0; /* smaller than any cookie */
> 		else
> 			return next_cookie;
> 	}
> 
239,241c246
< 	do {
< 		async_synchronize_cookie(next_cookie);
< 	} while (!list_empty(&async_running) || !list_empty(&async_pending));
---
> 	async_synchronize_cookie_domain(next_cookie, NULL);
261c266
<  * @running: running list to synchronize on
---
>  * @running: running list to synchronize on, NULL indicates all lists




diff -r linux-3.0.36/kernel/audit_tree.c linux-3.0.36-lenovo/kernel/audit_tree.c
259d258
< 		fsnotify_put_mark(entry);
268c267
< 		free_chunk(new);
---
> 		fsnotify_put_mark(&new->mark);
302d300
< 	fsnotify_put_mark(entry);
331c329
< 		free_chunk(chunk);
---
> 		fsnotify_put_mark(entry);
340a339
> 		fsnotify_get_mark(entry);
405c404
< 		free_chunk(chunk);
---
> 		fsnotify_put_mark(chunk_entry);
420a420
> 		fsnotify_get_mark(chunk_entry);
454d453
< 	fsnotify_put_mark(old_entry); /* and kill it */




diff -r linux-3.0.36/kernel/cgroup.c linux-3.0.36-lenovo/kernel/cgroup.c
270a271,297
> /*
>  * A queue for waiters to do rmdir() cgroup. A tasks will sleep when
>  * cgroup->count == 0 && list_empty(&cgroup->children) && subsys has some
>  * reference to css->refcnt. In general, this refcnt is expected to goes down
>  * to zero, soon.
>  *
>  * CGRP_WAIT_ON_RMDIR flag is set under cgroup's inode->i_mutex;
>  */
> DECLARE_WAIT_QUEUE_HEAD(cgroup_rmdir_waitq);
> 
> static void cgroup_wakeup_rmdir_waiter(struct cgroup *cgrp)
> {
> 	if (unlikely(test_and_clear_bit(CGRP_WAIT_ON_RMDIR, &cgrp->flags)))
> 		wake_up_all(&cgroup_rmdir_waitq);
> }
> 
> void cgroup_exclude_rmdir(struct cgroup_subsys_state *css)
> {
> 	css_get(css);
> }
> 
> void cgroup_release_and_wakeup_rmdir(struct cgroup_subsys_state *css)
> {
> 	cgroup_wakeup_rmdir_waiter(css->cgroup);
> 	css_put(css);
> }
> 
330,336c357
< /* We don't maintain the lists running through each css_set to its
<  * task until after the first call to cgroup_iter_start(). This
<  * reduces the fork()/exit() overhead for people who have cgroups
<  * compiled into their kernel but not actually in use */
< static int use_task_css_set_links __read_mostly;
< 
< static void __put_css_set(struct css_set *cg, int taskexit)
---
> static void free_css_set_work(struct work_struct *work)
337a359
> 	struct css_set *cg = container_of(work, struct css_set, work);
340,355d361
< 	/*
< 	 * Ensure that the refcount doesn't hit zero while any readers
< 	 * can see it. Similar to atomic_dec_and_lock(), but for an
< 	 * rwlock
< 	 */
< 	if (atomic_add_unless(&cg->refcount, -1, 1))
< 		return;
< 	write_lock(&css_set_lock);
< 	if (!atomic_dec_and_test(&cg->refcount)) {
< 		write_unlock(&css_set_lock);
< 		return;
< 	}
< 
< 	/* This css_set is dead. unlink it and release cgroup refcounts */
< 	hlist_del(&cg->hlist);
< 	css_set_count--;
356a363
> 	write_lock(&css_set_lock);
362,365c369
< 		if (atomic_dec_and_test(&cgrp->count) &&
< 		    notify_on_release(cgrp)) {
< 			if (taskexit)
< 				set_bit(CGRP_RELEASABLE, &cgrp->flags);
---
> 		if (atomic_dec_and_test(&cgrp->count)) {
366a371
> 			cgroup_wakeup_rmdir_waiter(cgrp);
368d372
< 
371d374
< 
373c376,385
< 	kfree_rcu(cg, rcu_head);
---
> 
> 	kfree(cg);
> }
> 
> static void free_css_set_rcu(struct rcu_head *obj)
> {
> 	struct css_set *cg = container_of(obj, struct css_set, rcu_head);
> 
> 	INIT_WORK(&cg->work, free_css_set_work);
> 	schedule_work(&cg->work);
375a388,393
> /* We don't maintain the lists running through each css_set to its
>  * task until after the first call to cgroup_iter_start(). This
>  * reduces the fork()/exit() overhead for people who have cgroups
>  * compiled into their kernel but not actually in use */
> static int use_task_css_set_links __read_mostly;
> 
384c402
< static inline void put_css_set(struct css_set *cg)
---
> static void put_css_set(struct css_set *cg)
386,387c404,415
< 	__put_css_set(cg, 0);
< }
---
> 	/*
> 	 * Ensure that the refcount doesn't hit zero while any readers
> 	 * can see it. Similar to atomic_dec_and_lock(), but for an
> 	 * rwlock
> 	 */
> 	if (atomic_add_unless(&cg->refcount, -1, 1))
> 		return;
> 	write_lock(&css_set_lock);
> 	if (!atomic_dec_and_test(&cg->refcount)) {
> 		write_unlock(&css_set_lock);
> 		return;
> 	}
389,391c417,421
< static inline void put_css_set_taskexit(struct css_set *cg)
< {
< 	__put_css_set(cg, 1);
---
> 	hlist_del(&cg->hlist);
> 	css_set_count--;
> 
> 	write_unlock(&css_set_lock);
> 	call_rcu(&cg->rcu_head, free_css_set_rcu);
723c753
<  * task->cgroup without the expense of grabbing a system global
---
>  * task->cgroups without the expense of grabbing a system global
725c755
<  * in cgroup_attach_task(), modifying a task'ss cgroup pointer we use
---
>  * in cgroup_attach_task(), modifying a task's cgroups pointer we use
915,941d944
<  * A queue for waiters to do rmdir() cgroup. A tasks will sleep when
<  * cgroup->count == 0 && list_empty(&cgroup->children) && subsys has some
<  * reference to css->refcnt. In general, this refcnt is expected to goes down
<  * to zero, soon.
<  *
<  * CGRP_WAIT_ON_RMDIR flag is set under cgroup's inode->i_mutex;
<  */
< DECLARE_WAIT_QUEUE_HEAD(cgroup_rmdir_waitq);
< 
< static void cgroup_wakeup_rmdir_waiter(struct cgroup *cgrp)
< {
< 	if (unlikely(test_and_clear_bit(CGRP_WAIT_ON_RMDIR, &cgrp->flags)))
< 		wake_up_all(&cgroup_rmdir_waitq);
< }
< 
< void cgroup_exclude_rmdir(struct cgroup_subsys_state *css)
< {
< 	css_get(css);
< }
< 
< void cgroup_release_and_wakeup_rmdir(struct cgroup_subsys_state *css)
< {
< 	cgroup_wakeup_rmdir_waiter(css->cgroup);
< 	css_put(css);
< }
< 
< /*
1803,1804d1805
< 	put_css_set(oldcg);
< 
1805a1807
> 	put_css_set(oldcg);
1822a1825
> 	struct css_set *cg;
1851a1855,1859
> 	task_lock(tsk);
> 	cg = tsk->cgroups;
> 	get_css_set(cg);
> 	task_unlock(tsk);
> 
1864,1865c1872,1874
< 
< 	synchronize_rcu();
---
> 	set_bit(CGRP_RELEASABLE, &cgrp->flags);
> 	/* put_css_set will not destroy cg until after an RCU grace period */
> 	put_css_set(cg);
2186a2196,2213
> static int cgroup_allow_attach(struct cgroup *cgrp, struct task_struct *tsk)
> {
> 	struct cgroup_subsys *ss;
> 	int ret;
> 
> 	for_each_subsys(cgrp->root, ss) {
> 		if (ss->allow_attach) {
> 			ret = ss->allow_attach(cgrp, tsk);
> 			if (ret)
> 				return ret;
> 		} else {
> 			return -EACCES;
> 		}
> 	}
> 
> 	return 0;
> }
> 
2232,2234c2259,2268
< 			rcu_read_unlock();
< 			cgroup_unlock();
< 			return -EACCES;
---
> 			/*
> 			 * if the default permission check fails, give each
> 			 * cgroup a chance to extend the permission check
> 			 */
> 			ret = cgroup_allow_attach(cgrp, tsk);
> 			if (ret) {
> 				rcu_read_unlock();
> 				cgroup_unlock();
> 				return ret;
> 			}
2634d2667
< 		dget(dentry);
2636d2668
< 	dput(dentry);
3807a3840,3841
> 	set_bit(CGRP_RELEASABLE, &parent->flags);
> 
3938a3973,3987
> /* checks if all of the css_sets attached to a cgroup have a refcount of 0.
>  * Must be called with css_set_lock held */
> static int cgroup_css_sets_empty(struct cgroup *cgrp)
> {
> 	struct cg_cgroup_link *link;
> 
> 	list_for_each_entry(link, &cgrp->css_sets, cgrp_link_list) {
> 		struct css_set *cg = link->cg;
> 		if (atomic_read(&cg->refcount) > 0)
> 			return 0;
> 	}
> 
> 	return 1;
> }
> 
3951c4000
< 	if (atomic_read(&cgrp->count) != 0) {
---
> 	if (!cgroup_css_sets_empty(cgrp)) {
3984c4033
< 	if (atomic_read(&cgrp->count) || !list_empty(&cgrp->children)) {
---
> 	if (!cgroup_css_sets_empty(cgrp) || !list_empty(&cgrp->children)) {
4024d4072
< 	set_bit(CGRP_RELEASABLE, &parent->flags);
4624c4672
< 		put_css_set_taskexit(cg);
---
> 		put_css_set(cg);
4677a4726,4733
> void __css_get(struct cgroup_subsys_state *css, int count)
> {
> 	atomic_add(count, &css->refcnt);
> 	set_bit(CGRP_RELEASABLE, &css->cgroup->flags);
> }
> EXPORT_SYMBOL_GPL(__css_get);
> 
> /* Caller must verify that the css is not for root cgroup */
4685,4688c4741
< 		if (notify_on_release(cgrp)) {
< 			set_bit(CGRP_RELEASABLE, &cgrp->flags);
< 			check_for_release(cgrp);
< 		}
---
> 		check_for_release(cgrp);




diff -r linux-3.0.36/kernel/cpu.c linux-3.0.36-lenovo/kernel/cpu.c
670a671,690
> 
> static ATOMIC_NOTIFIER_HEAD(idle_notifier);
> 
> void idle_notifier_register(struct notifier_block *n)
> {
> 	atomic_notifier_chain_register(&idle_notifier, n);
> }
> EXPORT_SYMBOL_GPL(idle_notifier_register);
> 
> void idle_notifier_unregister(struct notifier_block *n)
> {
> 	atomic_notifier_chain_unregister(&idle_notifier, n);
> }
> EXPORT_SYMBOL_GPL(idle_notifier_unregister);
> 
> void idle_notifier_call_chain(unsigned long val)
> {
> 	atomic_notifier_call_chain(&idle_notifier, val, NULL);
> }
> EXPORT_SYMBOL_GPL(idle_notifier_call_chain);
Only in linux-3.0.36-lenovo/kernel: cpu_pm.c




diff -r linux-3.0.36/kernel/cpuset.c linux-3.0.36-lenovo/kernel/cpuset.c
125a126,138
> #ifdef CONFIG_NUMA
> static inline bool task_has_mempolicy(struct task_struct *task)
> {
> 	return task->mempolicy;
> }
> #else
> static inline bool task_has_mempolicy(struct task_struct *task)
> {
> 	return false;
> }
> #endif
> 
> 
952c965,966
< repeat:
---
> 	bool need_loop;
> 
963,966d976
< 	nodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);
< 	mpol_rebind_task(tsk, newmems, MPOL_REBIND_STEP1);
< 
< 
968,977c978,981
< 	 * ensure checking ->mems_allowed_change_disable after setting all new
< 	 * allowed nodes.
< 	 *
< 	 * the read-side task can see an nodemask with new allowed nodes and
< 	 * old allowed nodes. and if it allocates page when cpuset clears newly
< 	 * disallowed ones continuous, it can see the new allowed bits.
< 	 *
< 	 * And if setting all new allowed nodes is after the checking, setting
< 	 * all new allowed nodes and clearing newly disallowed ones will be done
< 	 * continuous, and the read-side task may find no node to alloc page.
---
> 	 * Determine if a loop is necessary if another thread is doing
> 	 * get_mems_allowed().  If at least one node remains unchanged and
> 	 * tsk does not have a mempolicy, then an empty nodemask will not be
> 	 * possible when mems_allowed is larger than a word.
979c983,984
< 	smp_mb();
---
> 	need_loop = task_has_mempolicy(tsk) ||
> 			!nodes_intersects(*newmems, tsk->mems_allowed);
981,990c986,987
< 	/*
< 	 * Allocation of memory is very fast, we needn't sleep when waiting
< 	 * for the read-side.
< 	 */
< 	while (ACCESS_ONCE(tsk->mems_allowed_change_disable)) {
< 		task_unlock(tsk);
< 		if (!task_curr(tsk))
< 			yield();
< 		goto repeat;
< 	}
---
> 	if (need_loop)
> 		write_seqcount_begin(&tsk->mems_allowed_seq);
992,999c989,990
< 	/*
< 	 * ensure checking ->mems_allowed_change_disable before clearing all new
< 	 * disallowed nodes.
< 	 *
< 	 * if clearing newly disallowed bits before the checking, the read-side
< 	 * task may find no node to alloc page.
< 	 */
< 	smp_mb();
---
> 	nodes_or(tsk->mems_allowed, tsk->mems_allowed, *newmems);
> 	mpol_rebind_task(tsk, newmems, MPOL_REBIND_STEP1);
1002a994,997
> 
> 	if (need_loop)
> 		write_seqcount_end(&tsk->mems_allowed_seq);
> 
2086a2082,2084
>  *
>  * The only exception to this is suspend/resume, where we don't
>  * modify cpusets at all.




diff -r linux-3.0.36/kernel/events/core.c linux-3.0.36-lenovo/kernel/events/core.c
2972c2972
< static int perf_release(struct inode *inode, struct file *file)
---
> static void put_event(struct perf_event *event)
2974d2973
< 	struct perf_event *event = file->private_data;
2977c2976,2977
< 	file->private_data = NULL;
---
> 	if (!atomic_long_dec_and_test(&event->refcount))
> 		return;
3012c3012,3018
< 	return perf_event_release_kernel(event);
---
> 	perf_event_release_kernel(event);
> }
> 
> static int perf_release(struct inode *inode, struct file *file)
> {
> 	put_event(file->private_data);
> 	return 0;
3244c3250
< static struct perf_event *perf_fget_light(int fd, int *fput_needed)
---
> static struct file *perf_fget_light(int fd, int *fput_needed)
3258c3264
< 	return file->private_data;
---
> 	return file;
3289a3296
> 		struct file *output_file = NULL;
3295,3297c3302,3305
< 			output_event = perf_fget_light(arg, &fput_needed);
< 			if (IS_ERR(output_event))
< 				return PTR_ERR(output_event);
---
> 			output_file = perf_fget_light(arg, &fput_needed);
> 			if (IS_ERR(output_file))
> 				return PTR_ERR(output_file);
> 			output_event = output_file->private_data;
3302c3310
< 			fput_light(output_event->filp, fput_needed);
---
> 			fput_light(output_file, fput_needed);
6183a6192
> 	atomic_long_set(&event->refcount, 1);
6458,6460c6467,6469
< 		group_leader = perf_fget_light(group_fd, &fput_needed);
< 		if (IS_ERR(group_leader)) {
< 			err = PTR_ERR(group_leader);
---
> 		group_file = perf_fget_light(group_fd, &fput_needed);
> 		if (IS_ERR(group_file)) {
> 			err = PTR_ERR(group_file);
6463c6472
< 		group_file = group_leader->filp;
---
> 		group_leader = group_file->private_data;
6597d6605
< 	event->filp = event_file;
6685d6692
< 	event->filp = NULL;
6734c6741
< 	fput(parent_event->filp);
---
> 	put_event(parent_event);
6810,6812c6817,6818
< 	 *       fput(parent_event->filp)
< 	 *         perf_release()
< 	 *           mutex_lock(&ctx->mutex)
---
> 	 *       put_event()
> 	 *         mutex_lock(&ctx->mutex)
6880c6886
< 	fput(parent->filp);
---
> 	put_event(parent);
6959a6966,6971
> 
> 	if (!atomic_long_inc_not_zero(&parent_event->refcount)) {
> 		free_event(child_event);
> 		return NULL;
> 	}
> 
6997,7004d7008
< 
< 	/*
< 	 * Get a reference to the parent filp - we will fput it
< 	 * when the child event exits. This is safe to do because
< 	 * we are in the parent and we know that the filp still
< 	 * exists and has a nonzero count:
< 	 */
< 	atomic_long_inc(&parent_event->filp->f_count);




diff -r linux-3.0.36/kernel/exit.c linux-3.0.36-lenovo/kernel/exit.c
1051a1052,1067
> 
> 	/*
> 	 * The setting of TASK_RUNNING by try_to_wake_up() may be delayed
> 	 * when the following two conditions become true.
> 	 *   - There is race condition of mmap_sem (It is acquired by
> 	 *     exit_mm()), and
> 	 *   - SMI occurs before setting TASK_RUNINNG.
> 	 *     (or hypervisor of virtual machine switches to other guest)
> 	 *  As a result, we may become TASK_RUNNING after becoming TASK_DEAD
> 	 *
> 	 * To avoid it, we have to wait for releasing tsk->pi_lock which
> 	 * is held by try_to_wake_up()
> 	 */
> 	smp_mb();
> 	raw_spin_unlock_wait(&tsk->pi_lock);
> 




diff -r linux-3.0.36/kernel/fork.c linux-3.0.36-lenovo/kernel/fork.c
158a159,161
> /* Notifier list called when a task struct is freed */
> static ATOMIC_NOTIFIER_HEAD(task_free_notifier);
> 
189a193,204
> int task_free_register(struct notifier_block *n)
> {
> 	return atomic_notifier_chain_register(&task_free_notifier, n);
> }
> EXPORT_SYMBOL(task_free_register);
> 
> int task_free_unregister(struct notifier_block *n)
> {
> 	return atomic_notifier_chain_unregister(&task_free_notifier, n);
> }
> EXPORT_SYMBOL(task_free_unregister);
> 
199a215
> 	atomic_notifier_call_chain(&task_free_notifier, 0, tsk);
987a1004,1006
> #ifdef CONFIG_CPUSETS
> 	seqcount_init(&tsk->mems_allowed_seq);
> #endif
1020c1039
< 	plist_head_init_raw(&p->pi_waiters, &p->pi_lock);
---
> 	plist_head_init(&p->pi_waiters);




diff -r linux-3.0.36/kernel/futex.c linux-3.0.36-lenovo/kernel/futex.c
719c719
< 	int lock_taken, ret, ownerdied = 0;
---
> 	int lock_taken, ret, force_take = 0;
758,763c758
< 	 * There are two cases, where a futex might have no owner (the
< 	 * owner TID is 0): OWNER_DIED. We take over the futex in this
< 	 * case. We also do an unconditional take over, when the owner
< 	 * of the futex died.
< 	 *
< 	 * This is safe as we are protected by the hash bucket lock !
---
> 	 * Should we force take the futex? See below.
765,766c760,764
< 	if (unlikely(ownerdied || !(curval & FUTEX_TID_MASK))) {
< 		/* Keep the OWNER_DIED bit */
---
> 	if (unlikely(force_take)) {
> 		/*
> 		 * Keep the OWNER_DIED and the WAITERS bit and set the
> 		 * new TID value.
> 		 */
768c766
< 		ownerdied = 0;
---
> 		force_take = 0;
778c776
< 	 * We took the lock due to owner died take over.
---
> 	 * We took the lock due to forced take over.
793,795c791,798
< 			 * No owner found for this futex. Check if the
< 			 * OWNER_DIED bit is set to figure out whether
< 			 * this is a robust futex or not.
---
> 			 * We failed to find an owner for this
> 			 * futex. So we have no pi_state to block
> 			 * on. This can happen in two cases:
> 			 *
> 			 * 1) The owner died
> 			 * 2) A stale FUTEX_WAITERS bit
> 			 *
> 			 * Re-read the futex value.
801,803c804,806
< 			 * We simply start over in case of a robust
< 			 * futex. The code above will take the futex
< 			 * and return happy.
---
> 			 * If the owner died or we have a stale
> 			 * WAITERS bit the owner TID in the user space
> 			 * futex is 0.
805,806c808,809
< 			if (curval & FUTEX_OWNER_DIED) {
< 				ownerdied = 1;
---
> 			if (!(curval & FUTEX_TID_MASK)) {
> 				force_take = 1;
842a846,848
> 	if (WARN(q->pi_state || q->rt_waiter, "refusing to wake PI futex\n"))
> 		return;
> 
1077a1084,1087
> 			if (this->pi_state || this->rt_waiter) {
> 				ret = -EINVAL;
> 				goto out_unlock;
> 			}
1089a1100,1103
> 				if (this->pi_state || this->rt_waiter) {
> 					ret = -EINVAL;
> 					goto out_unlock;
> 				}
1097a1112
> out_unlock:
1386a1402,1404
> 		 *
> 		 * We should never be requeueing a futex_q with a pi_state,
> 		 * which is awaiting a futex_unlock_pi().
1389c1407,1408
< 		    (!requeue_pi && this->rt_waiter)) {
---
> 		    (!requeue_pi && this->rt_waiter) ||
> 		    this->pi_state) {
2234,2238c2253,2257
<  * uaddr2 which must be PI aware.  Normal wakeup will wake on uaddr2 and
<  * complete the acquisition of the rt_mutex prior to returning to userspace.
<  * This ensures the rt_mutex maintains an owner when it has waiters; without
<  * one, the pi logic wouldn't know which task to boost/deboost, if there was a
<  * need to.
---
>  * uaddr2 which must be PI aware and unique from uaddr.  Normal wakeup will wake
>  * on uaddr2 and complete the acquisition of the rt_mutex prior to returning to
>  * userspace.  This ensures the rt_mutex maintains an owner when it has waiters;
>  * without one, the pi logic would not know which task to boost/deboost, if
>  * there was a need to.
2274a2294,2296
> 	if (uaddr == uaddr2)
> 		return -EINVAL;
> 
2346c2368
< 		WARN_ON(!&q.pi_state);
---
> 		WARN_ON(!q.pi_state);
2373c2395
< 		if (rt_mutex_owner(pi_mutex) == current)
---
> 		if (pi_mutex && rt_mutex_owner(pi_mutex) == current)
2739c2761
< 		plist_head_init(&futex_queues[i].chain, &futex_queues[i].lock);
---
> 		plist_head_init(&futex_queues[i].chain);




diff -r linux-3.0.36/kernel/hrtimer.c linux-3.0.36-lenovo/kernel/hrtimer.c
659a660,667
> static inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)
> {
> 	ktime_t *offs_real = &base->clock_base[HRTIMER_BASE_REALTIME].offset;
> 	ktime_t *offs_boot = &base->clock_base[HRTIMER_BASE_BOOTTIME].offset;
> 
> 	return ktime_get_update_offsets(offs_real, offs_boot);
> }
> 
668d675
< 	struct timespec realtime_offset, xtim, wtm, sleep;
673,677d679
< 	/* Optimized out for !HIGH_RES */
< 	get_xtime_and_monotonic_and_sleep_offset(&xtim, &wtm, &sleep);
< 	set_normalized_timespec(&realtime_offset, -wtm.tv_sec, -wtm.tv_nsec);
< 
< 	/* Adjust CLOCK_REALTIME offset */
679,683c681
< 	base->clock_base[HRTIMER_BASE_REALTIME].offset =
< 		timespec_to_ktime(realtime_offset);
< 	base->clock_base[HRTIMER_BASE_BOOTTIME].offset =
< 		timespec_to_ktime(sleep);
< 
---
> 	hrtimer_update_base(base);
713d710
< 
719a717,729
> /*
>  * Called from timekeeping code to reprogramm the hrtimer interrupt
>  * device. If called from the timer interrupt context we defer it to
>  * softirq context.
>  */
> void clock_was_set_delayed(void)
> {
> 	struct hrtimer_cpu_base *cpu_base = &__get_cpu_var(hrtimer_bases);
> 
> 	cpu_base->clock_was_set = 1;
> 	__raise_softirq_irqoff(HRTIMER_SOFTIRQ);
> }
> 
1253c1263,1264
< 	entry_time = now = ktime_get();
---
> 	raw_spin_lock(&cpu_base->lock);
> 	entry_time = now = hrtimer_update_base(cpu_base);
1256,1257d1266
< 
< 	raw_spin_lock(&cpu_base->lock);
1332a1342,1344
> 	 *
> 	 * Acquire base lock for updating the offsets and retrieving
> 	 * the current time.
1334c1346,1347
< 	now = ktime_get();
---
> 	raw_spin_lock(&cpu_base->lock);
> 	now = hrtimer_update_base(cpu_base);
1345a1359
> 	raw_spin_unlock(&cpu_base->lock);
1397a1412,1418
> 	struct hrtimer_cpu_base *cpu_base = &__get_cpu_var(hrtimer_bases);
> 
> 	if (cpu_base->clock_was_set) {
> 		cpu_base->clock_was_set = 0;
> 		clock_was_set();
> 	}
> 




diff -r linux-3.0.36/kernel/irq/handle.c linux-3.0.36-lenovo/kernel/irq/handle.c
120c120
< 	unsigned int random = 0, irq = desc->irq_data.irq;
---
> 	unsigned int flags = 0, irq = desc->irq_data.irq;
148c148
< 			random |= action->flags;
---
> 			flags |= action->flags;
159,160c159
< 	if (random & IRQF_SAMPLE_RANDOM)
< 		add_interrupt_randomness(irq);
---
> 	add_interrupt_randomness(irq, flags);




diff -r linux-3.0.36/kernel/irq/manage.c linux-3.0.36-lenovo/kernel/irq/manage.c
700a701
> 	bool valid = true;
715c716,723
< 	cpumask_copy(mask, desc->irq_data.affinity);
---
> 	/*
> 	 * This code is triggered unconditionally. Check the affinity
> 	 * mask pointer. For CPU_MASK_OFFSTACK=n this is optimized out.
> 	 */
> 	if (desc->irq_data.affinity)
> 		cpumask_copy(mask, desc->irq_data.affinity);
> 	else
> 		valid = false;
718c726,727
< 	set_cpus_allowed_ptr(current, mask);
---
> 	if (valid)
> 		set_cpus_allowed_ptr(current, mask);
889,904d897
< 	/*
< 	 * Some drivers like serial.c use request_irq() heavily,
< 	 * so we have to be careful not to interfere with a
< 	 * running system.
< 	 */
< 	if (new->flags & IRQF_SAMPLE_RANDOM) {
< 		/*
< 		 * This function might sleep, we want to call it first,
< 		 * outside of the atomic block.
< 		 * Yes, this might clear the entropy pool if the wrong
< 		 * driver is attempted to be loaded, without actually
< 		 * installing a new handler, but is this really a problem,
< 		 * only the sysadmin is able to do this.
< 		 */
< 		rand_initialize_irq(irq);
< 	}
943a937,946
> 		/*
> 		 * Tell the thread to set its affinity. This is
> 		 * important for shared interrupt handlers as we do
> 		 * not invoke setup_affinity() for the secondary
> 		 * handlers as everything is already set up. Even for
> 		 * interrupts marked with IRQF_NO_BALANCE this is
> 		 * correct as we want the thread to move to the cpu(s)
> 		 * on which the requesting code placed the interrupt.
> 		 */
> 		set_bit(IRQTF_AFFINITY, &new->thread_flags);
1328d1330
<  *	IRQF_SAMPLE_RANDOM	The interrupt can be used for entropy




diff -r linux-3.0.36/kernel/irq/pm.c linux-3.0.36-lenovo/kernel/irq/pm.c
107c107,111
< 			if (desc->istate & IRQS_PENDING)
---
> 			if (desc->istate & IRQS_PENDING) {
> 				pr_info("Wakeup IRQ %d %s pending, suspend aborted\n",
> 					irq,
> 					desc->action && desc->action->name ?
> 					desc->action->name : "");
108a113
> 			}




diff -r linux-3.0.36/kernel/Makefile linux-3.0.36-lenovo/kernel/Makefile
103a104
> obj-$(CONFIG_CPU_PM) += cpu_pm.o




diff -r linux-3.0.36/kernel/module.c linux-3.0.36-lenovo/kernel/module.c
1984a1985,1988
> #ifdef CONFIG_PLAT_RK
> 	return;
> #endif
> 
2607a2612,2615
> 	/* lve claims to be GPL but upstream won't provide source */
> 	if (strcmp(mod->name, "lve") == 0)
> 		add_taint_module(mod, TAINT_PROPRIETARY_MODULE);
> 
2825a2834,2840
> #ifdef CONFIG_RK_CONFIG
> {
> 	extern int module_parse_kernel_cmdline(const char *name, const struct kernel_param *params, unsigned num);
> 	module_parse_kernel_cmdline(mod->name, mod->kp, mod->num_kp);
> }
> #endif
> 
3396a3412
> #ifndef CONFIG_PLAT_RK
3408a3425
> #endif




diff -r linux-3.0.36/kernel/panic.c linux-3.0.36-lenovo/kernel/panic.c
29a30,32
> /* Machine specific panic information string */
> char *mach_panic_string;
> 
36c39,42
< int panic_timeout;
---
> #ifndef CONFIG_PANIC_TIMEOUT
> #define CONFIG_PANIC_TIMEOUT 0
> #endif
> int panic_timeout = CONFIG_PANIC_TIMEOUT;
352a359,363
> 
> 	if (mach_panic_string)
> 		printk(KERN_WARNING "Board Information: %s\n",
> 		       mach_panic_string);
> 




diff -r linux-3.0.36/kernel/params.c linux-3.0.36-lenovo/kernel/params.c
219a220,261
> #ifdef CONFIG_RK_CONFIG
> static int ignore_unknown(char *param, char *val)
> {
> 	return 0;
> }
> 
> int module_parse_kernel_cmdline(const char *name, const struct kernel_param *params, unsigned num)
> {
> 	int ret;
> 	unsigned i;
> 	size_t name_len = strlen(name);
> 	struct kernel_param new_params[num];
> 	char args[strlen(saved_command_line) + 1];
> 
> 	if (!num)
> 		return 0;
> 
> 	strcpy(args, saved_command_line);
> 	memcpy(new_params, params, sizeof(struct kernel_param) * num);
> 
> 	for (i = 0; i < num; i++)
> 		new_params[i].name = NULL;
> 	for (i = 0; i < num; i++) {
> 		char *new_name = kmalloc(strlen(params[i].name) + name_len + 2, GFP_KERNEL);
> 		if (!new_name) {
> 			ret = -ENOMEM;
> 			goto out;
> 		}
> 		sprintf(new_name, "%s.%s", name, params[i].name);
> 		new_params[i].name = new_name;
> 	}
> 
> 	ret = parse_args(name, args, new_params, num, ignore_unknown);
> 
> out:
> 	for (i = 0; i < num; i++)
> 		if (new_params[i].name)
> 			kfree(new_params[i].name);
> 	return ret;
> }
> #endif
> 




diff -r linux-3.0.36/kernel/pm_qos_params.c linux-3.0.36-lenovo/kernel/pm_qos_params.c
77c77
< 	.requests = PLIST_HEAD_INIT(cpu_dma_pm_qos.requests, pm_qos_lock),
---
> 	.requests = PLIST_HEAD_INIT(cpu_dma_pm_qos.requests),
87c87
< 	.requests = PLIST_HEAD_INIT(network_lat_pm_qos.requests, pm_qos_lock),
---
> 	.requests = PLIST_HEAD_INIT(network_lat_pm_qos.requests),
98c98
< 	.requests = PLIST_HEAD_INIT(network_throughput_pm_qos.requests, pm_qos_lock),
---
> 	.requests = PLIST_HEAD_INIT(network_throughput_pm_qos.requests),
Only in linux-3.0.36-lenovo/kernel/power: consoleearlysuspend.c
Only in linux-3.0.36-lenovo/kernel/power: earlysuspend.c
Only in linux-3.0.36-lenovo/kernel/power: fbearlysuspend.c




diff -r linux-3.0.36/kernel/power/hibernate.c linux-3.0.36-lenovo/kernel/power/hibernate.c
346a347
> 	ftrace_stop();
371a373
> 	ftrace_start();
473a476
> 	ftrace_stop();
480a484
> 	ftrace_start();
506a511
> 	ftrace_stop();
549a555
> 	ftrace_start();




diff -r linux-3.0.36/kernel/power/Kconfig linux-3.0.36-lenovo/kernel/power/Kconfig
20a21,87
> config HAS_WAKELOCK
> 	bool
> 
> config HAS_EARLYSUSPEND
> 	bool
> 
> config WAKELOCK
> 	bool "Wake lock"
> 	depends on PM && RTC_CLASS
> 	default n
> 	select HAS_WAKELOCK
> 	---help---
> 	  Enable wakelocks. When user space request a sleep state the
> 	  sleep request will be delayed until no wake locks are held.
> 
> config WAKELOCK_STAT
> 	bool "Wake lock stats"
> 	depends on WAKELOCK
> 	default y
> 	---help---
> 	  Report wake lock stats in /proc/wakelocks
> 
> config USER_WAKELOCK
> 	bool "Userspace wake locks"
> 	depends on WAKELOCK
> 	default y
> 	---help---
> 	  User-space wake lock api. Write "lockname" or "lockname timeout"
> 	  to /sys/power/wake_lock lock and if needed create a wake lock.
> 	  Write "lockname" to /sys/power/wake_unlock to unlock a user wake
> 	  lock.
> 
> config EARLYSUSPEND
> 	bool "Early suspend"
> 	depends on WAKELOCK
> 	default y
> 	select HAS_EARLYSUSPEND
> 	---help---
> 	  Call early suspend handlers when the user requested sleep state
> 	  changes.
> 
> choice
> 	prompt "User-space screen access"
> 	default FB_EARLYSUSPEND if !FRAMEBUFFER_CONSOLE
> 	default CONSOLE_EARLYSUSPEND
> 	depends on HAS_EARLYSUSPEND
> 
> 	config NO_USER_SPACE_SCREEN_ACCESS_CONTROL
> 		bool "None"
> 
> 	config CONSOLE_EARLYSUSPEND
> 		bool "Console switch on early-suspend"
> 		depends on HAS_EARLYSUSPEND && VT
> 		---help---
> 		  Register early suspend handler to perform a console switch to
> 		  when user-space should stop drawing to the screen and a switch
> 		  back when it should resume.
> 
> 	config FB_EARLYSUSPEND
> 		bool "Sysfs interface"
> 		depends on HAS_EARLYSUSPEND
> 		---help---
> 		  Register early suspend handler that notifies and waits for
> 		  user-space through sysfs when user-space should stop drawing
> 		  to the screen and notifies user-space when it should resume.
> endchoice
> 
229a297,312
> 
> config CPU_PM
> 	bool
> 	depends on SUSPEND || CPU_IDLE
> 
> config SUSPEND_TIME
> 	bool "Log time spent in suspend"
> 	---help---
> 	  Prints the time spent in suspend in the kernel log, and
> 	  keeps statistics on the time spent in suspend in
> 	  /sys/kernel/debug/suspend_time
> 
> config SUSPEND_SYNC_WORKQUEUE
> 	bool "Suspend sync in workqueue"
> 	depends on WAKELOCK
> 	default y




diff -r linux-3.0.36/kernel/power/main.c linux-3.0.36-lenovo/kernel/power/main.c
172a173,175
> #ifdef CONFIG_EARLYSUSPEND
> 	suspend_state_t state = PM_SUSPEND_ON;
> #else
173a177
> #endif
194a199,204
> #ifdef CONFIG_EARLYSUSPEND
> 		if (state == PM_SUSPEND_ON || valid_state(state)) {
> 			error = 0;
> 			request_suspend_state(state);
> 		}
> #else
196a207
> #endif
299a311,315
> #ifdef CONFIG_USER_WAKELOCK
> power_attr(wake_lock);
> power_attr(wake_unlock);
> #endif
> 
310a327,330
> #endif
> #ifdef CONFIG_USER_WAKELOCK
> 	&wake_lock_attr.attr,
> 	&wake_unlock_attr.attr,




diff -r linux-3.0.36/kernel/power/Makefile linux-3.0.36-lenovo/kernel/power/Makefile
10a11,16
> obj-$(CONFIG_WAKELOCK)		+= wakelock.o
> obj-$(CONFIG_USER_WAKELOCK)	+= userwakelock.o
> obj-$(CONFIG_EARLYSUSPEND)	+= earlysuspend.o
> obj-$(CONFIG_CONSOLE_EARLYSUSPEND)	+= consoleearlysuspend.o
> obj-$(CONFIG_FB_EARLYSUSPEND)	+= fbearlysuspend.o
> obj-$(CONFIG_SUSPEND_TIME)	+= suspend_time.o




diff -r linux-3.0.36/kernel/power/power.h linux-3.0.36-lenovo/kernel/power/power.h
247a248,276
> 
> #ifdef CONFIG_WAKELOCK
> /* kernel/power/wakelock.c */
> extern struct workqueue_struct *suspend_work_queue;
> extern struct wake_lock main_wake_lock;
> extern suspend_state_t requested_suspend_state;
> #endif
> 
> #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
> extern void suspend_sys_sync_queue(void);
> extern int suspend_sys_sync_wait(void);
> #endif
> 
> #ifdef CONFIG_USER_WAKELOCK
> ssize_t wake_lock_show(struct kobject *kobj, struct kobj_attribute *attr,
> 			char *buf);
> ssize_t wake_lock_store(struct kobject *kobj, struct kobj_attribute *attr,
> 			const char *buf, size_t n);
> ssize_t wake_unlock_show(struct kobject *kobj, struct kobj_attribute *attr,
> 			char *buf);
> ssize_t  wake_unlock_store(struct kobject *kobj, struct kobj_attribute *attr,
> 			const char *buf, size_t n);
> #endif
> 
> #ifdef CONFIG_EARLYSUSPEND
> /* kernel/power/earlysuspend.c */
> void request_suspend_state(suspend_state_t state);
> suspend_state_t get_suspend_state(void);
> #endif




diff -r linux-3.0.36/kernel/power/process.c linux-3.0.36-lenovo/kernel/power/process.c
18a19,20
> #include <linux/wakelock.h>
> #include "power.h"
84a87,90
> 		if (todo && has_wake_lock(WAKE_LOCK_SUSPEND)) {
> 			wakeup = 1;
> 			break;
> 		}
111,117c117,129
< 		printk("\n");
< 		printk(KERN_ERR "Freezing of tasks %s after %d.%02d seconds "
< 		       "(%d tasks refusing to freeze, wq_busy=%d):\n",
< 		       wakeup ? "aborted" : "failed",
< 		       elapsed_csecs / 100, elapsed_csecs % 100,
< 		       todo - wq_busy, wq_busy);
< 
---
> 		if(wakeup) {
> 			printk("\n");
> 			printk(KERN_ERR "Freezing of %s aborted\n",
> 					sig_only ? "user space " : "tasks ");
> 			print_active_wake_locks(WAKE_LOCK_SUSPEND);
> 		}
> 		else {
> 			printk("\n");
> 			printk(KERN_ERR "Freezing of tasks failed after %d.%02d seconds "
> 			       "(%d tasks refusing to freeze, wq_busy=%d):\n",
> 			       elapsed_csecs / 100, elapsed_csecs % 100,
> 			       todo - wq_busy, wq_busy);
> 		}
123c135,136
< 			if (!wakeup && freezing(p) && !freezer_should_skip(p))
---
> 			if (freezing(p) && !freezer_should_skip(p) &&
> 				elapsed_csecs > 100)
148a162,167
> 
> #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
> 	error = suspend_sys_sync_wait();
> 	if (error)
> 		goto Exit;
> #endif




diff -r linux-3.0.36/kernel/power/suspend.c linux-3.0.36-lenovo/kernel/power/suspend.c
25a26
> #include <linux/ftrace.h>
30a32,34
> #ifdef CONFIG_EARLYSUSPEND
> 	[PM_SUSPEND_ON]		= "on",
> #endif
212a217
> 	ftrace_stop();
228a234
> 	ftrace_start();
275a282,284
> #ifdef CONFIG_SUSPEND_SYNC_WORKQUEUE
> 	suspend_sys_sync_queue();
> #else
278a288
> #endif
Only in linux-3.0.36-lenovo/kernel/power: suspend_time.c
Only in linux-3.0.36-lenovo/kernel/power: userwakelock.c
Only in linux-3.0.36-lenovo/kernel/power: wakelock.c




diff -r linux-3.0.36/kernel/printk.c linux-3.0.36-lenovo/kernel/printk.c
55a56,59
> #ifdef        CONFIG_DEBUG_LL
> extern void printascii(char *);
> #endif
> 
292a297,343
> /*
>  * Return the number of unread characters in the log buffer.
>  */
> static int log_buf_get_len(void)
> {
> 	return logged_chars;
> }
> 
> /*
>  * Clears the ring-buffer
>  */
> void log_buf_clear(void)
> {
> 	logged_chars = 0;
> }
> 
> /*
>  * Copy a range of characters from the log buffer.
>  */
> int log_buf_copy(char *dest, int idx, int len)
> {
> 	int ret, max;
> 	bool took_lock = false;
> 
> 	if (!oops_in_progress) {
> 		spin_lock_irq(&logbuf_lock);
> 		took_lock = true;
> 	}
> 
> 	max = log_buf_get_len();
> 	if (idx < 0 || idx >= max) {
> 		ret = -1;
> 	} else {
> 		if (len > max - idx)
> 			len = max - idx;
> 		ret = len;
> 		idx += (log_end - max);
> 		while (len-- > 0)
> 			dest[len] = LOG_BUF(idx + len);
> 	}
> 
> 	if (took_lock)
> 		spin_unlock_irq(&logbuf_lock);
> 
> 	return ret;
> }
> 
635a687,697
> 			/*
> 			 * prepare buf_prefix, as a contiguous array,
> 			 * to be processed by log_prefix function
> 			 */
> 			char buf_prefix[SYSLOG_PRI_MAX_LENGTH+1];
> 			unsigned i;
> 			for (i = 0; i < ((end - cur_index)) && (i < SYSLOG_PRI_MAX_LENGTH); i++) {
> 				buf_prefix[i] = LOG_BUF(cur_index + i);
> 			}
> 			buf_prefix[i] = '\0'; /* force '\0' as last string character */
> 
637c699
< 			cur_index += log_prefix(&LOG_BUF(cur_index), &msg_level, NULL);
---
> 			cur_index += log_prefix((const char *)&buf_prefix, &msg_level, NULL);
876a939,942
> #ifdef	CONFIG_DEBUG_LL
> 	printascii(printk_buf);
> #endif
> 
970a1037,1058
> #ifdef CONFIG_PLAT_RK
> void pm_emit_log_char(char c)
> {
> 	emit_log_char(c);
> }
> #endif
> 
> #ifdef CONFIG_RK29_LAST_LOG
> void __init switch_log_buf(char *new_log_buf, int size)
> {
> 	unsigned long flags;
> 
> 	if (!new_log_buf || log_buf_len > size)
> 		return;
> 
> 	spin_lock_irqsave(&logbuf_lock, flags);
> 	memcpy(new_log_buf, log_buf, min(log_buf_len, size));
> 	log_buf = new_log_buf;
> 	log_buf_len = size;
> 	spin_unlock_irqrestore(&logbuf_lock, flags);
> }
> #endif /* CONFIG_RK29_LAST_LOG */
1151d1238
< 	case CPU_DYING:




diff -r linux-3.0.36/kernel/rcutree.c linux-3.0.36-lenovo/kernel/rcutree.c
286c286,288
< 	return *rdp->nxttail[RCU_DONE_TAIL] && !rcu_gp_in_progress(rsp);
---
> 	return *rdp->nxttail[RCU_DONE_TAIL +
> 			     ACCESS_ONCE(rsp->completed) != rdp->completed] &&
> 	       !rcu_gp_in_progress(rsp);




diff -r linux-3.0.36/kernel/resource.c linux-3.0.36-lenovo/kernel/resource.c
421a422,424
> 		if (tmp.end < tmp.start)
> 			goto next;
> 
439c442,443
< 		if (!this)
---
> 
> next:		if (!this || this->end == root->end)
440a445
> 
733a739
> 	struct resource *next_res = NULL;
743,745c749
< 	conflict = __request_resource(parent, res);
< 	if (!conflict)
< 		return;
---
> 	while (1) {
747,748c751,758
< 	/* failed, split and try again */
< 	kfree(res);
---
> 		conflict = __request_resource(parent, res);
> 		if (!conflict) {
> 			if (!next_res)
> 				break;
> 			res = next_res;
> 			next_res = NULL;
> 			continue;
> 		}
750,752c760,787
< 	/* conflict covered whole area */
< 	if (conflict->start <= start && conflict->end >= end)
< 		return;
---
> 		/* conflict covered whole area */
> 		if (conflict->start <= res->start &&
> 				conflict->end >= res->end) {
> 			kfree(res);
> 			WARN_ON(next_res);
> 			break;
> 		}
> 
> 		/* failed, split and try again */
> 		if (conflict->start > res->start) {
> 			end = res->end;
> 			res->end = conflict->start - 1;
> 			if (conflict->end < end) {
> 				next_res = kzalloc(sizeof(*next_res),
> 						GFP_ATOMIC);
> 				if (!next_res) {
> 					kfree(res);
> 					break;
> 				}
> 				next_res->name = name;
> 				next_res->start = conflict->end + 1;
> 				next_res->end = end;
> 				next_res->flags = IORESOURCE_BUSY;
> 			}
> 		} else {
> 			res->start = conflict->end + 1;
> 		}
> 	}
754,757d788
< 	if (conflict->start > start)
< 		__reserve_region_with_split(root, start, conflict->start-1, name);
< 	if (conflict->end < end)
< 		__reserve_region_with_split(root, conflict->end+1, end, name);




diff -r linux-3.0.36/kernel/rtmutex.c linux-3.0.36-lenovo/kernel/rtmutex.c
893c893
< 	plist_head_init_raw(&lock->wait_list, &lock->wait_lock);
---
> 	plist_head_init(&lock->wait_list);




diff -r linux-3.0.36/kernel/sched_autogroup.c linux-3.0.36-lenovo/kernel/sched_autogroup.c
163,165d162
< 	if (!ACCESS_ONCE(sysctl_sched_autogroup_enabled))
< 		goto out;
< 
171d167
< out:




diff -r linux-3.0.36/kernel/sched_autogroup.h linux-3.0.36-lenovo/kernel/sched_autogroup.h
4,8d3
< 	/*
< 	 * reference doesn't mean how many thread attach to this
< 	 * autogroup now. It just stands for the number of task
< 	 * could use this autogroup.
< 	 */




diff -r linux-3.0.36/kernel/sched.c linux-3.0.36-lenovo/kernel/sched.c
73a74
> #include <linux/cpuacct.h>
608,611c609,617
<  * We use task_subsys_state_check() and extend the RCU verification with
<  * pi->lock and rq->lock because cpu_cgroup_attach() holds those locks for each
<  * task it moves into the cgroup. Therefore by holding either of those locks,
<  * we pin the task to the current cgroup.
---
>  * We cannot use task_subsys_state() and friends because the cgroup
>  * subsystem changes that value before the cgroup_subsys::attach() method
>  * is called, therefore we cannot pin it and might observe the wrong value.
>  *
>  * The same is true for autogroup's p->signal->autogroup->tg, the autogroup
>  * core changes this before calling sched_move_task().
>  *
>  * Instead we use a 'copy' which is updated from sched_move_task() while
>  * holding both task_struct::pi_lock and rq::lock.
615,623c621
< 	struct task_group *tg;
< 	struct cgroup_subsys_state *css;
< 
< 	css = task_subsys_state_check(p, cpu_cgroup_subsys_id,
< 			lockdep_is_held(&p->pi_lock) ||
< 			lockdep_is_held(&task_rq(p)->lock));
< 	tg = container_of(css, struct task_group, css);
< 
< 	return autogroup_task_group(p, tg);
---
> 	return p->sched_task_group;
2209c2207
< 	 * see set_task_rq().
---
> 	 * see task_group().
6482c6480
< 	case CPU_ONLINE:
---
> 	case CPU_STARTING:
7782a7781,7782
> static int num_cpus_frozen;	/* used to mark begin/end of suspend/resume */
> 
7786a7787,7789
>  *
>  * If we come here as part of a suspend/resume, don't touch cpusets because we
>  * want to restore it back to its original state upon resume anyway.
7791c7794,7815
< 	switch (action & ~CPU_TASKS_FROZEN) {
---
> 	switch (action) {
> 	case CPU_ONLINE_FROZEN:
> 	case CPU_DOWN_FAILED_FROZEN:
> 
> 		/*
> 		 * num_cpus_frozen tracks how many CPUs are involved in suspend
> 		 * resume sequence. As long as this is not the last online
> 		 * operation in the resume sequence, just build a single sched
> 		 * domain, ignoring cpusets.
> 		 */
> 		num_cpus_frozen--;
> 		if (likely(num_cpus_frozen)) {
> 			partition_sched_domains(1, NULL, NULL);
> 			break;
> 		}
> 
> 		/*
> 		 * This is the last CPU online operation. So fall through and
> 		 * restore the original sched domains by considering the
> 		 * cpuset configurations.
> 		 */
> 
7795c7819
< 		return NOTIFY_OK;
---
> 		break;
7798a7823
> 	return NOTIFY_OK;
7804c7829
< 	switch (action & ~CPU_TASKS_FROZEN) {
---
> 	switch (action) {
7807c7832,7836
< 		return NOTIFY_OK;
---
> 		break;
> 	case CPU_DOWN_PREPARE_FROZEN:
> 		num_cpus_frozen++;
> 		partition_sched_domains(1, NULL, NULL);
> 		break;
7810a7840
> 	return NOTIFY_OK;
7923c7953
< 	plist_head_init_raw(&rt_rq->pushable_tasks, &rq->lock);
---
> 	plist_head_init(&rt_rq->pushable_tasks);
8128c8158
< 	plist_head_init_raw(&init_task.pi_waiters, &init_task.pi_lock);
---
> 	plist_head_init(&init_task.pi_waiters);
8178a8209,8216
> static int __might_sleep_init_called;
> int __init __might_sleep_init(void)
> {
> 	__might_sleep_init_called = 1;
> 	return 0;
> }
> early_initcall(__might_sleep_init);
> 
8185c8223,8226
< 	    system_state != SYSTEM_RUNNING || oops_in_progress)
---
> 	    oops_in_progress)
> 		return;
> 	if (system_state != SYSTEM_RUNNING &&
> 	    (!__might_sleep_init_called || system_state != SYSTEM_BOOTING))
8547a8589
> 	struct task_group *tg;
8561a8604,8609
> 	tg = container_of(task_subsys_state_check(tsk, cpu_cgroup_subsys_id,
> 				lockdep_is_held(&tsk->sighand->siglock)),
> 			  struct task_group, css);
> 	tg = autogroup_task_group(tsk, tg);
> 	tsk->sched_task_group = tg;
> 
8928a8977,8990
> cpu_cgroup_allow_attach(struct cgroup *cgrp, struct task_struct *tsk)
> {
> 	const struct cred *cred = current_cred(), *tcred;
> 
> 	tcred = __task_cred(tsk);
> 
> 	if ((current != tsk) && !capable(CAP_SYS_NICE) &&
> 	    cred->euid != tcred->uid && cred->euid != tcred->suid)
> 		return -EACCES;
> 
> 	return 0;
> }
> 
> static int
9032a9095
> 	.allow_attach	= cpu_cgroup_allow_attach,
9058a9122,9123
> 	struct cpuacct_charge_calls *cpufreq_fn;
> 	void *cpuacct_data;
9060a9126,9145
> static struct cpuacct *cpuacct_root;
> 
> /* Default calls for cpufreq accounting */
> static struct cpuacct_charge_calls *cpuacct_cpufreq;
> int cpuacct_register_cpufreq(struct cpuacct_charge_calls *fn)
> {
> 	cpuacct_cpufreq = fn;
> 
> 	/*
> 	 * Root node is created before platform can register callbacks,
> 	 * initalize here.
> 	 */
> 	if (cpuacct_root && fn) {
> 		cpuacct_root->cpufreq_fn = fn;
> 		if (fn->init)
> 			fn->init(&cpuacct_root->cpuacct_data);
> 	}
> 	return 0;
> }
> 
9094a9180,9185
> 	ca->cpufreq_fn = cpuacct_cpufreq;
> 
> 	/* If available, have platform code initalize cpu frequency table */
> 	if (ca->cpufreq_fn && ca->cpufreq_fn->init)
> 		ca->cpufreq_fn->init(&ca->cpuacct_data);
> 
9096a9188,9189
> 	else
> 		cpuacct_root = ca;
9223a9317,9342
> static int cpuacct_cpufreq_show(struct cgroup *cgrp, struct cftype *cft,
> 		struct cgroup_map_cb *cb)
> {
> 	struct cpuacct *ca = cgroup_ca(cgrp);
> 	if (ca->cpufreq_fn && ca->cpufreq_fn->cpufreq_show)
> 		ca->cpufreq_fn->cpufreq_show(ca->cpuacct_data, cb);
> 
> 	return 0;
> }
> 
> /* return total cpu power usage (milliWatt second) of a group */
> static u64 cpuacct_powerusage_read(struct cgroup *cgrp, struct cftype *cft)
> {
> 	int i;
> 	struct cpuacct *ca = cgroup_ca(cgrp);
> 	u64 totalpower = 0;
> 
> 	if (ca->cpufreq_fn && ca->cpufreq_fn->power_usage)
> 		for_each_present_cpu(i) {
> 			totalpower += ca->cpufreq_fn->power_usage(
> 					ca->cpuacct_data);
> 		}
> 
> 	return totalpower;
> }
> 
9237a9357,9364
> 	{
> 		.name =  "cpufreq",
> 		.read_map = cpuacct_cpufreq_show,
> 	},
> 	{
> 		.name = "power",
> 		.read_u64 = cpuacct_powerusage_read
> 	},
9266a9394,9397
> 
> 		/* Call back into platform code to account for CPU speeds */
> 		if (ca->cpufreq_fn && ca->cpufreq_fn->charge)
> 			ca->cpufreq_fn->charge(ca->cpuacct_data, cputime, cpu);




diff -r linux-3.0.36/kernel/smp.c linux-3.0.36-lenovo/kernel/smp.c
33a34
> 	cpumask_var_t		cpumask_ipi;
56a58,60
> 		if (!zalloc_cpumask_var_node(&cfd->cpumask_ipi, GFP_KERNEL,
> 				cpu_to_node(cpu)))
> 			return notifier_from_errno(-ENOMEM);
65a70
> 		free_cpumask_var(cfd->cpumask_ipi);
526a532,537
> 	/*
> 	 * After we put an entry into the list, data->cpumask
> 	 * may be cleared again when another CPU sends another IPI for
> 	 * a SMP function call, so data->cpumask will be zero.
> 	 */
> 	cpumask_copy(data->cpumask_ipi, data->cpumask);
550c561
< 	arch_send_call_function_ipi_mask(data->cpumask);
---
> 	arch_send_call_function_ipi_mask(data->cpumask_ipi);




diff -r linux-3.0.36/kernel/sys.c linux-3.0.36-lenovo/kernel/sys.c
55a56,67
> /***************
> *	 DEBUG
> ****************/
> #define RESTART_DEBUG
> #ifdef RESTART_DEBUG
> #define restart_dbg(format, arg...) \
> 	printk("RESTART_DEBUG : " format "\n" , ## arg)
> #else
> #define restart_dbg(format, arg...) do {} while (0)
> #endif
> 
> 
116c128
< int C_A_D = 1;
---
> int C_A_D = 0;
335a348,352
> 	/*
> 	*  debug trace
> 	*/
> 	restart_dbg("%s->%d->cmd=%s",__FUNCTION__,__LINE__,cmd);
> 	
336a354
> 	disable_nonboot_cpus();
424a443,447
> 		/*
> 		*  debug trace
> 		*/
> 		restart_dbg("%s->%d->cmd=%x",__FUNCTION__,__LINE__,cmd);
> 		
441a465,469
> 		/*
> 		*  debug trace
> 		*/
> 		restart_dbg("%s->%d->cmd=%x",__FUNCTION__,__LINE__,cmd);
> 		
452c480,484
< 
---
> 		/*
> 		*  debug trace
> 		*/
> 		restart_dbg("%s->%d->cmd=%x args=%s",__FUNCTION__,__LINE__,cmd,buffer);
> 		
1135c1167
< static int override_release(char __user *release, int len)
---
> static int override_release(char __user *release, size_t len)
1138d1169
< 	char buf[65];
1141c1172,1173
< 		char *rest = UTS_RELEASE;
---
> 		const char *rest = UTS_RELEASE;
> 		char buf[65] = { 0 };
1143a1176
> 		size_t copy;
1153,1154c1186,1188
< 		snprintf(buf, len, "2.6.%u%s", v, rest);
< 		ret = copy_to_user(release, buf, len);
---
> 		copy = clamp_t(size_t, len, 1, sizeof(buf));
> 		copy = scnprintf(buf, copy, "2.6.%u%s", v, rest);
> 		ret = copy_to_user(release, buf, copy + 1);




diff -r linux-3.0.36/kernel/sysctl.c linux-3.0.36-lenovo/kernel/sysctl.c
98a99
> extern int min_free_order_shift;
1189a1191,1197
> 	},
> 	{
> 		.procname	= "min_free_order_shift",
> 		.data		= &min_free_order_shift,
> 		.maxlen		= sizeof(min_free_order_shift),
> 		.mode		= 0644,
> 		.proc_handler	= &proc_dointvec




diff -r linux-3.0.36/kernel/time/Makefile linux-3.0.36-lenovo/kernel/time/Makefile
2c2
< obj-y += timeconv.o posix-clock.o alarmtimer.o
---
> obj-y += timeconv.o posix-clock.o #alarmtimer.o




diff -r linux-3.0.36/kernel/time/ntp.c linux-3.0.36-lenovo/kernel/time/ntp.c
34,35d33
< static struct hrtimer		leap_timer;
< 
353,355c351,358
<  * Leap second processing. If in leap-insert state at the end of the
<  * day, the system clock is set back one second; if in leap-delete
<  * state, the system clock is set ahead one second.
---
>  * this routine handles the overflow of the microsecond field
>  *
>  * The tricky bits of code to handle the accurate clock support
>  * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.
>  * They were originally developed for SUN and DEC kernels.
>  * All the kudos should go to Dave for this stuff.
>  *
>  * Also handles leap second processing, and returns leap offset
357c360
< static enum hrtimer_restart ntp_leap_second(struct hrtimer *timer)
---
> int second_overflow(unsigned long secs)
359,361c362,363
< 	enum hrtimer_restart res = HRTIMER_NORESTART;
< 
< 	write_seqlock(&xtime_lock);
---
> 	int leap = 0;
> 	s64 delta;
362a365,369
> 	/*
> 	 * Leap second processing. If in leap-insert state at the end of the
> 	 * day, the system clock is set back one second; if in leap-delete
> 	 * state, the system clock is set ahead one second.
> 	 */
364a372,375
> 		if (time_status & STA_INS)
> 			time_state = TIME_INS;
> 		else if (time_status & STA_DEL)
> 			time_state = TIME_DEL;
367,372c378,386
< 		timekeeping_leap_insert(-1);
< 		time_state = TIME_OOP;
< 		printk(KERN_NOTICE
< 			"Clock: inserting leap second 23:59:60 UTC\n");
< 		hrtimer_add_expires_ns(&leap_timer, NSEC_PER_SEC);
< 		res = HRTIMER_RESTART;
---
> 		if (!(time_status & STA_INS))
> 			time_state = TIME_OK;
> 		else if (secs % 86400 == 0) {
> 			leap = -1;
> 			time_state = TIME_OOP;
> 			time_tai++;
> 			printk(KERN_NOTICE
> 				"Clock: inserting leap second 23:59:60 UTC\n");
> 		}
375,379c389,397
< 		timekeeping_leap_insert(1);
< 		time_tai--;
< 		time_state = TIME_WAIT;
< 		printk(KERN_NOTICE
< 			"Clock: deleting leap second 23:59:59 UTC\n");
---
> 		if (!(time_status & STA_DEL))
> 			time_state = TIME_OK;
> 		else if ((secs + 1) % 86400 == 0) {
> 			leap = 1;
> 			time_tai--;
> 			time_state = TIME_WAIT;
> 			printk(KERN_NOTICE
> 				"Clock: deleting leap second 23:59:59 UTC\n");
> 		}
382d399
< 		time_tai++;
384c401,402
< 		/* fall through */
---
> 		break;
> 
391,406d408
< 	write_sequnlock(&xtime_lock);
< 
< 	return res;
< }
< 
< /*
<  * this routine handles the overflow of the microsecond field
<  *
<  * The tricky bits of code to handle the accurate clock support
<  * were provided by Dave Mills (Mills@UDEL.EDU) of NTP fame.
<  * They were originally developed for SUN and DEC kernels.
<  * All the kudos should go to Dave for this stuff.
<  */
< void second_overflow(void)
< {
< 	s64 delta;
426c428
< 		return;
---
> 		goto out;
431c433
< 		return;
---
> 		goto out;
437c439
< 		return;
---
> 		goto out;
442a445,446
> out:
> 	return leap;
504,524d507
< /*
<  * Start the leap seconds timer:
<  */
< static inline void ntp_start_leap_timer(struct timespec *ts)
< {
< 	long now = ts->tv_sec;
< 
< 	if (time_status & STA_INS) {
< 		time_state = TIME_INS;
< 		now += 86400 - now % 86400;
< 		hrtimer_start(&leap_timer, ktime_set(now, 0), HRTIMER_MODE_ABS);
< 
< 		return;
< 	}
< 
< 	if (time_status & STA_DEL) {
< 		time_state = TIME_DEL;
< 		now += 86400 - (now + 1) % 86400;
< 		hrtimer_start(&leap_timer, ktime_set(now, 0), HRTIMER_MODE_ABS);
< 	}
< }
549,564d531
< 	switch (time_state) {
< 	case TIME_OK:
< 		ntp_start_leap_timer(ts);
< 		break;
< 	case TIME_INS:
< 	case TIME_DEL:
< 		time_state = TIME_OK;
< 		ntp_start_leap_timer(ts);
< 	case TIME_WAIT:
< 		if (!(time_status & (STA_INS | STA_DEL)))
< 			time_state = TIME_OK;
< 		break;
< 	case TIME_OOP:
< 		hrtimer_restart(&leap_timer);
< 		break;
< 	}
646,648d612
< 
< 		if (txc->modes & ADJ_STATUS && time_state != TIME_OK)
< 			hrtimer_cancel(&leap_timer);
970,971d933
< 	hrtimer_init(&leap_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);
< 	leap_timer.function = ntp_leap_second;




diff -r linux-3.0.36/kernel/time/timekeeping.c linux-3.0.36-lenovo/kernel/time/timekeeping.c
163a164,169
> /* Offset clock monotonic -> clock realtime */
> static ktime_t offs_real;
> 
> /* Offset clock monotonic -> clock boottime */
> static ktime_t offs_boot;
> 
169,170c175,182
< /* flag for if timekeeping is suspended */
< int __read_mostly timekeeping_suspended;
---
> /* must hold write on xtime_lock */
> static void update_rt_offset(void)
> {
> 	struct timespec tmp, *wtm = &wall_to_monotonic;
> 
> 	set_normalized_timespec(&tmp, -wtm->tv_sec, -wtm->tv_nsec);
> 	offs_real = timespec_to_ktime(tmp);
> }
172,173c184,185
< /* must hold xtime_lock */
< void timekeeping_leap_insert(int leapsecond)
---
> /* must hold write on xtime_lock */
> static void timekeeping_update(bool clearntp)
175,178c187,193
< 	xtime.tv_sec += leapsecond;
< 	wall_to_monotonic.tv_sec -= leapsecond;
< 	update_vsyscall(&xtime, &wall_to_monotonic, timekeeper.clock,
< 			timekeeper.mult);
---
> 	if (clearntp) {
> 		timekeeper.ntp_error = 0;
> 		ntp_clear();
> 	}
> 	update_rt_offset();
> 	update_vsyscall(&xtime, &wall_to_monotonic,
> 			 timekeeper.clock, timekeeper.mult);
180a196,200
> 
> 
> /* flag for if timekeeping is suspended */
> int __read_mostly timekeeping_suspended;
> 
365c385
< 	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
---
> 	if (!timespec_valid_strict(tv))
378,382c398
< 	timekeeper.ntp_error = 0;
< 	ntp_clear();
< 
< 	update_vsyscall(&xtime, &wall_to_monotonic, timekeeper.clock,
< 				timekeeper.mult);
---
> 	timekeeping_update(true);
403a420,421
> 	struct timespec tmp;
> 	int ret = 0;
411a430,435
> 	tmp = timespec_add(xtime,  *ts);
> 	if (!timespec_valid_strict(&tmp)) {
> 		ret = -EINVAL;
> 		goto error;
> 	}
> 
415,419c439,440
< 	timekeeper.ntp_error = 0;
< 	ntp_clear();
< 
< 	update_vsyscall(&xtime, &wall_to_monotonic, timekeeper.clock,
< 				timekeeper.mult);
---
> error: /* even if we error out, we forwarded the time, so call update */
> 	timekeeping_update(true);
426c447
< 	return 0;
---
> 	return ret;
572a594,600
> 	if (!timespec_valid_strict(&now)) {
> 		pr_warn("WARNING: Persistent clock returned invalid value!\n"
> 			"         Check your CMOS/BIOS settings.\n");
> 		now.tv_sec = 0;
> 		now.tv_nsec = 0;
> 	}
> 
573a602,607
> 	if (!timespec_valid_strict(&boot)) {
> 		pr_warn("WARNING: Boot clock returned invalid value!\n"
> 			"         Check your CMOS/BIOS settings.\n");
> 		boot.tv_sec = 0;
> 		boot.tv_nsec = 0;
> 	}
593a628
> 	update_rt_offset();
601a637,642
> static void update_sleep_time(struct timespec t)
> {
> 	total_sleep_time = t;
> 	offs_boot = timespec_to_ktime(t);
> }
> 
610a652,657
> 	if (!timespec_valid_strict(delta)) {
> 		printk(KERN_WARNING "__timekeeping_inject_sleeptime: Invalid "
> 					"sleep delta value!\n");
> 		return;
> 	}
> 
613c660
< 	total_sleep_time = timespec_add(total_sleep_time, *delta);
---
> 	update_sleep_time(timespec_add(total_sleep_time, *delta));
642,645c689
< 	timekeeper.ntp_error = 0;
< 	ntp_clear();
< 	update_vsyscall(&xtime, &wall_to_monotonic, timekeeper.clock,
< 				timekeeper.mult);
---
> 	timekeeping_update(true);
679a724
> 	timekeeping_update(false);
830a876
> 		int leap;
833c879,883
< 		second_overflow();
---
> 		leap = second_overflow(xtime.tv_sec);
> 		xtime.tv_sec += leap;
> 		wall_to_monotonic.tv_sec -= leap;
> 		if (leap)
> 			clock_was_set_delayed();
877a928,931
> 	/* Check if there's really nothing to do */
> 	if (offset < timekeeper.cycle_interval)
> 		return;
> 
938a993
> 		int leap;
941c996,1000
< 		second_overflow();
---
> 		leap = second_overflow(xtime.tv_sec);
> 		xtime.tv_sec += leap;
> 		wall_to_monotonic.tv_sec -= leap;
> 		if (leap)
> 			clock_was_set_delayed();
944,946c1003
< 	/* check to see if there is a new clocksource to use */
< 	update_vsyscall(&xtime, &wall_to_monotonic, timekeeper.clock,
< 				timekeeper.mult);
---
> 	timekeeping_update(false);
999c1056
< 			ts->tv_nsec + tomono.tv_nsec + sleep.tv_nsec + nsecs);
---
> 		(s64)ts->tv_nsec + tomono.tv_nsec + sleep.tv_nsec + nsecs);
1103a1161,1194
> 
> #ifdef CONFIG_HIGH_RES_TIMERS
> /**
>  * ktime_get_update_offsets - hrtimer helper
>  * @real:	pointer to storage for monotonic -> realtime offset
>  * @_boot:	pointer to storage for monotonic -> boottime offset
>  *
>  * Returns current monotonic time and updates the offsets
>  * Called from hrtimer_interupt() or retrigger_next_event()
>  */
> ktime_t ktime_get_update_offsets(ktime_t *real, ktime_t *boot)
> {
> 	ktime_t now;
> 	unsigned int seq;
> 	u64 secs, nsecs;
> 
> 	do {
> 		seq = read_seqbegin(&xtime_lock);
> 
> 		secs = xtime.tv_sec;
> 		nsecs = xtime.tv_nsec;
> 		nsecs += timekeeping_get_ns();
> 		/* If arch requires, add in gettimeoffset() */
> 		nsecs += arch_gettimeoffset();
> 
> 		*real = offs_real;
> 		*boot = offs_boot;
> 	} while (read_seqretry(&xtime_lock, seq));
> 
> 	now = ktime_add_ns(ktime_set(secs, 0), nsecs);
> 	now = ktime_sub(now, *real);
> 	return now;
> }
> #endif




diff -r linux-3.0.36/kernel/timeconst.pl linux-3.0.36-lenovo/kernel/timeconst.pl
373c373
< 	if (!defined(@val)) {
---
> 	if (! @val ) {




diff -r linux-3.0.36/kernel/timer.c linux-3.0.36-lenovo/kernel/timer.c
65a66
> #define MAX_TVAL ((unsigned long)((1ULL << (TVR_BITS + 4*TVN_BITS)) - 1))
359,360c360,362
< 		/* If the timeout is larger than 0xffffffff on 64-bit
< 		 * architectures then we use the maximum timeout:
---
> 		/* If the timeout is larger than MAX_TVAL (on 64-bit
> 		 * architectures or with CONFIG_BASE_SMALL=1) then we
> 		 * use the maximum timeout.
362,363c364,365
< 		if (idx > 0xffffffffUL) {
< 			idx = 0xffffffffUL;
---
> 		if (idx > MAX_TVAL) {
> 			idx = MAX_TVAL;




diff -r linux-3.0.36/kernel/trace/ftrace.c linux-3.0.36-lenovo/kernel/trace/ftrace.c
2061c2061
< 	iter->flags &= ~(FTRACE_ITER_PRINTALL & FTRACE_ITER_HASH);
---
> 	iter->flags &= ~(FTRACE_ITER_PRINTALL | FTRACE_ITER_HASH);
3463c3463
< 	.priority = 0,
---
> 	.priority = INT_MAX,	/* Run before anything that can use kprobes */




diff -r linux-3.0.36/kernel/trace/ring_buffer.c linux-3.0.36-lenovo/kernel/trace/ring_buffer.c
2928a2929,2930
> 	if (!reader)
> 		goto out;




diff -r linux-3.0.36/kernel/trace/trace.c linux-3.0.36-lenovo/kernel/trace/trace.c
2434a2435
> 			ring_buffer_record_disable_cpu(global_trace.buffer, cpu);
2438a2440
> 			ring_buffer_record_enable_cpu(global_trace.buffer, cpu);




diff -r linux-3.0.36/kernel/watchdog.c linux-3.0.36-lenovo/kernel/watchdog.c
116c116
< static unsigned long get_sample_period(void)
---
> static u64 get_sample_period(void)
124c124
< 	return get_softlockup_thresh() * (NSEC_PER_SEC / 5);
---
> 	return get_softlockup_thresh() * ((u64)NSEC_PER_SEC / 5);




diff -r linux-3.0.36/kernel/workqueue.c linux-3.0.36-lenovo/kernel/workqueue.c
1148,1149c1148,1149
< 		BUG_ON(timer_pending(timer));
< 		BUG_ON(!list_empty(&work->entry));
---
> 		WARN_ON_ONCE(timer_pending(timer));
> 		WARN_ON_ONCE(!list_empty(&work->entry));
1870a1871
> 	smp_wmb();	/* paired with test_and_set_bit(PENDING) */
1871a1873
> 
2045c2047,2048
< 	if (kthread_should_stop())
---
> 	if (kthread_should_stop()) {
> 		__set_current_state(TASK_RUNNING);
2046a2050
> 	}
3414a3419
> 		unsigned long worker_flags = worker->flags;
3419c3424,3425
< 		 * rebinding is scheduled.
---
> 		 * rebinding is scheduled.  The morphing should
> 		 * be atomic.
3421,3422c3427,3429
< 		worker->flags |= WORKER_REBIND;
< 		worker->flags &= ~WORKER_ROGUE;
---
> 		worker_flags |= WORKER_REBIND;
> 		worker_flags &= ~WORKER_ROGUE;
> 		ACCESS_ONCE(worker->flags) = worker_flags;
3563a3571,3605
> /*
>  * Workqueues should be brought up before normal priority CPU notifiers.
>  * This will be registered high priority CPU notifier.
>  */
> static int __devinit workqueue_cpu_up_callback(struct notifier_block *nfb,
> 					       unsigned long action,
> 					       void *hcpu)
> {
> 	switch (action & ~CPU_TASKS_FROZEN) {
> 	case CPU_UP_PREPARE:
> 	case CPU_UP_CANCELED:
> 	case CPU_DOWN_FAILED:
> 	case CPU_ONLINE:
> 		return workqueue_cpu_callback(nfb, action, hcpu);
> 	}
> 	return NOTIFY_OK;
> }
> 
> /*
>  * Workqueues should be brought down after normal priority CPU notifiers.
>  * This will be registered as low priority CPU notifier.
>  */
> static int __devinit workqueue_cpu_down_callback(struct notifier_block *nfb,
> 						 unsigned long action,
> 						 void *hcpu)
> {
> 	switch (action & ~CPU_TASKS_FROZEN) {
> 	case CPU_DOWN_PREPARE:
> 	case CPU_DYING:
> 	case CPU_POST_DEAD:
> 		return workqueue_cpu_callback(nfb, action, hcpu);
> 	}
> 	return NOTIFY_OK;
> }
> 
3567c3609
< 	struct completion completion;
---
> 	struct work_struct work;
3573c3615
< static int do_work_for_cpu(void *_wfc)
---
> static void work_for_cpu_fn(struct work_struct *work)
3575c3617,3618
< 	struct work_for_cpu *wfc = _wfc;
---
> 	struct work_for_cpu *wfc = container_of(work, struct work_for_cpu, work);
> 
3577,3578d3619
< 	complete(&wfc->completion);
< 	return 0;
3593,3598c3634
< 	struct task_struct *sub_thread;
< 	struct work_for_cpu wfc = {
< 		.completion = COMPLETION_INITIALIZER_ONSTACK(wfc.completion),
< 		.fn = fn,
< 		.arg = arg,
< 	};
---
> 	struct work_for_cpu wfc = { .fn = fn, .arg = arg };
3600,3605c3636,3638
< 	sub_thread = kthread_create(do_work_for_cpu, &wfc, "work_for_cpu");
< 	if (IS_ERR(sub_thread))
< 		return PTR_ERR(sub_thread);
< 	kthread_bind(sub_thread, cpu);
< 	wake_up_process(sub_thread);
< 	wait_for_completion(&wfc.completion);
---
> 	INIT_WORK_ONSTACK(&wfc.work, work_for_cpu_fn);
> 	schedule_work_on(cpu, &wfc.work);
> 	flush_work(&wfc.work);
3757c3790,3791
< 	cpu_notifier(workqueue_cpu_callback, CPU_PRI_WORKQUEUE);
---
> 	cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP);
> 	cpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN);




diff -r linux-3.0.36/lib/gcd.c linux-3.0.36-lenovo/lib/gcd.c
11a12,14
> 
> 	if (!b)
> 		return a;




diff -r linux-3.0.36/lib/genalloc.c linux-3.0.36-lenovo/lib/genalloc.c
60c60
< 				(nbits + BITS_PER_BYTE - 1) / BITS_PER_BYTE;
---
> 				BITS_TO_LONGS(nbits) * sizeof(long);




diff -r linux-3.0.36/lib/Kconfig.debug linux-3.0.36-lenovo/lib/Kconfig.debug
670c670
< 	bool
---
> 	bool "Stacktrace"
671a672
> 	default y




diff -r linux-3.0.36/lib/plist.c linux-3.0.36-lenovo/lib/plist.c
59,63d58
< 	WARN_ON(head != &test_head && !head->rawlock && !head->spinlock);
< 	if (head->rawlock)
< 		WARN_ON_SMP(!raw_spin_is_locked(head->rawlock));
< 	if (head->spinlock)
< 		WARN_ON_SMP(!spin_is_locked(head->spinlock));
183c178
< 	plist_head_init(&test_head, NULL);
---
> 	plist_head_init(&test_head);




diff -r linux-3.0.36/MAINTAINERS linux-3.0.36-lenovo/MAINTAINERS
2494c2494
< M:	Stephen Hemminger <shemminger@linux-foundation.org>
---
> M:	Stephen Hemminger <stephen@networkplumber.org>
4330c4330
< M:	Stephen Hemminger <shemminger@linux-foundation.org>
---
> M:	Stephen Hemminger <stephen@networkplumber.org>
5250c5250
< M:	Matt Mackall <mpm@selenic.com>
---
> M:	Theodore Ts'o" <tytso@mit.edu>
5782c5782
< M:	Stephen Hemminger <shemminger@linux-foundation.org>
---
> M:	Stephen Hemminger <stephen@networkplumber.org>
6359a6360,6366
> 
> UHID USERSPACE HID IO DRIVER:
> M:	David Herrmann <dh.herrmann@googlemail.com>
> L:	linux-input@vger.kernel.org
> S:	Maintained
> F:	drivers/hid/uhid.c
> F:	include/linux/uhid.h




diff -r linux-3.0.36/Makefile linux-3.0.36-lenovo/Makefile
195c195,205
< ARCH		?= $(SUBARCH)
---
> #ARCH		?= $(SUBARCH)
> ARCH		?= arm
> ifneq ($(wildcard ../toolchain/arm-eabi-4.4.3),)
> CROSS_COMPILE	?= ../toolchain/arm-eabi-4.4.3/bin/arm-eabi-
> endif
> ifneq ($(wildcard ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3),)
> CROSS_COMPILE	?= ../prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/arm-eabi-
> endif
> ifneq ($(wildcard ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6),)
> CROSS_COMPILE   ?= ../prebuilts/gcc/linux-x86/arm/arm-eabi-4.6/bin/arm-eabi-
> endif
331a342,344
> ifneq ($(wildcard $(CROSS_COMPILE)ld.bfd),)
> LD		= $(CROSS_COMPILE)ld.bfd
> else
332a346
> endif
1222c1236
< boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
---
> boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/rk*_defconfig)
1567a1582,1585
> 
> 
> %.o: %.uu prepare scripts FORCE
> 	$(Q)$(MAKE) $(build)=$(build-dir) $(target-dir)$(notdir $@)
Only in linux-3.0.36-lenovo: mkkrnlimg
Only in linux-3.0.36-lenovo/mm: ashmem.c




diff -r linux-3.0.36/mm/compaction.c linux-3.0.36-lenovo/mm/compaction.c
38,41d37
< 	/* Account for isolated anon and file pages */
< 	unsigned long nr_anon;
< 	unsigned long nr_file;
< 
226c222
< 	unsigned int count[NR_LRU_LISTS] = { 0, };
---
> 	unsigned int count[2] = { 0, };
228,231c224,225
< 	list_for_each_entry(page, &cc->migratepages, lru) {
< 		int lru = page_lru_base_type(page);
< 		count[lru]++;
< 	}
---
> 	list_for_each_entry(page, &cc->migratepages, lru)
> 		count[!!page_is_file_cache(page)]++;
233,236c227,228
< 	cc->nr_anon = count[LRU_ACTIVE_ANON] + count[LRU_INACTIVE_ANON];
< 	cc->nr_file = count[LRU_ACTIVE_FILE] + count[LRU_INACTIVE_FILE];
< 	__mod_zone_page_state(zone, NR_ISOLATED_ANON, cc->nr_anon);
< 	__mod_zone_page_state(zone, NR_ISOLATED_FILE, cc->nr_file);
---
> 	__mod_zone_page_state(zone, NR_ISOLATED_ANON, count[0]);
> 	__mod_zone_page_state(zone, NR_ISOLATED_FILE, count[1]);
271a264
> 	isolate_mode_t mode = ISOLATE_ACTIVE|ISOLATE_INACTIVE;
380a374,376
> 		if (!cc->sync)
> 			mode |= ISOLATE_ASYNC_MIGRATE;
> 
382c378
< 		if (__isolate_lru_page(page, ISOLATE_BOTH, 0) != 0)
---
> 		if (__isolate_lru_page(page, mode, 0) != 0)
584c580
< 				cc->sync);
---
> 				cc->sync ? MIGRATE_SYNC_LIGHT : MIGRATE_ASYNC);
598a595,598
> 			if (err == -ENOMEM) {
> 				ret = COMPACT_PARTIAL;
> 				goto out;
> 			}
600d599
< 
718c717
< static int compact_nodes(void)
---
> static void compact_nodes(void)
724,725d722
< 
< 	return COMPACT_COMPLETE;
736c733
< 		return compact_nodes();
---
> 		compact_nodes();




diff -r linux-3.0.36/mm/dmapool.c linux-3.0.36-lenovo/mm/dmapool.c
52d51
< 	wait_queue_head_t waitq;
64,65d62
< #define	POOL_TIMEOUT_JIFFIES	((100 /* msec */ * HZ) / 1000)
< 
174d170
< 	init_waitqueue_head(&retval->waitq);
229d224
< 		list_add(&page->page_list, &pool->page_list);
317d311
<  restart:
322,325d315
< 	page = pool_alloc_page(pool, GFP_ATOMIC);
< 	if (!page) {
< 		if (mem_flags & __GFP_WAIT) {
< 			DECLARE_WAITQUEUE(wait, current);
327,329c317,318
< 			__set_current_state(TASK_UNINTERRUPTIBLE);
< 			__add_wait_queue(&pool->waitq, &wait);
< 			spin_unlock_irqrestore(&pool->lock, flags);
---
> 	/* pool_alloc_page() might sleep, so temporarily drop &pool->lock */
> 	spin_unlock_irqrestore(&pool->lock, flags);
331c320,322
< 			schedule_timeout(POOL_TIMEOUT_JIFFIES);
---
> 	page = pool_alloc_page(pool, mem_flags);
> 	if (!page)
> 		return NULL;
333,339c324
< 			spin_lock_irqsave(&pool->lock, flags);
< 			__remove_wait_queue(&pool->waitq, &wait);
< 			goto restart;
< 		}
< 		retval = NULL;
< 		goto done;
< 	}
---
> 	spin_lock_irqsave(&pool->lock, flags);
340a326
> 	list_add(&page->page_list, &pool->page_list);
350d335
<  done:
437,438d421
< 	if (waitqueue_active(&pool->waitq))
< 		wake_up_locked(&pool->waitq);




diff -r linux-3.0.36/mm/filemap.c linux-3.0.36-lenovo/mm/filemap.c
519,522c519,525
< 		get_mems_allowed();
< 		n = cpuset_mem_spread_node();
< 		page = alloc_pages_exact_node(n, gfp, 0);
< 		put_mems_allowed();
---
> 		unsigned int cpuset_mems_cookie;
> 		do {
> 			cpuset_mems_cookie = get_mems_allowed();
> 			n = cpuset_mem_spread_node();
> 			page = alloc_pages_exact_node(n, gfp, 0);
> 		} while (!put_mems_allowed(cpuset_mems_cookie) && !page);
> 




diff -r linux-3.0.36/mm/huge_memory.c linux-3.0.36-lenovo/mm/huge_memory.c
922a923,924
> 		if (ret & VM_FAULT_OOM)
> 			split_huge_page(page);
929a932
> 		split_huge_page(page);




diff -r linux-3.0.36/mm/hugetlb.c linux-3.0.36-lenovo/mm/hugetlb.c
462a463
> 	unsigned int cpuset_mems_cookie;
464c465,466
< 	get_mems_allowed();
---
> retry_cpuset:
> 	cpuset_mems_cookie = get_mems_allowed();
491c493
< err:
---
> 
493c495,496
< 	put_mems_allowed();
---
> 	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 		goto retry_cpuset;
494a498,501
> 
> err:
> 	mpol_cond_put(mpol);
> 	return NULL;
2296a2304,2319
> 	/*
> 	 * Clear this flag so that x86's huge_pmd_share page_table_shareable
> 	 * test will fail on a vma being torn down, and not grab a page table
> 	 * on its way out.  We're lucky that the flag has such an appropriate
> 	 * name, and can in fact be safely cleared here. We could clear it
> 	 * before the __unmap_hugepage_range above, but all that's necessary
> 	 * is to clear it before releasing the i_mmap_mutex below.
> 	 *
> 	 * This works because in the contexts this is called, the VMA is
> 	 * going to be destroyed. It is not vunerable to madvise(DONTNEED)
> 	 * because madvise is not supported on hugetlbfs. The same applies
> 	 * for direct IO. unmap_hugepage_range() is only being called just
> 	 * before free_pgtables() so clearing VM_MAYSHARE will not cause
> 	 * surprises later.
> 	 */
> 	vma->vm_flags &= ~VM_MAYSHARE;
2849,2850c2872,2877
< 	mutex_unlock(&vma->vm_file->f_mapping->i_mmap_mutex);
< 
---
> 	/*
> 	 * Must flush TLB before releasing i_mmap_mutex: x86's huge_pmd_unshare
> 	 * may have cleared our pud entry and done put_page on the page table:
> 	 * once we release i_mmap_mutex, another task can do the final put_page
> 	 * and that page table be reused and filled with junk.
> 	 */
2851a2879
> 	mutex_unlock(&vma->vm_file->f_mapping->i_mmap_mutex);




diff -r linux-3.0.36/mm/madvise.c linux-3.0.36-lenovo/mm/madvise.c
15a16
> #include <linux/file.h>
199a201
> 	struct file *f;
206,207c208,210
< 	if (!vma->vm_file || !vma->vm_file->f_mapping
< 		|| !vma->vm_file->f_mapping->host) {
---
> 	f = vma->vm_file;
> 
> 	if (!f || !f->f_mapping || !f->f_mapping->host) {
221c224,230
< 	/* vmtruncate_range needs to take i_mutex and i_alloc_sem */
---
> 	/*
> 	 * vmtruncate_range may need to take i_mutex and i_alloc_sem.
> 	 * We need to explicitly grab a reference because the vma (and
> 	 * hence the vma's reference to the file) can go away as soon as
> 	 * we drop mmap_sem.
> 	 */
> 	get_file(f);
223a233
> 	fput(f);




diff -r linux-3.0.36/mm/Makefile linux-3.0.36-lenovo/mm/Makefile
32a33
> obj-$(CONFIG_ASHMEM) += ashmem.o




diff -r linux-3.0.36/mm/memcontrol.c linux-3.0.36-lenovo/mm/memcontrol.c
1254c1254,1255
< 					int mode, struct zone *z,
---
> 					isolate_mode_t mode,
> 					struct zone *z,




diff -r linux-3.0.36/mm/memory.c linux-3.0.36-lenovo/mm/memory.c
207a208,210
> 	if (tlb->batch_count == MAX_GATHER_BATCH_COUNT)
> 		return 0;
> 
211a215
> 	tlb->batch_count++;
237a242
> 	tlb->batch_count = 0;
3467a3473
> retry:
3480a3487,3488
> 		int ret;
> 
3485,3487c3493,3504
< 			    !pmd_trans_splitting(orig_pmd))
< 				return do_huge_pmd_wp_page(mm, vma, address,
< 							   pmd, orig_pmd);
---
> 			    !pmd_trans_splitting(orig_pmd)) {
> 				ret = do_huge_pmd_wp_page(mm, vma, address, pmd,
> 							  orig_pmd);
> 				/*
> 				 * If COW results in an oom, the huge pmd will
> 				 * have been split, so retry the fault on the
> 				 * pte for a smaller charge.
> 				 */
> 				if (unlikely(ret & VM_FAULT_OOM))
> 					goto retry;
> 				return ret;
> 			}




diff -r linux-3.0.36/mm/memory-failure.c linux-3.0.36-lenovo/mm/memory-failure.c
1337,1338c1337,1338
< 	ret = migrate_huge_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL, 0,
< 				true);
---
> 	ret = migrate_huge_pages(&pagelist, new_page, MPOL_MF_MOVE_ALL, false,
> 				MIGRATE_SYNC);
1384a1385
> 	struct page *hpage = compound_trans_head(page);
1387a1389,1395
> 	if (PageTransHuge(hpage)) {
> 		if (PageAnon(hpage) && unlikely(split_huge_page(hpage))) {
> 			pr_info("soft offline: %#lx: failed to split THP\n",
> 				pfn);
> 			return -EBUSY;
> 		}
> 	}
1467c1475
< 								0, true);
---
> 							false, MIGRATE_SYNC);




diff -r linux-3.0.36/mm/memory_hotplug.c linux-3.0.36-lenovo/mm/memory_hotplug.c
119,121d118
< 	if (!pfn_valid(start_pfn))
< 		return;
< 
180,182c177,186
< 	for (; pfn < end_pfn; pfn += PAGES_PER_SECTION)
< 		register_page_bootmem_info_section(pfn);
< 
---
> 	for (; pfn < end_pfn; pfn += PAGES_PER_SECTION) {
> 		/*
> 		 * Some platforms can assign the same pfn to multiple nodes - on
> 		 * node0 as well as nodeN.  To avoid registering a pfn against
> 		 * multiple nodes we check that this pfn does not already
> 		 * reside in some other node.
> 		 */
> 		if (pfn_valid(pfn) && (pfn_to_nid(pfn) == node))
> 			register_page_bootmem_info_section(pfn);
> 	}
750c754
< 								true, true);
---
> 							true, MIGRATE_SYNC);




diff -r linux-3.0.36/mm/mempolicy.c linux-3.0.36-lenovo/mm/mempolicy.c
608a609,644
> /*
>  * Apply policy to a single VMA
>  * This must be called with the mmap_sem held for writing.
>  */
> static int vma_replace_policy(struct vm_area_struct *vma,
> 						struct mempolicy *pol)
> {
> 	int err;
> 	struct mempolicy *old;
> 	struct mempolicy *new;
> 
> 	pr_debug("vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\n",
> 		 vma->vm_start, vma->vm_end, vma->vm_pgoff,
> 		 vma->vm_ops, vma->vm_file,
> 		 vma->vm_ops ? vma->vm_ops->set_policy : NULL);
> 
> 	new = mpol_dup(pol);
> 	if (IS_ERR(new))
> 		return PTR_ERR(new);
> 
> 	if (vma->vm_ops && vma->vm_ops->set_policy) {
> 		err = vma->vm_ops->set_policy(vma, new);
> 		if (err)
> 			goto err_out;
> 	}
> 
> 	old = vma->vm_policy;
> 	vma->vm_policy = new; /* protected by mmap_sem */
> 	mpol_put(old);
> 
> 	return 0;
>  err_out:
> 	mpol_put(new);
> 	return err;
> }
> 
648,664c684,686
< 
< 		/*
< 		 * Apply policy to a single VMA. The reference counting of
< 		 * policy for vma_policy linkages has already been handled by
< 		 * vma_merge and split_vma as necessary. If this is a shared
< 		 * policy then ->set_policy will increment the reference count
< 		 * for an sp node.
< 		 */
< 		pr_debug("vma %lx-%lx/%lx vm_ops %p vm_file %p set_policy %p\n",
< 			vma->vm_start, vma->vm_end, vma->vm_pgoff,
< 			vma->vm_ops, vma->vm_file,
< 			vma->vm_ops ? vma->vm_ops->set_policy : NULL);
< 		if (vma->vm_ops && vma->vm_ops->set_policy) {
< 			err = vma->vm_ops->set_policy(vma, new_pol);
< 			if (err)
< 				goto out;
< 		}
---
> 		err = vma_replace_policy(vma, new_pol);
> 		if (err)
> 			goto out;
929c951
< 								false, true);
---
> 							false, MIGRATE_SYNC);
1492c1514
< 		} else if (vma->vm_policy)
---
> 		} else if (vma->vm_policy) {
1493a1516,1525
> 
> 			/*
> 			 * shmem_alloc_page() passes MPOL_F_SHARED policy with
> 			 * a pseudo vma whose vma->vm_ops=NULL. Take a reference
> 			 * count on these policies which will be dropped by
> 			 * mpol_cond_put() later
> 			 */
> 			if (mpol_needs_cond_ref(pol))
> 				mpol_get(pol);
> 		}
1813c1845
< 	struct mempolicy *pol = get_vma_policy(current, vma, addr);
---
> 	struct mempolicy *pol;
1815a1848,1852
> 	unsigned int cpuset_mems_cookie;
> 
> retry_cpuset:
> 	pol = get_vma_policy(current, vma, addr);
> 	cpuset_mems_cookie = get_mems_allowed();
1817d1853
< 	get_mems_allowed();
1824c1860,1862
< 		put_mems_allowed();
---
> 		if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 			goto retry_cpuset;
> 
1835c1873,1874
< 		put_mems_allowed();
---
> 		if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 			goto retry_cpuset;
1843c1882,1883
< 	put_mems_allowed();
---
> 	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 		goto retry_cpuset;
1869a1910
> 	unsigned int cpuset_mems_cookie;
1874c1915,1917
< 	get_mems_allowed();
---
> retry_cpuset:
> 	cpuset_mems_cookie = get_mems_allowed();
> 
1885c1928,1931
< 	put_mems_allowed();
---
> 
> 	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 		goto retry_cpuset;
> 
1930,1951d1975
< /*
<  * If *frompol needs [has] an extra ref, copy *frompol to *tompol ,
<  * eliminate the * MPOL_F_* flags that require conditional ref and
<  * [NOTE!!!] drop the extra ref.  Not safe to reference *frompol directly
<  * after return.  Use the returned value.
<  *
<  * Allows use of a mempolicy for, e.g., multiple allocations with a single
<  * policy lookup, even if the policy needs/has extra ref on lookup.
<  * shmem_readahead needs this.
<  */
< struct mempolicy *__mpol_cond_copy(struct mempolicy *tompol,
< 						struct mempolicy *frompol)
< {
< 	if (!mpol_needs_cond_ref(frompol))
< 		return frompol;
< 
< 	*tompol = *frompol;
< 	tompol->flags &= ~MPOL_F_SHARED;	/* copy doesn't need unref */
< 	__mpol_put(frompol);
< 	return tompol;
< }
< 
1988c2012
< /* Caller holds sp->lock */
---
> /* Caller holds sp->mutex */
2052c2076
< 	spin_lock(&sp->lock);
---
> 	mutex_lock(&sp->mutex);
2058c2082
< 	spin_unlock(&sp->lock);
---
> 	mutex_unlock(&sp->mutex);
2061a2086,2091
> static void sp_free(struct sp_node *n)
> {
> 	mpol_put(n->policy);
> 	kmem_cache_free(sn_cache, n);
> }
> 
2066,2067c2096
< 	mpol_put(n->policy);
< 	kmem_cache_free(sn_cache, n);
---
> 	sp_free(n);
2073c2102,2103
< 	struct sp_node *n = kmem_cache_alloc(sn_cache, GFP_KERNEL);
---
> 	struct sp_node *n;
> 	struct mempolicy *newpol;
2074a2105
> 	n = kmem_cache_alloc(sn_cache, GFP_KERNEL);
2076a2108,2115
> 
> 	newpol = mpol_dup(pol);
> 	if (IS_ERR(newpol)) {
> 		kmem_cache_free(sn_cache, n);
> 		return NULL;
> 	}
> 	newpol->flags |= MPOL_F_SHARED;
> 
2079,2081c2118,2119
< 	mpol_get(pol);
< 	pol->flags |= MPOL_F_SHARED;	/* for unref */
< 	n->policy = pol;
---
> 	n->policy = newpol;
> 
2089c2127,2128
< 	struct sp_node *n, *new2 = NULL;
---
> 	struct sp_node *n;
> 	int ret = 0;
2091,2092c2130
< restart:
< 	spin_lock(&sp->lock);
---
> 	mutex_lock(&sp->mutex);
2104a2143,2144
> 				struct sp_node *new2;
> 				new2 = sp_alloc(end, n->end, n->policy);
2106,2110c2146,2147
< 					spin_unlock(&sp->lock);
< 					new2 = sp_alloc(end, n->end, n->policy);
< 					if (!new2)
< 						return -ENOMEM;
< 					goto restart;
---
> 					ret = -ENOMEM;
> 					goto out;
2114d2150
< 				new2 = NULL;
2125,2130c2161,2163
< 	spin_unlock(&sp->lock);
< 	if (new2) {
< 		mpol_put(new2->policy);
< 		kmem_cache_free(sn_cache, new2);
< 	}
< 	return 0;
---
> out:
> 	mutex_unlock(&sp->mutex);
> 	return ret;
2148c2181
< 	spin_lock_init(&sp->lock);
---
> 	mutex_init(&sp->mutex);
2202c2235
< 		kmem_cache_free(sn_cache, new);
---
> 		sp_free(new);
2214c2247
< 	spin_lock(&p->lock);
---
> 	mutex_lock(&p->mutex);
2219,2221c2252
< 		rb_erase(&n->nd, &p->root);
< 		mpol_put(n->policy);
< 		kmem_cache_free(sn_cache, n);
---
> 		sp_delete(p, n);
2223c2254
< 	spin_unlock(&p->lock);
---
> 	mutex_unlock(&p->mutex);
2280,2281c2311
<  * "local" is pseudo-policy:  MPOL_PREFERRED with MPOL_F_LOCAL flag
<  * Used only for mpol_parse_str() and mpol_to_str()
---
>  * "local" is implemented internally by MPOL_PREFERRED with MPOL_F_LOCAL flag.
2296c2326
<  * mpol_parse_str - parse string to mempolicy
---
>  * mpol_parse_str - parse string to mempolicy, for tmpfs mpol mount option.
2299c2329
<  * @no_context:  flag whether to "contextualize" the mempolicy
---
>  * @unused:  redundant argument, to be removed later.
2304,2310d2333
<  * if @no_context is true, save the input nodemask in w.user_nodemask in
<  * the returned mempolicy.  This will be used to "clone" the mempolicy in
<  * a specific context [cpuset] at a later time.  Used to parse tmpfs mpol
<  * mount option.  Note that if 'static' or 'relative' mode flags were
<  * specified, the input nodemask will already have been saved.  Saving
<  * it again is redundant, but safe.
<  *
2313c2336
< int mpol_parse_str(char *str, struct mempolicy **mpol, int no_context)
---
> int mpol_parse_str(char *str, struct mempolicy **mpol, int unused)
2317c2340
< 	unsigned short uninitialized_var(mode_flags);
---
> 	unsigned short mode_flags;
2405,2422c2428,2444
< 	if (no_context) {
< 		/* save for contextualization */
< 		new->w.user_nodemask = nodes;
< 	} else {
< 		int ret;
< 		NODEMASK_SCRATCH(scratch);
< 		if (scratch) {
< 			task_lock(current);
< 			ret = mpol_set_nodemask(new, &nodes, scratch);
< 			task_unlock(current);
< 		} else
< 			ret = -ENOMEM;
< 		NODEMASK_SCRATCH_FREE(scratch);
< 		if (ret) {
< 			mpol_put(new);
< 			goto out;
< 		}
< 	}
---
> 	/*
> 	 * Save nodes for mpol_to_str() to show the tmpfs mount options
> 	 * for /proc/mounts, /proc/pid/mounts and /proc/pid/mountinfo.
> 	 */
> 	if (mode != MPOL_PREFERRED)
> 		new->v.nodes = nodes;
> 	else if (nodelist)
> 		new->v.preferred_node = first_node(nodes);
> 	else
> 		new->flags |= MPOL_F_LOCAL;
> 
> 	/*
> 	 * Save nodes for contextualization: this will be used to "clone"
> 	 * the mempolicy in a specific context [cpuset] at a later time.
> 	 */
> 	new->w.user_nodemask = nodes;
> 
2442c2464
<  * @no_context:  "context free" mempolicy - use nodemask in w.user_nodemask
---
>  * @unused:  redundant argument, to be removed later.
2448c2470
< int mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol, int no_context)
---
> int mpol_to_str(char *buffer, int maxlen, struct mempolicy *pol, int unused)
2474c2496
< 			mode = MPOL_LOCAL;	/* pseudo-policy */
---
> 			mode = MPOL_LOCAL;
2482,2485c2504
< 		if (no_context)
< 			nodes = pol->w.user_nodemask;
< 		else
< 			nodes = pol->v.nodes;
---
> 		nodes = pol->v.nodes;
2489c2508
< 		BUG();
---
> 		return -EINVAL;




diff -r linux-3.0.36/mm/migrate.c linux-3.0.36-lenovo/mm/migrate.c
222a223,272
> #ifdef CONFIG_BLOCK
> /* Returns true if all buffers are successfully locked */
> static bool buffer_migrate_lock_buffers(struct buffer_head *head,
> 							enum migrate_mode mode)
> {
> 	struct buffer_head *bh = head;
> 
> 	/* Simple case, sync compaction */
> 	if (mode != MIGRATE_ASYNC) {
> 		do {
> 			get_bh(bh);
> 			lock_buffer(bh);
> 			bh = bh->b_this_page;
> 
> 		} while (bh != head);
> 
> 		return true;
> 	}
> 
> 	/* async case, we cannot block on lock_buffer so use trylock_buffer */
> 	do {
> 		get_bh(bh);
> 		if (!trylock_buffer(bh)) {
> 			/*
> 			 * We failed to lock the buffer and cannot stall in
> 			 * async migration. Release the taken locks
> 			 */
> 			struct buffer_head *failed_bh = bh;
> 			put_bh(failed_bh);
> 			bh = head;
> 			while (bh != failed_bh) {
> 				unlock_buffer(bh);
> 				put_bh(bh);
> 				bh = bh->b_this_page;
> 			}
> 			return false;
> 		}
> 
> 		bh = bh->b_this_page;
> 	} while (bh != head);
> 	return true;
> }
> #else
> static inline bool buffer_migrate_lock_buffers(struct buffer_head *head,
> 							enum migrate_mode mode)
> {
> 	return true;
> }
> #endif /* CONFIG_BLOCK */
> 
232c282,283
< 		struct page *newpage, struct page *page)
---
> 		struct page *newpage, struct page *page,
> 		struct buffer_head *head, enum migrate_mode mode)
261a313,326
> 	 * In the async migration case of moving a page with buffers, lock the
> 	 * buffers using trylock before the mapping is moved. If the mapping
> 	 * was moved, we later failed to lock the buffers and could not move
> 	 * the mapping back due to an elevated page count, we would have to
> 	 * block waiting on other references to be dropped.
> 	 */
> 	if (mode == MIGRATE_ASYNC && head &&
> 			!buffer_migrate_lock_buffers(head, mode)) {
> 		page_unfreeze_refs(page, expected_count);
> 		spin_unlock_irq(&mapping->tree_lock);
> 		return -EAGAIN;
> 	}
> 
> 	/*
418c483,484
< 		struct page *newpage, struct page *page)
---
> 		struct page *newpage, struct page *page,
> 		enum migrate_mode mode)
424c490
< 	rc = migrate_page_move_mapping(mapping, newpage, page);
---
> 	rc = migrate_page_move_mapping(mapping, newpage, page, NULL, mode);
441c507
< 		struct page *newpage, struct page *page)
---
> 		struct page *newpage, struct page *page, enum migrate_mode mode)
447c513
< 		return migrate_page(mapping, newpage, page);
---
> 		return migrate_page(mapping, newpage, page, mode);
451c517
< 	rc = migrate_page_move_mapping(mapping, newpage, page);
---
> 	rc = migrate_page_move_mapping(mapping, newpage, page, head, mode);
456,462c522,528
< 	bh = head;
< 	do {
< 		get_bh(bh);
< 		lock_buffer(bh);
< 		bh = bh->b_this_page;
< 
< 	} while (bh != head);
---
> 	/*
> 	 * In the async case, migrate_page_move_mapping locked the buffers
> 	 * with an IRQ-safe spinlock held. In the sync case, the buffers
> 	 * need to be locked now
> 	 */
> 	if (mode != MIGRATE_ASYNC)
> 		BUG_ON(!buffer_migrate_lock_buffers(head, mode));
539c605
< 	struct page *newpage, struct page *page)
---
> 	struct page *newpage, struct page *page, enum migrate_mode mode)
541c607,610
< 	if (PageDirty(page))
---
> 	if (PageDirty(page)) {
> 		/* Only writeback pages in full synchronous migration */
> 		if (mode != MIGRATE_SYNC)
> 			return -EBUSY;
542a612
> 	}
552c622
< 	return migrate_page(mapping, newpage, page);
---
> 	return migrate_page(mapping, newpage, page, mode);
567c637
< 					int remap_swapcache, bool sync)
---
> 				int remap_swapcache, enum migrate_mode mode)
588,589c658,659
< 		rc = migrate_page(mapping, newpage, page);
< 	else {
---
> 		rc = migrate_page(mapping, newpage, page, mode);
> 	else if (mapping->a_ops->migratepage)
591,593c661,664
< 		 * Do not writeback pages if !sync and migratepage is
< 		 * not pointing to migrate_page() which is nonblocking
< 		 * (swapcache/tmpfs uses migratepage = migrate_page).
---
> 		 * Most pages have a mapping and most filesystems provide a
> 		 * migratepage callback. Anonymous pages are part of swap
> 		 * space which also has its own migratepage callback. This
> 		 * is the most common path for page migration.
595,610c666,669
< 		if (PageDirty(page) && !sync &&
< 		    mapping->a_ops->migratepage != migrate_page)
< 			rc = -EBUSY;
< 		else if (mapping->a_ops->migratepage)
< 			/*
< 			 * Most pages have a mapping and most filesystems
< 			 * should provide a migration function. Anonymous
< 			 * pages are part of swap space which also has its
< 			 * own migration function. This is the most common
< 			 * path for page migration.
< 			 */
< 			rc = mapping->a_ops->migratepage(mapping,
< 							newpage, page);
< 		else
< 			rc = fallback_migrate_page(mapping, newpage, page);
< 	}
---
> 		rc = mapping->a_ops->migratepage(mapping,
> 						newpage, page, mode);
> 	else
> 		rc = fallback_migrate_page(mapping, newpage, page, mode);
624,629c683,684
< /*
<  * Obtain the lock on page, remove all ptes and migrate the page
<  * to the newly allocated page in newpage.
<  */
< static int unmap_and_move(new_page_t get_new_page, unsigned long private,
< 			struct page *page, int force, bool offlining, bool sync)
---
> static int __unmap_and_move(struct page *page, struct page *newpage,
> 			int force, bool offlining, enum migrate_mode mode)
631,633c686
< 	int rc = 0;
< 	int *result = NULL;
< 	struct page *newpage = get_new_page(page, private, &result);
---
> 	int rc = -EAGAIN;
639,652d691
< 	if (!newpage)
< 		return -ENOMEM;
< 
< 	if (page_count(page) == 1) {
< 		/* page was freed from under us. So we are done. */
< 		goto move_newpage;
< 	}
< 	if (unlikely(PageTransHuge(page)))
< 		if (unlikely(split_huge_page(page)))
< 			goto move_newpage;
< 
< 	/* prepare cgroup just returns 0 or -ENOMEM */
< 	rc = -EAGAIN;
< 
654,655c693,694
< 		if (!force || !sync)
< 			goto move_newpage;
---
> 		if (!force || mode == MIGRATE_ASYNC)
> 			goto out;
671c710
< 			goto move_newpage;
---
> 			goto out;
700,701c739,742
< 		 * For !sync, there is no point retrying as the retry loop
< 		 * is expected to be too short for PageWriteback to be cleared
---
> 		 * Only in the case of a full syncronous migration is it
> 		 * necessary to wait for PageWriteback. In the async case,
> 		 * the retry loop is too short and in the sync-light case,
> 		 * the overhead of stalling is too much
703c744
< 		if (!sync) {
---
> 		if (mode != MIGRATE_SYNC) {
774c815
< 		rc = move_to_new_page(newpage, page, remap_swapcache, sync);
---
> 		rc = move_to_new_page(newpage, page, remap_swapcache, mode);
787a829,831
> out:
> 	return rc;
> }
789c833,858
< move_newpage:
---
> /*
>  * Obtain the lock on page, remove all ptes and migrate the page
>  * to the newly allocated page in newpage.
>  */
> static int unmap_and_move(new_page_t get_new_page, unsigned long private,
> 			struct page *page, int force, bool offlining,
> 			enum migrate_mode mode)
> {
> 	int rc = 0;
> 	int *result = NULL;
> 	struct page *newpage = get_new_page(page, private, &result);
> 
> 	if (!newpage)
> 		return -ENOMEM;
> 
> 	if (page_count(page) == 1) {
> 		/* page was freed from under us. So we are done. */
> 		goto out;
> 	}
> 
> 	if (unlikely(PageTransHuge(page)))
> 		if (unlikely(split_huge_page(page)))
> 			goto out;
> 
> 	rc = __unmap_and_move(page, newpage, force, offlining, mode);
> out:
791,797c860,866
<  		/*
<  		 * A page that has been migrated has all references
<  		 * removed and will be freed. A page that has not been
<  		 * migrated will have kepts its references and be
<  		 * restored.
<  		 */
<  		list_del(&page->lru);
---
> 		/*
> 		 * A page that has been migrated has all references
> 		 * removed and will be freed. A page that has not been
> 		 * migrated will have kepts its references and be
> 		 * restored.
> 		 */
> 		list_del(&page->lru);
802d870
< 
808d875
< 
838c905,906
< 				int force, bool offlining, bool sync)
---
> 				int force, bool offlining,
> 				enum migrate_mode mode)
851c919
< 		if (!force || !sync)
---
> 		if (!force || mode != MIGRATE_SYNC)
862c930
< 		rc = move_to_new_page(new_hpage, hpage, 1, sync);
---
> 		rc = move_to_new_page(new_hpage, hpage, 1, mode);
905c973
< 		bool sync)
---
> 		enum migrate_mode mode)
926c994
< 						sync);
---
> 						mode);
956c1024
< 		bool sync)
---
> 		enum migrate_mode mode)
973c1041
< 					sync);
---
> 					mode);
1102c1170
< 				(unsigned long)pm, 0, true);
---
> 				(unsigned long)pm, 0, MIGRATE_SYNC);




diff -r linux-3.0.36/mm/mmu_notifier.c linux-3.0.36-lenovo/mm/mmu_notifier.c
35a36,53
> 	struct hlist_node *n;
> 
> 	/*
> 	 * RCU here will block mmu_notifier_unregister until
> 	 * ->release returns.
> 	 */
> 	rcu_read_lock();
> 	hlist_for_each_entry_rcu(mn, n, &mm->mmu_notifier_mm->list, hlist)
> 		/*
> 		 * if ->release runs before mmu_notifier_unregister it
> 		 * must be handled as it's the only way for the driver
> 		 * to flush all existing sptes and stop the driver
> 		 * from establishing any more sptes before all the
> 		 * pages in the mm are freed.
> 		 */
> 		if (mn->ops->release)
> 			mn->ops->release(mn, mm);
> 	rcu_read_unlock();
49,65d66
< 		/*
< 		 * RCU here will block mmu_notifier_unregister until
< 		 * ->release returns.
< 		 */
< 		rcu_read_lock();
< 		spin_unlock(&mm->mmu_notifier_mm->lock);
< 		/*
< 		 * if ->release runs before mmu_notifier_unregister it
< 		 * must be handled as it's the only way for the driver
< 		 * to flush all existing sptes and stop the driver
< 		 * from establishing any more sptes before all the
< 		 * pages in the mm are freed.
< 		 */
< 		if (mn->ops->release)
< 			mn->ops->release(mn, mm);
< 		rcu_read_unlock();
< 		spin_lock(&mm->mmu_notifier_mm->lock);
287d287
< 	spin_lock(&mm->mmu_notifier_mm->lock);
289,290d288
< 		hlist_del_rcu(&mn->hlist);
< 
296c294
< 		spin_unlock(&mm->mmu_notifier_mm->lock);
---
> 
305c303,305
< 	} else
---
> 
> 		spin_lock(&mm->mmu_notifier_mm->lock);
> 		hlist_del_rcu(&mn->hlist);
306a307
> 	}




diff -r linux-3.0.36/mm/page_alloc.c linux-3.0.36-lenovo/mm/page_alloc.c
129a130,143
> 
> static bool pm_suspending(void)
> {
> 	if ((gfp_allowed_mask & GFP_IOFS) == GFP_IOFS)
> 		return false;
> 	return true;
> }
> 
> #else
> 
> static bool pm_suspending(void)
> {
> 	return false;
> }
178a193
> int min_free_order_shift = 1;
543c558
< 		higher_buddy = page + (buddy_idx - combined_idx);
---
> 		higher_buddy = higher_page + (buddy_idx - combined_idx);
1490c1505
< 		min >>= 1;
---
> 		min >>= min_free_order_shift;
1900,1901c1915,1917
< 	int migratetype, unsigned long *did_some_progress,
< 	bool sync_migration)
---
> 	int migratetype, bool sync_migration,
> 	bool *deferred_compaction,
> 	unsigned long *did_some_progress)
1905c1921,1925
< 	if (!order || compaction_deferred(preferred_zone))
---
> 	if (!order)
> 		return NULL;
> 
> 	if (compaction_deferred(preferred_zone)) {
> 		*deferred_compaction = true;
1906a1927
> 	}
1935c1956,1962
< 		defer_compaction(preferred_zone);
---
> 
> 		/*
> 		 * As async compaction considers a subset of pageblocks, only
> 		 * defer if the failure was a sync compaction failure.
> 		 */
> 		if (sync_migration)
> 			defer_compaction(preferred_zone);
1947,1948c1974,1976
< 	int migratetype, unsigned long *did_some_progress,
< 	bool sync_migration)
---
> 	int migratetype, bool sync_migration,
> 	bool *deferred_compaction,
> 	unsigned long *did_some_progress)
2097a2126
> 	bool deferred_compaction = false;
2178,2179c2207,2209
< 					migratetype, &did_some_progress,
< 					sync_migration);
---
> 					migratetype, sync_migration,
> 					&deferred_compaction,
> 					&did_some_progress);
2183a2214,2222
> 	/*
> 	 * If compaction is deferred for high-order allocations, it is because
> 	 * sync compaction recently failed. In this is the case and the caller
> 	 * has requested the system not be heavily disrupted, fail the
> 	 * allocation now instead of entering direct reclaim
> 	 */
> 	if (deferred_compaction && (gfp_mask & __GFP_NO_KSWAPD))
> 		goto nopage;
> 
2227a2267,2274
> 
> 		/*
> 		 * Suspend converts GFP_KERNEL to __GFP_WAIT which can
> 		 * prevent reclaim making forward progress without
> 		 * invoking OOM. Bail if we are suspending
> 		 */
> 		if (pm_suspending())
> 			goto nopage;
2246,2247c2293,2295
< 					migratetype, &did_some_progress,
< 					sync_migration);
---
> 					migratetype, sync_migration,
> 					&deferred_compaction,
> 					&did_some_progress);
2271c2319
< 	struct page *page;
---
> 	struct page *page = NULL;
2272a2321
> 	unsigned int cpuset_mems_cookie;
2291c2340,2342
< 	get_mems_allowed();
---
> retry_cpuset:
> 	cpuset_mems_cookie = get_mems_allowed();
> 
2296,2299c2347,2348
< 	if (!preferred_zone) {
< 		put_mems_allowed();
< 		return NULL;
< 	}
---
> 	if (!preferred_zone)
> 		goto out;
2309d2357
< 	put_mems_allowed();
2311a2360,2370
> 
> out:
> 	/*
> 	 * When updating a task's mems_allowed, it is possible to race with
> 	 * parallel threads in such a way that an allocation can fail while
> 	 * the mask is being updated. If a page allocation is about to fail,
> 	 * check if the cpuset changed during allocation and if so, retry.
> 	 */
> 	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !page))
> 		goto retry_cpuset;
> 
2534a2594
> 	unsigned int cpuset_mems_cookie;
2539,2541c2599,2602
< 	get_mems_allowed();
< 	ret = !node_isset(nid, cpuset_current_mems_allowed);
< 	put_mems_allowed();
---
> 	do {
> 		cpuset_mems_cookie = get_mems_allowed();
> 		ret = !node_isset(nid, cpuset_current_mems_allowed);
> 	} while (!put_mems_allowed(cpuset_mems_cookie));
3421,3425d3481
< 		/* Blocks with reserved pages will never free, skip them. */
< 		block_end_pfn = min(pfn + pageblock_nr_pages, end_pfn);
< 		if (pageblock_is_reserved(pfn, block_end_pfn))
< 			continue;
< 
3428,3432c3484,3492
< 		/* If this block is reserved, account for it */
< 		if (reserve > 0 && block_migratetype == MIGRATE_RESERVE) {
< 			reserve--;
< 			continue;
< 		}
---
> 		/* Only test what is necessary when the reserves are not met */
> 		if (reserve > 0) {
> 			/*
> 			 * Blocks with reserved pages will never free, skip
> 			 * them.
> 			 */
> 			block_end_pfn = min(pfn + pageblock_nr_pages, end_pfn);
> 			if (pageblock_is_reserved(pfn, block_end_pfn))
> 				continue;
3434,3439c3494,3508
< 		/* Suitable for reserving if this block is movable */
< 		if (reserve > 0 && block_migratetype == MIGRATE_MOVABLE) {
< 			set_pageblock_migratetype(page, MIGRATE_RESERVE);
< 			move_freepages_block(zone, page, MIGRATE_RESERVE);
< 			reserve--;
< 			continue;
---
> 			/* If this block is reserved, account for it */
> 			if (block_migratetype == MIGRATE_RESERVE) {
> 				reserve--;
> 				continue;
> 			}
> 
> 			/* Suitable for reserving if this block is movable */
> 			if (block_migratetype == MIGRATE_MOVABLE) {
> 				set_pageblock_migratetype(page,
> 							MIGRATE_RESERVE);
> 				move_freepages_block(zone, page,
> 							MIGRATE_RESERVE);
> 				reserve--;
> 				continue;
> 			}
5449c5518
< 	pfn = pfn - zone->zone_start_pfn;
---
> 	pfn = pfn - round_down(zone->zone_start_pfn, pageblock_nr_pages);




diff -r linux-3.0.36/mm/rmap.c linux-3.0.36-lenovo/mm/rmap.c
59a60
> #include <linux/backing-dev.h>
939c940
< 		if (mapping) {
---
> 		if (mapping)
941,943d941
< 			if (page_test_and_clear_dirty(page_to_pfn(page), 1))
< 				ret = 1;
< 		}
1123a1122,1123
> 	struct address_space *mapping = page_mapping(page);
> 
1133a1134,1144
> 	 *
> 	 * And we can skip it on file pages, so long as the filesystem
> 	 * participates in dirty tracking; but need to catch shm and tmpfs
> 	 * and ramfs pages which have been modified since creation by read
> 	 * fault.
> 	 *
> 	 * Note that mapping must be decided above, before decrementing
> 	 * mapcount (which luckily provides a barrier): once page is unmapped,
> 	 * it could be truncated and page->mapping reset to NULL at any moment.
> 	 * Note also that we are relying on page_mapping(page) to set mapping
> 	 * to &swapper_space when PageSwapCache(page).
1135c1146
< 	if ((!PageAnon(page) || PageSwapCache(page)) &&
---
> 	if (mapping && !mapping_cap_account_dirty(mapping) &&




diff -r linux-3.0.36/mm/shmem.c linux-3.0.36-lenovo/mm/shmem.c
1171d1170
< 	struct mempolicy mpol, *spol;
1175,1177d1173
< 	spol = mpol_cond_copy(&mpol,
< 				mpol_shared_policy_lookup(&info->policy, idx));
< 
1182c1178,1179
< 	pvma.vm_policy = spol;
---
> 	pvma.vm_policy = mpol_shared_policy_lookup(&info->policy, idx);
> 
1183a1181,1184
> 
> 	/* Drop reference taken by mpol_shared_policy_lookup() */
> 	mpol_cond_put(pvma.vm_policy);
> 
1190a1192
> 	struct page *page;
1198,1201c1200,1205
< 	/*
< 	 * alloc_page_vma() will drop the shared policy reference
< 	 */
< 	return alloc_page_vma(gfp, &pvma, 0);
---
> 	page = alloc_page_vma(gfp, &pvma, 0);
> 
> 	/* Drop reference taken by mpol_shared_policy_lookup() */
> 	mpol_cond_put(pvma.vm_policy);
> 
> 	return page;
2351,2352c2355
< 	u64 inum = fid->raw[2];
< 	inum = (inum << 32) | fid->raw[1];
---
> 	u64 inum;
2356a2360,2362
> 	inum = fid->raw[2];
> 	inum = (inum << 32) | fid->raw[1];
> 
3017a3024,3032
> void shmem_set_file(struct vm_area_struct *vma, struct file *file)
> {
> 	if (vma->vm_file)
> 		fput(vma->vm_file);
> 	vma->vm_file = file;
> 	vma->vm_ops = &shmem_vm_ops;
> 	vma->vm_flags |= VM_CAN_NONLINEAR;
> }
> 
3031,3035c3046
< 	if (vma->vm_file)
< 		fput(vma->vm_file);
< 	vma->vm_file = file;
< 	vma->vm_ops = &shmem_vm_ops;
< 	vma->vm_flags |= VM_CAN_NONLINEAR;
---
> 	shmem_set_file(vma, file);




diff -r linux-3.0.36/mm/slab.c linux-3.0.36-lenovo/mm/slab.c
3221d3220
< 	get_mems_allowed();
3226d3224
< 	put_mems_allowed();
3248a3247
> 	unsigned int cpuset_mems_cookie;
3253,3254d3251
< 	get_mems_allowed();
< 	zonelist = node_zonelist(slab_node(current->mempolicy), flags);
3256a3254,3257
> retry_cpuset:
> 	cpuset_mems_cookie = get_mems_allowed();
> 	zonelist = node_zonelist(slab_node(current->mempolicy), flags);
> 
3309c3310,3312
< 	put_mems_allowed();
---
> 
> 	if (unlikely(!put_mems_allowed(cpuset_mems_cookie) && !obj))
> 		goto retry_cpuset;




diff -r linux-3.0.36/mm/slub.c linux-3.0.36-lenovo/mm/slub.c
1459a1460
> 	unsigned int cpuset_mems_cookie;
1483,1486c1484,1488
< 	get_mems_allowed();
< 	zonelist = node_zonelist(slab_node(current->mempolicy), flags);
< 	for_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {
< 		struct kmem_cache_node *n;
---
> 	do {
> 		cpuset_mems_cookie = get_mems_allowed();
> 		zonelist = node_zonelist(slab_node(current->mempolicy), flags);
> 		for_each_zone_zonelist(zone, z, zonelist, high_zoneidx) {
> 			struct kmem_cache_node *n;
1488c1490
< 		n = get_node(s, zone_to_nid(zone));
---
> 			n = get_node(s, zone_to_nid(zone));
1490,1495c1492,1506
< 		if (n && cpuset_zone_allowed_hardwall(zone, flags) &&
< 				n->nr_partial > s->min_partial) {
< 			page = get_partial_node(n);
< 			if (page) {
< 				put_mems_allowed();
< 				return page;
---
> 			if (n && cpuset_zone_allowed_hardwall(zone, flags) &&
> 					n->nr_partial > s->min_partial) {
> 				page = get_partial_node(n);
> 				if (page) {
> 					/*
> 					 * Return the object even if
> 					 * put_mems_allowed indicated that
> 					 * the cpuset mems_allowed was
> 					 * updated in parallel. It's a
> 					 * harmless race between the alloc
> 					 * and the cpuset update.
> 					 */
> 					put_mems_allowed(cpuset_mems_cookie);
> 					return page;
> 				}
1498,1499c1509
< 	}
< 	put_mems_allowed();
---
> 	} while (!put_mems_allowed(cpuset_mems_cookie));




diff -r linux-3.0.36/mm/sparse.c linux-3.0.36-lenovo/mm/sparse.c
622c622
< static void free_map_bootmem(struct page *page, unsigned long nr_pages)
---
> static void free_map_bootmem(struct page *memmap, unsigned long nr_pages)
663c663
< static void free_map_bootmem(struct page *page, unsigned long nr_pages)
---
> static void free_map_bootmem(struct page *memmap, unsigned long nr_pages)
666a667
> 	struct page *page = virt_to_page(memmap);
715,717d715
< 		struct page *memmap_page;
< 		memmap_page = virt_to_page(memmap);
< 
721c719
< 		free_map_bootmem(memmap_page, nr_pages);
---
> 		free_map_bootmem(memmap, nr_pages);




diff -r linux-3.0.36/mm/truncate.c linux-3.0.36-lenovo/mm/truncate.c
400a401,402
> 	clear_page_mlock(page);
> 
405d406
< 	clear_page_mlock(page);




diff -r linux-3.0.36/mm/vmscan.c linux-3.0.36-lenovo/mm/vmscan.c
251,252c251,255
< 		unsigned long total_scan;
< 		unsigned long max_pass;
---
> 		long total_scan;
> 		long max_pass;
> 		int shrink_ret = 0;
> 		long nr;
> 		long new_nr;
254a258,270
> 		if (max_pass <= 0)
> 			continue;
> 
> 		/*
> 		 * copy the current shrinker scan count into a local variable
> 		 * and zero it so that other concurrent shrinker invocations
> 		 * don't also do this scanning work.
> 		 */
> 		do {
> 			nr = shrinker->nr;
> 		} while (cmpxchg(&shrinker->nr, nr, 0) != nr);
> 
> 		total_scan = nr;
258,259c274,275
< 		shrinker->nr += delta;
< 		if (shrinker->nr < 0) {
---
> 		total_scan += delta;
> 		if (total_scan < 0) {
262,263c278,279
< 			       shrinker->shrink, shrinker->nr);
< 			shrinker->nr = max_pass;
---
> 			       shrinker->shrink, total_scan);
> 			total_scan = max_pass;
266a283,297
> 		 * We need to avoid excessive windup on filesystem shrinkers
> 		 * due to large numbers of GFP_NOFS allocations causing the
> 		 * shrinkers to return -1 all the time. This results in a large
> 		 * nr being built up so when a shrink that can do some work
> 		 * comes along it empties the entire cache due to nr >>>
> 		 * max_pass.  This is bad for sustaining a working set in
> 		 * memory.
> 		 *
> 		 * Hence only allow the shrinker to scan the entire cache when
> 		 * a large delta change is calculated directly.
> 		 */
> 		if (delta < max_pass / 4)
> 			total_scan = min(total_scan, max_pass / 2);
> 
> 		/*
271,272c302,303
< 		if (shrinker->nr > max_pass * 2)
< 			shrinker->nr = max_pass * 2;
---
> 		if (total_scan > max_pass * 2)
> 			total_scan = max_pass * 2;
274,275c305,307
< 		total_scan = shrinker->nr;
< 		shrinker->nr = 0;
---
> 		trace_mm_shrink_slab_start(shrinker, shrink, nr,
> 					nr_pages_scanned, lru_pages,
> 					max_pass, delta, total_scan);
279d310
< 			int shrink_ret;
295c326,338
< 		shrinker->nr += total_scan;
---
> 		/*
> 		 * move the unused scan count back into the shrinker in a
> 		 * manner that handles concurrent updates. If we exhausted the
> 		 * scan, there is no need to do an update.
> 		 */
> 		do {
> 			nr = shrinker->nr;
> 			new_nr = total_scan + nr;
> 			if (total_scan <= 0)
> 				break;
> 		} while (cmpxchg(&shrinker->nr, nr, new_nr) != nr);
> 
> 		trace_mm_shrink_slab_end(shrinker, shrink_ret, nr, new_nr);
686c729,735
< 		if (referenced_page)
---
> 		if (referenced_page || referenced_ptes > 1)
> 			return PAGEREF_ACTIVATE;
> 
> 		/*
> 		 * Activate file-backed executable pages after first usage.
> 		 */
> 		if (vm_flags & VM_EXEC)
975c1024
< int __isolate_lru_page(struct page *page, int mode, int file)
---
> int __isolate_lru_page(struct page *page, isolate_mode_t mode, int file)
976a1026
> 	bool all_lru_mode;
982a1033,1035
> 	all_lru_mode = (mode & (ISOLATE_ACTIVE|ISOLATE_INACTIVE)) ==
> 		(ISOLATE_ACTIVE|ISOLATE_INACTIVE);
> 
988c1041
< 	if (mode != ISOLATE_BOTH && (!PageActive(page) != !mode))
---
> 	if (!all_lru_mode && !PageActive(page) != !(mode & ISOLATE_ACTIVE))
991c1044
< 	if (mode != ISOLATE_BOTH && page_is_file_cache(page) != file)
---
> 	if (!all_lru_mode && !!page_is_file_cache(page) != file)
1003a1057,1093
> 	/*
> 	 * To minimise LRU disruption, the caller can indicate that it only
> 	 * wants to isolate pages it will be able to operate on without
> 	 * blocking - clean pages for the most part.
> 	 *
> 	 * ISOLATE_CLEAN means that only clean pages should be isolated. This
> 	 * is used by reclaim when it is cannot write to backing storage
> 	 *
> 	 * ISOLATE_ASYNC_MIGRATE is used to indicate that it only wants to pages
> 	 * that it is possible to migrate without blocking
> 	 */
> 	if (mode & (ISOLATE_CLEAN|ISOLATE_ASYNC_MIGRATE)) {
> 		/* All the caller can do on PageWriteback is block */
> 		if (PageWriteback(page))
> 			return ret;
> 
> 		if (PageDirty(page)) {
> 			struct address_space *mapping;
> 
> 			/* ISOLATE_CLEAN means only clean pages */
> 			if (mode & ISOLATE_CLEAN)
> 				return ret;
> 
> 			/*
> 			 * Only pages without mappings or that have a
> 			 * ->migratepage callback are possible to migrate
> 			 * without blocking
> 			 */
> 			mapping = page_mapping(page);
> 			if (mapping && !mapping->a_ops->migratepage)
> 				return ret;
> 		}
> 	}
> 
> 	if ((mode & ISOLATE_UNMAPPED) && page_mapped(page))
> 		return ret;
> 
1039c1129,1130
< 		unsigned long *scanned, int order, int mode, int file)
---
> 		unsigned long *scanned, int order, isolate_mode_t mode,
> 		int file)
1114c1205
< 			if (nr_swap_pages <= 0 && PageAnon(cursor_page) &&
---
> 			if (nr_swap_pages <= 0 && PageSwapBacked(cursor_page) &&
1164,1165c1255,1256
< 					int mode, struct zone *z,
< 					int active, int file)
---
> 					isolate_mode_t mode,
> 					struct zone *z,	int active, int file)
1410a1502
> 	isolate_mode_t reclaim_mode = ISOLATE_INACTIVE;
1420a1513,1515
> 	if (sc->reclaim_mode & RECLAIM_MODE_LUMPYRECLAIM)
> 		reclaim_mode |= ISOLATE_ACTIVE;
> 
1421a1517,1522
> 
> 	if (!sc->may_unmap)
> 		reclaim_mode |= ISOLATE_UNMAPPED;
> 	if (!sc->may_writepage)
> 		reclaim_mode |= ISOLATE_CLEAN;
> 
1425,1429c1526,1527
< 		nr_taken = isolate_pages_global(nr_to_scan,
< 			&page_list, &nr_scanned, sc->order,
< 			sc->reclaim_mode & RECLAIM_MODE_LUMPYRECLAIM ?
< 					ISOLATE_BOTH : ISOLATE_INACTIVE,
< 			zone, 0, file);
---
> 		nr_taken = isolate_pages_global(nr_to_scan, &page_list,
> 			&nr_scanned, sc->order, reclaim_mode, zone, 0, file);
1438,1443c1536,1538
< 		nr_taken = mem_cgroup_isolate_pages(nr_to_scan,
< 			&page_list, &nr_scanned, sc->order,
< 			sc->reclaim_mode & RECLAIM_MODE_LUMPYRECLAIM ?
< 					ISOLATE_BOTH : ISOLATE_INACTIVE,
< 			zone, sc->mem_cgroup,
< 			0, file);
---
> 		nr_taken = mem_cgroup_isolate_pages(nr_to_scan, &page_list,
> 			&nr_scanned, sc->order, reclaim_mode, zone,
> 			sc->mem_cgroup, 0, file);
1544a1640
> 	isolate_mode_t reclaim_mode = ISOLATE_ACTIVE;
1546a1643,1648
> 
> 	if (!sc->may_unmap)
> 		reclaim_mode |= ISOLATE_UNMAPPED;
> 	if (!sc->may_writepage)
> 		reclaim_mode |= ISOLATE_CLEAN;
> 
1551c1653
< 						ISOLATE_ACTIVE, zone,
---
> 						reclaim_mode, zone,
1557c1659
< 						ISOLATE_ACTIVE, zone,
---
> 						reclaim_mode, zone,
1750c1852
< 	int force_scan = 0;
---
> 	bool force_scan = false;
1753,1766c1855,1861
< 
< 	anon  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_ANON) +
< 		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
< 	file  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE) +
< 		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
< 
< 	if (((anon + file) >> priority) < SWAP_CLUSTER_MAX) {
< 		/* kswapd does zone balancing and need to scan this zone */
< 		if (scanning_global_lru(sc) && current_is_kswapd())
< 			force_scan = 1;
< 		/* memcg may have small limit and need to avoid priority drop */
< 		if (!scanning_global_lru(sc))
< 			force_scan = 1;
< 	}
---
> 	/* kswapd does zone balancing and needs to scan this zone */
> 	if (scanning_global_lru(sc) && current_is_kswapd() &&
> 	    zone->all_unreclaimable)
> 		force_scan = true;
> 	/* memcg may have small limit and need to avoid priority drop */
> 	if (!scanning_global_lru(sc))
> 		force_scan = true;
1778a1874,1878
> 	anon  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_ANON) +
> 		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
> 	file  = zone_nr_lru_pages(zone, sc, LRU_ACTIVE_FILE) +
> 		zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
> 
1915,1916c2015,2017
< 	inactive_lru_pages = zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON) +
< 				zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
---
> 	inactive_lru_pages = zone_nr_lru_pages(zone, sc, LRU_INACTIVE_FILE);
> 	if (nr_swap_pages > 0)
> 		inactive_lru_pages += zone_nr_lru_pages(zone, sc, LRU_INACTIVE_ANON);
1987a2089,2124
> /* Returns true if compaction should go ahead for a high-order request */
> static inline bool compaction_ready(struct zone *zone, struct scan_control *sc)
> {
> 	unsigned long balance_gap, watermark;
> 	bool watermark_ok;
> 
> 	/* Do not consider compaction for orders reclaim is meant to satisfy */
> 	if (sc->order <= PAGE_ALLOC_COSTLY_ORDER)
> 		return false;
> 
> 	/*
> 	 * Compaction takes time to run and there are potentially other
> 	 * callers using the pages just freed. Continue reclaiming until
> 	 * there is a buffer of free pages available to give compaction
> 	 * a reasonable chance of completing and allocating the page
> 	 */
> 	balance_gap = min(low_wmark_pages(zone),
> 		(zone->present_pages + KSWAPD_ZONE_BALANCE_GAP_RATIO-1) /
> 			KSWAPD_ZONE_BALANCE_GAP_RATIO);
> 	watermark = high_wmark_pages(zone) + balance_gap + (2UL << sc->order);
> 	watermark_ok = zone_watermark_ok_safe(zone, 0, watermark, 0, 0);
> 
> 	/*
> 	 * If compaction is deferred, reclaim up to a point where
> 	 * compaction will have a chance of success when re-enabled
> 	 */
> 	if (compaction_deferred(zone))
> 		return watermark_ok;
> 
> 	/* If compaction is not ready to start, keep reclaiming */
> 	if (!compaction_suitable(zone, sc->order))
> 		return false;
> 
> 	return watermark_ok;
> }
> 
2002a2140,2144
>  *
>  * This function returns true if a zone is being reclaimed for a costly
>  * high-order allocation and compaction is ready to begin. This indicates to
>  * the caller that it should consider retrying the allocation instead of
>  * further reclaim.
2004c2146
< static void shrink_zones(int priority, struct zonelist *zonelist,
---
> static bool shrink_zones(int priority, struct zonelist *zonelist,
2010a2153
> 	bool aborted_reclaim = false;
2024a2168,2182
> 			if (COMPACTION_BUILD) {
> 				/*
> 				 * If we already have plenty of memory free for
> 				 * compaction in this zone, don't free any more.
> 				 * Even though compaction is invoked for any
> 				 * non-zero order, only frequent costly order
> 				 * reclamation is disruptive enough to become a
> 				 * noticable problem, like transparent huge page
> 				 * allocations.
> 				 */
> 				if (compaction_ready(zone, sc)) {
> 					aborted_reclaim = true;
> 					continue;
> 				}
> 			}
2041a2200,2201
> 
> 	return aborted_reclaim;
2094a2255
> 	bool aborted_reclaim;
2096d2256
< 	get_mems_allowed();
2106c2266,2267
< 		shrink_zones(priority, zonelist, sc);
---
> 		aborted_reclaim = shrink_zones(priority, zonelist, sc);
> 
2158d2318
< 	put_mems_allowed();
2170a2331,2334
> 	/* Aborted reclaim to try compaction? don't OOM, then */
> 	if (aborted_reclaim)
> 		return 1;
> 
2461a2626,2628
> 			} else {
> 				/* If balanced, clear the congested flag */
> 				zone_clear_flag(zone, ZONE_CONGESTED);
2698c2865,2868
< 		schedule();
---
> 
> 		if (!kthread_should_stop())
> 			schedule();
> 
2724a2895
> 	unsigned balanced_order;
2725a2897
> 	int balanced_classzone_idx;
2755a2928
> 	balanced_order = 0;
2756a2930
> 	balanced_classzone_idx = classzone_idx;
2765c2939,2940
< 		if (classzone_idx >= new_classzone_idx && order == new_order) {
---
> 		if (balanced_classzone_idx >= new_classzone_idx &&
> 					balanced_order == new_order) {
2780c2955,2956
< 			kswapd_try_to_sleep(pgdat, order, classzone_idx);
---
> 			kswapd_try_to_sleep(pgdat, balanced_order,
> 						balanced_classzone_idx);
2782a2959,2960
> 			new_order = order;
> 			new_classzone_idx = classzone_idx;
2797c2975,2977
< 			order = balance_pgdat(pgdat, order, &classzone_idx);
---
> 			balanced_classzone_idx = classzone_idx;
> 			balanced_order = balance_pgdat(pgdat, order,
> 						&balanced_classzone_idx);
2799a2980,2981
> 
> 	current->reclaim_state = NULL;
2955c3137,3138
<  * Called by memory hotplug when all memory in a node is offlined.
---
>  * Called by memory hotplug when all memory in a node is offlined.  Caller must
>  * hold lock_memory_hotplug().
2961c3144
< 	if (kswapd)
---
> 	if (kswapd) {
2962a3146,3147
> 		NODE_DATA(nid)->kswapd = NULL;
> 	}




diff -r linux-3.0.36/mm/vmstat.c linux-3.0.36-lenovo/mm/vmstat.c
81c81
< atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS];
---
> atomic_long_t vm_stat[NR_VM_ZONE_STAT_ITEMS] __cacheline_aligned_in_smp;




diff -r linux-3.0.36/net/8021q/vlan_core.c linux-3.0.36-lenovo/net/8021q/vlan_core.c
109d108
< 	skb_reset_mac_len(skb);
175a175,176
> 	skb_reset_mac_len(skb);
> 
Only in linux-3.0.36-lenovo/net: activity_stats.c




diff -r linux-3.0.36/net/atm/common.c linux-3.0.36-lenovo/net/atm/common.c
786a787
> 		memset(&pvc, 0, sizeof(pvc));




diff -r linux-3.0.36/net/atm/pvc.c linux-3.0.36-lenovo/net/atm/pvc.c
96a97
> 	memset(addr, 0, sizeof(*addr));




diff -r linux-3.0.36/net/bluetooth/af_bluetooth.c linux-3.0.36-lenovo/net/bluetooth/af_bluetooth.c
42a43,51
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> #include <linux/android_aid.h>
> #endif
> 
> #ifndef CONFIG_BT_SOCK_DEBUG
> #undef  BT_DBG
> #define BT_DBG(D...)
> #endif
> 
127a137,158
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> static inline int current_has_bt_admin(void)
> {
> 	return (!current_euid() || in_egroup_p(AID_NET_BT_ADMIN));
> }
> 
> static inline int current_has_bt(void)
> {
> 	return (current_has_bt_admin() || in_egroup_p(AID_NET_BT));
> }
> # else
> static inline int current_has_bt_admin(void)
> {
> 	return 1;
> }
> 
> static inline int current_has_bt(void)
> {
> 	return 1;
> }
> #endif
> 
132a164,170
> 	if (proto == BTPROTO_RFCOMM || proto == BTPROTO_SCO ||
> 			proto == BTPROTO_L2CAP) {
> 		if (!current_has_bt())
> 			return -EPERM;
> 	} else if (!current_has_bt_admin())
> 		return -EPERM;
> 
496a535
> 	set_current_state(TASK_INTERRUPTIBLE);
498,499d536
< 		set_current_state(TASK_INTERRUPTIBLE);
< 
512a550
> 		set_current_state(TASK_INTERRUPTIBLE);
518c556
< 	set_current_state(TASK_RUNNING);
---
> 	__set_current_state(TASK_RUNNING);




diff -r linux-3.0.36/net/bluetooth/bnep/bnep.h linux-3.0.36-lenovo/net/bluetooth/bnep/bnep.h
157a158
> 	atomic_t      terminate;




diff -r linux-3.0.36/net/bluetooth/bnep/core.c linux-3.0.36-lenovo/net/bluetooth/bnep/core.c
487c487
< 	while (!kthread_should_stop()) {
---
> 	while (1) {
489a490,491
> 		if (atomic_read(&s->terminate))
> 			break;
507c509
< 	set_current_state(TASK_RUNNING);
---
> 	__set_current_state(TASK_RUNNING);
643,645c645,648
< 	if (s)
< 		kthread_stop(s->task);
< 	else
---
> 	if (s) {
> 		atomic_inc(&s->terminate);
> 		wake_up_process(s->task);
> 	} else




diff -r linux-3.0.36/net/bluetooth/cmtp/capi.c linux-3.0.36-lenovo/net/bluetooth/cmtp/capi.c
329c329
< 	__u16 cmd, appl;
---
> 	__u16 appl;
347d346
< 	cmd = CAPICMD(CAPIMSG_COMMAND(skb->data), CAPIMSG_SUBCOMMAND(skb->data));




diff -r linux-3.0.36/net/bluetooth/hci_conn.c linux-3.0.36-lenovo/net/bluetooth/hci_conn.c
55a56
> 	conn->sec_level = BT_SECURITY_LOW;
60a62
> 	cp.peer_addr_type = conn->dst_type;
205a208,256
> void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
> 							__u8 ltk[16])
> {
> 	struct hci_dev *hdev = conn->hdev;
> 	struct hci_cp_le_start_enc cp;
> 
> 	BT_DBG("%p", conn);
> 
> 	memset(&cp, 0, sizeof(cp));
> 
> 	cp.handle = cpu_to_le16(conn->handle);
> 	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
> 	cp.ediv = ediv;
> 	memcpy(cp.rand, rand, sizeof(rand));
> 
> 	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
> }
> EXPORT_SYMBOL(hci_le_start_enc);
> 
> void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
> {
> 	struct hci_dev *hdev = conn->hdev;
> 	struct hci_cp_le_ltk_reply cp;
> 
> 	BT_DBG("%p", conn);
> 
> 	memset(&cp, 0, sizeof(cp));
> 
> 	cp.handle = cpu_to_le16(conn->handle);
> 	memcpy(cp.ltk, ltk, sizeof(ltk));
> 
> 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
> }
> EXPORT_SYMBOL(hci_le_ltk_reply);
> 
> void hci_le_ltk_neg_reply(struct hci_conn *conn)
> {
> 	struct hci_dev *hdev = conn->hdev;
> 	struct hci_cp_le_ltk_neg_reply cp;
> 
> 	BT_DBG("%p", conn);
> 
> 	memset(&cp, 0, sizeof(cp));
> 
> 	cp.handle = cpu_to_le16(conn->handle);
> 
> 	hci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(cp), &cp);
> }
> 
285c336,337
< struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
---
> struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type,
> 					__u16 pkt_type, bdaddr_t *dst)
313,318c365,366
< 		if (lmp_esco_capable(hdev))
< 			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
< 					(hdev->esco_type & EDR_ESCO_MASK);
< 		else
< 			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
< 		break;
---
> 		if (!pkt_type)
> 			pkt_type = SCO_ESCO_MASK;
320c368,380
< 		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
---
> 		if (!pkt_type)
> 			pkt_type = ALL_ESCO_MASK;
> 		if (lmp_esco_capable(hdev)) {
> 			/* HCI Setup Synchronous Connection Command uses
> 			   reverse logic on the EDR_ESCO_MASK bits */
> 			conn->pkt_type = (pkt_type ^ EDR_ESCO_MASK) &
> 					hdev->esco_type;
> 		} else {
> 			/* Legacy HCI Add Sco Connection Command uses a
> 			   shifted bitmask */
> 			conn->pkt_type = (pkt_type << 5) & hdev->pkt_type &
> 					SCO_PTYPE_MASK;
> 		}
444c504,506
< struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
---
> struct hci_conn *hci_connect(struct hci_dev *hdev, int type,
> 					__u16 pkt_type, bdaddr_t *dst,
> 					__u8 sec_level, __u8 auth_type)
452a515,516
> 		struct adv_entry *entry;
> 
456c520,525
< 		le = hci_conn_add(hdev, LE_LINK, dst);
---
> 
> 		entry = hci_find_adv_entry(hdev, dst);
> 		if (!entry)
> 			return ERR_PTR(-EHOSTUNREACH);
> 
> 		le = hci_conn_add(hdev, LE_LINK, 0, dst);
459,460c528,531
< 		if (le->state == BT_OPEN)
< 			hci_le_connect(le);
---
> 
> 		le->dst_type = entry->bdaddr_type;
> 
> 		hci_le_connect(le);
469c540
< 		acl = hci_conn_add(hdev, ACL_LINK, dst);
---
> 		acl = hci_conn_add(hdev, ACL_LINK, 0, dst);
488c559
< 		sco = hci_conn_add(hdev, type, dst);
---
> 		sco = hci_conn_add(hdev, type, pkt_type, dst);
503c574
< 		hci_conn_enter_active_mode(acl);
---
> 		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
557a629,630
> 		if (conn->key_type != 0xff)
> 			set_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
641,643c714
< 	if (conn->key_type == HCI_LK_AUTH_COMBINATION ||
< 			(conn->key_type == HCI_LK_COMBINATION &&
< 			conn->pin_length == 16))
---
> 	if (conn->sec_level == BT_SECURITY_HIGH)
686c757
< void hci_conn_enter_active_mode(struct hci_conn *conn)
---
> void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
695c766,769
< 	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
---
> 	if (conn->mode != HCI_CM_SNIFF)
> 		goto timer;
> 
> 	if (!conn->power_save && !force_active)
835a910,918
> 		if (c->type == SCO_LINK) {
> 			(ci + n)->mtu = hdev->sco_mtu;
> 			(ci + n)->cnt = hdev->sco_cnt;
> 			(ci + n)->pkts = hdev->sco_pkts;
> 		} else {
> 			(ci + n)->mtu = hdev->acl_mtu;
> 			(ci + n)->cnt = hdev->acl_cnt;
> 			(ci + n)->pkts = hdev->acl_pkts;
> 		}
871a955,963
> 		if (req.type == SCO_LINK) {
> 			ci.mtu = hdev->sco_mtu;
> 			ci.cnt = hdev->sco_cnt;
> 			ci.pkts = hdev->sco_pkts;
> 		} else {
> 			ci.mtu = hdev->acl_mtu;
> 			ci.cnt = hdev->acl_cnt;
> 			ci.pkts = hdev->acl_pkts;
> 		}




diff -r linux-3.0.36/net/bluetooth/hci_core.c linux-3.0.36-lenovo/net/bluetooth/hci_core.c
44a45
> #include <linux/crypto.h>
148c149
< 		err = -bt_err(hdev->req_result);
---
> 		err = -bt_to_errno(hdev->req_result);
547c548
< 		if (lmp_le_capable(hdev))
---
> 		if (lmp_host_le_capable(hdev))
1063a1065,1100
> struct link_key *hci_find_ltk(struct hci_dev *hdev, __le16 ediv, u8 rand[8])
> {
> 	struct link_key *k;
> 
> 	list_for_each_entry(k, &hdev->link_keys, list) {
> 		struct key_master_id *id;
> 
> 		if (k->type != HCI_LK_SMP_LTK)
> 			continue;
> 
> 		if (k->dlen != sizeof(*id))
> 			continue;
> 
> 		id = (void *) &k->data;
> 		if (id->ediv == ediv &&
> 				(memcmp(rand, id->rand, sizeof(id->rand)) == 0))
> 			return k;
> 	}
> 
> 	return NULL;
> }
> EXPORT_SYMBOL(hci_find_ltk);
> 
> struct link_key *hci_find_link_key_type(struct hci_dev *hdev,
> 					bdaddr_t *bdaddr, u8 type)
> {
> 	struct link_key *k;
> 
> 	list_for_each_entry(k, &hdev->link_keys, list)
> 		if (k->type == type && bacmp(bdaddr, &k->bdaddr) == 0)
> 			return k;
> 
> 	return NULL;
> }
> EXPORT_SYMBOL(hci_find_link_key_type);
> 
1118a1156,1193
> int hci_add_ltk(struct hci_dev *hdev, int new_key, bdaddr_t *bdaddr,
> 			u8 key_size, __le16 ediv, u8 rand[8], u8 ltk[16])
> {
> 	struct link_key *key, *old_key;
> 	struct key_master_id *id;
> 	u8 old_key_type;
> 
> 	BT_DBG("%s addr %s", hdev->name, batostr(bdaddr));
> 
> 	old_key = hci_find_link_key_type(hdev, bdaddr, HCI_LK_SMP_LTK);
> 	if (old_key) {
> 		key = old_key;
> 		old_key_type = old_key->type;
> 	} else {
> 		key = kzalloc(sizeof(*key) + sizeof(*id), GFP_ATOMIC);
> 		if (!key)
> 			return -ENOMEM;
> 		list_add(&key->list, &hdev->link_keys);
> 		old_key_type = 0xff;
> 	}
> 
> 	key->dlen = sizeof(*id);
> 
> 	bacpy(&key->bdaddr, bdaddr);
> 	memcpy(key->val, ltk, sizeof(key->val));
> 	key->type = HCI_LK_SMP_LTK;
> 	key->pin_len = key_size;
> 
> 	id = (void *) &key->data;
> 	id->ediv = ediv;
> 	memcpy(id->rand, rand, sizeof(id->rand));
> 
> 	if (new_key)
> 		mgmt_new_key(hdev->id, key, old_key_type);
> 
> 	return 0;
> }
> 
1142d1216
< 	clear_bit(HCI_RESET, &hdev->flags);
1209a1284,1446
> struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev,
> 						bdaddr_t *bdaddr)
> {
> 	struct list_head *p;
> 
> 	list_for_each(p, &hdev->blacklist) {
> 		struct bdaddr_list *b;
> 
> 		b = list_entry(p, struct bdaddr_list, list);
> 
> 		if (bacmp(bdaddr, &b->bdaddr) == 0)
> 			return b;
> 	}
> 
> 	return NULL;
> }
> 
> int hci_blacklist_clear(struct hci_dev *hdev)
> {
> 	struct list_head *p, *n;
> 
> 	list_for_each_safe(p, n, &hdev->blacklist) {
> 		struct bdaddr_list *b;
> 
> 		b = list_entry(p, struct bdaddr_list, list);
> 
> 		list_del(p);
> 		kfree(b);
> 	}
> 
> 	return 0;
> }
> 
> int hci_blacklist_add(struct hci_dev *hdev, bdaddr_t *bdaddr)
> {
> 	struct bdaddr_list *entry;
> 	int err;
> 
> 	if (bacmp(bdaddr, BDADDR_ANY) == 0)
> 		return -EBADF;
> 
> 	hci_dev_lock_bh(hdev);
> 
> 	if (hci_blacklist_lookup(hdev, bdaddr)) {
> 		err = -EEXIST;
> 		goto err;
> 	}
> 
> 	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
> 	if (!entry) {
> 		return -ENOMEM;
> 		goto err;
> 	}
> 
> 	bacpy(&entry->bdaddr, bdaddr);
> 
> 	list_add(&entry->list, &hdev->blacklist);
> 
> 	err = 0;
> 
> err:
> 	hci_dev_unlock_bh(hdev);
> 	return err;
> }
> 
> int hci_blacklist_del(struct hci_dev *hdev, bdaddr_t *bdaddr)
> {
> 	struct bdaddr_list *entry;
> 	int err = 0;
> 
> 	hci_dev_lock_bh(hdev);
> 
> 	if (bacmp(bdaddr, BDADDR_ANY) == 0) {
> 		hci_blacklist_clear(hdev);
> 		goto done;
> 	}
> 
> 	entry = hci_blacklist_lookup(hdev, bdaddr);
> 	if (!entry) {
> 		err = -ENOENT;
> 		goto done;
> 	}
> 
> 	list_del(&entry->list);
> 	kfree(entry);
> 
> done:
> 	hci_dev_unlock_bh(hdev);
> 	return err;
> }
> 
> static void hci_clear_adv_cache(unsigned long arg)
> {
> 	struct hci_dev *hdev = (void *) arg;
> 
> 	hci_dev_lock(hdev);
> 
> 	hci_adv_entries_clear(hdev);
> 
> 	hci_dev_unlock(hdev);
> }
> 
> int hci_adv_entries_clear(struct hci_dev *hdev)
> {
> 	struct adv_entry *entry, *tmp;
> 
> 	list_for_each_entry_safe(entry, tmp, &hdev->adv_entries, list) {
> 		list_del(&entry->list);
> 		kfree(entry);
> 	}
> 
> 	BT_DBG("%s adv cache cleared", hdev->name);
> 
> 	return 0;
> }
> 
> struct adv_entry *hci_find_adv_entry(struct hci_dev *hdev, bdaddr_t *bdaddr)
> {
> 	struct adv_entry *entry;
> 
> 	list_for_each_entry(entry, &hdev->adv_entries, list)
> 		if (bacmp(bdaddr, &entry->bdaddr) == 0)
> 			return entry;
> 
> 	return NULL;
> }
> 
> static inline int is_connectable_adv(u8 evt_type)
> {
> 	if (evt_type == ADV_IND || evt_type == ADV_DIRECT_IND)
> 		return 1;
> 
> 	return 0;
> }
> 
> int hci_add_adv_entry(struct hci_dev *hdev,
> 					struct hci_ev_le_advertising_info *ev)
> {
> 	struct adv_entry *entry;
> 
> 	if (!is_connectable_adv(ev->evt_type))
> 		return -EINVAL;
> 
> 	/* Only new entries should be added to adv_entries. So, if
> 	 * bdaddr was found, don't add it. */
> 	if (hci_find_adv_entry(hdev, &ev->bdaddr))
> 		return 0;
> 
> 	entry = kzalloc(sizeof(*entry), GFP_ATOMIC);
> 	if (!entry)
> 		return -ENOMEM;
> 
> 	bacpy(&entry->bdaddr, &ev->bdaddr);
> 	entry->bdaddr_type = ev->bdaddr_type;
> 
> 	list_add(&entry->list, &hdev->adv_entries);
> 
> 	BT_DBG("%s adv entry added: address %s type %u", hdev->name,
> 				batostr(&entry->bdaddr), entry->bdaddr_type);
> 
> 	return 0;
> }
> 
1275a1513,1516
> 	INIT_LIST_HEAD(&hdev->adv_entries);
> 	setup_timer(&hdev->adv_timer, hci_clear_adv_cache,
> 						(unsigned long) hdev);
> 
1289a1531,1535
> 	hdev->tfm = crypto_alloc_blkcipher("ecb(aes)", 0, CRYPTO_ALG_ASYNC);
> 	if (IS_ERR(hdev->tfm))
> 		BT_INFO("Failed to load transform for ecb(aes): %ld",
> 							PTR_ERR(hdev->tfm));
> 
1291a1538
> #if !defined(CONFIG_MT6620) && !defined(CONFIG_MT5931_MT6622)
1303a1551
> #endif
1335a1584,1585
> 	cancel_work_sync(&hdev->power_on);
> 
1339a1590,1592
> 	if (!IS_ERR(hdev->tfm))
> 		crypto_free_blkcipher(hdev->tfm);
> 
1349a1603
> 	del_timer(&hdev->adv_timer);
1357a1612
> 	hci_adv_entries_clear(hdev);
1901c2156
< 			hci_conn_enter_active_mode(conn);
---
> 			hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
2040c2295
< 		hci_conn_enter_active_mode(conn);
---
> 		hci_conn_enter_active_mode(conn, bt_cb(skb)->force_active);
2166c2421,2424
< 			mod_timer(&hdev->cmd_timer,
---
> 			if (test_bit(HCI_RESET, &hdev->flags))
> 				del_timer(&hdev->cmd_timer);
> 			else
> 				mod_timer(&hdev->cmd_timer,




diff -r linux-3.0.36/net/bluetooth/hci_event.c linux-3.0.36-lenovo/net/bluetooth/hci_event.c
47a48,49
> static int enable_le;
> 
527a530,543
> static void hci_set_le_support(struct hci_dev *hdev)
> {
> 	struct hci_cp_write_le_host_supported cp;
> 
> 	memset(&cp, 0, sizeof(cp));
> 
> 	if (enable_le) {
> 		cp.le = 1;
> 		cp.simul = !!(hdev->features[6] & LMP_SIMUL_LE_BR);
> 	}
> 
> 	hci_send_cmd(hdev, HCI_OP_WRITE_LE_HOST_SUPPORTED, sizeof(cp), &cp);
> }
> 
544a561,571
> 
> 	if (hdev->features[7] & LMP_EXTFEATURES) {
> 		struct hci_cp_read_local_ext_features cp;
> 
> 		cp.page = 0x01;
> 		hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES,
> 							sizeof(cp), &cp);
> 	}
> 
> 	if (hdev->features[4] & LMP_LE)
> 		hci_set_le_support(hdev);
660a688,702
> static void hci_cc_read_local_ext_features(struct hci_dev *hdev,
> 							struct sk_buff *skb)
> {
> 	struct hci_rp_read_local_ext_features *rp = (void *) skb->data;
> 
> 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
> 
> 	if (rp->status)
> 		return;
> 
> 	memcpy(hdev->extfeatures, rp->features, 8);
> 
> 	hci_req_complete(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, rp->status);
> }
> 
843a886,951
> static void hci_cc_le_set_scan_enable(struct hci_dev *hdev,
> 					struct sk_buff *skb)
> {
> 	struct hci_cp_le_set_scan_enable *cp;
> 	__u8 status = *((__u8 *) skb->data);
> 
> 	BT_DBG("%s status 0x%x", hdev->name, status);
> 
> 	if (status)
> 		return;
> 
> 	cp = hci_sent_cmd_data(hdev, HCI_OP_LE_SET_SCAN_ENABLE);
> 	if (!cp)
> 		return;
> 
> 	hci_dev_lock(hdev);
> 
> 	if (cp->enable == 0x01) {
> 		del_timer(&hdev->adv_timer);
> 		hci_adv_entries_clear(hdev);
> 	} else if (cp->enable == 0x00) {
> 		mod_timer(&hdev->adv_timer, jiffies + ADV_CLEAR_TIMEOUT);
> 	}
> 
> 	hci_dev_unlock(hdev);
> }
> 
> static void hci_cc_le_ltk_reply(struct hci_dev *hdev, struct sk_buff *skb)
> {
> 	struct hci_rp_le_ltk_reply *rp = (void *) skb->data;
> 
> 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
> 
> 	if (rp->status)
> 		return;
> 
> 	hci_req_complete(hdev, HCI_OP_LE_LTK_REPLY, rp->status);
> }
> 
> static void hci_cc_le_ltk_neg_reply(struct hci_dev *hdev, struct sk_buff *skb)
> {
> 	struct hci_rp_le_ltk_neg_reply *rp = (void *) skb->data;
> 
> 	BT_DBG("%s status 0x%x", hdev->name, rp->status);
> 
> 	if (rp->status)
> 		return;
> 
> 	hci_req_complete(hdev, HCI_OP_LE_LTK_NEG_REPLY, rp->status);
> }
> 
> static inline void hci_cc_write_le_host_supported(struct hci_dev *hdev,
> 							struct sk_buff *skb)
> {
> 	struct hci_cp_read_local_ext_features cp;
> 	__u8 status = *((__u8 *) skb->data);
> 
> 	BT_DBG("%s status 0x%x", hdev->name, status);
> 
> 	if (status)
> 		return;
> 
> 	cp.page = 0x01;
> 	hci_send_cmd(hdev, HCI_OP_READ_LOCAL_EXT_FEATURES, sizeof(cp), &cp);
> }
> 
887c995
< 			conn = hci_conn_add(hdev, ACL_LINK, &cp->bdaddr);
---
> 			conn = hci_conn_add(hdev, ACL_LINK, 0, &cp->bdaddr);
1210,1211c1318,1320
< 			conn = hci_conn_add(hdev, LE_LINK, &cp->peer_addr);
< 			if (conn)
---
> 			conn = hci_conn_add(hdev, LE_LINK, 0, &cp->peer_addr);
> 			if (conn) {
> 				conn->dst_type = cp->peer_addr_type;
1213c1322
< 			else
---
> 			} else {
1214a1324
> 			}
1220a1331,1335
> static void hci_cs_le_start_enc(struct hci_dev *hdev, u8 status)
> {
> 	BT_DBG("%s status 0x%x", hdev->name, status);
> }
> 
1349a1465,1473
> static inline bool is_sco_active(struct hci_dev *hdev)
> {
> 	if (hci_conn_hash_lookup_state(hdev, SCO_LINK, BT_CONNECTED) ||
> 			(hci_conn_hash_lookup_state(hdev, ESCO_LINK,
> 						    BT_CONNECTED)))
> 		return true;
> 	return false;
> }
> 
1374c1498,1499
< 			conn = hci_conn_add(hdev, ev->link_type, &ev->bdaddr);
---
> 			/* pkt_type not yet used for incoming connections */
> 			conn = hci_conn_add(hdev, ev->link_type, 0, &ev->bdaddr);
1392c1517,1518
< 			if (lmp_rswitch_capable(hdev) && (mask & HCI_LM_MASTER))
---
> 			if (lmp_rswitch_capable(hdev) && ((mask & HCI_LM_MASTER)
> 						|| is_sco_active(hdev)))
1464,1465c1590,1597
< 	if (conn) {
< 		if (!ev->status) {
---
> 	if (!conn)
> 		goto unlock;
> 
> 	if (!ev->status) {
> 		if (!(conn->ssp_mode > 0 && hdev->ssp_mode > 0) &&
> 				test_bit(HCI_CONN_REAUTH_PEND,	&conn->pend)) {
> 			BT_INFO("re-auth of legacy device is not possible.");
> 		} else {
1468,1469d1599
< 		} else {
< 			mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
1470a1601,1603
> 	} else {
> 		mgmt_auth_failed(hdev->id, &conn->dst, ev->status);
> 	}
1472c1605,1606
< 		clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
---
> 	clear_bit(HCI_CONN_AUTH_PEND, &conn->pend);
> 	clear_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
1474,1486c1608,1614
< 		if (conn->state == BT_CONFIG) {
< 			if (!ev->status && hdev->ssp_mode > 0 &&
< 							conn->ssp_mode > 0) {
< 				struct hci_cp_set_conn_encrypt cp;
< 				cp.handle  = ev->handle;
< 				cp.encrypt = 0x01;
< 				hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT,
< 							sizeof(cp), &cp);
< 			} else {
< 				conn->state = BT_CONNECTED;
< 				hci_proto_connect_cfm(conn, ev->status);
< 				hci_conn_put(conn);
< 			}
---
> 	if (conn->state == BT_CONFIG) {
> 		if (!ev->status && hdev->ssp_mode > 0 && conn->ssp_mode > 0) {
> 			struct hci_cp_set_conn_encrypt cp;
> 			cp.handle  = ev->handle;
> 			cp.encrypt = 0x01;
> 			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
> 									&cp);
1488,1491c1616,1617
< 			hci_auth_cfm(conn, ev->status);
< 
< 			hci_conn_hold(conn);
< 			conn->disc_timeout = HCI_DISCONN_TIMEOUT;
---
> 			conn->state = BT_CONNECTED;
> 			hci_proto_connect_cfm(conn, ev->status);
1493a1620,1621
> 	} else {
> 		hci_auth_cfm(conn, ev->status);
1495,1505c1623,1637
< 		if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
< 			if (!ev->status) {
< 				struct hci_cp_set_conn_encrypt cp;
< 				cp.handle  = ev->handle;
< 				cp.encrypt = 0x01;
< 				hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT,
< 							sizeof(cp), &cp);
< 			} else {
< 				clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
< 				hci_encrypt_cfm(conn, ev->status, 0x00);
< 			}
---
> 		hci_conn_hold(conn);
> 		conn->disc_timeout = HCI_DISCONN_TIMEOUT;
> 		hci_conn_put(conn);
> 	}
> 
> 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
> 		if (!ev->status) {
> 			struct hci_cp_set_conn_encrypt cp;
> 			cp.handle  = ev->handle;
> 			cp.encrypt = 0x01;
> 			hci_send_cmd(hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
> 									&cp);
> 		} else {
> 			clear_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend);
> 			hci_encrypt_cfm(conn, ev->status, 0x00);
1508a1641
> unlock:
1558a1692
> 				conn->sec_level = conn->pending_sec_level;
1761a1896,1899
> 	case HCI_OP_READ_LOCAL_EXT_FEATURES:
> 		hci_cc_read_local_ext_features(hdev, skb);
> 		break;
> 
1817a1956,1971
> 	case HCI_OP_LE_SET_SCAN_ENABLE:
> 		hci_cc_le_set_scan_enable(hdev, skb);
> 		break;
> 
> 	case HCI_OP_LE_LTK_REPLY:
> 		hci_cc_le_ltk_reply(hdev, skb);
> 		break;
> 
> 	case HCI_OP_LE_LTK_NEG_REPLY:
> 		hci_cc_le_ltk_neg_reply(hdev, skb);
> 		break;
> 
> 	case HCI_OP_WRITE_LE_HOST_SUPPORTED:
> 		hci_cc_write_le_host_supported(hdev, skb);
> 		break;
> 
1826c1980
< 	if (ev->ncmd) {
---
> 	if (ev->ncmd && !test_bit(HCI_RESET, &hdev->flags)) {
1895a2050,2053
> 	case HCI_OP_LE_START_ENC:
> 		hci_cs_le_start_enc(hdev, ev->status);
> 		break;
> 
2334a2493
> 	case 0x10:	/* Connection Accept Timeout */
2654c2813
< 		conn = hci_conn_add(hdev, LE_LINK, &ev->bdaddr);
---
> 		conn = hci_conn_add(hdev, LE_LINK, 0, &ev->bdaddr);
2659a2819,2820
> 
> 		conn->dst_type = ev->bdaddr_type;
2671a2833
> 	conn->sec_level = BT_SECURITY_LOW;
2683a2846,2903
> static inline void hci_le_adv_report_evt(struct hci_dev *hdev,
> 						struct sk_buff *skb)
> {
> 	struct hci_ev_le_advertising_info *ev;
> 	u8 num_reports;
> 
> 	num_reports = skb->data[0];
> 	ev = (void *) &skb->data[1];
> 
> 	hci_dev_lock(hdev);
> 
> 	hci_add_adv_entry(hdev, ev);
> 
> 	while (--num_reports) {
> 		ev = (void *) (ev->data + ev->length + 1);
> 		hci_add_adv_entry(hdev, ev);
> 	}
> 
> 	hci_dev_unlock(hdev);
> }
> 
> static inline void hci_le_ltk_request_evt(struct hci_dev *hdev,
> 						struct sk_buff *skb)
> {
> 	struct hci_ev_le_ltk_req *ev = (void *) skb->data;
> 	struct hci_cp_le_ltk_reply cp;
> 	struct hci_cp_le_ltk_neg_reply neg;
> 	struct hci_conn *conn;
> 	struct link_key *ltk;
> 
> 	BT_DBG("%s handle %d", hdev->name, cpu_to_le16(ev->handle));
> 
> 	hci_dev_lock(hdev);
> 
> 	conn = hci_conn_hash_lookup_handle(hdev, __le16_to_cpu(ev->handle));
> 	if (conn == NULL)
> 		goto not_found;
> 
> 	ltk = hci_find_ltk(hdev, ev->ediv, ev->random);
> 	if (ltk == NULL)
> 		goto not_found;
> 
> 	memcpy(cp.ltk, ltk->val, sizeof(ltk->val));
> 	cp.handle = cpu_to_le16(conn->handle);
> 	conn->pin_length = ltk->pin_len;
> 
> 	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
> 
> 	hci_dev_unlock(hdev);
> 
> 	return;
> 
> not_found:
> 	neg.handle = ev->handle;
> 	hci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(neg), &neg);
> 	hci_dev_unlock(hdev);
> }
> 
2694a2915,2922
> 	case HCI_EV_LE_ADVERTISING_REPORT:
> 		hci_le_adv_report_evt(hdev, skb);
> 		break;
> 
> 	case HCI_EV_LE_LTK_REQ:
> 		hci_le_ltk_request_evt(hdev, skb);
> 		break;
> 
2887a3116,3118
> 
> module_param(enable_le, bool, 0444);
> MODULE_PARM_DESC(enable_le, "Enable LE support");




diff -r linux-3.0.36/net/bluetooth/hci_sock.c linux-3.0.36-lenovo/net/bluetooth/hci_sock.c
183,199c183
< struct bdaddr_list *hci_blacklist_lookup(struct hci_dev *hdev, bdaddr_t *bdaddr)
< {
< 	struct list_head *p;
< 
< 	list_for_each(p, &hdev->blacklist) {
< 		struct bdaddr_list *b;
< 
< 		b = list_entry(p, struct bdaddr_list, list);
< 
< 		if (bacmp(bdaddr, &b->bdaddr) == 0)
< 			return b;
< 	}
< 
< 	return NULL;
< }
< 
< static int hci_blacklist_add(struct hci_dev *hdev, void __user *arg)
---
> static int hci_sock_blacklist_add(struct hci_dev *hdev, void __user *arg)
202d185
< 	struct bdaddr_list *entry;
207,221c190
< 	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
< 		return -EBADF;
< 
< 	if (hci_blacklist_lookup(hdev, &bdaddr))
< 		return -EEXIST;
< 
< 	entry = kzalloc(sizeof(struct bdaddr_list), GFP_KERNEL);
< 	if (!entry)
< 		return -ENOMEM;
< 
< 	bacpy(&entry->bdaddr, &bdaddr);
< 
< 	list_add(&entry->list, &hdev->blacklist);
< 
< 	return 0;
---
> 	return hci_blacklist_add(hdev, &bdaddr);
224,240c193
< int hci_blacklist_clear(struct hci_dev *hdev)
< {
< 	struct list_head *p, *n;
< 
< 	list_for_each_safe(p, n, &hdev->blacklist) {
< 		struct bdaddr_list *b;
< 
< 		b = list_entry(p, struct bdaddr_list, list);
< 
< 		list_del(p);
< 		kfree(b);
< 	}
< 
< 	return 0;
< }
< 
< static int hci_blacklist_del(struct hci_dev *hdev, void __user *arg)
---
> static int hci_sock_blacklist_del(struct hci_dev *hdev, void __user *arg)
243d195
< 	struct bdaddr_list *entry;
248,258c200
< 	if (bacmp(&bdaddr, BDADDR_ANY) == 0)
< 		return hci_blacklist_clear(hdev);
< 
< 	entry = hci_blacklist_lookup(hdev, &bdaddr);
< 	if (!entry)
< 		return -ENOENT;
< 
< 	list_del(&entry->list);
< 	kfree(entry);
< 
< 	return 0;
---
> 	return hci_blacklist_del(hdev, &bdaddr);
293c235
< 		return hci_blacklist_add(hdev, (void __user *) arg);
---
> 		return hci_sock_blacklist_add(hdev, (void __user *) arg);
298c240
< 		return hci_blacklist_del(hdev, (void __user *) arg);
---
> 		return hci_sock_blacklist_del(hdev, (void __user *) arg);
434a377
> 	haddr->hci_channel= 0;
646a590
> 			memset(&uf, 0, sizeof(uf));




diff -r linux-3.0.36/net/bluetooth/hidp/core.c linux-3.0.36-lenovo/net/bluetooth/hidp/core.c
766a767
> 	kfree(session->rd_data);
844c845,846
< 		hci_conn_put_device(session->conn);
---
> 		input_free_device(input);
> 		session->input = NULL;
937c939
< 	strncpy(hid->name, req->name, 128);
---
> 	strncpy(hid->name, req->name, sizeof(req->name) - 1);
1047,1048c1049,1054
< 	if (err < 0)
< 		goto err_add_device;
---
> 	if (err < 0) {
> 		atomic_inc(&session->terminate);
> 		wake_up_process(session->task);
> 		up_write(&hidp_session_sem);
> 		return err;
> 	}
1062,1067d1067
< err_add_device:
< 	hid_destroy_device(session->hid);
< 	session->hid = NULL;
< 	atomic_inc(&session->terminate);
< 	wake_up_process(session->task);
< 
1093d1092
< 	input_free_device(session->input);




diff -r linux-3.0.36/net/bluetooth/Kconfig linux-3.0.36-lenovo/net/bluetooth/Kconfig
8a9
> 	select CRYPTO
24a26
> 	     SMP Module (Security Manager Protocol)
38a41,44
> 	select CRYPTO
> 	select CRYPTO_BLKCIPHER
> 	select CRYPTO_AES
> 	select CRYPTO_ECB
42a49,51
> 
> 	  Also included is support for SMP (Security Manager Protocol) which
> 	  is the security layer on top of LE (Low Energy) links.




diff -r linux-3.0.36/net/bluetooth/l2cap_core.c linux-3.0.36-lenovo/net/bluetooth/l2cap_core.c
56a57
> #include <net/bluetooth/smp.h>
63,68c64,65
< static struct workqueue_struct *_busy_wq;
< 
< LIST_HEAD(chan_list);
< DEFINE_RWLOCK(chan_list_lock);
< 
< static void l2cap_busy_work(struct work_struct *work);
---
> static LIST_HEAD(chan_list);
> static DEFINE_RWLOCK(chan_list_lock);
71a69,70
> static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
> 								void *data);
72a72,73
> static void l2cap_send_disconn_req(struct l2cap_conn *conn,
> 				struct l2cap_chan *chan, int err);
76a78,89
> 
> static inline void chan_hold(struct l2cap_chan *c)
> {
> 	atomic_inc(&c->refcnt);
> }
> 
> static inline void chan_put(struct l2cap_chan *c)
> {
> 	if (atomic_dec_and_test(&c->refcnt))
> 		kfree(c);
> }
> 
206a220,275
> static void l2cap_set_timer(struct l2cap_chan *chan, struct timer_list *timer, long timeout)
> {
> 	BT_DBG("chan %p state %d timeout %ld", chan->sk, chan->state, timeout);
> 
> 	if (!mod_timer(timer, jiffies + msecs_to_jiffies(timeout)))
> 		chan_hold(chan);
> }
> 
> static void l2cap_clear_timer(struct l2cap_chan *chan, struct timer_list *timer)
> {
> 	BT_DBG("chan %p state %d", chan, chan->state);
> 
> 	if (timer_pending(timer) && del_timer(timer))
> 		chan_put(chan);
> }
> 
> static void l2cap_state_change(struct l2cap_chan *chan, int state)
> {
> 	chan->state = state;
> 	chan->ops->state_change(chan->data, state);
> }
> 
> static void l2cap_chan_timeout(unsigned long arg)
> {
> 	struct l2cap_chan *chan = (struct l2cap_chan *) arg;
> 	struct sock *sk = chan->sk;
> 	int reason;
> 
> 	BT_DBG("chan %p state %d", chan, chan->state);
> 
> 	bh_lock_sock(sk);
> 
> 	if (sock_owned_by_user(sk)) {
> 		/* sk is owned by user. Try again later */
> 		__set_chan_timer(chan, HZ / 5);
> 		bh_unlock_sock(sk);
> 		chan_put(chan);
> 		return;
> 	}
> 
> 	if (chan->state == BT_CONNECTED || chan->state == BT_CONFIG)
> 		reason = ECONNREFUSED;
> 	else if (chan->state == BT_CONNECT &&
> 					chan->sec_level != BT_SECURITY_SDP)
> 		reason = ECONNREFUSED;
> 	else
> 		reason = ETIMEDOUT;
> 
> 	l2cap_chan_close(chan, reason);
> 
> 	bh_unlock_sock(sk);
> 
> 	chan->ops->close(chan->data);
> 	chan_put(chan);
> }
> 
220a290,295
> 	setup_timer(&chan->chan_timer, l2cap_chan_timeout, (unsigned long) chan);
> 
> 	chan->state = BT_OPEN;
> 
> 	atomic_set(&chan->refcnt, 1);
> 
230c305
< 	kfree(chan);
---
> 	chan_put(chan);
235,236d309
< 	struct sock *sk = chan->sk;
< 
244c317
< 	if (sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM) {
---
> 	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED) {
255c328
< 	} else if (sk->sk_type == SOCK_DGRAM) {
---
> 	} else if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
267c340
< 	sock_hold(sk);
---
> 	chan_hold(chan);
274c347
< void l2cap_chan_del(struct l2cap_chan *chan, int err)
---
> static void l2cap_chan_del(struct l2cap_chan *chan, int err)
280c353
< 	l2cap_sock_clear_timer(sk);
---
> 	__clear_chan_timer(chan);
289c362
< 		__sock_put(sk);
---
> 		chan_put(chan);
295c368
< 	sk->sk_state = BT_CLOSED;
---
> 	l2cap_state_change(chan, BT_CLOSED);
307,308c380,381
< 	if (!(chan->conf_state & L2CAP_CONF_OUTPUT_DONE &&
< 			chan->conf_state & L2CAP_CONF_INPUT_DONE))
---
> 	if (!(test_bit(CONF_OUTPUT_DONE, &chan->conf_state) &&
> 			test_bit(CONF_INPUT_DONE, &chan->conf_state)))
316,318c389,391
< 		del_timer(&chan->retrans_timer);
< 		del_timer(&chan->monitor_timer);
< 		del_timer(&chan->ack_timer);
---
> 		__clear_retrans_timer(chan);
> 		__clear_monitor_timer(chan);
> 		__clear_ack_timer(chan);
321d393
< 		skb_queue_purge(&chan->busy_q);
330c402
< static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
---
> static void l2cap_chan_cleanup_listen(struct sock *parent)
331a404,421
> 	struct sock *sk;
> 
> 	BT_DBG("parent %p", parent);
> 
> 	/* Close not yet accepted channels */
> 	while ((sk = bt_accept_dequeue(parent, NULL))) {
> 		struct l2cap_chan *chan = l2cap_pi(sk)->chan;
> 		__clear_chan_timer(chan);
> 		lock_sock(sk);
> 		l2cap_chan_close(chan, ECONNRESET);
> 		release_sock(sk);
> 		chan->ops->close(chan->data);
> 	}
> }
> 
> void l2cap_chan_close(struct l2cap_chan *chan, int reason)
> {
> 	struct l2cap_conn *conn = chan->conn;
334c424,481
< 	if (sk->sk_type == SOCK_RAW) {
---
> 	BT_DBG("chan %p state %d socket %p", chan, chan->state, sk->sk_socket);
> 
> 	switch (chan->state) {
> 	case BT_LISTEN:
> 		l2cap_chan_cleanup_listen(sk);
> 
> 		l2cap_state_change(chan, BT_CLOSED);
> 		sock_set_flag(sk, SOCK_ZAPPED);
> 		break;
> 
> 	case BT_CONNECTED:
> 	case BT_CONFIG:
> 		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
> 					conn->hcon->type == ACL_LINK) {
> 			__clear_chan_timer(chan);
> 			__set_chan_timer(chan, sk->sk_sndtimeo);
> 			l2cap_send_disconn_req(conn, chan, reason);
> 		} else
> 			l2cap_chan_del(chan, reason);
> 		break;
> 
> 	case BT_CONNECT2:
> 		if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED &&
> 					conn->hcon->type == ACL_LINK) {
> 			struct l2cap_conn_rsp rsp;
> 			__u16 result;
> 
> 			if (bt_sk(sk)->defer_setup)
> 				result = L2CAP_CR_SEC_BLOCK;
> 			else
> 				result = L2CAP_CR_BAD_PSM;
> 			l2cap_state_change(chan, BT_DISCONN);
> 
> 			rsp.scid   = cpu_to_le16(chan->dcid);
> 			rsp.dcid   = cpu_to_le16(chan->scid);
> 			rsp.result = cpu_to_le16(result);
> 			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
> 			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
> 							sizeof(rsp), &rsp);
> 		}
> 
> 		l2cap_chan_del(chan, reason);
> 		break;
> 
> 	case BT_CONNECT:
> 	case BT_DISCONN:
> 		l2cap_chan_del(chan, reason);
> 		break;
> 
> 	default:
> 		sock_set_flag(sk, SOCK_ZAPPED);
> 		break;
> 	}
> }
> 
> static inline u8 l2cap_get_auth_type(struct l2cap_chan *chan)
> {
> 	if (chan->chan_type == L2CAP_CHAN_RAW) {
374c521
< u8 l2cap_get_ident(struct l2cap_conn *conn)
---
> static u8 l2cap_get_ident(struct l2cap_conn *conn)
396c543
< void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
---
> static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len, void *data)
410a558,559
> 	bt_cb(skb)->force_active = BT_POWER_FORCE_ACTIVE_ON;
> 
418d566
< 	struct l2cap_pinfo *pi = l2cap_pi(chan->sk);
420d567
< 	struct sock *sk = (struct sock *)pi;
424c571
< 	if (sk->sk_state != BT_CONNECTED)
---
> 	if (chan->state != BT_CONNECTED)
435c582
< 	if (chan->conn_state & L2CAP_CONN_SEND_FBIT) {
---
> 	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
437,438d583
< 		chan->conn_state &= ~L2CAP_CONN_SEND_FBIT;
< 	}
440c585
< 	if (chan->conn_state & L2CAP_CONN_SEND_PBIT) {
---
> 	if (test_and_clear_bit(CONN_SEND_PBIT, &chan->conn_state))
442,443d586
< 		chan->conn_state &= ~L2CAP_CONN_SEND_PBIT;
< 	}
463a607,608
> 	bt_cb(skb)->force_active = chan->force_active;
> 
469c614
< 	if (chan->conn_state & L2CAP_CONN_LOCAL_BUSY) {
---
> 	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
471c616
< 		chan->conn_state |= L2CAP_CONN_RNR_SENT;
---
> 		set_bit(CONN_RNR_SENT, &chan->conn_state);
482c627
< 	return !(chan->conf_state & L2CAP_CONF_CONNECT_PEND);
---
> 	return !test_bit(CONF_CONNECT_PEND, &chan->conf_state);
500c645
< 			chan->conf_state |= L2CAP_CONF_CONNECT_PEND;
---
> 			set_bit(CONF_CONNECT_PEND, &chan->conf_state);
536c681
< void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err)
---
> static void l2cap_send_disconn_req(struct l2cap_conn *conn, struct l2cap_chan *chan, int err)
547,549c692,694
< 		del_timer(&chan->retrans_timer);
< 		del_timer(&chan->monitor_timer);
< 		del_timer(&chan->ack_timer);
---
> 		__clear_retrans_timer(chan);
> 		__clear_monitor_timer(chan);
> 		__clear_ack_timer(chan);
557c702
< 	sk->sk_state = BT_DISCONN;
---
> 	l2cap_state_change(chan, BT_DISCONN);
575,576c720
< 		if (sk->sk_type != SOCK_SEQPACKET &&
< 				sk->sk_type != SOCK_STREAM) {
---
> 		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
581c725
< 		if (sk->sk_state == BT_CONNECT) {
---
> 		if (chan->state == BT_CONNECT) {
590,594c734,737
< 			if (!l2cap_mode_supported(chan->mode,
< 					conn->feat_mask)
< 					&& chan->conf_state &
< 					L2CAP_CONF_STATE2_DEVICE) {
< 				/* __l2cap_sock_close() calls list_del(chan)
---
> 			if (!l2cap_mode_supported(chan->mode, conn->feat_mask)
> 					&& test_bit(CONF_STATE2_DEVICE,
> 					&chan->conf_state)) {
> 				/* l2cap_chan_close() calls list_del(chan)
596,598c739,741
< 				read_unlock_bh(&conn->chan_lock);
< 				 __l2cap_sock_close(sk, ECONNRESET);
< 				read_lock_bh(&conn->chan_lock);
---
> 				read_unlock(&conn->chan_lock);
> 				l2cap_chan_close(chan, ECONNRESET);
> 				read_lock(&conn->chan_lock);
607c750
< 			chan->conf_state |= L2CAP_CONF_CONNECT_PEND;
---
> 			set_bit(CONF_CONNECT_PEND, &chan->conf_state);
612c755
< 		} else if (sk->sk_state == BT_CONNECT2) {
---
> 		} else if (chan->state == BT_CONNECT2) {
627c770
< 					sk->sk_state = BT_CONFIG;
---
> 					l2cap_state_change(chan, BT_CONFIG);
639c782
< 			if (chan->conf_state & L2CAP_CONF_REQ_SENT ||
---
> 			if (test_bit(CONF_REQ_SENT, &chan->conf_state) ||
645c788
< 			chan->conf_state |= L2CAP_CONF_REQ_SENT;
---
> 			set_bit(CONF_REQ_SENT, &chan->conf_state);
669c812
< 		if (state && sk->sk_state != state)
---
> 		if (state && c->state != state)
713,719c856,857
< 	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
< 	if (!sk)
< 		goto clean;
< 
< 	chan = l2cap_chan_create(sk);
< 	if (!chan) {
< 		l2cap_sock_kill(sk);
---
> 	chan = pchan->ops->new_connection(pchan->data);
> 	if (!chan)
721d858
< 	}
723c860
< 	l2cap_pi(sk)->chan = chan;
---
> 	sk = chan->sk;
729,730d865
< 	l2cap_sock_init(sk, parent);
< 
738c873
< 	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
---
> 	__set_chan_timer(chan, sk->sk_sndtimeo);
740c875
< 	sk->sk_state = BT_CONNECTED;
---
> 	l2cap_state_change(chan, BT_CONNECTED);
748a884,900
> static void l2cap_chan_ready(struct sock *sk)
> {
> 	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
> 	struct sock *parent = bt_sk(sk)->parent;
> 
> 	BT_DBG("sk %p, parent %p", sk, parent);
> 
> 	chan->conf_state = 0;
> 	__clear_chan_timer(chan);
> 
> 	l2cap_state_change(chan, BT_CONNECTED);
> 	sk->sk_state_change(sk);
> 
> 	if (parent)
> 		parent->sk_data_ready(parent, 0);
> }
> 
766,769c918,919
< 			l2cap_sock_clear_timer(sk);
< 			sk->sk_state = BT_CONNECTED;
< 			sk->sk_state_change(sk);
< 		}
---
> 			if (smp_conn_security(conn, chan->sec_level))
> 				l2cap_chan_ready(sk);
771,774c921,923
< 		if (sk->sk_type != SOCK_SEQPACKET &&
< 				sk->sk_type != SOCK_STREAM) {
< 			l2cap_sock_clear_timer(sk);
< 			sk->sk_state = BT_CONNECTED;
---
> 		} else if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
> 			__clear_chan_timer(chan);
> 			l2cap_state_change(chan, BT_CONNECTED);
776c925,926
< 		} else if (sk->sk_state == BT_CONNECT)
---
> 
> 		} else if (chan->state == BT_CONNECT)
813a964,1002
> static void l2cap_conn_del(struct hci_conn *hcon, int err)
> {
> 	struct l2cap_conn *conn = hcon->l2cap_data;
> 	struct l2cap_chan *chan, *l;
> 	struct sock *sk;
> 
> 	if (!conn)
> 		return;
> 
> 	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
> 
> 	kfree_skb(conn->rx_skb);
> 
> 	/* Kill channels */
> 	list_for_each_entry_safe(chan, l, &conn->chan_l, list) {
> 		sk = chan->sk;
> 		bh_lock_sock(sk);
> 		l2cap_chan_del(chan, err);
> 		bh_unlock_sock(sk);
> 		chan->ops->close(chan->data);
> 	}
> 
> 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
> 		del_timer_sync(&conn->info_timer);
> 
> 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &hcon->pend))
> 		del_timer(&conn->security_timer);
> 
> 	hcon->l2cap_data = NULL;
> 	kfree(conn);
> }
> 
> static void security_timeout(unsigned long arg)
> {
> 	struct l2cap_conn *conn = (void *) arg;
> 
> 	l2cap_conn_del(conn->hcon, ETIMEDOUT);
> }
> 
845c1034,1037
< 	if (hcon->type != LE_LINK)
---
> 	if (hcon->type == LE_LINK)
> 		setup_timer(&conn->security_timer, security_timeout,
> 						(unsigned long) conn);
> 	else
854,882d1045
< static void l2cap_conn_del(struct hci_conn *hcon, int err)
< {
< 	struct l2cap_conn *conn = hcon->l2cap_data;
< 	struct l2cap_chan *chan, *l;
< 	struct sock *sk;
< 
< 	if (!conn)
< 		return;
< 
< 	BT_DBG("hcon %p conn %p, err %d", hcon, conn, err);
< 
< 	kfree_skb(conn->rx_skb);
< 
< 	/* Kill channels */
< 	list_for_each_entry_safe(chan, l, &conn->chan_l, list) {
< 		sk = chan->sk;
< 		bh_lock_sock(sk);
< 		l2cap_chan_del(chan, err);
< 		bh_unlock_sock(sk);
< 		l2cap_sock_kill(sk);
< 	}
< 
< 	if (conn->info_state & L2CAP_INFO_FEAT_MASK_REQ_SENT)
< 		del_timer_sync(&conn->info_timer);
< 
< 	hcon->l2cap_data = NULL;
< 	kfree(conn);
< }
< 
904c1067
< 		if (state && sk->sk_state != state)
---
> 		if (state && c->state != state)
948c1111
< 		hcon = hci_connect(hdev, LE_LINK, dst,
---
> 		hcon = hci_connect(hdev, LE_LINK, 0, dst,
951c1114
< 		hcon = hci_connect(hdev, ACL_LINK, dst,
---
> 		hcon = hci_connect(hdev, ACL_LINK, 0, dst,
971,972c1134,1135
< 	sk->sk_state = BT_CONNECT;
< 	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
---
> 	l2cap_state_change(chan, BT_CONNECT);
> 	__set_chan_timer(chan, sk->sk_sndtimeo);
975,977c1138,1139
< 		if (sk->sk_type != SOCK_SEQPACKET &&
< 				sk->sk_type != SOCK_STREAM) {
< 			l2cap_sock_clear_timer(sk);
---
> 		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED) {
> 			__clear_chan_timer(chan);
979c1141
< 				sk->sk_state = BT_CONNECTED;
---
> 				l2cap_state_change(chan, BT_CONNECTED);
1000,1002c1162,1163
< 	while ((chan->unacked_frames > 0 && chan->conn)) {
< 		set_current_state(TASK_INTERRUPTIBLE);
< 
---
> 	set_current_state(TASK_INTERRUPTIBLE);
> 	while (chan->unacked_frames > 0 && chan->conn) {
1013a1175
> 		set_current_state(TASK_INTERRUPTIBLE);
1039c1201
< 	__mod_monitor_timer();
---
> 	__set_monitor_timer(chan);
1054c1216
< 	__mod_monitor_timer();
---
> 	__set_monitor_timer(chan);
1056c1218
< 	chan->conn_state |= L2CAP_CONN_WAIT_F;
---
> 	set_bit(CONN_WAIT_F, &chan->conn_state);
1078c1240
< 		del_timer(&chan->retrans_timer);
---
> 		__clear_retrans_timer(chan);
1092a1255
> 	bt_cb(skb)->force_active = chan->force_active;
1146c1309
< 	if (chan->conn_state & L2CAP_CONN_SEND_FBIT) {
---
> 	if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
1148,1149d1310
< 		chan->conn_state &= ~L2CAP_CONN_SEND_FBIT;
< 	}
1167d1327
< 	struct sock *sk = chan->sk;
1171c1331
< 	if (sk->sk_state != BT_CONNECTED)
---
> 	if (chan->state != BT_CONNECTED)
1189c1349
< 		if (chan->conn_state & L2CAP_CONN_SEND_FBIT) {
---
> 		if (test_and_clear_bit(CONN_SEND_FBIT, &chan->conn_state))
1191,1192c1351
< 			chan->conn_state &= ~L2CAP_CONN_SEND_FBIT;
< 		}
---
> 
1205c1364
< 		__mod_retrans_timer();
---
> 		__set_retrans_timer(chan);
1244c1403
< 	if (chan->conn_state & L2CAP_CONN_LOCAL_BUSY) {
---
> 	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
1246c1405
< 		chan->conn_state |= L2CAP_CONN_RNR_SENT;
---
> 		set_bit(CONN_RNR_SENT, &chan->conn_state);
1454c1613
< static void l2cap_chan_ready(struct sock *sk)
---
> int l2cap_chan_send(struct l2cap_chan *chan, struct msghdr *msg, size_t len)
1456,1457c1615,1617
< 	struct sock *parent = bt_sk(sk)->parent;
< 	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
---
> 	struct sk_buff *skb;
> 	u16 control;
> 	int err;
1459c1619,1623
< 	BT_DBG("sk %p, parent %p", sk, parent);
---
> 	/* Connectionless channel */
> 	if (chan->chan_type == L2CAP_CHAN_CONN_LESS) {
> 		skb = l2cap_create_connless_pdu(chan, msg, len);
> 		if (IS_ERR(skb))
> 			return PTR_ERR(skb);
1461,1462c1625,1627
< 	chan->conf_state = 0;
< 	l2cap_sock_clear_timer(sk);
---
> 		l2cap_do_send(chan, skb);
> 		return len;
> 	}
1464,1474c1629,1686
< 	if (!parent) {
< 		/* Outgoing channel.
< 		 * Wake up socket sleeping on connect.
< 		 */
< 		sk->sk_state = BT_CONNECTED;
< 		sk->sk_state_change(sk);
< 	} else {
< 		/* Incoming channel.
< 		 * Wake up socket sleeping on accept.
< 		 */
< 		parent->sk_data_ready(parent, 0);
---
> 	switch (chan->mode) {
> 	case L2CAP_MODE_BASIC:
> 		/* Check outgoing MTU */
> 		if (len > chan->omtu)
> 			return -EMSGSIZE;
> 
> 		/* Create a basic PDU */
> 		skb = l2cap_create_basic_pdu(chan, msg, len);
> 		if (IS_ERR(skb))
> 			return PTR_ERR(skb);
> 
> 		l2cap_do_send(chan, skb);
> 		err = len;
> 		break;
> 
> 	case L2CAP_MODE_ERTM:
> 	case L2CAP_MODE_STREAMING:
> 		/* Entire SDU fits into one PDU */
> 		if (len <= chan->remote_mps) {
> 			control = L2CAP_SDU_UNSEGMENTED;
> 			skb = l2cap_create_iframe_pdu(chan, msg, len, control,
> 									0);
> 			if (IS_ERR(skb))
> 				return PTR_ERR(skb);
> 
> 			__skb_queue_tail(&chan->tx_q, skb);
> 
> 			if (chan->tx_send_head == NULL)
> 				chan->tx_send_head = skb;
> 
> 		} else {
> 			/* Segment SDU into multiples PDUs */
> 			err = l2cap_sar_segment_sdu(chan, msg, len);
> 			if (err < 0)
> 				return err;
> 		}
> 
> 		if (chan->mode == L2CAP_MODE_STREAMING) {
> 			l2cap_streaming_send(chan);
> 			err = len;
> 			break;
> 		}
> 
> 		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
> 				test_bit(CONN_WAIT_F, &chan->conn_state)) {
> 			err = len;
> 			break;
> 		}
> 
> 		err = l2cap_ertm_send(chan);
> 		if (err >= 0)
> 			err = len;
> 
> 		break;
> 
> 	default:
> 		BT_DBG("bad state %1.1x", chan->mode);
> 		err = -EBADFD;
1475a1688,1689
> 
> 	return err;
1489c1703
< 		if (sk->sk_type != SOCK_RAW)
---
> 		if (chan->chan_type != L2CAP_CHAN_RAW)
1499c1713
< 		if (sock_queue_rcv_skb(sk, nskb))
---
> 		if (chan->ops->recv(chan->data, nskb))
1658d1871
< 	skb_queue_head_init(&chan->busy_q);
1662d1874
< 	INIT_WORK(&chan->busy_work, l2cap_busy_work);
1694c1906
< 		if (chan->conf_state & L2CAP_CONF_STATE2_DEVICE)
---
> 		if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state))
1741c1953
< 				chan->conf_state & L2CAP_CONF_NO_FCS_RECV) {
---
> 				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
1764c1976
< 				chan->conf_state & L2CAP_CONF_NO_FCS_RECV) {
---
> 				test_bit(CONF_NO_FCS_RECV, &chan->conf_state)) {
1816c2028
< 				chan->conf_state |= L2CAP_CONF_NO_FCS_RECV;
---
> 				set_bit(CONF_NO_FCS_RECV, &chan->conf_state);
1836c2048
< 		if (!(chan->conf_state & L2CAP_CONF_STATE2_DEVICE)) {
---
> 		if (!test_bit(CONF_STATE2_DEVICE, &chan->conf_state)) {
1869c2081
< 			chan->conf_state |= L2CAP_CONF_MTU_DONE;
---
> 			set_bit(CONF_MTU_DONE, &chan->conf_state);
1876c2088
< 			chan->conf_state |= L2CAP_CONF_MODE_DONE;
---
> 			set_bit(CONF_MODE_DONE, &chan->conf_state);
1893c2105
< 			chan->conf_state |= L2CAP_CONF_MODE_DONE;
---
> 			set_bit(CONF_MODE_DONE, &chan->conf_state);
1906c2118
< 			chan->conf_state |= L2CAP_CONF_MODE_DONE;
---
> 			set_bit(CONF_MODE_DONE, &chan->conf_state);
1921c2133
< 			chan->conf_state |= L2CAP_CONF_OUTPUT_DONE;
---
> 			set_bit(CONF_OUTPUT_DONE, &chan->conf_state);
1963c2175
< 			if ((chan->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
---
> 			if (test_bit(CONF_STATE2_DEVICE, &chan->conf_state) &&
2025c2237
< 	if (chan->conf_state & L2CAP_CONF_REQ_SENT)
---
> 	if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
2028d2239
< 	chan->conf_state |= L2CAP_CONF_REQ_SENT;
2128,2134c2339,2340
< 	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP, GFP_ATOMIC);
< 	if (!sk)
< 		goto response;
< 
< 	chan = l2cap_chan_create(sk);
< 	if (!chan) {
< 		l2cap_sock_kill(sk);
---
> 	chan = pchan->ops->new_connection(pchan->data);
> 	if (!chan)
2136d2341
< 	}
2138c2343
< 	l2cap_pi(sk)->chan = chan;
---
> 	sk = chan->sk;
2146c2351
< 		l2cap_sock_kill(sk);
---
> 		chan->ops->close(chan->data);
2152d2356
< 	l2cap_sock_init(sk, parent);
2164c2368
< 	l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
---
> 	__set_chan_timer(chan, sk->sk_sndtimeo);
2171c2375
< 				sk->sk_state = BT_CONNECT2;
---
> 				l2cap_state_change(chan, BT_CONNECT2);
2176c2380
< 				sk->sk_state = BT_CONFIG;
---
> 				l2cap_state_change(chan, BT_CONFIG);
2181c2385
< 			sk->sk_state = BT_CONNECT2;
---
> 			l2cap_state_change(chan, BT_CONNECT2);
2186c2390
< 		sk->sk_state = BT_CONNECT2;
---
> 		l2cap_state_change(chan, BT_CONNECT2);
2217c2421
< 	if (chan && !(chan->conf_state & L2CAP_CONF_REQ_SENT) &&
---
> 	if (chan && !test_bit(CONF_REQ_SENT, &chan->conf_state) &&
2220c2424
< 		chan->conf_state |= L2CAP_CONF_REQ_SENT;
---
> 		set_bit(CONF_REQ_SENT, &chan->conf_state);
2258c2462
< 		sk->sk_state = BT_CONFIG;
---
> 		l2cap_state_change(chan, BT_CONFIG);
2261c2465
< 		chan->conf_state &= ~L2CAP_CONF_CONNECT_PEND;
---
> 		clear_bit(CONF_CONNECT_PEND, &chan->conf_state);
2263c2467
< 		if (chan->conf_state & L2CAP_CONF_REQ_SENT)
---
> 		if (test_and_set_bit(CONF_REQ_SENT, &chan->conf_state))
2266,2267d2469
< 		chan->conf_state |= L2CAP_CONF_REQ_SENT;
< 
2274c2476
< 		chan->conf_state |= L2CAP_CONF_CONNECT_PEND;
---
> 		set_bit(CONF_CONNECT_PEND, &chan->conf_state);
2280,2282c2482,2484
< 			sk->sk_state = BT_DISCONN;
< 			l2cap_sock_clear_timer(sk);
< 			l2cap_sock_set_timer(sk, HZ / 5);
---
> 			l2cap_state_change(chan, BT_DISCONN);
> 			__clear_chan_timer(chan);
> 			__set_chan_timer(chan, HZ / 5);
2296,2297d2497
< 	struct l2cap_pinfo *pi = l2cap_pi(chan->sk);
< 
2303c2503
< 	else if (!(pi->chan->conf_state & L2CAP_CONF_NO_FCS_RECV))
---
> 	else if (!test_bit(CONF_NO_FCS_RECV, &chan->conf_state))
2370c2570
< 	if (!(chan->conf_state & L2CAP_CONF_OUTPUT_DONE))
---
> 	if (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))
2373c2573
< 	if (chan->conf_state & L2CAP_CONF_INPUT_DONE) {
---
> 	if (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {
2376c2576
< 		sk->sk_state = BT_CONNECTED;
---
> 		l2cap_state_change(chan, BT_CONNECTED);
2388c2588
< 	if (!(chan->conf_state & L2CAP_CONF_REQ_SENT)) {
---
> 	if (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {
2390d2589
< 		chan->conf_state |= L2CAP_CONF_REQ_SENT;
2455c2654
< 		l2cap_sock_set_timer(sk, HZ * 5);
---
> 		__set_chan_timer(chan, HZ * 5);
2463c2662
< 	chan->conf_state |= L2CAP_CONF_INPUT_DONE;
---
> 	set_bit(CONF_INPUT_DONE, &chan->conf_state);
2465c2664
< 	if (chan->conf_state & L2CAP_CONF_OUTPUT_DONE) {
---
> 	if (test_bit(CONF_OUTPUT_DONE, &chan->conf_state)) {
2468c2667
< 		sk->sk_state = BT_CONNECTED;
---
> 		l2cap_state_change(chan, BT_CONNECTED);
2510,2512c2709,2711
< 		sk->sk_state = BT_DISCONN;
< 		l2cap_sock_clear_timer(sk);
< 		l2cap_sock_set_timer(sk, HZ / 5);
---
> 		l2cap_state_change(chan, BT_DISCONN);
> 		__clear_chan_timer(chan);
> 		__set_chan_timer(chan, HZ / 5);
2520c2719
< 	l2cap_sock_kill(sk);
---
> 	chan->ops->close(chan->data);
2544,2546c2743,2745
< 		sk->sk_state = BT_DISCONN;
< 		l2cap_sock_clear_timer(sk);
< 		l2cap_sock_set_timer(sk, HZ / 5);
---
> 		l2cap_state_change(chan,BT_DISCONN);
> 		__clear_chan_timer(chan);
> 		__set_chan_timer(chan, HZ / 5);
2554c2753
< 	l2cap_sock_kill(sk);
---
> 	chan->ops->close(chan->data);
2862c3061
< 	if (chan->conn_state & L2CAP_CONN_LOCAL_BUSY) {
---
> 	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
2865c3064
< 		chan->conn_state |= L2CAP_CONN_RNR_SENT;
---
> 		set_bit(CONN_RNR_SENT, &chan->conn_state);
2868c3067
< 	if (chan->conn_state & L2CAP_CONN_REMOTE_BUSY)
---
> 	if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state))
2873c3072
< 	if (!(chan->conn_state & L2CAP_CONN_LOCAL_BUSY) &&
---
> 	if (!test_bit(CONN_LOCAL_BUSY, &chan->conn_state) &&
2929c3128
< 		if (chan->conn_state & L2CAP_CONN_SAR_SDU)
---
> 		if (test_bit(CONN_SAR_SDU, &chan->conn_state))
2932,2936c3131
< 		err = sock_queue_rcv_skb(chan->sk, skb);
< 		if (!err)
< 			return err;
< 
< 		break;
---
> 		return chan->ops->recv(chan->data, skb);
2939c3134
< 		if (chan->conn_state & L2CAP_CONN_SAR_SDU)
---
> 		if (test_bit(CONN_SAR_SDU, &chan->conn_state))
2958c3153
< 		chan->conn_state |= L2CAP_CONN_SAR_SDU;
---
> 		set_bit(CONN_SAR_SDU, &chan->conn_state);
2963c3158
< 		if (!(chan->conn_state & L2CAP_CONN_SAR_SDU))
---
> 		if (!test_bit(CONN_SAR_SDU, &chan->conn_state))
2978c3173
< 		if (!(chan->conn_state & L2CAP_CONN_SAR_SDU))
---
> 		if (!test_bit(CONN_SAR_SDU, &chan->conn_state))
2984,2985c3179
< 		if (!(chan->conn_state & L2CAP_CONN_SAR_RETRY)) {
< 			chan->partial_sdu_len += skb->len;
---
> 		chan->partial_sdu_len += skb->len;
2987,2988c3181,3182
< 			if (chan->partial_sdu_len > chan->imtu)
< 				goto drop;
---
> 		if (chan->partial_sdu_len > chan->imtu)
> 			goto drop;
2990,2991c3184,3185
< 			if (chan->partial_sdu_len != chan->sdu_len)
< 				goto drop;
---
> 		if (chan->partial_sdu_len != chan->sdu_len)
> 			goto drop;
2993,2994c3187
< 			memcpy(skb_put(chan->sdu, skb->len), skb->data, skb->len);
< 		}
---
> 		memcpy(skb_put(chan->sdu, skb->len), skb->data, skb->len);
2998d3190
< 			chan->conn_state |= L2CAP_CONN_SAR_RETRY;
3002c3194
< 		err = sock_queue_rcv_skb(chan->sk, _skb);
---
> 		err = chan->ops->recv(chan->data, _skb);
3005d3196
< 			chan->conn_state |= L2CAP_CONN_SAR_RETRY;
3009,3010c3200
< 		chan->conn_state &= ~L2CAP_CONN_SAR_RETRY;
< 		chan->conn_state &= ~L2CAP_CONN_SAR_SDU;
---
> 		clear_bit(CONN_SAR_SDU, &chan->conn_state);
3029c3219
< static int l2cap_try_push_rx_skb(struct l2cap_chan *chan)
---
> static void l2cap_ertm_enter_local_busy(struct l2cap_chan *chan)
3031d3220
< 	struct sk_buff *skb;
3033d3221
< 	int err;
3035,3044c3223
< 	while ((skb = skb_dequeue(&chan->busy_q))) {
< 		control = bt_cb(skb)->sar << L2CAP_CTRL_SAR_SHIFT;
< 		err = l2cap_ertm_reassembly_sdu(chan, skb, control);
< 		if (err < 0) {
< 			skb_queue_head(&chan->busy_q, skb);
< 			return -EBUSY;
< 		}
< 
< 		chan->buffer_seq = (chan->buffer_seq + 1) % 64;
< 	}
---
> 	BT_DBG("chan %p, Enter local busy", chan);
3046,3047c3225
< 	if (!(chan->conn_state & L2CAP_CONN_RNR_SENT))
< 		goto done;
---
> 	set_bit(CONN_LOCAL_BUSY, &chan->conn_state);
3050c3228
< 	control |= L2CAP_SUPER_RCV_READY | L2CAP_CTRL_POLL;
---
> 	control |= L2CAP_SUPER_RCV_NOT_READY;
3052,3055d3229
< 	chan->retry_count = 1;
< 
< 	del_timer(&chan->retrans_timer);
< 	__mod_monitor_timer();
3057c3231
< 	chan->conn_state |= L2CAP_CONN_WAIT_F;
---
> 	set_bit(CONN_RNR_SENT, &chan->conn_state);
3059,3065c3233
< done:
< 	chan->conn_state &= ~L2CAP_CONN_LOCAL_BUSY;
< 	chan->conn_state &= ~L2CAP_CONN_RNR_SENT;
< 
< 	BT_DBG("chan %p, Exit local busy", chan);
< 
< 	return 0;
---
> 	__clear_ack_timer(chan);
3068c3236
< static void l2cap_busy_work(struct work_struct *work)
---
> static void l2cap_ertm_exit_local_busy(struct l2cap_chan *chan)
3070,3090c3238
< 	DECLARE_WAITQUEUE(wait, current);
< 	struct l2cap_chan *chan =
< 		container_of(work, struct l2cap_chan, busy_work);
< 	struct sock *sk = chan->sk;
< 	int n_tries = 0, timeo = HZ/5, err;
< 	struct sk_buff *skb;
< 
< 	lock_sock(sk);
< 
< 	add_wait_queue(sk_sleep(sk), &wait);
< 	while ((skb = skb_peek(&chan->busy_q))) {
< 		set_current_state(TASK_INTERRUPTIBLE);
< 
< 		if (n_tries++ > L2CAP_LOCAL_BUSY_TRIES) {
< 			err = -EBUSY;
< 			l2cap_send_disconn_req(chan->conn, chan, EBUSY);
< 			break;
< 		}
< 
< 		if (!timeo)
< 			timeo = HZ/5;
---
> 	u16 control;
3092,3095c3240,3241
< 		if (signal_pending(current)) {
< 			err = sock_intr_errno(timeo);
< 			break;
< 		}
---
> 	if (!test_bit(CONN_RNR_SENT, &chan->conn_state))
> 		goto done;
3097,3099c3243,3246
< 		release_sock(sk);
< 		timeo = schedule_timeout(timeo);
< 		lock_sock(sk);
---
> 	control = chan->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
> 	control |= L2CAP_SUPER_RCV_READY | L2CAP_CTRL_POLL;
> 	l2cap_send_sframe(chan, control);
> 	chan->retry_count = 1;
3101,3103c3248,3249
< 		err = sock_error(sk);
< 		if (err)
< 			break;
---
> 	__clear_retrans_timer(chan);
> 	__set_monitor_timer(chan);
3105,3107c3251
< 		if (l2cap_try_push_rx_skb(chan) == 0)
< 			break;
< 	}
---
> 	set_bit(CONN_WAIT_F, &chan->conn_state);
3109,3110c3253,3255
< 	set_current_state(TASK_RUNNING);
< 	remove_wait_queue(sk_sleep(sk), &wait);
---
> done:
> 	clear_bit(CONN_LOCAL_BUSY, &chan->conn_state);
> 	clear_bit(CONN_RNR_SENT, &chan->conn_state);
3112c3257
< 	release_sock(sk);
---
> 	BT_DBG("chan %p, Exit local busy", chan);
3115c3260
< static int l2cap_push_rx_skb(struct l2cap_chan *chan, struct sk_buff *skb, u16 control)
---
> void l2cap_chan_busy(struct l2cap_chan *chan, int busy)
3117,3130c3262,3266
< 	int sctrl, err;
< 
< 	if (chan->conn_state & L2CAP_CONN_LOCAL_BUSY) {
< 		bt_cb(skb)->sar = control >> L2CAP_CTRL_SAR_SHIFT;
< 		__skb_queue_tail(&chan->busy_q, skb);
< 		return l2cap_try_push_rx_skb(chan);
< 
< 
< 	}
< 
< 	err = l2cap_ertm_reassembly_sdu(chan, skb, control);
< 	if (err >= 0) {
< 		chan->buffer_seq = (chan->buffer_seq + 1) % 64;
< 		return err;
---
> 	if (chan->mode == L2CAP_MODE_ERTM) {
> 		if (busy)
> 			l2cap_ertm_enter_local_busy(chan);
> 		else
> 			l2cap_ertm_exit_local_busy(chan);
3132,3150d3267
< 
< 	/* Busy Condition */
< 	BT_DBG("chan %p, Enter local busy", chan);
< 
< 	chan->conn_state |= L2CAP_CONN_LOCAL_BUSY;
< 	bt_cb(skb)->sar = control >> L2CAP_CTRL_SAR_SHIFT;
< 	__skb_queue_tail(&chan->busy_q, skb);
< 
< 	sctrl = chan->buffer_seq << L2CAP_CTRL_REQSEQ_SHIFT;
< 	sctrl |= L2CAP_SUPER_RCV_NOT_READY;
< 	l2cap_send_sframe(chan, sctrl);
< 
< 	chan->conn_state |= L2CAP_CONN_RNR_SENT;
< 
< 	del_timer(&chan->ack_timer);
< 
< 	queue_work(_busy_wq, &chan->busy_work);
< 
< 	return err;
3165c3282
< 		if (chan->conn_state & L2CAP_CONN_SAR_SDU) {
---
> 		if (test_bit(CONN_SAR_SDU, &chan->conn_state)) {
3170c3287
< 		err = sock_queue_rcv_skb(chan->sk, skb);
---
> 		err = chan->ops->recv(chan->data, skb);
3177c3294
< 		if (chan->conn_state & L2CAP_CONN_SAR_SDU) {
---
> 		if (test_bit(CONN_SAR_SDU, &chan->conn_state)) {
3198c3315
< 		chan->conn_state |= L2CAP_CONN_SAR_SDU;
---
> 		set_bit(CONN_SAR_SDU, &chan->conn_state);
3204c3321
< 		if (!(chan->conn_state & L2CAP_CONN_SAR_SDU))
---
> 		if (!test_bit(CONN_SAR_SDU, &chan->conn_state))
3218c3335
< 		if (!(chan->conn_state & L2CAP_CONN_SAR_SDU))
---
> 		if (!test_bit(CONN_SAR_SDU, &chan->conn_state))
3223c3340
< 		chan->conn_state &= ~L2CAP_CONN_SAR_SDU;
---
> 		clear_bit(CONN_SAR_SDU, &chan->conn_state);
3231c3348
< 			err = sock_queue_rcv_skb(chan->sk, _skb);
---
> 			err = chan->ops->recv(chan->data, _skb);
3251c3368,3371
< 	while ((skb = skb_peek(&chan->srej_q))) {
---
> 	while ((skb = skb_peek(&chan->srej_q)) &&
> 			!test_bit(CONN_LOCAL_BUSY, &chan->conn_state)) {
> 		int err;
> 
3257c3377,3383
< 		l2cap_ertm_reassembly_sdu(chan, skb, control);
---
> 		err = l2cap_ertm_reassembly_sdu(chan, skb, control);
> 
> 		if (err < 0) {
> 			l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
> 			break;
> 		}
> 
3314,3315c3440,3441
< 			chan->conn_state & L2CAP_CONN_WAIT_F) {
< 		del_timer(&chan->monitor_timer);
---
> 			test_bit(CONN_WAIT_F, &chan->conn_state)) {
> 		__clear_monitor_timer(chan);
3317,3318c3443,3444
< 			__mod_retrans_timer();
< 		chan->conn_state &= ~L2CAP_CONN_WAIT_F;
---
> 			__set_retrans_timer(chan);
> 		clear_bit(CONN_WAIT_F, &chan->conn_state);
3324,3326d3449
< 	if (tx_seq == chan->expected_tx_seq)
< 		goto expected;
< 
3337c3460
< 	if (chan->conn_state == L2CAP_CONN_LOCAL_BUSY)
---
> 	if (test_bit(CONN_LOCAL_BUSY, &chan->conn_state))
3340c3463,3466
< 	if (chan->conn_state & L2CAP_CONN_SREJ_SENT) {
---
> 	if (tx_seq == chan->expected_tx_seq)
> 		goto expected;
> 
> 	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
3354c3480
< 				chan->conn_state &= ~L2CAP_CONN_SREJ_SENT;
---
> 				clear_bit(CONN_SREJ_SENT, &chan->conn_state);
3383c3509
< 		chan->conn_state |= L2CAP_CONN_SREJ_SENT;
---
> 		set_bit(CONN_SREJ_SENT, &chan->conn_state);
3391d3516
< 		__skb_queue_head_init(&chan->busy_q);
3394c3519
< 		chan->conn_state |= L2CAP_CONN_SEND_PBIT;
---
> 		set_bit(CONN_SEND_PBIT, &chan->conn_state);
3398c3523
< 		del_timer(&chan->ack_timer);
---
> 		__clear_ack_timer(chan);
3405c3530
< 	if (chan->conn_state & L2CAP_CONN_SREJ_SENT) {
---
> 	if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
3412,3414c3537,3542
< 	err = l2cap_push_rx_skb(chan, skb, rx_control);
< 	if (err < 0)
< 		return 0;
---
> 	err = l2cap_ertm_reassembly_sdu(chan, skb, rx_control);
> 	chan->buffer_seq = (chan->buffer_seq + 1) % 64;
> 	if (err < 0) {
> 		l2cap_send_disconn_req(chan->conn, chan, ECONNRESET);
> 		return err;
> 	}
3417,3419c3545
< 		if (chan->conn_state & L2CAP_CONN_REJ_ACT)
< 			chan->conn_state &= ~L2CAP_CONN_REJ_ACT;
< 		else
---
> 		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
3423c3549
< 	__mod_ack_timer();
---
> 	__set_ack_timer(chan);
3445,3447c3571,3573
< 		chan->conn_state |= L2CAP_CONN_SEND_FBIT;
< 		if (chan->conn_state & L2CAP_CONN_SREJ_SENT) {
< 			if ((chan->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
---
> 		set_bit(CONN_SEND_FBIT, &chan->conn_state);
> 		if (test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
> 			if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
3449c3575
< 				__mod_retrans_timer();
---
> 				__set_retrans_timer(chan);
3451c3577
< 			chan->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
---
> 			clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
3458c3584
< 		chan->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
---
> 		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
3460,3462c3586
< 		if (chan->conn_state & L2CAP_CONN_REJ_ACT)
< 			chan->conn_state &= ~L2CAP_CONN_REJ_ACT;
< 		else
---
> 		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
3466c3590
< 		if ((chan->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
---
> 		if (test_bit(CONN_REMOTE_BUSY, &chan->conn_state) &&
3468c3592
< 			__mod_retrans_timer();
---
> 			__set_retrans_timer(chan);
3470,3471c3594,3595
< 		chan->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
< 		if (chan->conn_state & L2CAP_CONN_SREJ_SENT)
---
> 		clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
> 		if (test_bit(CONN_SREJ_SENT, &chan->conn_state))
3484c3608
< 	chan->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
---
> 	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
3490,3492c3614
< 		if (chan->conn_state & L2CAP_CONN_REJ_ACT)
< 			chan->conn_state &= ~L2CAP_CONN_REJ_ACT;
< 		else
---
> 		if (!test_and_clear_bit(CONN_REJ_ACT, &chan->conn_state))
3497,3498c3619,3620
< 		if (chan->conn_state & L2CAP_CONN_WAIT_F)
< 			chan->conn_state |= L2CAP_CONN_REJ_ACT;
---
> 		if (test_bit(CONN_WAIT_F, &chan->conn_state))
> 			set_bit(CONN_REJ_ACT, &chan->conn_state);
3507c3629
< 	chan->conn_state &= ~L2CAP_CONN_REMOTE_BUSY;
---
> 	clear_bit(CONN_REMOTE_BUSY, &chan->conn_state);
3513c3635
< 		chan->conn_state |= L2CAP_CONN_SEND_FBIT;
---
> 		set_bit(CONN_SEND_FBIT, &chan->conn_state);
3518c3640
< 		if (chan->conn_state & L2CAP_CONN_WAIT_F) {
---
> 		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
3520c3642
< 			chan->conn_state |= L2CAP_CONN_SREJ_ACT;
---
> 			set_bit(CONN_SREJ_ACT, &chan->conn_state);
3523c3645
< 		if ((chan->conn_state & L2CAP_CONN_SREJ_ACT) &&
---
> 		if (test_bit(CONN_SREJ_ACT, &chan->conn_state) &&
3525c3647
< 			chan->conn_state &= ~L2CAP_CONN_SREJ_ACT;
---
> 			clear_bit(CONN_SREJ_ACT, &chan->conn_state);
3530c3652
< 		if (chan->conn_state & L2CAP_CONN_WAIT_F) {
---
> 		if (test_bit(CONN_WAIT_F, &chan->conn_state)) {
3532c3654
< 			chan->conn_state |= L2CAP_CONN_SREJ_ACT;
---
> 			set_bit(CONN_SREJ_ACT, &chan->conn_state);
3543c3665
< 	chan->conn_state |= L2CAP_CONN_REMOTE_BUSY;
---
> 	set_bit(CONN_REMOTE_BUSY, &chan->conn_state);
3548c3670
< 		chan->conn_state |= L2CAP_CONN_SEND_FBIT;
---
> 		set_bit(CONN_SEND_FBIT, &chan->conn_state);
3550,3551c3672,3673
< 	if (!(chan->conn_state & L2CAP_CONN_SREJ_SENT)) {
< 		del_timer(&chan->retrans_timer);
---
> 	if (!test_bit(CONN_SREJ_SENT, &chan->conn_state)) {
> 		__clear_retrans_timer(chan);
3568,3569c3690,3691
< 			chan->conn_state & L2CAP_CONN_WAIT_F) {
< 		del_timer(&chan->monitor_timer);
---
> 			test_bit(CONN_WAIT_F, &chan->conn_state)) {
> 		__clear_monitor_timer(chan);
3571,3572c3693,3694
< 			__mod_retrans_timer();
< 		chan->conn_state &= ~L2CAP_CONN_WAIT_F;
---
> 			__set_retrans_timer(chan);
> 		clear_bit(CONN_WAIT_F, &chan->conn_state);
3671d3792
< 	struct l2cap_pinfo *pi;
3683d3803
< 	pi = l2cap_pi(sk);
3687c3807
< 	if (sk->sk_state != BT_CONNECTED)
---
> 	if (chan->state != BT_CONNECTED)
3700c3820
< 		if (!sock_queue_rcv_skb(sk, skb))
---
> 		if (!chan->ops->recv(chan->data, skb))
3772c3892
< 	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
---
> 	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
3775c3895
< 	if (l2cap_pi(sk)->chan->imtu < skb->len)
---
> 	if (chan->imtu < skb->len)
3778c3898
< 	if (!sock_queue_rcv_skb(sk, skb))
---
> 	if (!chan->ops->recv(chan->data, skb))
3805c3925
< 	if (sk->sk_state != BT_BOUND && sk->sk_state != BT_CONNECTED)
---
> 	if (chan->state != BT_BOUND && chan->state != BT_CONNECTED)
3808c3928
< 	if (l2cap_pi(sk)->chan->imtu < skb->len)
---
> 	if (chan->imtu < skb->len)
3811c3931
< 	if (!sock_queue_rcv_skb(sk, skb))
---
> 	if (!chan->ops->recv(chan->data, skb))
3855a3976,3980
> 	case L2CAP_CID_SMP:
> 		if (smp_sig_channel(conn, skb))
> 			l2cap_conn_del(conn->hcon, EACCES);
> 		break;
> 
3879c4004
< 		if (sk->sk_state != BT_LISTEN)
---
> 		if (c->state != BT_LISTEN)
3912c4037
< 		l2cap_conn_del(hcon, bt_err(status));
---
> 		l2cap_conn_del(hcon, bt_to_errno(status));
3923c4048
< 	if (hcon->type != ACL_LINK || !conn)
---
> 	if ((hcon->type != ACL_LINK && hcon->type != LE_LINK) || !conn)
3936c4061
< 	l2cap_conn_del(hcon, bt_err(reason));
---
> 	l2cap_conn_del(hcon, bt_to_errno(reason));
3943,3945c4068
< 	struct sock *sk = chan->sk;
< 
< 	if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM)
---
> 	if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED)
3950,3951c4073,4074
< 			l2cap_sock_clear_timer(sk);
< 			l2cap_sock_set_timer(sk, HZ * 5);
---
> 			__clear_chan_timer(chan);
> 			__set_chan_timer(chan, HZ * 5);
3953c4076
< 			__l2cap_sock_close(sk, ECONNREFUSED);
---
> 			l2cap_chan_close(chan, ECONNREFUSED);
3956c4079
< 			l2cap_sock_clear_timer(sk);
---
> 			__clear_chan_timer(chan);
3977c4100,4114
< 		if (chan->conf_state & L2CAP_CONF_CONNECT_PEND) {
---
> 		BT_DBG("chan->scid %d", chan->scid);
> 
> 		if (chan->scid == L2CAP_CID_LE_DATA) {
> 			if (!status && encrypt) {
> 				chan->sec_level = hcon->sec_level;
> 				del_timer(&conn->security_timer);
> 				l2cap_chan_ready(sk);
> 				smp_distribute_keys(conn, 0);
> 			}
> 
> 			bh_unlock_sock(sk);
> 			continue;
> 		}
> 
> 		if (test_bit(CONF_CONNECT_PEND, &chan->conf_state)) {
3982,3983c4119,4120
< 		if (!status && (sk->sk_state == BT_CONNECTED ||
< 						sk->sk_state == BT_CONFIG)) {
---
> 		if (!status && (chan->state == BT_CONNECTED ||
> 						chan->state == BT_CONFIG)) {
3989c4126
< 		if (sk->sk_state == BT_CONNECT) {
---
> 		if (chan->state == BT_CONNECT) {
3996c4133
< 				chan->conf_state |= L2CAP_CONF_CONNECT_PEND;
---
> 				set_bit(CONF_CONNECT_PEND, &chan->conf_state);
4001,4002c4138,4139
< 				l2cap_sock_clear_timer(sk);
< 				l2cap_sock_set_timer(sk, HZ / 10);
---
> 				__clear_chan_timer(chan);
> 				__set_chan_timer(chan, HZ / 10);
4004c4141
< 		} else if (sk->sk_state == BT_CONNECT2) {
---
> 		} else if (chan->state == BT_CONNECT2) {
4016c4153
< 					sk->sk_state = BT_CONFIG;
---
> 					l2cap_state_change(chan, BT_CONFIG);
4021,4022c4158,4159
< 				sk->sk_state = BT_DISCONN;
< 				l2cap_sock_set_timer(sk, HZ / 10);
---
> 				l2cap_state_change(chan, BT_DISCONN);
> 				__set_chan_timer(chan, HZ / 10);
4166c4303
< 					sk->sk_state, __le16_to_cpu(c->psm),
---
> 					c->state, __le16_to_cpu(c->psm),
4209,4214d4345
< 	_busy_wq = create_singlethread_workqueue("l2cap");
< 	if (!_busy_wq) {
< 		err = -ENOMEM;
< 		goto error;
< 	}
< 
4232d4362
< 	destroy_workqueue(_busy_wq);
4240,4242d4369
< 
< 	flush_workqueue(_busy_wq);
< 	destroy_workqueue(_busy_wq);




diff -r linux-3.0.36/net/bluetooth/l2cap_sock.c linux-3.0.36-lenovo/net/bluetooth/l2cap_sock.c
31a32
> #include <net/bluetooth/smp.h>
34,79c35,36
< 
< /* ---- L2CAP timers ---- */
< static void l2cap_sock_timeout(unsigned long arg)
< {
< 	struct sock *sk = (struct sock *) arg;
< 	int reason;
< 
< 	BT_DBG("sock %p state %d", sk, sk->sk_state);
< 
< 	bh_lock_sock(sk);
< 
< 	if (sock_owned_by_user(sk)) {
< 		/* sk is owned by user. Try again later */
< 		l2cap_sock_set_timer(sk, HZ / 5);
< 		bh_unlock_sock(sk);
< 		sock_put(sk);
< 		return;
< 	}
< 
< 	if (sk->sk_state == BT_CONNECTED || sk->sk_state == BT_CONFIG)
< 		reason = ECONNREFUSED;
< 	else if (sk->sk_state == BT_CONNECT &&
< 			l2cap_pi(sk)->chan->sec_level != BT_SECURITY_SDP)
< 		reason = ECONNREFUSED;
< 	else
< 		reason = ETIMEDOUT;
< 
< 	__l2cap_sock_close(sk, reason);
< 
< 	bh_unlock_sock(sk);
< 
< 	l2cap_sock_kill(sk);
< 	sock_put(sk);
< }
< 
< void l2cap_sock_set_timer(struct sock *sk, long timeout)
< {
< 	BT_DBG("sk %p state %d timeout %ld", sk, sk->sk_state, timeout);
< 	sk_reset_timer(sk, &sk->sk_timer, jiffies + timeout);
< }
< 
< void l2cap_sock_clear_timer(struct sock *sk)
< {
< 	BT_DBG("sock %p state %d", sk, sk->sk_state);
< 	sk_stop_timer(sk, &sk->sk_timer);
< }
---
> static void l2cap_sock_init(struct sock *sk, struct sock *parent);
> static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio);
135a93,94
> 
> 	chan->state = BT_BOUND;
165c124
< 	if ((sk->sk_type == SOCK_SEQPACKET || sk->sk_type == SOCK_STREAM)
---
> 	if (chan->chan_type == L2CAP_CHAN_CONN_ORIENTED
207,208c166,167
< 	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 &&
< 				sk->sk_type != SOCK_RAW && !la.l2_cid) {
---
> 	if ((__le16_to_cpu(la.l2_psm) & 0x0101) != 0x0001 && !la.l2_cid &&
> 					chan->chan_type != L2CAP_CHAN_RAW) {
260a220,221
> 
> 	chan->state = BT_LISTEN;
277,281d237
< 	if (sk->sk_state != BT_LISTEN) {
< 		err = -EBADFD;
< 		goto done;
< 	}
< 
288c244
< 	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
---
> 	while (1) {
290,291c246,248
< 		if (!timeo) {
< 			err = -EAGAIN;
---
> 
> 		if (sk->sk_state != BT_LISTEN) {
> 			err = -EBADFD;
295,297c252,254
< 		release_sock(sk);
< 		timeo = schedule_timeout(timeo);
< 		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
---
> 		nsk = bt_accept_dequeue(sk, newsock);
> 		if (nsk)
> 			break;
299,300c256,257
< 		if (sk->sk_state != BT_LISTEN) {
< 			err = -EBADFD;
---
> 		if (!timeo) {
> 			err = -EAGAIN;
307a265,268
> 
> 		release_sock(sk);
> 		timeo = schedule_timeout(timeo);
> 		lock_sock_nested(sk, SINGLE_DEPTH_NESTING);
309c270
< 	set_current_state(TASK_RUNNING);
---
> 	__set_current_state(TASK_RUNNING);
331a293
> 	memset(la, 0, sizeof(struct sockaddr_l2));
439a402
> 	struct bt_power pwr;
457,458c420,421
< 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
< 				&& sk->sk_type != SOCK_RAW) {
---
> 		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
> 					chan->chan_type != L2CAP_CHAN_RAW) {
462a426
> 		memset(&sec, 0, sizeof(sec));
464a429,431
> 		if (sk->sk_state == BT_CONNECTED)
> 			sec.key_size = chan->conn->hcon->enc_key_size;
> 
487a455,469
> 	case BT_POWER:
> 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
> 				&& sk->sk_type != SOCK_RAW) {
> 			err = -EINVAL;
> 			break;
> 		}
> 
> 		pwr.force_active = chan->force_active;
> 
> 		len = min_t(unsigned int, len, sizeof(pwr));
> 		if (copy_to_user(optval, (char *) &pwr, len))
> 			err = -EFAULT;
> 
> 		break;
> 
538c520
< 			chan->conf_state &= ~L2CAP_CONF_STATE2_DEVICE;
---
> 			clear_bit(CONF_STATE2_DEVICE, &chan->conf_state);
587a570,571
> 	struct bt_power pwr;
> 	struct l2cap_conn *conn;
603,604c587,588
< 		if (sk->sk_type != SOCK_SEQPACKET && sk->sk_type != SOCK_STREAM
< 				&& sk->sk_type != SOCK_RAW) {
---
> 		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
> 					chan->chan_type != L2CAP_CHAN_RAW) {
623a608,621
> 
> 		conn = chan->conn;
> 		if (conn && chan->scid == L2CAP_CID_LE_DATA) {
> 			if (!conn->hcon->out) {
> 				err = -EINVAL;
> 				break;
> 			}
> 
> 			if (smp_conn_security(conn, sec.level))
> 				break;
> 
> 			err = 0;
> 			sk->sk_state = BT_CONFIG;
> 		}
663a662,678
> 	case BT_POWER:
> 		if (chan->chan_type != L2CAP_CHAN_CONN_ORIENTED &&
> 					chan->chan_type != L2CAP_CHAN_RAW) {
> 			err = -EINVAL;
> 			break;
> 		}
> 
> 		pwr.force_active = BT_POWER_FORCE_ACTIVE_ON;
> 
> 		len = min_t(unsigned int, sizeof(pwr), optlen);
> 		if (copy_from_user((char *) &pwr, optval, len)) {
> 			err = -EFAULT;
> 			break;
> 		}
> 		chan->force_active = pwr.force_active;
> 		break;
> 
677,678d691
< 	struct sk_buff *skb;
< 	u16 control;
693,706c706,707
< 		err = -ENOTCONN;
< 		goto done;
< 	}
< 
< 	/* Connectionless channel */
< 	if (sk->sk_type == SOCK_DGRAM) {
< 		skb = l2cap_create_connless_pdu(chan, msg, len);
< 		if (IS_ERR(skb)) {
< 			err = PTR_ERR(skb);
< 		} else {
< 			l2cap_do_send(chan, skb);
< 			err = len;
< 		}
< 		goto done;
---
> 		release_sock(sk);
> 		return -ENOTCONN;
709,742c710
< 	switch (chan->mode) {
< 	case L2CAP_MODE_BASIC:
< 		/* Check outgoing MTU */
< 		if (len > chan->omtu) {
< 			err = -EMSGSIZE;
< 			goto done;
< 		}
< 
< 		/* Create a basic PDU */
< 		skb = l2cap_create_basic_pdu(chan, msg, len);
< 		if (IS_ERR(skb)) {
< 			err = PTR_ERR(skb);
< 			goto done;
< 		}
< 
< 		l2cap_do_send(chan, skb);
< 		err = len;
< 		break;
< 
< 	case L2CAP_MODE_ERTM:
< 	case L2CAP_MODE_STREAMING:
< 		/* Entire SDU fits into one PDU */
< 		if (len <= chan->remote_mps) {
< 			control = L2CAP_SDU_UNSEGMENTED;
< 			skb = l2cap_create_iframe_pdu(chan, msg, len, control,
< 									0);
< 			if (IS_ERR(skb)) {
< 				err = PTR_ERR(skb);
< 				goto done;
< 			}
< 			__skb_queue_tail(&chan->tx_q, skb);
< 
< 			if (chan->tx_send_head == NULL)
< 				chan->tx_send_head = skb;
---
> 	err = l2cap_chan_send(chan, msg, len);
744,773d711
< 		} else {
< 		/* Segment SDU into multiples PDUs */
< 			err = l2cap_sar_segment_sdu(chan, msg, len);
< 			if (err < 0)
< 				goto done;
< 		}
< 
< 		if (chan->mode == L2CAP_MODE_STREAMING) {
< 			l2cap_streaming_send(chan);
< 			err = len;
< 			break;
< 		}
< 
< 		if ((chan->conn_state & L2CAP_CONN_REMOTE_BUSY) &&
< 				(chan->conn_state & L2CAP_CONN_WAIT_F)) {
< 			err = len;
< 			break;
< 		}
< 		err = l2cap_ertm_send(chan);
< 
< 		if (err >= 0)
< 			err = len;
< 		break;
< 
< 	default:
< 		BT_DBG("bad state %1.1x", chan->mode);
< 		err = -EBADFD;
< 	}
< 
< done:
780a719,720
> 	struct l2cap_pinfo *pi = l2cap_pi(sk);
> 	int err;
787c727
< 		__l2cap_connect_rsp_defer(l2cap_pi(sk)->chan);
---
> 		__l2cap_connect_rsp_defer(pi->chan);
795c735,761
< 		return bt_sock_stream_recvmsg(iocb, sock, msg, len, flags);
---
> 		err = bt_sock_stream_recvmsg(iocb, sock, msg, len, flags);
> 	else
> 		err = bt_sock_recvmsg(iocb, sock, msg, len, flags);
> 
> 	if (pi->chan->mode != L2CAP_MODE_ERTM)
> 		return err;
> 
> 	/* Attempt to put pending rx data in the socket buffer */
> 
> 	lock_sock(sk);
> 
> 	if (!test_bit(CONN_LOCAL_BUSY, &pi->chan->conn_state))
> 		goto done;
> 
> 	if (pi->rx_busy_skb) {
> 		if (!sock_queue_rcv_skb(sk, pi->rx_busy_skb))
> 			pi->rx_busy_skb = NULL;
> 		else
> 			goto done;
> 	}
> 
> 	/* Restore data flow when half of the receive buffer is
> 	 * available.  This avoids resending large numbers of
> 	 * frames.
> 	 */
> 	if (atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf >> 1)
> 		l2cap_chan_busy(pi->chan, 0);
797c763,765
< 	return bt_sock_recvmsg(iocb, sock, msg, len, flags);
---
> done:
> 	release_sock(sk);
> 	return err;
803c771
< void l2cap_sock_kill(struct sock *sk)
---
> static void l2cap_sock_kill(struct sock *sk)
817,897d784
< /* Must be called on unlocked socket. */
< static void l2cap_sock_close(struct sock *sk)
< {
< 	l2cap_sock_clear_timer(sk);
< 	lock_sock(sk);
< 	__l2cap_sock_close(sk, ECONNRESET);
< 	release_sock(sk);
< 	l2cap_sock_kill(sk);
< }
< 
< static void l2cap_sock_cleanup_listen(struct sock *parent)
< {
< 	struct sock *sk;
< 
< 	BT_DBG("parent %p", parent);
< 
< 	/* Close not yet accepted channels */
< 	while ((sk = bt_accept_dequeue(parent, NULL)))
< 		l2cap_sock_close(sk);
< 
< 	parent->sk_state = BT_CLOSED;
< 	sock_set_flag(parent, SOCK_ZAPPED);
< }
< 
< void __l2cap_sock_close(struct sock *sk, int reason)
< {
< 	struct l2cap_chan *chan = l2cap_pi(sk)->chan;
< 	struct l2cap_conn *conn = chan->conn;
< 
< 	BT_DBG("sk %p state %d socket %p", sk, sk->sk_state, sk->sk_socket);
< 
< 	switch (sk->sk_state) {
< 	case BT_LISTEN:
< 		l2cap_sock_cleanup_listen(sk);
< 		break;
< 
< 	case BT_CONNECTED:
< 	case BT_CONFIG:
< 		if ((sk->sk_type == SOCK_SEQPACKET ||
< 					sk->sk_type == SOCK_STREAM) &&
< 					conn->hcon->type == ACL_LINK) {
< 			l2cap_sock_set_timer(sk, sk->sk_sndtimeo);
< 			l2cap_send_disconn_req(conn, chan, reason);
< 		} else
< 			l2cap_chan_del(chan, reason);
< 		break;
< 
< 	case BT_CONNECT2:
< 		if ((sk->sk_type == SOCK_SEQPACKET ||
< 					sk->sk_type == SOCK_STREAM) &&
< 					conn->hcon->type == ACL_LINK) {
< 			struct l2cap_conn_rsp rsp;
< 			__u16 result;
< 
< 			if (bt_sk(sk)->defer_setup)
< 				result = L2CAP_CR_SEC_BLOCK;
< 			else
< 				result = L2CAP_CR_BAD_PSM;
< 
< 			rsp.scid   = cpu_to_le16(chan->dcid);
< 			rsp.dcid   = cpu_to_le16(chan->scid);
< 			rsp.result = cpu_to_le16(result);
< 			rsp.status = cpu_to_le16(L2CAP_CS_NO_INFO);
< 			l2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,
< 							sizeof(rsp), &rsp);
< 		}
< 
< 		l2cap_chan_del(chan, reason);
< 		break;
< 
< 	case BT_CONNECT:
< 	case BT_DISCONN:
< 		l2cap_chan_del(chan, reason);
< 		break;
< 
< 	default:
< 		sock_set_flag(sk, SOCK_ZAPPED);
< 		break;
< 	}
< }
< 
915,916c802
< 		l2cap_sock_clear_timer(sk);
< 		__l2cap_sock_close(sk, 0);
---
> 		l2cap_chan_close(chan, 0);
946a833,897
> static struct l2cap_chan *l2cap_sock_new_connection_cb(void *data)
> {
> 	struct sock *sk, *parent = data;
> 
> 	sk = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,
> 								GFP_ATOMIC);
> 	if (!sk)
> 		return NULL;
> 
> 	l2cap_sock_init(sk, parent);
> 
> 	return l2cap_pi(sk)->chan;
> }
> 
> static int l2cap_sock_recv_cb(void *data, struct sk_buff *skb)
> {
> 	int err;
> 	struct sock *sk = data;
> 	struct l2cap_pinfo *pi = l2cap_pi(sk);
> 
> 	if (pi->rx_busy_skb)
> 		return -ENOMEM;
> 
> 	err = sock_queue_rcv_skb(sk, skb);
> 
> 	/* For ERTM, handle one skb that doesn't fit into the recv
> 	 * buffer.  This is important to do because the data frames
> 	 * have already been acked, so the skb cannot be discarded.
> 	 *
> 	 * Notify the l2cap core that the buffer is full, so the
> 	 * LOCAL_BUSY state is entered and no more frames are
> 	 * acked and reassembled until there is buffer space
> 	 * available.
> 	 */
> 	if (err < 0 && pi->chan->mode == L2CAP_MODE_ERTM) {
> 		pi->rx_busy_skb = skb;
> 		l2cap_chan_busy(pi->chan, 1);
> 		err = 0;
> 	}
> 
> 	return err;
> }
> 
> static void l2cap_sock_close_cb(void *data)
> {
> 	struct sock *sk = data;
> 
> 	l2cap_sock_kill(sk);
> }
> 
> static void l2cap_sock_state_change_cb(void *data, int state)
> {
> 	struct sock *sk = data;
> 
> 	sk->sk_state = state;
> }
> 
> static struct l2cap_ops l2cap_chan_ops = {
> 	.name		= "L2CAP Socket Interface",
> 	.new_connection	= l2cap_sock_new_connection_cb,
> 	.recv		= l2cap_sock_recv_cb,
> 	.close		= l2cap_sock_close_cb,
> 	.state_change	= l2cap_sock_state_change_cb,
> };
> 
950a902,906
> 	if (l2cap_pi(sk)->rx_busy_skb) {
> 		kfree_skb(l2cap_pi(sk)->rx_busy_skb);
> 		l2cap_pi(sk)->rx_busy_skb = NULL;
> 	}
> 
955c911
< void l2cap_sock_init(struct sock *sk, struct sock *parent)
---
> static void l2cap_sock_init(struct sock *sk, struct sock *parent)
967a924
> 		chan->chan_type = pchan->chan_type;
978a936
> 		chan->force_active = pchan->force_active;
979a938,951
> 
> 		switch (sk->sk_type) {
> 		case SOCK_RAW:
> 			chan->chan_type = L2CAP_CHAN_RAW;
> 			break;
> 		case SOCK_DGRAM:
> 			chan->chan_type = L2CAP_CHAN_CONN_LESS;
> 			break;
> 		case SOCK_SEQPACKET:
> 		case SOCK_STREAM:
> 			chan->chan_type = L2CAP_CHAN_CONN_ORIENTED;
> 			break;
> 		}
> 
984c956
< 			chan->conf_state |= L2CAP_CONF_STATE2_DEVICE;
---
> 			set_bit(CONF_STATE2_DEVICE, &chan->conf_state);
994a967,968
> 		chan->force_active = BT_POWER_FORCE_ACTIVE_ON;
> 
998a973,975
> 
> 	chan->data = sk;
> 	chan->ops = &l2cap_chan_ops;
1007c984
< struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
---
> static struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock, int proto, gfp_t prio)
1009a987
> 	struct l2cap_chan *chan;
1019c997
< 	sk->sk_sndtimeo = msecs_to_jiffies(L2CAP_CONN_TIMEOUT);
---
> 	sk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;
1026c1004,1010
< 	setup_timer(&sk->sk_timer, l2cap_sock_timeout, (unsigned long) sk);
---
> 	chan = l2cap_chan_create(sk);
> 	if (!chan) {
> 		l2cap_sock_kill(sk);
> 		return NULL;
> 	}
> 
> 	l2cap_pi(sk)->chan = chan;
1035d1018
< 	struct l2cap_chan *chan;
1053,1060d1035
< 
< 	chan = l2cap_chan_create(sk);
< 	if (!chan) {
< 		l2cap_sock_kill(sk);
< 		return -ENOMEM;
< 	}
< 
< 	l2cap_pi(sk)->chan = chan;




diff -r linux-3.0.36/net/bluetooth/lib.c linux-3.0.36-lenovo/net/bluetooth/lib.c
62c62
< int bt_err(__u16 code)
---
> int bt_to_errno(__u16 code)
152c152,171
< EXPORT_SYMBOL(bt_err);
---
> EXPORT_SYMBOL(bt_to_errno);
> 
> int bt_printk(const char *level, const char *format, ...)
> {
> 	struct va_format vaf;
> 	va_list args;
> 	int r;
> 
> 	va_start(args, format);
> 
> 	vaf.fmt = format;
> 	vaf.va = &args;
> 
> 	r = printk("%sBluetooth: %pV\n", level, &vaf);
> 
> 	va_end(args);
> 
> 	return r;
> }
> EXPORT_SYMBOL(bt_printk);




diff -r linux-3.0.36/net/bluetooth/Makefile linux-3.0.36-lenovo/net/bluetooth/Makefile
12c12
< bluetooth-$(CONFIG_BT_L2CAP)	+= l2cap_core.o l2cap_sock.o
---
> bluetooth-$(CONFIG_BT_L2CAP)	+= l2cap_core.o l2cap_sock.o smp.o




diff -r linux-3.0.36/net/bluetooth/mgmt.c linux-3.0.36-lenovo/net/bluetooth/mgmt.c
44c44
< LIST_HEAD(cmd_list);
---
> static LIST_HEAD(cmd_list);
182c182
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
211c211
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
319c319
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
346c346
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
371c371
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
406c406
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
432c432
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
466c466
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
525c525
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
541c541
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
742c742
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
766c766
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
791c791
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
826c826
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
850c850
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
860c860
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
882c882
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
900c900
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
911c911
< 	int i;
---
> 	int i, err;
921,923c921,923
< 	if (expected_len != len) {
< 		BT_ERR("load_keys: expected %u bytes, got %u bytes",
< 							len, expected_len);
---
> 	if (expected_len > len) {
> 		BT_ERR("load_keys: expected at least %u bytes, got %u bytes",
> 							expected_len, len);
934c934
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
945,946c945,963
< 	for (i = 0; i < key_count; i++) {
< 		struct mgmt_key_info *key = &cp->keys[i];
---
> 	len -= sizeof(*cp);
> 	i = 0;
> 
> 	while (i < len) {
> 		struct mgmt_key_info *key = (void *) cp->keys + i;
> 
> 		i += sizeof(*key) + key->dlen;
> 
> 		if (key->type == HCI_LK_SMP_LTK) {
> 			struct key_master_id *id = (void *) key->data;
> 
> 			if (key->dlen != sizeof(struct key_master_id))
> 				continue;
> 
> 			hci_add_ltk(hdev, 0, &key->bdaddr, key->pin_len,
> 						id->ediv, id->rand, key->val);
> 
> 			continue;
> 		}
952c969,971
< 	hci_dev_unlock(hdev);
---
> 	err = cmd_complete(sk, index, MGMT_OP_LOAD_KEYS, NULL, 0);
> 
> 	hci_dev_unlock_bh(hdev);
955c974
< 	return 0;
---
> 	return err;
974c993
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
993c1012
< 		err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, 0, NULL);
---
> 		err = hci_send_cmd(hdev, HCI_OP_DISCONNECT, sizeof(dc), &dc);
997c1016
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1023c1042
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1058c1077
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1079c1098
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1095,1096d1113
< 	read_lock(&hci_dev_list_lock);
< 
1104,1105d1120
< 	read_unlock(&hci_dev_list_lock);
< 
1110c1125
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1114a1130,1148
> static int send_pin_code_neg_reply(struct sock *sk, u16 index,
> 		struct hci_dev *hdev, struct mgmt_cp_pin_code_neg_reply *cp)
> {
> 	struct pending_cmd *cmd;
> 	int err;
> 
> 	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, index, cp,
> 								sizeof(*cp));
> 	if (!cmd)
> 		return -ENOMEM;
> 
> 	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
> 								&cp->bdaddr);
> 	if (err < 0)
> 		mgmt_pending_remove(cmd);
> 
> 	return err;
> }
> 
1118a1153
> 	struct hci_conn *conn;
1119a1155
> 	struct mgmt_cp_pin_code_neg_reply ncp;
1135c1171
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1141a1178,1196
> 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &cp->bdaddr);
> 	if (!conn) {
> 		err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY, ENOTCONN);
> 		goto failed;
> 	}
> 
> 	if (conn->pending_sec_level == BT_SECURITY_HIGH && cp->pin_len != 16) {
> 		bacpy(&ncp.bdaddr, &cp->bdaddr);
> 
> 		BT_ERR("PIN code is not 16 bytes long");
> 
> 		err = send_pin_code_neg_reply(sk, index, hdev, &ncp);
> 		if (err >= 0)
> 			err = cmd_status(sk, index, MGMT_OP_PIN_CODE_REPLY,
> 								EINVAL);
> 
> 		goto failed;
> 	}
> 
1150c1205
< 	memcpy(reply.pin_code, cp->pin_code, 16);
---
> 	memcpy(reply.pin_code, cp->pin_code, sizeof(reply.pin_code));
1157c1212
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1168d1222
< 	struct pending_cmd *cmd;
1184c1238
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1192,1202c1246
< 	cmd = mgmt_pending_add(sk, MGMT_OP_PIN_CODE_NEG_REPLY, index,
< 								data, len);
< 	if (!cmd) {
< 		err = -ENOMEM;
< 		goto failed;
< 	}
< 
< 	err = hci_send_cmd(hdev, HCI_OP_PIN_CODE_NEG_REPLY, sizeof(cp->bdaddr),
< 								&cp->bdaddr);
< 	if (err < 0)
< 		mgmt_pending_remove(cmd);
---
> 	err = send_pin_code_neg_reply(sk, index, hdev, cp);
1205c1249
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1228c1272
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1235c1279
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1321c1365
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1331c1375
< 	conn = hci_connect(hdev, ACL_LINK, &cp->bdaddr, sec_level, auth_type);
---
> 	conn = hci_connect(hdev, ACL_LINK, 0, &cp->bdaddr, sec_level, auth_type);
1363c1407
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1395c1439
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1413c1457
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1437c1481
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1452c1496
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1471c1515
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1501c1545
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1525c1569
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1535c1579
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1559c1603
< 	hci_dev_lock(hdev);
---
> 	hci_dev_lock_bh(hdev);
1569c1613
< 	hci_dev_unlock(hdev);
---
> 	hci_dev_unlock_bh(hdev);
1643a1688,1751
> static int block_device(struct sock *sk, u16 index, unsigned char *data,
> 								u16 len)
> {
> 	struct hci_dev *hdev;
> 	struct mgmt_cp_block_device *cp;
> 	int err;
> 
> 	BT_DBG("hci%u", index);
> 
> 	cp = (void *) data;
> 
> 	if (len != sizeof(*cp))
> 		return cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
> 							EINVAL);
> 
> 	hdev = hci_dev_get(index);
> 	if (!hdev)
> 		return cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE,
> 							ENODEV);
> 
> 	err = hci_blacklist_add(hdev, &cp->bdaddr);
> 
> 	if (err < 0)
> 		err = cmd_status(sk, index, MGMT_OP_BLOCK_DEVICE, -err);
> 	else
> 		err = cmd_complete(sk, index, MGMT_OP_BLOCK_DEVICE,
> 							NULL, 0);
> 	hci_dev_put(hdev);
> 
> 	return err;
> }
> 
> static int unblock_device(struct sock *sk, u16 index, unsigned char *data,
> 								u16 len)
> {
> 	struct hci_dev *hdev;
> 	struct mgmt_cp_unblock_device *cp;
> 	int err;
> 
> 	BT_DBG("hci%u", index);
> 
> 	cp = (void *) data;
> 
> 	if (len != sizeof(*cp))
> 		return cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
> 								EINVAL);
> 
> 	hdev = hci_dev_get(index);
> 	if (!hdev)
> 		return cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE,
> 								ENODEV);
> 
> 	err = hci_blacklist_del(hdev, &cp->bdaddr);
> 
> 	if (err < 0)
> 		err = cmd_status(sk, index, MGMT_OP_UNBLOCK_DEVICE, -err);
> 	else
> 		err = cmd_complete(sk, index, MGMT_OP_UNBLOCK_DEVICE,
> 								NULL, 0);
> 	hci_dev_put(hdev);
> 
> 	return err;
> }
> 
1757a1866,1871
> 	case MGMT_OP_BLOCK_DEVICE:
> 		err = block_device(sk, index, buf + sizeof(*hdr), len);
> 		break;
> 	case MGMT_OP_UNBLOCK_DEVICE:
> 		err = unblock_device(sk, index, buf + sizeof(*hdr), len);
> 		break;
1866c1980,1981
< 	struct mgmt_ev_new_key ev;
---
> 	struct mgmt_ev_new_key *ev;
> 	int err, total;
1868c1983,1986
< 	memset(&ev, 0, sizeof(ev));
---
> 	total = sizeof(struct mgmt_ev_new_key) + key->dlen;
> 	ev = kzalloc(total, GFP_ATOMIC);
> 	if (!ev)
> 		return -ENOMEM;
1870,1874c1988,1993
< 	ev.store_hint = persistent;
< 	bacpy(&ev.key.bdaddr, &key->bdaddr);
< 	ev.key.type = key->type;
< 	memcpy(ev.key.val, key->val, 16);
< 	ev.key.pin_len = key->pin_len;
---
> 	bacpy(&ev->key.bdaddr, &key->bdaddr);
> 	ev->key.type = key->type;
> 	memcpy(ev->key.val, key->val, 16);
> 	ev->key.pin_len = key->pin_len;
> 	ev->key.dlen = key->dlen;
> 	ev->store_hint = persistent;
1876c1995,2001
< 	return mgmt_event(MGMT_EV_NEW_KEY, index, &ev, sizeof(ev), NULL);
---
> 	memcpy(ev->key.data, key->data, key->dlen);
> 
> 	err = mgmt_event(MGMT_EV_NEW_KEY, index, ev, total, NULL);
> 
> 	kfree(ev);
> 
> 	return err;




diff -r linux-3.0.36/net/bluetooth/rfcomm/core.c linux-3.0.36-lenovo/net/bluetooth/rfcomm/core.c
65d64
< static unsigned long rfcomm_event;
123d121
< 	set_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
469d466
< 	case BT_CONFIG:
2041c2038
< 	while (!kthread_should_stop()) {
---
> 	while (1) {
2043,2048c2040,2042
< 		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
< 			/* No pending events. Let's sleep.
< 			 * Incoming connections and data will wake us up. */
< 			schedule();
< 		}
< 		set_current_state(TASK_RUNNING);
---
> 
> 		if (kthread_should_stop())
> 			break;
2051d2044
< 		clear_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event);
2052a2046,2047
> 
> 		schedule();
2053a2049
> 	__set_current_state(TASK_RUNNING);




diff -r linux-3.0.36/net/bluetooth/rfcomm/sock.c linux-3.0.36-lenovo/net/bluetooth/rfcomm/sock.c
488,492d487
< 	if (sk->sk_state != BT_LISTEN) {
< 		err = -EBADFD;
< 		goto done;
< 	}
< 
504c499
< 	while (!(nsk = bt_accept_dequeue(sk, newsock))) {
---
> 	while (1) {
506,507c501,503
< 		if (!timeo) {
< 			err = -EAGAIN;
---
> 
> 		if (sk->sk_state != BT_LISTEN) {
> 			err = -EBADFD;
511,513c507,509
< 		release_sock(sk);
< 		timeo = schedule_timeout(timeo);
< 		lock_sock(sk);
---
> 		nsk = bt_accept_dequeue(sk, newsock);
> 		if (nsk)
> 			break;
515,516c511,512
< 		if (sk->sk_state != BT_LISTEN) {
< 			err = -EBADFD;
---
> 		if (!timeo) {
> 			err = -EAGAIN;
523a520,523
> 
> 		release_sock(sk);
> 		timeo = schedule_timeout(timeo);
> 		lock_sock(sk);
525c525
< 	set_current_state(TASK_RUNNING);
---
> 	__set_current_state(TASK_RUNNING);
546a547
> 	memset(sa, 0, sizeof(*sa));
682c683,684
< 	int len, err = 0;
---
> 	int err = 0;
> 	size_t len;
744d745
< 	struct sock *l2cap_sk;
789d789
< 		l2cap_sk = rfcomm_pi(sk)->dlc->session->sock->sk;




diff -r linux-3.0.36/net/bluetooth/rfcomm/tty.c linux-3.0.36-lenovo/net/bluetooth/rfcomm/tty.c
474c474
< 	dl = kmalloc(size, GFP_KERNEL);
---
> 	dl = kzalloc(size, GFP_KERNEL);




diff -r linux-3.0.36/net/bluetooth/sco.c linux-3.0.36-lenovo/net/bluetooth/sco.c
179a180
> 	__u16 pkt_type = sco_pi(sk)->pkt_type;
195c196
< 	else
---
> 	else {
196a198,199
> 		pkt_type &= SCO_ESCO_MASK;
> 	}
198c201
< 	hcon = hci_connect(hdev, type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
---
> 	hcon = hci_connect(hdev, type, pkt_type, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
463c466
< static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_len)
---
> static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int alen)
465c468
< 	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
---
> 	struct sockaddr_sco sa;
467,468c470,471
< 	bdaddr_t *src = &sa->sco_bdaddr;
< 	int err = 0;
---
> 	bdaddr_t *src = &sa.sco_bdaddr;
> 	int len, err = 0;
470c473
< 	BT_DBG("sk %p %s", sk, batostr(&sa->sco_bdaddr));
---
> 	BT_DBG("sk %p %s", sk, batostr(&sa.sco_bdaddr));
474a478,481
> 	memset(&sa, 0, sizeof(sa));
> 	len = min_t(unsigned int, sizeof(sa), alen);
> 	memcpy(&sa, addr, len);
> 
488c495,496
< 		bacpy(&bt_sk(sk)->src, &sa->sco_bdaddr);
---
> 		bacpy(&bt_sk(sk)->src, &sa.sco_bdaddr);
> 		sco_pi(sk)->pkt_type = sa.sco_pkt_type;
501d508
< 	struct sockaddr_sco *sa = (struct sockaddr_sco *) addr;
503,504c510,511
< 	int err = 0;
< 
---
> 	struct sockaddr_sco sa;
> 	int len, err = 0;
508,509c515
< 	if (alen < sizeof(struct sockaddr_sco) ||
< 	    addr->sa_family != AF_BLUETOOTH)
---
> 	if (!addr || addr->sa_family != AF_BLUETOOTH)
512,516c518,520
< 	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND)
< 		return -EBADFD;
< 
< 	if (sk->sk_type != SOCK_SEQPACKET)
< 		return -EINVAL;
---
> 	memset(&sa, 0, sizeof(sa));
> 	len = min_t(unsigned int, sizeof(sa), alen);
> 	memcpy(&sa, addr, len);
519a524,533
> 	if (sk->sk_type != SOCK_SEQPACKET) {
> 		err = -EINVAL;
> 		goto done;
> 	}
> 
> 	if (sk->sk_state != BT_OPEN && sk->sk_state != BT_BOUND) {
> 		err = -EBADFD;
> 		goto done;
> 	}
> 
521c535,536
< 	bacpy(&bt_sk(sk)->dst, &sa->sco_bdaddr);
---
> 	bacpy(&bt_sk(sk)->dst, &sa.sco_bdaddr);
> 	sco_pi(sk)->pkt_type = sa.sco_pkt_type;
567,571d581
< 	if (sk->sk_state != BT_LISTEN) {
< 		err = -EBADFD;
< 		goto done;
< 	}
< 
578c588
< 	while (!(ch = bt_accept_dequeue(sk, newsock))) {
---
> 	while (1) {
580,581c590,592
< 		if (!timeo) {
< 			err = -EAGAIN;
---
> 
> 		if (sk->sk_state != BT_LISTEN) {
> 			err = -EBADFD;
585,587c596,598
< 		release_sock(sk);
< 		timeo = schedule_timeout(timeo);
< 		lock_sock(sk);
---
> 		ch = bt_accept_dequeue(sk, newsock);
> 		if (ch)
> 			break;
589,590c600,601
< 		if (sk->sk_state != BT_LISTEN) {
< 			err = -EBADFD;
---
> 		if (!timeo) {
> 			err = -EAGAIN;
597a609,612
> 
> 		release_sock(sk);
> 		timeo = schedule_timeout(timeo);
> 		lock_sock(sk);
599c614
< 	set_current_state(TASK_RUNNING);
---
> 	__set_current_state(TASK_RUNNING);
627a643
> 	sa->sco_pkt_type = sco_pi(sk)->pkt_type;
935c951
< 		sco_conn_del(hcon, bt_err(status));
---
> 		sco_conn_del(hcon, bt_to_errno(status));
947c963
< 	sco_conn_del(hcon, bt_err(reason));
---
> 	sco_conn_del(hcon, bt_to_errno(reason));
Only in linux-3.0.36-lenovo/net/bluetooth: smp.c




diff -r linux-3.0.36/net/bridge/br_device.c linux-3.0.36-lenovo/net/bridge/br_device.c
41,45d40
< 	u64_stats_update_begin(&brstats->syncp);
< 	brstats->tx_packets++;
< 	brstats->tx_bytes += skb->len;
< 	u64_stats_update_end(&brstats->syncp);
< 
49a45,50
> 
> 	u64_stats_update_begin(&brstats->syncp);
> 	brstats->tx_packets++;
> 	/* Exclude ETH_HLEN from byte stats for consistency with Rx chain */
> 	brstats->tx_bytes += skb->len;
> 	u64_stats_update_end(&brstats->syncp);




diff -r linux-3.0.36/net/bridge/br_if.c linux-3.0.36-lenovo/net/bridge/br_if.c
243a244
> 	dev->rtnl_link_ops = &br_link_ops;




diff -r linux-3.0.36/net/bridge/br_netfilter.c linux-3.0.36-lenovo/net/bridge/br_netfilter.c
235a236,238
> 	if (!pskb_may_pull(skb, sizeof(struct iphdr)))
> 		goto inhdr_error;
> 




diff -r linux-3.0.36/net/bridge/br_netlink.c linux-3.0.36-lenovo/net/bridge/br_netlink.c
206c206
< static struct rtnl_link_ops br_link_ops __read_mostly = {
---
> struct rtnl_link_ops br_link_ops __read_mostly = {
222c222,223
< 	err = __rtnl_register(PF_BRIDGE, RTM_GETLINK, NULL, br_dump_ifinfo);
---
> 	err = __rtnl_register(PF_BRIDGE, RTM_GETLINK, NULL,
> 			      br_dump_ifinfo, NULL);
225c226,227
< 	err = __rtnl_register(PF_BRIDGE, RTM_SETLINK, br_rtm_setlink, NULL);
---
> 	err = __rtnl_register(PF_BRIDGE, RTM_SETLINK,
> 			      br_rtm_setlink, NULL, NULL);
228c230,231
< 	err = __rtnl_register(PF_BRIDGE, RTM_NEWNEIGH, br_fdb_add, NULL);
---
> 	err = __rtnl_register(PF_BRIDGE, RTM_NEWNEIGH,
> 			      br_fdb_add, NULL, NULL);
231c234,235
< 	err = __rtnl_register(PF_BRIDGE, RTM_DELNEIGH, br_fdb_delete, NULL);
---
> 	err = __rtnl_register(PF_BRIDGE, RTM_DELNEIGH,
> 			      br_fdb_delete, NULL, NULL);
234c238,239
< 	err = __rtnl_register(PF_BRIDGE, RTM_GETNEIGH, NULL, br_fdb_dump);
---
> 	err = __rtnl_register(PF_BRIDGE, RTM_GETNEIGH,
> 			      NULL, br_fdb_dump, NULL);




diff -r linux-3.0.36/net/bridge/br_private.h linux-3.0.36-lenovo/net/bridge/br_private.h
531a532
> extern struct rtnl_link_ops br_link_ops;




diff -r linux-3.0.36/net/caif/caif_dev.c linux-3.0.36-lenovo/net/caif/caif_dev.c
427d426
< 	unregister_pernet_subsys(&caif_net_ops);
429a429
> 	unregister_pernet_subsys(&caif_net_ops);




diff -r linux-3.0.36/net/can/bcm.c linux-3.0.36-lenovo/net/can/bcm.c
1087a1088,1090
> 		/* ifindex for timeout events w/o previous frame reception */
> 		op->rx_ifindex = ifindex;
> 




diff -r linux-3.0.36/net/core/dev_addr_lists.c linux-3.0.36-lenovo/net/core/dev_addr_lists.c
310c310,311
< 	if (ha->addr == dev->dev_addr && ha->refcount == 1)
---
> 	if (!memcmp(ha->addr, addr, dev->addr_len) &&
> 	    ha->type == addr_type && ha->refcount == 1)




diff -r linux-3.0.36/net/core/dev.c linux-3.0.36-lenovo/net/core/dev.c
1047a1048,1049
> 	char *new_ifalias;
> 
1061,1062c1063,1064
< 	dev->ifalias = krealloc(dev->ifalias, len + 1, GFP_KERNEL);
< 	if (!dev->ifalias)
---
> 	new_ifalias = krealloc(dev->ifalias, len + 1, GFP_KERNEL);
> 	if (!new_ifalias)
1063a1066
> 	dev->ifalias = new_ifalias;
1165a1169
> 		add_device_randomness(dev->dev_addr, dev->addr_len);
2037c2041,2042
< 	if (!can_checksum_protocol(features, protocol)) {
---
> 	if (skb->ip_summed != CHECKSUM_NONE &&
> 	    !can_checksum_protocol(features, protocol)) {
2051a2057,2059
> 	if (skb_shinfo(skb)->gso_segs > skb->dev->gso_max_segs)
> 		features &= ~NETIF_F_GSO_MASK;
> 
2555c2563
< 		if (pskb_may_pull(skb, nhoff + 4)) {
---
> 		if (pskb_may_pull(skb, nhoff + 4))
2557,2559d2564
< 			if (ports.v16[1] < ports.v16[0])
< 				swap(ports.v16[0], ports.v16[1]);
< 		}
2563c2568,2570
< 	if (addr2 < addr1)
---
> 	if (addr2 < addr1 ||
> 	    (addr2 == addr1 &&
> 	     ports.v16[1] < ports.v16[0])) {
2564a2572,2573
> 		swap(ports.v16[0], ports.v16[1]);
> 	}
2700c2709,2710
< 		      rflow->last_qtail)) >= 0))
---
> 		      rflow->last_qtail)) >= 0)) {
> 			tcpu = next_cpu;
2701a2712
> 		}
4732a4744
> 	add_device_randomness(dev->dev_addr, dev->addr_len);
5509a5522
> 	add_device_randomness(dev->dev_addr, dev->addr_len);
5869a5883
> 	dev->gso_max_segs = GSO_MAX_SEGS;
6253c6267,6268
< 	INIT_LIST_HEAD(&net->dev_base_head);
---
> 	if (net != &init_net)
> 		INIT_LIST_HEAD(&net->dev_base_head);




diff -r linux-3.0.36/net/core/drop_monitor.c linux-3.0.36-lenovo/net/core/drop_monitor.c
36,38d35
< static void send_dm_alert(struct work_struct *unused);
< 
< 
45c42
< static DEFINE_SPINLOCK(trace_state_lock);
---
> static DEFINE_MUTEX(trace_state_mutex);
48,51c45,48
< 	struct work_struct dm_alert_work;
< 	struct sk_buff *skb;
< 	atomic_t dm_hit_count;
< 	struct timer_list send_timer;
---
> 	spinlock_t		lock;
> 	struct sk_buff		*skb;
> 	struct work_struct	dm_alert_work;
> 	struct timer_list	send_timer;
77c74
< static void reset_per_cpu_data(struct per_cpu_dm_data *data)
---
> static struct sk_buff *reset_per_cpu_data(struct per_cpu_dm_data *data)
81a79,80
> 	struct sk_buff *skb;
> 	unsigned long flags;
87,93c86,103
< 	data->skb = genlmsg_new(al, GFP_KERNEL);
< 	genlmsg_put(data->skb, 0, 0, &net_drop_monitor_family,
< 			0, NET_DM_CMD_ALERT);
< 	nla = nla_reserve(data->skb, NLA_UNSPEC, sizeof(struct net_dm_alert_msg));
< 	msg = nla_data(nla);
< 	memset(msg, 0, al);
< 	atomic_set(&data->dm_hit_count, dm_hit_limit);
---
> 	skb = genlmsg_new(al, GFP_KERNEL);
> 
> 	if (skb) {
> 		genlmsg_put(skb, 0, 0, &net_drop_monitor_family,
> 				0, NET_DM_CMD_ALERT);
> 		nla = nla_reserve(skb, NLA_UNSPEC,
> 				  sizeof(struct net_dm_alert_msg));
> 		msg = nla_data(nla);
> 		memset(msg, 0, al);
> 	} else {
> 		mod_timer(&data->send_timer, jiffies + HZ / 10);
> 	}
> 
> 	spin_lock_irqsave(&data->lock, flags);
> 	swap(data->skb, skb);
> 	spin_unlock_irqrestore(&data->lock, flags);
> 
> 	return skb;
96c106
< static void send_dm_alert(struct work_struct *unused)
---
> static void send_dm_alert(struct work_struct *work)
99,104c109
< 	struct per_cpu_dm_data *data = &__get_cpu_var(dm_cpu_data);
< 
< 	/*
< 	 * Grab the skb we're about to send
< 	 */
< 	skb = data->skb;
---
> 	struct per_cpu_dm_data *data;
106,109c111
< 	/*
< 	 * Replace it with a new one
< 	 */
< 	reset_per_cpu_data(data);
---
> 	data = container_of(work, struct per_cpu_dm_data, dm_alert_work);
111,114c113
< 	/*
< 	 * Ship it!
< 	 */
< 	genlmsg_multicast(skb, 0, NET_DM_GRP_ALERT, GFP_KERNEL);
---
> 	skb = reset_per_cpu_data(data);
115a115,116
> 	if (skb)
> 		genlmsg_multicast(skb, 0, NET_DM_GRP_ALERT, GFP_KERNEL);
121,122c122
<  * hysteresis period.  Note that it operates under the timer interrupt
<  * so we don't need to disable preemption here
---
>  * hysteresis period.
124c124
< static void sched_send_work(unsigned long unused)
---
> static void sched_send_work(unsigned long _data)
126c126
< 	struct per_cpu_dm_data *data =  &__get_cpu_var(dm_cpu_data);
---
> 	struct per_cpu_dm_data *data = (struct per_cpu_dm_data *)_data;
137c137,139
< 	struct per_cpu_dm_data *data = &__get_cpu_var(dm_cpu_data);
---
> 	struct sk_buff *dskb;
> 	struct per_cpu_dm_data *data;
> 	unsigned long flags;
138a141,144
> 	local_irq_save(flags);
> 	data = &__get_cpu_var(dm_cpu_data);
> 	spin_lock(&data->lock);
> 	dskb = data->skb;
140,143c146
< 	if (!atomic_add_unless(&data->dm_hit_count, -1, 0)) {
< 		/*
< 		 * we're already at zero, discard this hit
< 		 */
---
> 	if (!dskb)
145d147
< 	}
147c149
< 	nlh = (struct nlmsghdr *)data->skb->data;
---
> 	nlh = (struct nlmsghdr *)dskb->data;
156c158,159
< 
---
> 	if (msg->entries == dm_hit_limit)
> 		goto out;
160c163
< 	__nla_reserve_nohdr(data->skb, sizeof(struct net_dm_drop_point));
---
> 	__nla_reserve_nohdr(dskb, sizeof(struct net_dm_drop_point));
168c171
< 		add_timer_on(&data->send_timer, smp_processor_id());
---
> 		add_timer(&data->send_timer);
172c175
< 	return;
---
> 	spin_unlock_irqrestore(&data->lock, flags);
216c219
< 	spin_lock(&trace_state_lock);
---
> 	mutex_lock(&trace_state_mutex);
255c258
< 	spin_unlock(&trace_state_lock);
---
> 	mutex_unlock(&trace_state_mutex);
298c301
< 		spin_lock(&trace_state_lock);
---
> 		mutex_lock(&trace_state_mutex);
300c303
< 		spin_unlock(&trace_state_lock);
---
> 		mutex_unlock(&trace_state_mutex);
303c306
< 		spin_lock(&trace_state_lock);
---
> 		mutex_lock(&trace_state_mutex);
314c317
< 		spin_unlock(&trace_state_lock);
---
> 		mutex_unlock(&trace_state_mutex);
370d372
< 		reset_per_cpu_data(data);
373c375
< 		data->send_timer.data = cpu;
---
> 		data->send_timer.data = (unsigned long)data;
374a377,378
> 		spin_lock_init(&data->lock);
> 		reset_per_cpu_data(data);
375a380
> 




diff -r linux-3.0.36/net/core/ethtool.c linux-3.0.36-lenovo/net/core/ethtool.c
1966a1967
> 	case ETHTOOL_GSSET_INFO:




diff -r linux-3.0.36/net/core/fib_rules.c linux-3.0.36-lenovo/net/core/fib_rules.c
743,745c743,745
< 	rtnl_register(PF_UNSPEC, RTM_NEWRULE, fib_nl_newrule, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELRULE, fib_nl_delrule, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_GETRULE, NULL, fib_nl_dumprule);
---
> 	rtnl_register(PF_UNSPEC, RTM_NEWRULE, fib_nl_newrule, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELRULE, fib_nl_delrule, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETRULE, NULL, fib_nl_dumprule, NULL);




diff -r linux-3.0.36/net/core/neighbour.c linux-3.0.36-lenovo/net/core/neighbour.c
1316,1317d1315
< 	__skb_pull(skb, skb_network_offset(skb));
< 
1328a1327
> 			__skb_pull(skb, skb_network_offset(skb));
1361,1362d1359
< 	__skb_pull(skb, skb_network_offset(skb));
< 
1363a1361
> 		__skb_pull(skb, skb_network_offset(skb));
2923,2928c2921,2927
< 	rtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELNEIGH, neigh_delete, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_GETNEIGH, NULL, neigh_dump_info);
< 
< 	rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info);
< 	rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL);
---
> 	rtnl_register(PF_UNSPEC, RTM_NEWNEIGH, neigh_add, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELNEIGH, neigh_delete, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETNEIGH, NULL, neigh_dump_info, NULL);
> 
> 	rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info,
> 		      NULL);
> 	rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL, NULL);




diff -r linux-3.0.36/net/core/net_namespace.c linux-3.0.36-lenovo/net/core/net_namespace.c
27c27,29
< struct net init_net;
---
> struct net init_net = {
> 	.dev_base_head = LIST_HEAD_INIT(init_net.dev_base_head),
> };




diff -r linux-3.0.36/net/core/netpoll.c linux-3.0.36-lenovo/net/core/netpoll.c
360c360
< 	int total_len, eth_len, ip_len, udp_len;
---
> 	int total_len, ip_len, udp_len;
367,368c367,368
< 	ip_len = eth_len = udp_len + sizeof(*iph);
< 	total_len = eth_len + ETH_HLEN + NET_IP_ALIGN;
---
> 	ip_len = udp_len + sizeof(*iph);
> 	total_len = ip_len + LL_RESERVED_SPACE(np->dev);
370c370,371
< 	skb = find_skb(np, total_len, total_len - len);
---
> 	skb = find_skb(np, total_len + np->dev->needed_tailroom,
> 		       total_len - len);
375c376
< 	skb->len += len;
---
> 	skb_put(skb, len);




diff -r linux-3.0.36/net/core/pktgen.c linux-3.0.36-lenovo/net/core/pktgen.c
1806c1806
< 		pktgen_add_device(t, f);
---
> 		ret = pktgen_add_device(t, f);
1808,1809c1808,1812
< 		ret = count;
< 		sprintf(pg_result, "OK: add_device=%s", f);
---
> 		if (!ret) {
> 			ret = count;
> 			sprintf(pg_result, "OK: add_device=%s", f);
> 		} else
> 			sprintf(pg_result, "ERROR: can not add device %s", f);
2935c2938
< 	if (datalen < sizeof(struct pktgen_hdr)) {
---
> 	if (datalen < 0 || datalen < sizeof(struct pktgen_hdr)) {




diff -r linux-3.0.36/net/core/rtnetlink.c linux-3.0.36-lenovo/net/core/rtnetlink.c
58a59
> 	rtnl_calcit_func 	calcit;
146a148,162
> static rtnl_calcit_func rtnl_get_calcit(int protocol, int msgindex)
> {
> 	struct rtnl_link *tab;
> 
> 	if (protocol <= RTNL_FAMILY_MAX)
> 		tab = rtnl_msg_handlers[protocol];
> 	else
> 		tab = NULL;
> 
> 	if (tab == NULL || tab[msgindex].calcit == NULL)
> 		tab = rtnl_msg_handlers[PF_UNSPEC];
> 
> 	return tab ? tab[msgindex].calcit : NULL;
> }
> 
152a169
>  * @calcit: Function pointer to calc size of dump message
165c182,183
< 		    rtnl_doit_func doit, rtnl_dumpit_func dumpit)
---
> 		    rtnl_doit_func doit, rtnl_dumpit_func dumpit,
> 		    rtnl_calcit_func calcit)
187a206,208
> 	if (calcit)
> 		tab[msgindex].calcit = calcit;
> 
202c223,224
< 		   rtnl_doit_func doit, rtnl_dumpit_func dumpit)
---
> 		   rtnl_doit_func doit, rtnl_dumpit_func dumpit,
> 		   rtnl_calcit_func calcit)
204c226
< 	if (__rtnl_register(protocol, msgtype, doit, dumpit) < 0)
---
> 	if (__rtnl_register(protocol, msgtype, doit, dumpit, calcit) < 0)
649a672,677
> static unsigned int rtnl_dev_get_flags(const struct net_device *dev)
> {
> 	return (dev->flags & ~(IFF_PROMISC | IFF_ALLMULTI)) |
> 	       (dev->gflags & (IFF_PROMISC | IFF_ALLMULTI));
> }
> 
658c686
< 			(dev->flags & ~ifm->ifi_change);
---
> 			(rtnl_dev_get_flags(dev) & ~ifm->ifi_change);
701c729,730
< static inline int rtnl_vfinfo_size(const struct net_device *dev)
---
> static inline int rtnl_vfinfo_size(const struct net_device *dev,
> 				   u32 ext_filter_mask)
703,704c732,733
< 	if (dev->dev.parent && dev_is_pci(dev->dev.parent)) {
< 
---
> 	if (dev->dev.parent && dev_is_pci(dev->dev.parent) &&
> 	    (ext_filter_mask & RTEXT_FILTER_VF)) {
742c771,772
< static noinline size_t if_nlmsg_size(const struct net_device *dev)
---
> static noinline size_t if_nlmsg_size(const struct net_device *dev,
> 				     u32 ext_filter_mask)
760,761c790,792
< 	       + nla_total_size(4) /* IFLA_NUM_VF */
< 	       + rtnl_vfinfo_size(dev) /* IFLA_VFINFO_LIST */
---
> 	       + nla_total_size(ext_filter_mask
> 			        & RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */
> 	       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */
844c875
< 			    unsigned int flags)
---
> 			    unsigned int flags, u32 ext_filter_mask)
917c948
< 	if (dev->dev.parent)
---
> 	if (dev->dev.parent && (ext_filter_mask & RTEXT_FILTER_VF))
920c951,952
< 	if (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent) {
---
> 	if (dev->netdev_ops->ndo_get_vf_config && dev->dev.parent
> 	    && (ext_filter_mask & RTEXT_FILTER_VF)) {
1006a1039,1040
> 	struct nlattr *tb[IFLA_MAX+1];
> 	u32 ext_filter_mask = 0;
1011a1046,1053
> 
> 	if (nlmsg_parse(cb->nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,
> 			ifla_policy) >= 0) {
> 
> 		if (tb[IFLA_EXT_MASK])
> 			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
> 	}
> 
1021c1063,1064
< 					     NLM_F_MULTI) <= 0)
---
> 					     NLM_F_MULTI,
> 					     ext_filter_mask) <= 0)
1054a1098
> 	[IFLA_EXT_MASK]		= { .type = NLA_U32 },
1300a1345
> 		add_device_randomness(dev->dev_addr, dev->addr_len);
1785a1831
> 	u32 ext_filter_mask = 0;
1793a1840,1842
> 	if (tb[IFLA_EXT_MASK])
> 		ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
> 
1805c1854
< 	nskb = nlmsg_new(if_nlmsg_size(dev), GFP_KERNEL);
---
> 	nskb = nlmsg_new(if_nlmsg_size(dev, ext_filter_mask), GFP_KERNEL);
1810c1859
< 			       nlh->nlmsg_seq, 0, 0);
---
> 			       nlh->nlmsg_seq, 0, 0, ext_filter_mask);
1820a1870,1898
> static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)
> {
> 	struct net *net = sock_net(skb->sk);
> 	struct net_device *dev;
> 	struct nlattr *tb[IFLA_MAX+1];
> 	u32 ext_filter_mask = 0;
> 	u16 min_ifinfo_dump_size = 0;
> 
> 	if (nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,
> 			ifla_policy) >= 0) {
> 		if (tb[IFLA_EXT_MASK])
> 			ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);
> 	}
> 
> 	if (!ext_filter_mask)
> 		return NLMSG_GOODSIZE;
> 	/*
> 	 * traverse the list of net devices and compute the minimum
> 	 * buffer size based upon the filter mask.
> 	 */
> 	list_for_each_entry(dev, &net->dev_base_head, dev_list) {
> 		min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,
> 					     if_nlmsg_size(dev,
> 						           ext_filter_mask));
> 	}
> 
> 	return min_ifinfo_dump_size;
> }
> 
1849a1928
> 	size_t if_info_size;
1851c1930
< 	skb = nlmsg_new(if_nlmsg_size(dev), GFP_KERNEL);
---
> 	skb = nlmsg_new((if_info_size = if_nlmsg_size(dev, 0)), GFP_KERNEL);
1855c1934
< 	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0);
---
> 	err = rtnl_fill_ifinfo(skb, dev, type, 0, 0, change, 0, 0);
1904a1984,1985
> 		rtnl_calcit_func calcit;
> 		u16 min_dump_alloc = 0;
1908a1990,1992
> 		calcit = rtnl_get_calcit(family, type);
> 		if (calcit)
> 			min_dump_alloc = calcit(skb, nlh);
1912c1996,1997
< 		err = netlink_dump_start(rtnl, skb, nlh, dumpit, NULL);
---
> 		err = netlink_dump_start(rtnl, skb, nlh, dumpit,
> 					 NULL, min_dump_alloc);
2022,2025c2107,2111
< 	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink, rtnl_dump_ifinfo);
< 	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL);
---
> 	rtnl_register(PF_UNSPEC, RTM_GETLINK, rtnl_getlink,
> 		      rtnl_dump_ifinfo, rtnl_calcit);
> 	rtnl_register(PF_UNSPEC, RTM_SETLINK, rtnl_setlink, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_NEWLINK, rtnl_newlink, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELLINK, rtnl_dellink, NULL, NULL);
2027,2028c2113,2114
< 	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all);
< 	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all);
---
> 	rtnl_register(PF_UNSPEC, RTM_GETADDR, NULL, rtnl_dump_all, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETROUTE, NULL, rtnl_dump_all, NULL);




diff -r linux-3.0.36/net/core/sock.c linux-3.0.36-lenovo/net/core/sock.c
597c597,598
< 		if (sk->sk_protocol == IPPROTO_TCP)
---
> 		if (sk->sk_protocol == IPPROTO_TCP &&
> 		    sk->sk_type == SOCK_STREAM)
1314a1316
> 			sk->sk_gso_max_segs = dst->dev->gso_max_segs;
1503a1506,1510
> 	int npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
> 
> 	err = -EMSGSIZE;
> 	if (npages > MAX_SKB_FRAGS)
> 		goto failure;
1522d1528
< 				int npages;
1529d1534
< 				npages = (data_len + (PAGE_SIZE - 1)) >> PAGE_SHIFT;




diff -r linux-3.0.36/net/dcb/dcbnl.c linux-3.0.36-lenovo/net/dcb/dcbnl.c
1822,1823c1822,1823
< 	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL);
---
> 	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);




diff -r linux-3.0.36/net/dccp/ccid.h linux-3.0.36-lenovo/net/dccp/ccid.h
249c249
< 	if (ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)
---
> 	if (ccid != NULL && ccid->ccid_ops->ccid_hc_rx_getsockopt != NULL)
260c260
< 	if (ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)
---
> 	if (ccid != NULL && ccid->ccid_ops->ccid_hc_tx_getsockopt != NULL)




diff -r linux-3.0.36/net/dccp/ccids/ccid3.c linux-3.0.36-lenovo/net/dccp/ccids/ccid3.c
534a535
> 		memset(&tfrc, 0, sizeof(tfrc));




diff -r linux-3.0.36/net/decnet/dn_dev.c linux-3.0.36-lenovo/net/decnet/dn_dev.c
1417,1419c1417,1419
< 	rtnl_register(PF_DECnet, RTM_NEWADDR, dn_nl_newaddr, NULL);
< 	rtnl_register(PF_DECnet, RTM_DELADDR, dn_nl_deladdr, NULL);
< 	rtnl_register(PF_DECnet, RTM_GETADDR, NULL, dn_nl_dump_ifaddr);
---
> 	rtnl_register(PF_DECnet, RTM_NEWADDR, dn_nl_newaddr, NULL, NULL);
> 	rtnl_register(PF_DECnet, RTM_DELADDR, dn_nl_deladdr, NULL, NULL);
> 	rtnl_register(PF_DECnet, RTM_GETADDR, NULL, dn_nl_dump_ifaddr, NULL);




diff -r linux-3.0.36/net/decnet/dn_fib.c linux-3.0.36-lenovo/net/decnet/dn_fib.c
766,767c766,767
< 	rtnl_register(PF_DECnet, RTM_NEWROUTE, dn_fib_rtm_newroute, NULL);
< 	rtnl_register(PF_DECnet, RTM_DELROUTE, dn_fib_rtm_delroute, NULL);
---
> 	rtnl_register(PF_DECnet, RTM_NEWROUTE, dn_fib_rtm_newroute, NULL, NULL);
> 	rtnl_register(PF_DECnet, RTM_DELROUTE, dn_fib_rtm_delroute, NULL, NULL);




diff -r linux-3.0.36/net/decnet/dn_route.c linux-3.0.36-lenovo/net/decnet/dn_route.c
1846c1846,1847
< 	rtnl_register(PF_DECnet, RTM_GETROUTE, dn_cache_getroute, dn_fib_dump);
---
> 	rtnl_register(PF_DECnet, RTM_GETROUTE, dn_cache_getroute,
> 		      dn_fib_dump, NULL);
1849c1850
< 		      dn_cache_dump);
---
> 		      dn_cache_dump, NULL);




diff -r linux-3.0.36/net/ipv4/af_inet.c linux-3.0.36-lenovo/net/ipv4/af_inet.c
120a121,133
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> #include <linux/android_aid.h>
> 
> static inline int current_has_network(void)
> {
> 	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
> }
> #else
> static inline int current_has_network(void)
> {
> 	return 1;
> }
> #endif
260a274
> 
276a291,293
> 	if (!current_has_network())
> 		return -EACCES;
> 
876a894
> 	case SIOCKILLADDR:




diff -r linux-3.0.36/net/ipv4/cipso_ipv4.c linux-3.0.36-lenovo/net/ipv4/cipso_ipv4.c
1728,1729c1728,1731
< 			 * not the loopback device drop the packet. */
< 			if (!(skb->dev->flags & IFF_LOOPBACK)) {
---
> 			 * not the loopback device drop the packet. Further,
> 			 * there is no legitimate reason for setting this from
> 			 * userspace so reject it if skb is NULL. */
> 			if (skb == NULL || !(skb->dev->flags & IFF_LOOPBACK)) {




diff -r linux-3.0.36/net/ipv4/devinet.c linux-3.0.36-lenovo/net/ipv4/devinet.c
61a62
> #include <net/tcp.h>
737a739
> 	case SIOCKILLADDR:	/* Nuke all sockets on this address */
789c791,792
< 	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS)
---
> 	if (!ifa && cmd != SIOCSIFADDR && cmd != SIOCSIFFLAGS
> 	    && cmd != SIOCKILLADDR)
914a918,920
> 	case SIOCKILLADDR:	/* Nuke all connections on this address */
> 		ret = tcp_nuke_addr(net, (struct sockaddr *) sin);
> 		break;
1841,1843c1847,1849
< 	rtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL);
< 	rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL);
< 	rtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr);
---
> 	rtnl_register(PF_INET, RTM_NEWADDR, inet_rtm_newaddr, NULL, NULL);
> 	rtnl_register(PF_INET, RTM_DELADDR, inet_rtm_deladdr, NULL, NULL);
> 	rtnl_register(PF_INET, RTM_GETADDR, NULL, inet_dump_ifaddr, NULL);




diff -r linux-3.0.36/net/ipv4/fib_frontend.c linux-3.0.36-lenovo/net/ipv4/fib_frontend.c
1127,1129c1127,1129
< 	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL);
< 	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL);
< 	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib);
---
> 	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);
> 	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);
> 	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);




diff -r linux-3.0.36/net/ipv4/fib_semantics.c linux-3.0.36-lenovo/net/ipv4/fib_semantics.c
1117c1117
< 	if (order <= 0 || fi == NULL) {
---
> 	if (order <= 0 || fi == NULL || fi->fib_dev == NULL) {




diff -r linux-3.0.36/net/ipv4/inet_diag.c linux-3.0.36-lenovo/net/ipv4/inet_diag.c
872c872
< 					  inet_diag_dump, NULL);
---
> 					  inet_diag_dump, NULL, 0);




diff -r linux-3.0.36/net/ipv4/ipmr.c linux-3.0.36-lenovo/net/ipv4/ipmr.c
126a127,128
> static void ipmr_free_table(struct mr_table *mrt);
> 
133a136
> static void mroute_clean_tables(struct mr_table *mrt);
274c277
< 		kfree(mrt);
---
> 		ipmr_free_table(mrt);
302c305
< 	kfree(net->ipv4.mrt);
---
> 	ipmr_free_table(net->ipv4.mrt);
338a342,348
> static void ipmr_free_table(struct mr_table *mrt)
> {
> 	del_timer_sync(&mrt->ipmr_expire_timer);
> 	mroute_clean_tables(mrt);
> 	kfree(mrt);
> }
> 
2547c2557,2558
< 	rtnl_register(RTNL_FAMILY_IPMR, RTM_GETROUTE, NULL, ipmr_rtm_dumproute);
---
> 	rtnl_register(RTNL_FAMILY_IPMR, RTM_GETROUTE,
> 		      NULL, ipmr_rtm_dumproute, NULL);




diff -r linux-3.0.36/net/ipv4/ip_sockglue.c linux-3.0.36-lenovo/net/ipv4/ip_sockglue.c
470,481c470,490
< 	if (((1<<optname) & ((1<<IP_PKTINFO) | (1<<IP_RECVTTL) |
< 			     (1<<IP_RECVOPTS) | (1<<IP_RECVTOS) |
< 			     (1<<IP_RETOPTS) | (1<<IP_TOS) |
< 			     (1<<IP_TTL) | (1<<IP_HDRINCL) |
< 			     (1<<IP_MTU_DISCOVER) | (1<<IP_RECVERR) |
< 			     (1<<IP_ROUTER_ALERT) | (1<<IP_FREEBIND) |
< 			     (1<<IP_PASSSEC) | (1<<IP_TRANSPARENT) |
< 			     (1<<IP_MINTTL) | (1<<IP_NODEFRAG))) ||
< 	    optname == IP_MULTICAST_TTL ||
< 	    optname == IP_MULTICAST_ALL ||
< 	    optname == IP_MULTICAST_LOOP ||
< 	    optname == IP_RECVORIGDSTADDR) {
---
> 	switch (optname) {
> 	case IP_PKTINFO:
> 	case IP_RECVTTL:
> 	case IP_RECVOPTS:
> 	case IP_RECVTOS:
> 	case IP_RETOPTS:
> 	case IP_TOS:
> 	case IP_TTL:
> 	case IP_HDRINCL:
> 	case IP_MTU_DISCOVER:
> 	case IP_RECVERR:
> 	case IP_ROUTER_ALERT:
> 	case IP_FREEBIND:
> 	case IP_PASSSEC:
> 	case IP_TRANSPARENT:
> 	case IP_MINTTL:
> 	case IP_NODEFRAG:
> 	case IP_MULTICAST_TTL:
> 	case IP_MULTICAST_ALL:
> 	case IP_MULTICAST_LOOP:
> 	case IP_RECVORIGDSTADDR:
593c602
< 		if (val != -1 && (val < 0 || val > 255))
---
> 		if (val != -1 && (val < 1 || val > 255))




diff -r linux-3.0.36/net/ipv4/Makefile linux-3.0.36-lenovo/net/ipv4/Makefile
16a17
> obj-$(CONFIG_SYSFS) += sysfs_net_ipv4.o




diff -r linux-3.0.36/net/ipv4/netfilter/ipt_REJECT.c linux-3.0.36-lenovo/net/ipv4/netfilter/ipt_REJECT.c
130a131,138
> #ifdef CONFIG_IP_NF_TARGET_REJECT_SKERR
> 	if (skb_in->sk) {
> 		skb_in->sk->sk_err = icmp_err_convert[code].errno;
> 		skb_in->sk->sk_error_report(skb_in->sk);
> 		pr_debug("ipt_REJECT: sk_err=%d for skb=%p sk=%p\n",
> 			skb_in->sk->sk_err, skb_in, skb_in->sk);
> 	}
> #endif




diff -r linux-3.0.36/net/ipv4/netfilter/Kconfig linux-3.0.36-lenovo/net/ipv4/netfilter/Kconfig
115a116,127
> config IP_NF_TARGET_REJECT_SKERR
> 	bool "Force socket error when rejecting with icmp*"
> 	depends on IP_NF_TARGET_REJECT
> 	default n
> 	help
>           This option enables turning a "--reject-with icmp*" into a matching
>           socket error also.
> 	  The REJECT target normally allows sending an ICMP message. But it
>           leaves the local socket unaware of any ingress rejects.
> 
> 	  If unsure, say N.
> 




diff -r linux-3.0.36/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c linux-3.0.36-lenovo/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
86a87,94
> 	/* Check bogus IP headers */
> 	if (*dataoff > skb->len) {
> 		pr_debug("nf_conntrack_ipv4: bogus IPv4 packet: "
> 			 "nhoff %u, ihl %u, skblen %u\n",
> 			 nhoff, iph->ihl << 2, skb->len);
> 		return -NF_ACCEPT;
> 	}
> 




diff -r linux-3.0.36/net/ipv4/netfilter/nf_nat_sip.c linux-3.0.36-lenovo/net/ipv4/netfilter/nf_nat_sip.c
151c151
< 		unsigned int matchend, poff, plen, buflen, n;
---
> 		unsigned int olen, matchend, poff, plen, buflen, n;
165a166
> 		olen = *datalen;
170c171
< 		matchend = matchoff + matchlen;
---
> 		matchend = matchoff + matchlen + *datalen - olen;
504c505,508
< 		else if (ret != -EBUSY) {
---
> 		else if (ret == -EBUSY) {
> 			nf_ct_unexpect_related(rtp_exp);
> 			continue;
> 		} else if (ret < 0) {




diff -r linux-3.0.36/net/ipv4/netfilter/nf_nat_standalone.c linux-3.0.36-lenovo/net/ipv4/netfilter/nf_nat_standalone.c
197c197,198
< 		    (ct->tuplehash[dir].tuple.src.u.all !=
---
> 		    (ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&
> 		     ct->tuplehash[dir].tuple.src.u.all !=
233c234,235
< 		else if (ct->tuplehash[dir].tuple.dst.u.all !=
---
> 		else if (ct->tuplehash[dir].tuple.dst.protonum != IPPROTO_ICMP &&
> 			 ct->tuplehash[dir].tuple.dst.u.all !=




diff -r linux-3.0.36/net/ipv4/proc.c linux-3.0.36-lenovo/net/ipv4/proc.c
235d234
< 	SNMP_MIB_ITEM("TCPAbortOnSyn", LINUX_MIB_TCPABORTONSYN),
256a256,257
> 	SNMP_MIB_ITEM("TCPChallengeACK", LINUX_MIB_TCPCHALLENGEACK),
> 	SNMP_MIB_ITEM("TCPSYNChallenge", LINUX_MIB_TCPSYNCHALLENGE),




diff -r linux-3.0.36/net/ipv4/raw.c linux-3.0.36-lenovo/net/ipv4/raw.c
133c133
< static __inline__ int icmp_filter(struct sock *sk, struct sk_buff *skb)
---
> static int icmp_filter(const struct sock *sk, const struct sk_buff *skb)
135c135,136
< 	int type;
---
> 	struct icmphdr _hdr;
> 	const struct icmphdr *hdr;
137c138,140
< 	if (!pskb_may_pull(skb, sizeof(struct icmphdr)))
---
> 	hdr = skb_header_pointer(skb, skb_transport_offset(skb),
> 				 sizeof(_hdr), &_hdr);
> 	if (!hdr)
140,141c143
< 	type = icmp_hdr(skb)->type;
< 	if (type < 32) {
---
> 	if (hdr->type < 32) {
144c146
< 		return ((1 << type) & data) != 0;
---
> 		return ((1U << hdr->type) & data) != 0;




diff -r linux-3.0.36/net/ipv4/route.c linux-3.0.36-lenovo/net/ipv4/route.c
1376a1377
> 	struct hh_cache *old_hh;
1383a1385,1387
> 	old_hh = xchg(&rt->dst.hh, NULL);
> 	if (old_hh)
> 		hh_cache_put(old_hh);
2753a2758,2763
> 	dev_out = FIB_RES_DEV(res);
> 	if (dev_out == NULL) {
> 		rth = ERR_PTR(-ENODEV);
> 		goto out;
> 	}
> 
2757d2766
< 	dev_out = FIB_RES_DEV(res);
3453c3462
< 	rtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL);
---
> 	rtnl_register(PF_INET, RTM_GETROUTE, inet_rtm_getroute, NULL, NULL);




diff -r linux-3.0.36/net/ipv4/sysctl_net_ipv4.c linux-3.0.36-lenovo/net/ipv4/sysctl_net_ipv4.c
568a569,575
> 	{
> 		.procname	= "tcp_challenge_ack_limit",
> 		.data		= &sysctl_tcp_challenge_ack_limit,
> 		.maxlen		= sizeof(int),
> 		.mode		= 0644,
> 		.proc_handler	= proc_dointvec
> 	},
Only in linux-3.0.36-lenovo/net/ipv4: sysfs_net_ipv4.c




diff -r linux-3.0.36/net/ipv4/tcp.c linux-3.0.36-lenovo/net/ipv4/tcp.c
268a269
> #include <linux/uid_stat.h>
273a275,277
> #include <net/ip6_route.h>
> #include <net/ipv6.h>
> #include <net/transp_v6.h>
484d487
< 			struct sk_buff *skb;
488,491c491,493
< 			/* Subtract 1, if FIN is in queue. */
< 			skb = skb_peek_tail(&sk->sk_receive_queue);
< 			if (answ && skb)
< 				answ -= tcp_hdr(skb)->fin;
---
> 			/* Subtract 1, if FIN was received */
> 			if (answ && sock_flag(sk, SOCK_DONE))
> 				answ--;
742c744,746
< 			tp->xmit_size_goal_segs = xmit_size_goal / mss_now;
---
> 			tp->xmit_size_goal_segs =
> 				min_t(u16, xmit_size_goal / mss_now,
> 				      sk->sk_gso_max_segs);
1113a1118,1120
> 
> 	if (copied > 0)
> 		uid_stat_tcp_snd(current_uid(), copied);
1390c1397
< 	if (copied > 0)
---
> 	if (copied > 0) {
1391a1399,1401
> 		uid_stat_tcp_rcv(current_uid(), copied);
> 	}
> 
1593,1594c1603,1610
< 		if (tp->ucopy.dma_chan)
< 			dma_async_memcpy_issue_pending(tp->ucopy.dma_chan);
---
> 		if (tp->ucopy.dma_chan) {
> 			if (tp->rcv_wnd == 0 &&
> 			    !skb_queue_empty(&sk->sk_async_wait_queue)) {
> 				tcp_service_net_dma(sk, true);
> 				tcp_cleanup_rbuf(sk, copied);
> 			} else
> 				dma_async_memcpy_issue_pending(tp->ucopy.dma_chan);
> 		}
1772a1789,1791
> 
> 	if (copied > 0)
> 		uid_stat_tcp_rcv(current_uid(), copied);
1780a1800,1801
> 	if (err > 0)
> 		uid_stat_tcp_rcv(current_uid(), err);
2397c2418,2421
< 		icsk->icsk_user_timeout = msecs_to_jiffies(val);
---
> 		if (val < 0)
> 			err = -EINVAL;
> 		else
> 			icsk->icsk_user_timeout = msecs_to_jiffies(val);
3311a3336,3439
> }
> 
> static int tcp_is_local(struct net *net, __be32 addr) {
> 	struct rtable *rt;
> 	struct flowi4 fl4 = { .daddr = addr };
> 	rt = ip_route_output_key(net, &fl4);
> 	if (IS_ERR_OR_NULL(rt))
> 		return 0;
> 	return rt->dst.dev && (rt->dst.dev->flags & IFF_LOOPBACK);
> }
> 
> #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
> static int tcp_is_local6(struct net *net, struct in6_addr *addr) {
> 	struct rt6_info *rt6 = rt6_lookup(net, addr, addr, 0, 0);
> 	return rt6 && rt6->rt6i_dev && (rt6->rt6i_dev->flags & IFF_LOOPBACK);
> }
> #endif
> 
> /*
>  * tcp_nuke_addr - destroy all sockets on the given local address
>  * if local address is the unspecified address (0.0.0.0 or ::), destroy all
>  * sockets with local addresses that are not configured.
>  */
> int tcp_nuke_addr(struct net *net, struct sockaddr *addr)
> {
> 	int family = addr->sa_family;
> 	unsigned int bucket;
> 
> 	struct in_addr *in;
> #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
> 	struct in6_addr *in6;
> #endif
> 	if (family == AF_INET) {
> 		in = &((struct sockaddr_in *)addr)->sin_addr;
> #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
> 	} else if (family == AF_INET6) {
> 		in6 = &((struct sockaddr_in6 *)addr)->sin6_addr;
> #endif
> 	} else {
> 		return -EAFNOSUPPORT;
> 	}
> 
> 	for (bucket = 0; bucket < tcp_hashinfo.ehash_mask; bucket++) {
> 		struct hlist_nulls_node *node;
> 		struct sock *sk;
> 		spinlock_t *lock = inet_ehash_lockp(&tcp_hashinfo, bucket);
> 
> restart:
> 		spin_lock_bh(lock);
> 		sk_nulls_for_each(sk, node, &tcp_hashinfo.ehash[bucket].chain) {
> 			struct inet_sock *inet = inet_sk(sk);
> 
> 			if (sysctl_ip_dynaddr && sk->sk_state == TCP_SYN_SENT)
> 				continue;
> 			if (sock_flag(sk, SOCK_DEAD))
> 				continue;
> 
> 			if (family == AF_INET) {
> 				__be32 s4 = inet->inet_rcv_saddr;
> 				if (s4 == LOOPBACK4_IPV6)
> 					continue;
> 
> 				if (in->s_addr != s4 &&
> 				    !(in->s_addr == INADDR_ANY &&
> 				      !tcp_is_local(net, s4)))
> 					continue;
> 			}
> 
> #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
> 			if (family == AF_INET6) {
> 				struct in6_addr *s6;
> 				if (!inet->pinet6)
> 					continue;
> 
> 				s6 = &inet->pinet6->rcv_saddr;
> 				if (ipv6_addr_type(s6) == IPV6_ADDR_MAPPED)
> 					continue;
> 
> 				if (!ipv6_addr_equal(in6, s6) &&
> 				    !(ipv6_addr_equal(in6, &in6addr_any) &&
> 				      !tcp_is_local6(net, s6)))
> 				continue;
> 			}
> #endif
> 
> 			sock_hold(sk);
> 			spin_unlock_bh(lock);
> 
> 			local_bh_disable();
> 			bh_lock_sock(sk);
> 			sk->sk_err = ETIMEDOUT;
> 			sk->sk_error_report(sk);
> 
> 			tcp_done(sk);
> 			bh_unlock_sock(sk);
> 			local_bh_enable();
> 			sock_put(sk);
> 
> 			goto restart;
> 		}
> 		spin_unlock_bh(lock);
> 	}
> 
> 	return 0;




diff -r linux-3.0.36/net/ipv4/tcp_cong.c linux-3.0.36-lenovo/net/ipv4/tcp_cong.c
293c293,294
< 	    left * tp->mss_cache < sk->sk_gso_max_size)
---
> 	    left * tp->mss_cache < sk->sk_gso_max_size &&
> 	    left < sk->sk_gso_max_segs)




diff -r linux-3.0.36/net/ipv4/tcp_illinois.c linux-3.0.36-lenovo/net/ipv4/tcp_illinois.c
316d315
< 		u64 t = ca->sum_rtt;
318,319c317,318
< 		do_div(t, ca->cnt_rtt);
< 		info.tcpv_rtt = t;
---
> 		if (info.tcpv_rttcnt > 0) {
> 			u64 t = ca->sum_rtt;
320a320,322
> 			do_div(t, info.tcpv_rttcnt);
> 			info.tcpv_rtt = t;
> 		}




diff -r linux-3.0.36/net/ipv4/tcp_input.c linux-3.0.36-lenovo/net/ipv4/tcp_input.c
88a89,91
> /* rfc5961 challenge ack rate limiting */
> int sysctl_tcp_challenge_ack_limit = 100;
> 
3587a3591,3595
> 			if (!tcp_packets_in_flight(tp)) {
> 				tcp_enter_frto_loss(sk, 2, flag);
> 				return true;
> 			}
> 
3635a3644,3661
> /* RFC 5961 7 [ACK Throttling] */
> static void tcp_send_challenge_ack(struct sock *sk)
> {
> 	/* unprotected vars, we dont care of overwrites */
> 	static u32 challenge_timestamp;
> 	static unsigned int challenge_count;
> 	u32 now = jiffies / HZ;
> 
> 	if (now != challenge_timestamp) {
> 		challenge_timestamp = now;
> 		challenge_count = 0;
> 	}
> 	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
> 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
> 		tcp_send_ack(sk);
> 	}
> }
> 
3652c3678,3683
< 	if (before(ack, prior_snd_una))
---
> 	if (before(ack, prior_snd_una)) {
> 		/* RFC 5961 5.2 [Blind Data Injection Attack].[Mitigation] */
> 		if (before(ack, prior_snd_una - tp->max_window)) {
> 			tcp_send_challenge_ack(sk);
> 			return -1;
> 		}
3653a3685
> 	}
5171,5172c5203,5204
< static int tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
< 			      struct tcphdr *th, int syn_inerr)
---
> static bool tcp_validate_incoming(struct sock *sk, struct sk_buff *skb,
> 				  struct tcphdr *th, int syn_inerr)
5197c5229,5231
< 		if (!th->rst)
---
> 		if (!th->rst) {
> 			if (th->syn)
> 				goto syn_challenge;
5198a5233
> 		}
5204c5239,5248
< 		tcp_reset(sk);
---
> 		/* RFC 5961 3.2 :
> 		 * If sequence number exactly matches RCV.NXT, then
> 		 *     RESET the connection
> 		 * else
> 		 *     Send a challenge ACK
> 		 */
> 		if (TCP_SKB_CB(skb)->seq == tp->rcv_nxt)
> 			tcp_reset(sk);
> 		else
> 			tcp_send_challenge_ack(sk);
5208,5212d5251
< 	/* ts_recent update must be made after we are sure that the packet
< 	 * is in window.
< 	 */
< 	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);
< 
5215,5216c5254,5258
< 	/* step 4: Check for a SYN in window. */
< 	if (th->syn && !before(TCP_SKB_CB(skb)->seq, tp->rcv_nxt)) {
---
> 	/* step 4: Check for a SYN
> 	 * RFC 5691 4.2 : Send a challenge ack
> 	 */
> 	if (th->syn) {
> syn_challenge:
5219,5221c5261,5263
< 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONSYN);
< 		tcp_reset(sk);
< 		return -1;
---
> 		NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPSYNCHALLENGE);
> 		tcp_send_challenge_ack(sk);
> 		goto discard;
5224c5266
< 	return 1;
---
> 	return true;
5228c5270
< 	return 0;
---
> 	return false;
5258d5299
< 	int res;
5343c5384,5386
< 				if (tcp_dma_try_early_copy(sk, skb, tcp_header_len)) {
---
> 				if (tp->ucopy.task == current &&
> 				    sock_owned_by_user(sk) &&
> 				    tcp_dma_try_early_copy(sk, skb, tcp_header_len)) {
5436,5438c5479,5480
< 	res = tcp_validate_incoming(sk, skb, th, 1);
< 	if (res <= 0)
< 		return -res;
---
> 	if (!tcp_validate_incoming(sk, skb, th, 1))
> 		return 0;
5443a5486,5490
> 	/* ts_recent update must be made after we are sure that the packet
> 	 * is in window.
> 	 */
> 	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);
> 
5748d5794
< 	int res;
5763a5810,5811
> 			if (th->fin)
> 				goto discard;
5801,5803c5849,5850
< 	res = tcp_validate_incoming(sk, skb, th, 0);
< 	if (res <= 0)
< 		return -res;
---
> 	if (!tcp_validate_incoming(sk, skb, th, 0))
> 		return 0;
5918a5966,5970
> 
> 	/* ts_recent update must be made after we are sure that the packet
> 	 * is in window.
> 	 */
> 	tcp_replace_ts_recent(tp, TCP_SKB_CB(skb)->seq);




diff -r linux-3.0.36/net/ipv4/tcp_ipv4.c linux-3.0.36-lenovo/net/ipv4/tcp_ipv4.c
654,655c654,655
< 	 * routing might fail in this case. using iif for oif to
< 	 * make sure we can deliver it
---
> 	 * routing might fail in this case. No choice here, if we choose to force
> 	 * input interface, we will misroute in case of asymmetric route.
657c657,658
< 	arg.bound_dev_if = sk ? sk->sk_bound_dev_if : inet_iif(skb);
---
> 	if (sk)
> 		arg.bound_dev_if = sk->sk_bound_dev_if;




diff -r linux-3.0.36/net/ipv4/tcp_output.c linux-3.0.36-lenovo/net/ipv4/tcp_output.c
1313c1313
< 					unsigned int mss_now, unsigned int cwnd)
---
> 					unsigned int mss_now, unsigned int max_segs)
1316c1316
< 	u32 needed, window, cwnd_len;
---
> 	u32 needed, window, max_len;
1319c1319
< 	cwnd_len = mss_now * cwnd;
---
> 	max_len = mss_now * max_segs;
1321,1322c1321,1322
< 	if (likely(cwnd_len <= window && skb != tcp_write_queue_tail(sk)))
< 		return cwnd_len;
---
> 	if (likely(max_len <= window && skb != tcp_write_queue_tail(sk)))
> 		return max_len;
1326,1327c1326,1327
< 	if (cwnd_len <= needed)
< 		return cwnd_len;
---
> 	if (max_len <= needed)
> 		return max_len;
1554c1554,1555
< 	if (limit >= sk->sk_gso_max_size)
---
> 	if (limit >= min_t(unsigned int, sk->sk_gso_max_size,
> 			   sk->sk_gso_max_segs * tp->mss_cache))
1780c1781,1783
< 						    cwnd_quota);
---
> 						    min_t(unsigned int,
> 							  cwnd_quota,
> 							  sk->sk_gso_max_segs));




diff -r linux-3.0.36/net/ipv6/addrconf.c linux-3.0.36-lenovo/net/ipv6/addrconf.c
495,496c495
< 	rcu_read_lock();
< 	for_each_netdev_rcu(net, dev) {
---
> 	for_each_netdev(net, dev) {
505d503
< 	rcu_read_unlock();
831c829
< 	unsigned long tmp_prefered_lft, tmp_valid_lft, tmp_cstamp, tmp_tstamp, age;
---
> 	unsigned long tmp_prefered_lft, tmp_valid_lft, tmp_tstamp, age;
836a835
> 	unsigned long now = jiffies;
881c880
< 	age = (jiffies - ifp->tstamp) / HZ;
---
> 	age = (now - ifp->tstamp) / HZ;
891d889
< 	tmp_cstamp = ifp->cstamp;
936c934
< 	ift->cstamp = tmp_cstamp;
---
> 	ift->cstamp = now;
1995,2002c1993,1996
< 			list_for_each_entry(ift, &in6_dev->tempaddr_list, tmp_list) {
< 				/*
< 				 * When adjusting the lifetimes of an existing
< 				 * temporary address, only lower the lifetimes.
< 				 * Implementations must not increase the
< 				 * lifetimes of an existing temporary address
< 				 * when processing a Prefix Information Option.
< 				 */
---
> 			list_for_each_entry(ift, &in6_dev->tempaddr_list,
> 					    tmp_list) {
> 				int age, max_valid, max_prefered;
> 
2005a2000,2028
> 				/*
> 				 * RFC 4941 section 3.3:
> 				 * If a received option will extend the lifetime
> 				 * of a public address, the lifetimes of
> 				 * temporary addresses should be extended,
> 				 * subject to the overall constraint that no
> 				 * temporary addresses should ever remain
> 				 * "valid" or "preferred" for a time longer than
> 				 * (TEMP_VALID_LIFETIME) or
> 				 * (TEMP_PREFERRED_LIFETIME - DESYNC_FACTOR),
> 				 * respectively.
> 				 */
> 				age = (now - ift->cstamp) / HZ;
> 				max_valid = in6_dev->cnf.temp_valid_lft - age;
> 				if (max_valid < 0)
> 					max_valid = 0;
> 
> 				max_prefered = in6_dev->cnf.temp_prefered_lft -
> 					       in6_dev->cnf.max_desync_factor -
> 					       age;
> 				if (max_prefered < 0)
> 					max_prefered = 0;
> 
> 				if (valid_lft > max_valid)
> 					valid_lft = max_valid;
> 
> 				if (prefered_lft > max_prefered)
> 					prefered_lft = max_prefered;
> 
2008,2013c2031,2036
< 				if (ift->valid_lft > valid_lft &&
< 				    ift->valid_lft - valid_lft > (jiffies - ift->tstamp) / HZ)
< 					ift->valid_lft = valid_lft + (jiffies - ift->tstamp) / HZ;
< 				if (ift->prefered_lft > prefered_lft &&
< 				    ift->prefered_lft - prefered_lft > (jiffies - ift->tstamp) / HZ)
< 					ift->prefered_lft = prefered_lft + (jiffies - ift->tstamp) / HZ;
---
> 				ift->valid_lft = valid_lft;
> 				ift->prefered_lft = prefered_lft;
> 				ift->tstamp = now;
> 				if (prefered_lft > 0)
> 					ift->flags &= ~IFA_F_DEPRECATED;
> 
2021,2023c2044,2048
< 				 * When a new public address is created as described in [ADDRCONF],
< 				 * also create a new temporary address. Also create a temporary
< 				 * address if it's enabled but no temporary address currently exists.
---
> 				 * When a new public address is created as
> 				 * described in [ADDRCONF], also create a new
> 				 * temporary address. Also create a temporary
> 				 * address if it's enabled but no temporary
> 				 * address currently exists.
4699c4724,4725
< 	err = __rtnl_register(PF_INET6, RTM_GETLINK, NULL, inet6_dump_ifinfo);
---
> 	err = __rtnl_register(PF_INET6, RTM_GETLINK, NULL, inet6_dump_ifinfo,
> 			      NULL);
4704,4708c4730,4737
< 	__rtnl_register(PF_INET6, RTM_NEWADDR, inet6_rtm_newaddr, NULL);
< 	__rtnl_register(PF_INET6, RTM_DELADDR, inet6_rtm_deladdr, NULL);
< 	__rtnl_register(PF_INET6, RTM_GETADDR, inet6_rtm_getaddr, inet6_dump_ifaddr);
< 	__rtnl_register(PF_INET6, RTM_GETMULTICAST, NULL, inet6_dump_ifmcaddr);
< 	__rtnl_register(PF_INET6, RTM_GETANYCAST, NULL, inet6_dump_ifacaddr);
---
> 	__rtnl_register(PF_INET6, RTM_NEWADDR, inet6_rtm_newaddr, NULL, NULL);
> 	__rtnl_register(PF_INET6, RTM_DELADDR, inet6_rtm_deladdr, NULL, NULL);
> 	__rtnl_register(PF_INET6, RTM_GETADDR, inet6_rtm_getaddr,
> 			inet6_dump_ifaddr, NULL);
> 	__rtnl_register(PF_INET6, RTM_GETMULTICAST, NULL,
> 			inet6_dump_ifmcaddr, NULL);
> 	__rtnl_register(PF_INET6, RTM_GETANYCAST, NULL,
> 			inet6_dump_ifacaddr, NULL);




diff -r linux-3.0.36/net/ipv6/addrlabel.c linux-3.0.36-lenovo/net/ipv6/addrlabel.c
595,597c595,600
< 	__rtnl_register(PF_INET6, RTM_NEWADDRLABEL, ip6addrlbl_newdel, NULL);
< 	__rtnl_register(PF_INET6, RTM_DELADDRLABEL, ip6addrlbl_newdel, NULL);
< 	__rtnl_register(PF_INET6, RTM_GETADDRLABEL, ip6addrlbl_get, ip6addrlbl_dump);
---
> 	__rtnl_register(PF_INET6, RTM_NEWADDRLABEL, ip6addrlbl_newdel,
> 			NULL, NULL);
> 	__rtnl_register(PF_INET6, RTM_DELADDRLABEL, ip6addrlbl_newdel,
> 			NULL, NULL);
> 	__rtnl_register(PF_INET6, RTM_GETADDRLABEL, ip6addrlbl_get,
> 			ip6addrlbl_dump, NULL);




diff -r linux-3.0.36/net/ipv6/af_inet6.c linux-3.0.36-lenovo/net/ipv6/af_inet6.c
65a66,79
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> #include <linux/android_aid.h>
> 
> static inline int current_has_network(void)
> {
> 	return in_egroup_p(AID_INET) || capable(CAP_NET_RAW);
> }
> #else
> static inline int current_has_network(void)
> {
> 	return 1;
> }
> #endif
> 
111a126,128
> 	if (!current_has_network())
> 		return -EACCES;
> 
479a497,511
> int inet6_killaddr_ioctl(struct net *net, void __user *arg) {
> 	struct in6_ifreq ireq;
> 	struct sockaddr_in6 sin6;
> 
> 	if (!capable(CAP_NET_ADMIN))
> 		return -EACCES;
> 
> 	if (copy_from_user(&ireq, arg, sizeof(struct in6_ifreq)))
> 		return -EFAULT;
> 
> 	sin6.sin6_family = AF_INET6;
> 	ipv6_addr_copy(&sin6.sin6_addr, &ireq.ifr6_addr);
> 	return tcp_nuke_addr(net, (struct sockaddr *) &sin6);
> }
> 
503a536,537
> 	case SIOCKILLADDR:
> 		return inet6_killaddr_ioctl(net, (void __user *) arg);




diff -r linux-3.0.36/net/ipv6/ip6_fib.c linux-3.0.36-lenovo/net/ipv6/ip6_fib.c
1589c1589,1590
< 	ret = __rtnl_register(PF_INET6, RTM_GETROUTE, NULL, inet6_dump_fib);
---
> 	ret = __rtnl_register(PF_INET6, RTM_GETROUTE, NULL, inet6_dump_fib,
> 			      NULL);




diff -r linux-3.0.36/net/ipv6/ip6mr.c linux-3.0.36-lenovo/net/ipv6/ip6mr.c
1359c1359,1360
< 	rtnl_register(RTNL_FAMILY_IP6MR, RTM_GETROUTE, NULL, ip6mr_rtm_dumproute);
---
> 	rtnl_register(RTNL_FAMILY_IP6MR, RTM_GETROUTE, NULL,
> 		      ip6mr_rtm_dumproute, NULL);




diff -r linux-3.0.36/net/ipv6/ipv6_sockglue.c linux-3.0.36-lenovo/net/ipv6/ipv6_sockglue.c
800a801
> 		retv = 0;




diff -r linux-3.0.36/net/ipv6/mip6.c linux-3.0.36-lenovo/net/ipv6/mip6.c
87c87,88
< 	struct ip6_mh *mh;
---
> 	struct ip6_mh _hdr;
> 	const struct ip6_mh *mh;
89,91c90,92
< 	if (!pskb_may_pull(skb, (skb_transport_offset(skb)) + 8) ||
< 	    !pskb_may_pull(skb, (skb_transport_offset(skb) +
< 				 ((skb_transport_header(skb)[1] + 1) << 3))))
---
> 	mh = skb_header_pointer(skb, skb_transport_offset(skb),
> 				sizeof(_hdr), &_hdr);
> 	if (!mh)
94c95,96
< 	mh = (struct ip6_mh *)skb_transport_header(skb);
---
> 	if (((mh->ip6mh_hdrlen + 1) << 3) > skb->len)
> 		return -1;
99,100c101,102
< 		mip6_param_prob(skb, 0, ((&mh->ip6mh_hdrlen) -
< 					 skb_network_header(skb)));
---
> 		mip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_hdrlen) +
> 				skb_network_header_len(skb));
107,108c109,110
< 		mip6_param_prob(skb, 0, ((&mh->ip6mh_proto) -
< 					 skb_network_header(skb)));
---
> 		mip6_param_prob(skb, 0, offsetof(struct ip6_mh, ip6mh_proto) +
> 				skb_network_header_len(skb));




diff -r linux-3.0.36/net/ipv6/ndisc.c linux-3.0.36-lenovo/net/ipv6/ndisc.c
618c618
< 	struct in6_addr mcaddr;
---
> 	struct in6_addr mcaddr = IN6ADDR_LINKLOCAL_ALLNODES_INIT;
626d625
< 		addrconf_addr_solict_mult(&ifa->addr, &mcaddr);




diff -r linux-3.0.36/net/ipv6/netfilter/ip6_tables.c linux-3.0.36-lenovo/net/ipv6/netfilter/ip6_tables.c
2295c2295
<  * number. Otherwise, return -1.
---
>  * number. Otherwise, return -ENOENT or -EBADMSG.
2302,2304c2302,2303
<  * *offset is meaningless and fragment offset is stored in *fragoff if fragoff
<  * isn't NULL.
<  *
---
>  * *offset is meaningless. If fragoff is not NULL, the fragment offset is
>  * stored in *fragoff; if it is NULL, return -EINVAL.
2345c2344
< 					if (fragoff)
---
> 					if (fragoff) {
2347c2346,2349
< 					return hp->nexthdr;
---
> 						return hp->nexthdr;
> 					} else {
> 						return -EINVAL;
> 					}




diff -r linux-3.0.36/net/ipv6/netfilter/ip6t_REJECT.c linux-3.0.36-lenovo/net/ipv6/netfilter/ip6t_REJECT.c
179a180,188
> #ifdef CONFIG_IP6_NF_TARGET_REJECT_SKERR
> 	if (skb_in->sk) {
> 		icmpv6_err_convert(ICMPV6_DEST_UNREACH, code,
> 				   &skb_in->sk->sk_err);
> 		skb_in->sk->sk_error_report(skb_in->sk);
> 		pr_debug("ip6t_REJECT: sk_err=%d for skb=%p sk=%p\n",
> 			skb_in->sk->sk_err, skb_in, skb_in->sk);
> 	}
> #endif




diff -r linux-3.0.36/net/ipv6/netfilter/Kconfig linux-3.0.36-lenovo/net/ipv6/netfilter/Kconfig
176a177,188
> config IP6_NF_TARGET_REJECT_SKERR
> 	bool "Force socket error when rejecting with icmp*"
> 	depends on IP6_NF_TARGET_REJECT
> 	default n
> 	help
>           This option enables turning a "--reject-with icmp*" into a matching
>           socket error also.
> 	  The REJECT target normally allows sending an ICMP message. But it
>           leaves the local socket unaware of any ingress rejects.
> 
> 	  If unsure, say N.
> 




diff -r linux-3.0.36/net/ipv6/raw.c linux-3.0.36-lenovo/net/ipv6/raw.c
109c109
< static __inline__ int icmpv6_filter(struct sock *sk, struct sk_buff *skb)
---
> static int icmpv6_filter(const struct sock *sk, const struct sk_buff *skb)
111,112c111,112
< 	struct icmp6hdr *icmph;
< 	struct raw6_sock *rp = raw6_sk(sk);
---
> 	struct icmp6hdr *_hdr;
> 	const struct icmp6hdr *hdr;
114,116c114,118
< 	if (pskb_may_pull(skb, sizeof(struct icmp6hdr))) {
< 		__u32 *data = &rp->filter.data[0];
< 		int bit_nr;
---
> 	hdr = skb_header_pointer(skb, skb_transport_offset(skb),
> 				 sizeof(_hdr), &_hdr);
> 	if (hdr) {
> 		const __u32 *data = &raw6_sk(sk)->filter.data[0];
> 		unsigned int type = hdr->icmp6_type;
118,121c120
< 		icmph = (struct icmp6hdr *) skb->data;
< 		bit_nr = icmph->icmp6_type;
< 
< 		return (data[bit_nr >> 5] & (1 << (bit_nr & 31))) != 0;
---
> 		return (data[type >> 5] & (1U << (type & 31))) != 0;
123c122
< 	return 0;
---
> 	return 1;




diff -r linux-3.0.36/net/ipv6/route.c linux-3.0.36-lenovo/net/ipv6/route.c
174c174
< 	[RTAX_HOPLIMIT - 1] = 255,
---
> 	[RTAX_HOPLIMIT - 1] = 0,
236c236,238
< 	memset(&rt->rt6i_table, 0, sizeof(*rt) - sizeof(struct dst_entry));
---
> 	if (rt != NULL)
> 		memset(&rt->rt6i_table, 0,
> 			sizeof(*rt) - sizeof(struct dst_entry));
805c807,808
< 	if (!dst_get_neighbour_raw(&rt->dst) && !(rt->rt6i_flags & RTF_NONEXTHOP))
---
> 	if (!dst_get_neighbour_raw(&rt->dst) &&
> 	    !(rt->rt6i_flags & (RTF_NONEXTHOP | RTF_LOCAL)))
1071c1074
< 	dst_metric_set(&rt->dst, RTAX_HOPLIMIT, 255);
---
> 	dst_metric_set(&rt->dst, RTAX_HOPLIMIT, 0);
1402,1403c1405,1408
< 	if (rt == net->ipv6.ip6_null_entry)
< 		return -ENOENT;
---
> 	if (rt == net->ipv6.ip6_null_entry) {
> 		err = -ENOENT;
> 		goto out;
> 	}
1407d1411
< 
1409,1410d1412
< 	dst_release(&rt->dst);
< 
1412a1415,1416
> out:
> 	dst_release(&rt->dst);
2849,2852d2852
< #ifdef CONFIG_PROC_FS
< 	proc_net_fops_create(net, "ipv6_route", 0, &ipv6_route_proc_fops);
< 	proc_net_fops_create(net, "rt6_stats", S_IRUGO, &rt6_stats_seq_fops);
< #endif
2873,2876d2872
< #ifdef CONFIG_PROC_FS
< 	proc_net_remove(net, "ipv6_route");
< 	proc_net_remove(net, "rt6_stats");
< #endif
2884a2881,2897
> static int __net_init ip6_route_net_init_late(struct net *net)
> {
> #ifdef CONFIG_PROC_FS
> 	proc_net_fops_create(net, "ipv6_route", 0, &ipv6_route_proc_fops);
> 	proc_net_fops_create(net, "rt6_stats", S_IRUGO, &rt6_stats_seq_fops);
> #endif
> 	return 0;
> }
> 
> static void __net_exit ip6_route_net_exit_late(struct net *net)
> {
> #ifdef CONFIG_PROC_FS
> 	proc_net_remove(net, "ipv6_route");
> 	proc_net_remove(net, "rt6_stats");
> #endif
> }
> 
2889a2903,2907
> static struct pernet_operations ip6_route_net_late_ops = {
> 	.init = ip6_route_net_init_late,
> 	.exit = ip6_route_net_exit_late,
> };
> 
2939,2942c2957,2958
< 	ret = -ENOBUFS;
< 	if (__rtnl_register(PF_INET6, RTM_NEWROUTE, inet6_rtm_newroute, NULL) ||
< 	    __rtnl_register(PF_INET6, RTM_DELROUTE, inet6_rtm_delroute, NULL) ||
< 	    __rtnl_register(PF_INET6, RTM_GETROUTE, inet6_rtm_getroute, NULL))
---
> 	ret = register_pernet_subsys(&ip6_route_net_late_ops);
> 	if (ret)
2944a2961,2966
> 	ret = -ENOBUFS;
> 	if (__rtnl_register(PF_INET6, RTM_NEWROUTE, inet6_rtm_newroute, NULL, NULL) ||
> 	    __rtnl_register(PF_INET6, RTM_DELROUTE, inet6_rtm_delroute, NULL, NULL) ||
> 	    __rtnl_register(PF_INET6, RTM_GETROUTE, inet6_rtm_getroute, NULL, NULL))
> 		goto out_register_late_subsys;
> 
2947c2969
< 		goto fib6_rules_init;
---
> 		goto out_register_late_subsys;
2951a2974,2975
> out_register_late_subsys:
> 	unregister_pernet_subsys(&ip6_route_net_late_ops);
2969a2994
> 	unregister_pernet_subsys(&ip6_route_net_late_ops);




diff -r linux-3.0.36/net/ipv6/tcp_ipv6.c linux-3.0.36-lenovo/net/ipv6/tcp_ipv6.c
1063c1063,1064
< 	fl6.flowi6_oif = inet6_iif(skb);
---
> 	if (ipv6_addr_type(&fl6.daddr) & IPV6_ADDR_LINKLOCAL)
> 		fl6.flowi6_oif = inet6_iif(skb);




diff -r linux-3.0.36/net/Kconfig linux-3.0.36-lenovo/net/Kconfig
81a82,95
> config ANDROID_PARANOID_NETWORK
> 	bool "Only allow certain groups to create sockets"
> 	default y
> 	help
> 		none
> 
> config NET_ACTIVITY_STATS
> 	bool "Network activity statistics tracking"
> 	default y
> 	help
> 	 Network activity statistics are useful for tracking wireless
> 	 modem activity on 2G, 3G, 4G wireless networks. Counts number of
> 	 transmissions and groups them in specified time buckets.
> 
220c234
< 	boolean
---
> 	boolean "RPS"




diff -r linux-3.0.36/net/l2tp/l2tp_core.c linux-3.0.36-lenovo/net/l2tp/l2tp_core.c
1254a1255
> 	kfree_rcu(tunnel, rcu);
1256d1256
< 	synchronize_rcu();
1259d1258
< 	kfree(tunnel);




diff -r linux-3.0.36/net/l2tp/l2tp_core.h linux-3.0.36-lenovo/net/l2tp/l2tp_core.h
159a160
> 	struct rcu_head rcu;




diff -r linux-3.0.36/net/l2tp/l2tp_eth.c linux-3.0.36-lenovo/net/l2tp/l2tp_eth.c
135c135
< 	if (!pskb_may_pull(skb, sizeof(ETH_HLEN)))
---
> 	if (!pskb_may_pull(skb, ETH_HLEN))
169a170
> 			module_put(THIS_MODULE);
256a258
> 	__module_get(THIS_MODULE);
269a272
> 	spriv->dev = NULL;




diff -r linux-3.0.36/net/llc/af_llc.c linux-3.0.36-lenovo/net/llc/af_llc.c
969c969
< 	int rc = 0;
---
> 	int rc = -EBADF;
976d975
< 	memset(uaddr, 0, *uaddrlen);




diff -r linux-3.0.36/net/mac80211/ibss.c linux-3.0.36-lenovo/net/mac80211/ibss.c
943c943
< 	memcpy(sdata->u.ibss.ssid, params->ssid, IEEE80211_MAX_SSID_LEN);
---
> 	memcpy(sdata->u.ibss.ssid, params->ssid, params->ssid_len);
968,971d967
< 	sdata->u.ibss.state = IEEE80211_IBSS_MLME_SEARCH;
< 	memset(sdata->u.ibss.bssid, 0, ETH_ALEN);
< 	sdata->u.ibss.ssid_len = 0;
< 
990a987,990
> 
> 	ifibss->state = IEEE80211_IBSS_MLME_SEARCH;
> 	memset(ifibss->bssid, 0, ETH_ALEN);
> 	ifibss->ssid_len = 0;




diff -r linux-3.0.36/net/mac80211/ieee80211_i.h linux-3.0.36-lenovo/net/mac80211/ieee80211_i.h
1172,1173c1172
< void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
< 				    bool offchannel_ps_enable);
---
> void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);
1175,1176c1174
< 				 bool enable_beaconing,
< 				 bool offchannel_ps_disable);
---
> 				 bool enable_beaconing);




diff -r linux-3.0.36/net/mac80211/mesh.c linux-3.0.36-lenovo/net/mac80211/mesh.c
492a493
> 	del_timer_sync(&sdata->u.mesh.mesh_path_timer);




diff -r linux-3.0.36/net/mac80211/offchannel.c linux-3.0.36-lenovo/net/mac80211/offchannel.c
105,106c105
< void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local,
< 				    bool offchannel_ps_enable)
---
> void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local)
131,132c130
< 			if (offchannel_ps_enable &&
< 			    (sdata->vif.type == NL80211_IFTYPE_STATION) &&
---
> 			if (sdata->vif.type == NL80211_IFTYPE_STATION &&
158,159c156
< 				 bool enable_beaconing,
< 				 bool offchannel_ps_disable)
---
> 				 bool enable_beaconing)
169,173c166,168
< 		if (offchannel_ps_disable &&
< 		    sdata->vif.type == NL80211_IFTYPE_STATION) {
< 			if (sdata->u.mgd.associated)
< 				ieee80211_offchannel_ps_disable(sdata);
< 		}
---
> 		if (sdata->vif.type == NL80211_IFTYPE_STATION &&
> 		    sdata->u.mgd.associated)
> 			ieee80211_offchannel_ps_disable(sdata);




diff -r linux-3.0.36/net/mac80211/rx.c linux-3.0.36-lenovo/net/mac80211/rx.c
1354a1355,1358
> 
> 	if (ieee80211_is_ctl(fc))
> 		return RX_CONTINUE;
> 
1359d1362
< 		   (rx->skb)->len < 24 ||
2294c2297
< 	 * 802.11-2007 7.3.1.11.
---
> 	 * 802.11-2012 9.24.4.
2303a2307,2309
> 	if (is_multicast_ether_addr(mgmt->da))
> 		return RX_DROP_MONITOR;
> 
2768,2770c2774,2780
< 	if (ieee80211_is_mgmt(fc))
< 		err = skb_linearize(skb);
< 	else
---
> 	if (ieee80211_is_mgmt(fc)) {
> 		/* drop frame if too short for header */
> 		if (skb->len < ieee80211_hdrlen(fc))
> 			err = -ENOBUFS;
> 		else
> 			err = skb_linearize(skb);
> 	} else {
2771a2782
> 	}




diff -r linux-3.0.36/net/mac80211/scan.c linux-3.0.36-lenovo/net/mac80211/scan.c
317c317
< 		ieee80211_offchannel_return(local, enable_beacons, true);
---
> 		ieee80211_offchannel_return(local, enable_beacons);
566c566
< 	ieee80211_offchannel_stop_vifs(local, false);
---
> 	ieee80211_offchannel_stop_vifs(local);
597c597
< 	ieee80211_offchannel_return(local, true, false);
---
> 	ieee80211_offchannel_return(local, true);




diff -r linux-3.0.36/net/mac80211/sta_info.c linux-3.0.36-lenovo/net/mac80211/sta_info.c
336a337
> 	memset(&sinfo, 0, sizeof(sinfo));
796c797
< 	del_timer(&local->sta_cleanup);
---
> 	del_timer_sync(&local->sta_cleanup);




diff -r linux-3.0.36/net/mac80211/work.c linux-3.0.36-lenovo/net/mac80211/work.c
976,977c976
< 					ieee80211_offchannel_stop_vifs(local,
< 								       true);
---
> 					ieee80211_offchannel_stop_vifs(local);
984,985c983
< 								    true,
< 								    false);
---
> 								    true);
1088c1086
< 		ieee80211_offchannel_return(local, true, true);
---
> 		ieee80211_offchannel_return(local, true);




diff -r linux-3.0.36/net/mac80211/wpa.c linux-3.0.36-lenovo/net/mac80211/wpa.c
112c112,113
< 		if (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key)
---
> 		if (!(status->flag & RX_FLAG_IV_STRIPPED) && rx->key &&
> 		    rx->key->conf.cipher == WLAN_CIPHER_SUITE_TKIP)




diff -r linux-3.0.36/net/Makefile linux-3.0.36-lenovo/net/Makefile
70a71
> obj-$(CONFIG_NET_ACTIVITY_STATS)		+= activity_stats.o




diff -r linux-3.0.36/net/netfilter/ipset/ip_set_core.c linux-3.0.36-lenovo/net/netfilter/ipset/ip_set_core.c
1123c1123
< 				  ip_set_dump_done);
---
> 				  ip_set_dump_done, 0);




diff -r linux-3.0.36/net/netfilter/ipvs/ip_vs_ctl.c linux-3.0.36-lenovo/net/netfilter/ipvs/ip_vs_ctl.c
1522a1523
> 	struct netns_ipvs *ipvs = net_ipvs(net);
1527c1528
< 	if (event != NETDEV_UNREGISTER)
---
> 	if (event != NETDEV_UNREGISTER || !ipvs)
1553c1554
< 	list_for_each_entry(dest, &net_ipvs(net)->dest_trash, n_list) {
---
> 	list_for_each_entry(dest, &ipvs->dest_trash, n_list) {
2677a2679
> 		memset(&t, 0, sizeof(t));




diff -r linux-3.0.36/net/netfilter/Kconfig linux-3.0.36-lenovo/net/netfilter/Kconfig
904a905,906
> 	Conflicts with '"quota, tag, uid" match'
> 
937a940,955
> config NETFILTER_XT_MATCH_QTAGUID
> 	bool '"quota, tag, owner" match and stats support'
>         depends on NETFILTER_XT_MATCH_SOCKET
> 	depends on NETFILTER_XT_MATCH_OWNER=n
> 	help
> 	  This option replaces the `owner' match. In addition to matching
> 	  on uid, it keeps stats based on a tag assigned to a socket.
> 	  The full tag is comprised of a UID and an accounting tag.
> 	  The tags are assignable to sockets from user space (e.g. a download
> 	  manager can assign the socket to another UID for accounting).
> 	  Stats and control are done via /proc/net/xt_qtaguid/.
> 	  It replaces owner as it takes the same arguments, but should
> 	  really be recognized by the iptables tool.
> 
> 	  If unsure, say `N'.
> 
946a965,988
> 
> config NETFILTER_XT_MATCH_QUOTA2
> 	tristate '"quota2" match support'
> 	depends on NETFILTER_ADVANCED
> 	help
> 	  This option adds a `quota2' match, which allows to match on a
> 	  byte counter correctly and not per CPU.
> 	  It allows naming the quotas.
> 	  This is based on http://xtables-addons.git.sourceforge.net
> 
> 	  If you want to compile it as a module, say M here and read
> 	  <file:Documentation/kbuild/modules.txt>.  If unsure, say `N'.
> 
> config NETFILTER_XT_MATCH_QUOTA2_LOG
> 	bool '"quota2" Netfilter LOG support'
> 	depends on NETFILTER_XT_MATCH_QUOTA2
> 	depends on IP_NF_TARGET_ULOG=n    # not yes, not module, just no
> 	default n
> 	help
> 	  This option allows `quota2' to log ONCE when a quota limit
> 	  is passed. It logs via NETLINK using the NETLINK_NFLOG family.
> 	  It logs similarly to how ipt_ULOG would without data.
> 
> 	  If unsure, say `N'.




diff -r linux-3.0.36/net/netfilter/Makefile linux-3.0.36-lenovo/net/netfilter/Makefile
97a98
> obj-$(CONFIG_NETFILTER_XT_MATCH_QTAGUID) += xt_qtaguid_print.o xt_qtaguid.o
98a100
> obj-$(CONFIG_NETFILTER_XT_MATCH_QUOTA2) += xt_quota2.o




diff -r linux-3.0.36/net/netfilter/nf_conntrack_core.c linux-3.0.36-lenovo/net/netfilter/nf_conntrack_core.c
249a250,252
> 	struct nf_conntrack_ecache *ecache = nf_ct_ecache_find(ct);
> 
> 	BUG_ON(ecache == NULL);
253c256
< 		ct->timeout.expires = jiffies +
---
> 		ecache->timeout.expires = jiffies +
255c258
< 		add_timer(&ct->timeout);
---
> 		add_timer(&ecache->timeout);
268a272,274
> 	struct nf_conntrack_ecache *ecache = nf_ct_ecache_find(ct);
> 
> 	BUG_ON(ecache == NULL);
276,277c282,283
< 	setup_timer(&ct->timeout, death_by_event, (unsigned long)ct);
< 	ct->timeout.expires = jiffies +
---
> 	setup_timer(&ecache->timeout, death_by_event, (unsigned long)ct);
> 	ecache->timeout.expires = jiffies +
279c285
< 	add_timer(&ct->timeout);
---
> 	add_timer(&ecache->timeout);




diff -r linux-3.0.36/net/netfilter/nf_conntrack_expect.c linux-3.0.36-lenovo/net/netfilter/nf_conntrack_expect.c
367,383d366
< static inline int refresh_timer(struct nf_conntrack_expect *i)
< {
< 	struct nf_conn_help *master_help = nfct_help(i->master);
< 	const struct nf_conntrack_expect_policy *p;
< 
< 	if (!del_timer(&i->timeout))
< 		return 0;
< 
< 	p = &rcu_dereference_protected(
< 		master_help->helper,
< 		lockdep_is_held(&nf_conntrack_lock)
< 		)->expect_policy[i->class];
< 	i->timeout.expires = jiffies + p->timeout * HZ;
< 	add_timer(&i->timeout);
< 	return 1;
< }
< 
391c374
< 	struct hlist_node *n;
---
> 	struct hlist_node *n, *next;
402c385
< 	hlist_for_each_entry(i, n, &net->ct.expect_hash[h], hnode) {
---
> 	hlist_for_each_entry_safe(i, n, next, &net->ct.expect_hash[h], hnode) {
404,407c387,390
< 			/* Refresh timer: if it's dying, ignore.. */
< 			if (refresh_timer(i)) {
< 				ret = 0;
< 				goto out;
---
> 			if (del_timer(&i->timeout)) {
> 				nf_ct_unlink_expect(i);
> 				nf_ct_expect_put(i);
> 				break;




diff -r linux-3.0.36/net/netfilter/nf_conntrack_netlink.c linux-3.0.36-lenovo/net/netfilter/nf_conntrack_netlink.c
973c973
< 					  ctnetlink_done);
---
> 					  ctnetlink_done, 0);
1843c1843
< 					  ctnetlink_exp_done);
---
> 					  ctnetlink_exp_done, 0);




diff -r linux-3.0.36/net/netfilter/nf_conntrack_proto_tcp.c linux-3.0.36-lenovo/net/netfilter/nf_conntrack_proto_tcp.c
162c162
< /*synack*/ { sIV, sIV, sIG, sIG, sIG, sIG, sIG, sIG, sIG, sSR },
---
> /*synack*/ { sIV, sIV, sSR, sIV, sIV, sIV, sIV, sIV, sIV, sSR },
167,176c167,173
<  *	sSR -> sIG
<  *	sES -> sIG	Error: SYNs in window outside the SYN_SENT state
<  *			are errors. Receiver will reply with RST
<  *			and close the connection.
<  *			Or we are not in sync and hold a dead connection.
<  *	sFW -> sIG
<  *	sCW -> sIG
<  *	sLA -> sIG
<  *	sTW -> sIG
<  *	sCL -> sIG
---
>  *	sSR -> sSR	Late retransmitted SYN/ACK in simultaneous open
>  *	sES -> sIV	Invalid SYN/ACK packets sent by the client
>  *	sFW -> sIV
>  *	sCW -> sIV
>  *	sLA -> sIV
>  *	sTW -> sIV
>  *	sCL -> sIV
631,633c628
< 	if (seq == end
< 	    && (!tcph->rst
< 		|| (seq == 0 && state->state == TCP_CONNTRACK_SYN_SENT)))
---
> 	if (tcph->rst && seq == 0 && state->state == TCP_CONNTRACK_SYN_SENT)
635,639c630
< 		 * Packets contains no data: we assume it is valid
< 		 * and check the ack value only.
< 		 * However RST segments are always validated by their
< 		 * SEQ number, except when seq == 0 (reset sent answering
< 		 * SYN.
---
> 		 * RST sent answering SYN.




diff -r linux-3.0.36/net/netfilter/xt_hashlimit.c linux-3.0.36-lenovo/net/netfilter/xt_hashlimit.c
395,396c395
< static inline u_int32_t
< user2credits(u_int32_t user)
---
> static u32 user2credits(u32 user)
406c405
< static inline void rateinfo_recalc(struct dsthash_ent *dh, unsigned long now)
---
> static void rateinfo_recalc(struct dsthash_ent *dh, unsigned long now)
537,538c536
< 		dh->rateinfo.credit_cap = user2credits(hinfo->cfg.avg *
< 		                          hinfo->cfg.burst);
---
> 		dh->rateinfo.credit_cap = dh->rateinfo.credit;




diff -r linux-3.0.36/net/netfilter/xt_IDLETIMER.c linux-3.0.36-lenovo/net/netfilter/xt_IDLETIMER.c
7a8
>  *
40a42
> #include <linux/skbuff.h>
42a45
> #include <net/net_namespace.h>
58a62,63
> 	bool send_nl_msg;
> 	bool active;
65a71,96
> static void notify_netlink_uevent(const char *label, struct idletimer_tg *timer)
> {
> 	char label_msg[NLMSG_MAX_SIZE];
> 	char state_msg[NLMSG_MAX_SIZE];
> 	char *envp[] = { label_msg, state_msg, NULL };
> 	int res;
> 
> 	res = snprintf(label_msg, NLMSG_MAX_SIZE, "LABEL=%s",
> 		       label);
> 	if (NLMSG_MAX_SIZE <= res) {
> 		pr_err("message too long (%d)", res);
> 		return;
> 	}
> 	res = snprintf(state_msg, NLMSG_MAX_SIZE, "STATE=%s",
> 		       timer->active ? "active" : "inactive");
> 	if (NLMSG_MAX_SIZE <= res) {
> 		pr_err("message too long (%d)", res);
> 		return;
> 	}
> 	pr_debug("putting nlmsg: <%s> <%s>\n", label_msg, state_msg);
> 	kobject_uevent_env(idletimer_tg_kobj, KOBJ_CHANGE, envp);
> 	return;
> 
> 
> }
> 
85a117
> 	unsigned long now = jiffies;
95c127
< 	if (time_after(expires, jiffies))
---
> 	if (time_after(expires, now))
97c129
< 			       jiffies_to_msecs(expires - jiffies) / 1000);
---
> 			       jiffies_to_msecs(expires - now) / 1000);
99c131,135
< 	return sprintf(buf, "0\n");
---
> 	if (timer->send_nl_msg)
> 		return sprintf(buf, "0 %d\n",
> 			jiffies_to_msecs(now - expires) / 1000);
> 	else
> 		return sprintf(buf, "0\n");
107a144,146
> 
> 	if (timer->send_nl_msg)
> 		notify_netlink_uevent(timer->attr.attr.name, timer);
115a155
> 	timer->active = false;
149a190,191
> 	info->timer->send_nl_msg = (info->send_nl_msg == 0) ? false : true;
> 	info->timer->active = true;
172a215
> 	unsigned long now = jiffies;
178a222,230
> 	info->timer->active = true;
> 
> 	if (time_before(info->timer->timer.expires, now)) {
> 		schedule_work(&info->timer->work);
> 		pr_debug("Starting timer %s (Expired, Jiffies): %lu, %lu\n",
> 			 info->label, info->timer->timer.expires, now);
> 	}
> 
> 	/* TODO: Avoid modifying timers on each packet */
180c232
< 		  msecs_to_jiffies(info->timeout * 1000) + jiffies);
---
> 		  msecs_to_jiffies(info->timeout * 1000) + now);
188a241
> 	unsigned long now = jiffies;
190c243
< 	pr_debug("checkentry targinfo%s\n", info->label);
---
> 	pr_debug("checkentry targinfo %s\n", info->label);
208a262,270
> 		info->timer->active = true;
> 
> 		if (time_before(info->timer->timer.expires, now)) {
> 			schedule_work(&info->timer->work);
> 			pr_debug("Starting Checkentry timer"
> 				"(Expired, Jiffies): %lu, %lu\n",
> 				info->timer->timer.expires, now);
> 		}
> 
210c272
< 			  msecs_to_jiffies(info->timeout * 1000) + jiffies);
---
> 			  msecs_to_jiffies(info->timeout * 1000) + now);
223a286
> 
245c308
< 			 info->label, info->timer->refcnt);
---
> 		info->label, info->timer->refcnt);
252a316
> 	.revision	= 1,
317a382
> MODULE_ALIAS("arpt_IDLETIMER");




diff -r linux-3.0.36/net/netfilter/xt_limit.c linux-3.0.36-lenovo/net/netfilter/xt_limit.c
91,92c91
< static u_int32_t
< user2credits(u_int32_t user)
---
> static u32 user2credits(u32 user)
120a120,123
> 	/* User avg in seconds * XT_LIMIT_SCALE: convert to jiffies *
> 	   128. */
> 	priv->prev = jiffies;
> 	priv->credit = user2credits(r->avg * r->burst); /* Credits full. */
122,126c125
< 		/* User avg in seconds * XT_LIMIT_SCALE: convert to jiffies *
< 		   128. */
< 		priv->prev = jiffies;
< 		priv->credit = user2credits(r->avg * r->burst); /* Credits full. */
< 		r->credit_cap = user2credits(r->avg * r->burst); /* Credits full. */
---
> 		r->credit_cap = priv->credit; /* Credits full. */
Only in linux-3.0.36-lenovo/net/netfilter: xt_qtaguid.c
Only in linux-3.0.36-lenovo/net/netfilter: xt_qtaguid_internal.h
Only in linux-3.0.36-lenovo/net/netfilter: xt_qtaguid_print.c
Only in linux-3.0.36-lenovo/net/netfilter: xt_qtaguid_print.h
Only in linux-3.0.36-lenovo/net/netfilter: xt_quota2.c




diff -r linux-3.0.36/net/netfilter/xt_socket.c linux-3.0.36-lenovo/net/netfilter/xt_socket.c
38c38
< static void
---
> void
45a46
> EXPORT_SYMBOL(xt_socket_put_sk);
104,106c105,106
< static bool
< socket_match(const struct sk_buff *skb, struct xt_action_param *par,
< 	     const struct xt_socket_mtinfo1 *info)
---
> struct sock*
> xt_socket_get4_sk(const struct sk_buff *skb, struct xt_action_param *par)
123c123
< 			return false;
---
> 			return NULL;
134c134
< 			return false;
---
> 			return NULL;
136c136
< 		return false;
---
> 		return NULL;
159a160,176
> 
> 	pr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",
> 		 protocol, &saddr, ntohs(sport),
> 		 &daddr, ntohs(dport),
> 		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
> 
> 	return sk;
> }
> EXPORT_SYMBOL(xt_socket_get4_sk);
> 
> static bool
> socket_match(const struct sk_buff *skb, struct xt_action_param *par,
> 	     const struct xt_socket_mtinfo1 *info)
> {
> 	struct sock *sk;
> 
> 	sk = xt_socket_get4_sk(skb, par);
182,186d198
< 	pr_debug("proto %hhu %pI4:%hu -> %pI4:%hu (orig %pI4:%hu) sock %p\n",
< 		 protocol, &saddr, ntohs(sport),
< 		 &daddr, ntohs(dport),
< 		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
< 
256,257c268,269
< static bool
< socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
---
> struct sock*
> xt_socket_get6_sk(const struct sk_buff *skb, struct xt_action_param *par)
265d276
< 	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par->matchinfo;
277c288
< 			return false;
---
> 			return NULL;
287c298
< 			return false;
---
> 			return NULL;
289c300
< 		return false;
---
> 		return NULL;
293a305,321
> 	pr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "
> 		 "(orig %pI6:%hu) sock %p\n",
> 		 tproto, saddr, ntohs(sport),
> 		 daddr, ntohs(dport),
> 		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);
> 	return sk;
> }
> EXPORT_SYMBOL(xt_socket_get6_sk);
> 
> static bool
> socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
> {
> 	struct sock *sk;
> 	const struct xt_socket_mtinfo1 *info;
> 
> 	info = (struct xt_socket_mtinfo1 *) par->matchinfo;
> 	sk = xt_socket_get6_sk(skb, par);
315,320d342
< 
< 	pr_debug("proto %hhd %pI6:%hu -> %pI6:%hu "
< 		 "(orig %pI6:%hu) sock %p\n",
< 		 tproto, saddr, ntohs(sport),
< 		 daddr, ntohs(dport),
< 		 &iph->daddr, hp ? ntohs(hp->dest) : 0, sk);




diff -r linux-3.0.36/net/netlink/af_netlink.c linux-3.0.36-lenovo/net/netlink/af_netlink.c
139a140,141
> #define nl_deref_protected(X) rcu_dereference_protected(X, lockdep_is_held(&nl_table_lock));
> 
333a336,340
> 	struct listeners *listeners;
> 
> 	listeners = nl_deref_protected(tbl->listeners);
> 	if (!listeners)
> 		return;
341c348
< 		tbl->listeners->masks[i] = mask;
---
> 		listeners->masks[i] = mask;
522c529,533
< 			kfree(nl_table[sk->sk_protocol].listeners);
---
> 			struct listeners *old;
> 
> 			old = nl_deref_protected(nl_table[sk->sk_protocol].listeners);
> 			RCU_INIT_POINTER(nl_table[sk->sk_protocol].listeners, NULL);
> 			kfree_rcu(old, rcu);
953c964
< 	if (group - 1 < nl_table[sk->sk_protocol].groups)
---
> 	if (listeners && group - 1 < nl_table[sk->sk_protocol].groups)
1348c1359,1360
< 		if (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))
---
> 		if ((dst_group || dst_pid) &&
> 		    !netlink_capable(sock, NL_NONROOT_SEND))
1587c1599
< 		old = rcu_dereference_raw(tbl->listeners);
---
> 		old = nl_deref_protected(tbl->listeners);
1668c1680
< 	struct sk_buff *skb;
---
> 	struct sk_buff *skb = NULL;
1671,1674c1683
< 
< 	skb = sock_rmalloc(sk, NLMSG_GOODSIZE, 0, GFP_KERNEL);
< 	if (!skb)
< 		goto errout;
---
> 	int alloc_size;
1683a1693,1698
> 	alloc_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);
> 
> 	skb = sock_rmalloc(sk, alloc_size, 0, GFP_KERNEL);
> 	if (!skb)
> 		goto errout;
> 
1726c1741,1742
< 		       int (*done)(struct netlink_callback *))
---
> 		       int (*done)(struct netlink_callback *),
> 		       u16 min_dump_alloc)
1739a1756
> 	cb->min_dump_alloc = min_dump_alloc;
2100a2118
> 	nl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;




diff -r linux-3.0.36/net/netlink/genetlink.c linux-3.0.36-lenovo/net/netlink/genetlink.c
528c528
< 					 ops->dumpit, ops->done);
---
> 					 ops->dumpit, ops->done, 0);




diff -r linux-3.0.36/net/netrom/af_netrom.c linux-3.0.36-lenovo/net/netrom/af_netrom.c
1173c1173,1178
< 	skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
---
> 	er = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);
> 	if (er < 0) {
> 		skb_free_datagram(sk, skb);
> 		release_sock(sk);
> 		return er;
> 	}




diff -r linux-3.0.36/net/packet/af_packet.c linux-3.0.36-lenovo/net/packet/af_packet.c
869d868
< 		BUG_ON(__packet_get_status(po, ph) != TP_STATUS_SENDING);
1353,1355c1352,1353
< 	memset(&req, 0, sizeof(req));
< 
< 	if (po->rx_ring.pg_vec)
---
> 	if (po->rx_ring.pg_vec) {
> 		memset(&req, 0, sizeof(req));
1356a1355
> 	}
1358c1357,1358
< 	if (po->tx_ring.pg_vec)
---
> 	if (po->tx_ring.pg_vec) {
> 		memset(&req, 0, sizeof(req));
1359a1360
> 	}




diff -r linux-3.0.36/net/phonet/pn_netlink.c linux-3.0.36-lenovo/net/phonet/pn_netlink.c
292c292,293
< 	int err = __rtnl_register(PF_PHONET, RTM_NEWADDR, addr_doit, NULL);
---
> 	int err = __rtnl_register(PF_PHONET, RTM_NEWADDR, addr_doit,
> 				  NULL, NULL);
297,301c298,302
< 	__rtnl_register(PF_PHONET, RTM_DELADDR, addr_doit, NULL);
< 	__rtnl_register(PF_PHONET, RTM_GETADDR, NULL, getaddr_dumpit);
< 	__rtnl_register(PF_PHONET, RTM_NEWROUTE, route_doit, NULL);
< 	__rtnl_register(PF_PHONET, RTM_DELROUTE, route_doit, NULL);
< 	__rtnl_register(PF_PHONET, RTM_GETROUTE, NULL, route_dumpit);
---
> 	__rtnl_register(PF_PHONET, RTM_DELADDR, addr_doit, NULL, NULL);
> 	__rtnl_register(PF_PHONET, RTM_GETADDR, NULL, getaddr_dumpit, NULL);
> 	__rtnl_register(PF_PHONET, RTM_NEWROUTE, route_doit, NULL, NULL);
> 	__rtnl_register(PF_PHONET, RTM_DELROUTE, route_doit, NULL, NULL);
> 	__rtnl_register(PF_PHONET, RTM_GETROUTE, NULL, route_dumpit, NULL);




diff -r linux-3.0.36/net/rds/recv.c linux-3.0.36-lenovo/net/rds/recv.c
411a412,413
> 	msg->msg_namelen = 0;
> 
486a489
> 			msg->msg_namelen = sizeof(*sin);




diff -r linux-3.0.36/net/rds/send.c linux-3.0.36-lenovo/net/rds/send.c
1124c1124
< 		rds_send_xmit(conn);
---
> 		queue_delayed_work(rds_wq, &conn->c_send_w, 0);




diff -r linux-3.0.36/net/rfkill/core.c linux-3.0.36-lenovo/net/rfkill/core.c
771a772
> #ifdef CONFIG_RFKILL_PM
805a807
> #endif
811a814
> #ifdef CONFIG_RFKILL_PM
813a817
> #endif




diff -r linux-3.0.36/net/rfkill/Kconfig linux-3.0.36-lenovo/net/rfkill/Kconfig
12a13,17
> config RFKILL_PM
> 	bool "Power off on suspend"
> 	depends on RFKILL && PM
> 	default y
> 
44a50,61
> 
> config RFKILL_RESET
>         bool "Reset bluetooth on resume"
>         depends on RFKILL && PM
>         default n
> 
> config RFKILL_RK
>         bool "Rockchips RFKILL driver"
>         depends on RFKILL
>         help
>           rockchips rfkill driver for rk29/rk30
> 




diff -r linux-3.0.36/net/rfkill/Makefile linux-3.0.36-lenovo/net/rfkill/Makefile
9a10
> obj-$(CONFIG_RFKILL_RK)		+= rfkill-rk.o
Only in linux-3.0.36-lenovo/net/rfkill: rfkill-rk.c




diff -r linux-3.0.36/net/sched/act_api.c linux-3.0.36-lenovo/net/sched/act_api.c
1118,1120c1118,1121
< 	rtnl_register(PF_UNSPEC, RTM_NEWACTION, tc_ctl_action, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELACTION, tc_ctl_action, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_GETACTION, tc_ctl_action, tc_dump_action);
---
> 	rtnl_register(PF_UNSPEC, RTM_NEWACTION, tc_ctl_action, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELACTION, tc_ctl_action, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETACTION, tc_ctl_action, tc_dump_action,
> 		      NULL);




diff -r linux-3.0.36/net/sched/act_gact.c linux-3.0.36-lenovo/net/sched/act_gact.c
69a70,72
> #ifdef CONFIG_GACT_PROB
> 	struct tc_gact_p *p_parm = NULL;
> #endif
84a88,93
> #else
> 	if (tb[TCA_GACT_PROB]) {
> 		p_parm = nla_data(tb[TCA_GACT_PROB]);
> 		if (p_parm->ptype >= MAX_RAND)
> 			return -EINVAL;
> 	}
106,107c115
< 	if (tb[TCA_GACT_PROB] != NULL) {
< 		struct tc_gact_p *p_parm = nla_data(tb[TCA_GACT_PROB]);
---
> 	if (p_parm) {
135c143
< 	if (gact->tcfg_ptype && gact_rand[gact->tcfg_ptype] != NULL)
---
> 	if (gact->tcfg_ptype)




diff -r linux-3.0.36/net/sched/cls_api.c linux-3.0.36-lenovo/net/sched/cls_api.c
613,614c613,614
< 	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL);
---
> 	rtnl_register(PF_UNSPEC, RTM_NEWTFILTER, tc_ctl_tfilter, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELTFILTER, tc_ctl_tfilter, NULL, NULL);
616c616
< 						 tc_dump_tfilter);
---
> 		      tc_dump_tfilter, NULL);




diff -r linux-3.0.36/net/sched/sch_api.c linux-3.0.36-lenovo/net/sched/sch_api.c
1795,1800c1795,1800
< 	rtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_GETQDISC, tc_get_qdisc, tc_dump_qdisc);
< 	rtnl_register(PF_UNSPEC, RTM_NEWTCLASS, tc_ctl_tclass, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_DELTCLASS, tc_ctl_tclass, NULL);
< 	rtnl_register(PF_UNSPEC, RTM_GETTCLASS, tc_ctl_tclass, tc_dump_tclass);
---
> 	rtnl_register(PF_UNSPEC, RTM_NEWQDISC, tc_modify_qdisc, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELQDISC, tc_get_qdisc, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETQDISC, tc_get_qdisc, tc_dump_qdisc, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_NEWTCLASS, tc_ctl_tclass, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_DELTCLASS, tc_ctl_tclass, NULL, NULL);
> 	rtnl_register(PF_UNSPEC, RTM_GETTCLASS, tc_ctl_tclass, tc_dump_tclass, NULL);




diff -r linux-3.0.36/net/sched/sch_cbq.c linux-3.0.36-lenovo/net/sched/sch_cbq.c
253c253
< 			if (cl == NULL || cl->level >= head->level)
---
> 			if (cl == NULL)
256c256,257
< 
---
> 		if (cl->level >= head->level)
> 			goto fallback;




diff -r linux-3.0.36/net/sched/sch_htb.c linux-3.0.36-lenovo/net/sched/sch_htb.c
879c879
< 	next_event = q->now + 5 * PSCHED_TICKS_PER_SEC;
---
> 	next_event = q->now + 5LLU * PSCHED_TICKS_PER_SEC;




diff -r linux-3.0.36/net/sched/sch_qfq.c linux-3.0.36-lenovo/net/sched/sch_qfq.c
832c832,835
< 				cl->S = next->F;
---
> 				if (qfq_gt(limit, next->F))
> 					cl->S = next->F;
> 				else /* preserve timestamp correctness */
> 					cl->S = limit;




diff -r linux-3.0.36/net/sched/sch_sfb.c linux-3.0.36-lenovo/net/sched/sch_sfb.c
558a559,560
> 	if (opts == NULL)
> 		goto nla_put_failure;




diff -r linux-3.0.36/net/sctp/chunk.c linux-3.0.36-lenovo/net/sctp/chunk.c
186c186
< 		return NULL;
---
> 		return ERR_PTR(-ENOMEM);
283c283,284
< 		if (!chunk)
---
> 		if (!chunk) {
> 			err = -ENOMEM;
284a286,287
> 		}
> 
287c290
< 			goto errout;
---
> 			goto errout_chunk_free;
318c321,322
< 		if (!chunk)
---
> 		if (!chunk) {
> 			err = -ENOMEM;
319a324
> 		}
327c332
< 			goto errout;
---
> 			goto errout_chunk_free;
334a340,342
> errout_chunk_free:
> 	sctp_chunk_free(chunk);
> 
342c350
< 	return NULL;
---
> 	return ERR_PTR(err);




diff -r linux-3.0.36/net/sctp/endpointola.c linux-3.0.36-lenovo/net/sctp/endpointola.c
250a251,252
> 	int i;
> 
271a274,276
> 
> 	for (i = 0; i < SCTP_HOW_MANY_SECRETS; ++i)
> 		memset(&ep->secret_key[i], 0, SCTP_SECRET_SIZE);




diff -r linux-3.0.36/net/sctp/input.c linux-3.0.36-lenovo/net/sctp/input.c
740,742d739
< 	if (hlist_unhashed(&epb->node))
< 		return;
< 
748c745
< 	__hlist_del(&epb->node);
---
> 	hlist_del_init(&epb->node);
829c826
< 	__hlist_del(&epb->node);
---
> 	hlist_del_init(&epb->node);




diff -r linux-3.0.36/net/sctp/output.c linux-3.0.36-lenovo/net/sctp/output.c
336a337,355
> static void sctp_packet_release_owner(struct sk_buff *skb)
> {
> 	sk_free(skb->sk);
> }
> 
> static void sctp_packet_set_owner_w(struct sk_buff *skb, struct sock *sk)
> {
> 	skb_orphan(skb);
> 	skb->sk = sk;
> 	skb->destructor = sctp_packet_release_owner;
> 
> 	/*
> 	 * The data chunks have already been accounted for in sctp_sendmsg(),
> 	 * therefore only reserve a single byte to keep socket around until
> 	 * the packet has been transmitted.
> 	 */
> 	atomic_inc(&sk->sk_wmem_alloc);
> }
> 
378c397
< 	skb_set_owner_w(nskb, sk);
---
> 	sctp_packet_set_owner_w(nskb, sk);




diff -r linux-3.0.36/net/sctp/outqueue.c linux-3.0.36-lenovo/net/sctp/outqueue.c
226c226
< void sctp_outq_teardown(struct sctp_outq *q)
---
> static void __sctp_outq_teardown(struct sctp_outq *q)
279,280d278
< 	q->error = 0;
< 
287a286,291
> void sctp_outq_teardown(struct sctp_outq *q)
> {
> 	__sctp_outq_teardown(q);
> 	sctp_outq_init(q->asoc, q);
> }
> 
292c296
< 	sctp_outq_teardown(q);
---
> 	__sctp_outq_teardown(q);




diff -r linux-3.0.36/net/sctp/sm_sideeffect.c linux-3.0.36-lenovo/net/sctp/sm_sideeffect.c
1606a1607
> 			chunk->subh.sack_hdr = &sackh;
1608c1609
< 					SCTP_SACKH(&sackh));
---
> 					SCTP_CHUNK(chunk));




diff -r linux-3.0.36/net/sctp/socket.c linux-3.0.36-lenovo/net/sctp/socket.c
1163c1163,1168
< 	if (asoc)
---
> 	if (asoc) {
> 		/* sctp_primitive_ASSOCIATE may have added this association
> 		 * To the hash table, try to unhash it, just in case, its a noop
> 		 * if it wasn't hashed so we're safe
> 		 */
> 		sctp_unhash_established(asoc);
1164a1170
> 	}
1834,1835c1840,1841
< 	if (!datamsg) {
< 		err = -ENOMEM;
---
> 	if (IS_ERR(datamsg)) {
> 		err = PTR_ERR(datamsg);
1874c1880,1881
< 	if (new_asoc)
---
> 	if (new_asoc) {
> 		sctp_unhash_established(asoc);
1875a1883
> 	}
3299c3307
< 	kfree(authkey);
---
> 	kzfree(authkey);




diff -r linux-3.0.36/net/socket.c linux-3.0.36-lenovo/net/socket.c
2647a2648
> 	memset(&ifc, 0, sizeof(ifc));




diff -r linux-3.0.36/net/sunrpc/cache.c linux-3.0.36-lenovo/net/sunrpc/cache.c
1407c1407
< 	char tbuf[20];
---
> 	char tbuf[22];
1411c1411
< 	sprintf(tbuf, "%lu\n", convert_to_wallclock(cd->flush_time));
---
> 	snprintf(tbuf, sizeof(tbuf), "%lu\n", convert_to_wallclock(cd->flush_time));




diff -r linux-3.0.36/net/sunrpc/rpcb_clnt.c linux-3.0.36-lenovo/net/sunrpc/rpcb_clnt.c
196c196
< 		result = -PTR_ERR(clnt);
---
> 		result = PTR_ERR(clnt);
245c245
< 		result = -PTR_ERR(clnt);
---
> 		result = PTR_ERR(clnt);




diff -r linux-3.0.36/net/sunrpc/sched.c linux-3.0.36-lenovo/net/sunrpc/sched.c
715a716
> 	current->flags |= PF_FSTRANS;
716a718
> 	current->flags &= ~PF_FSTRANS;
844a847,865
> /*
>  * rpc_free_task - release rpc task and perform cleanups
>  *
>  * Note that we free up the rpc_task _after_ rpc_release_calldata()
>  * in order to work around a workqueue dependency issue.
>  *
>  * Tejun Heo states:
>  * "Workqueue currently considers two work items to be the same if they're
>  * on the same address and won't execute them concurrently - ie. it
>  * makes a work item which is queued again while being executed wait
>  * for the previous execution to complete.
>  *
>  * If a work function frees the work item, and then waits for an event
>  * which should be performed by another work item and *that* work item
>  * recycles the freed work item, it can create a false dependency loop.
>  * There really is no reliable way to detect this short of verifying
>  * every memory free."
>  *
>  */
847,848c868,870
< 	const struct rpc_call_ops *tk_ops = task->tk_ops;
< 	void *calldata = task->tk_calldata;
---
> 	unsigned short tk_flags = task->tk_flags;
> 
> 	rpc_release_calldata(task->tk_ops, task->tk_calldata);
850c872
< 	if (task->tk_flags & RPC_TASK_DYNAMIC) {
---
> 	if (tk_flags & RPC_TASK_DYNAMIC) {
854d875
< 	rpc_release_calldata(tk_ops, calldata);




diff -r linux-3.0.36/net/sunrpc/svcsock.c linux-3.0.36-lenovo/net/sunrpc/svcsock.c
1124a1125
> 		svc_tcp_save_pages(svsk, rqstp);
1127d1127
< 		svc_tcp_save_pages(svsk, rqstp);




diff -r linux-3.0.36/net/sunrpc/svc_xprt.c linux-3.0.36-lenovo/net/sunrpc/svc_xprt.c
326d325
< 	struct svc_serv	*serv = xprt->xpt_server;
372,373d370
< 		rqstp->rq_reserved = serv->sv_max_mesg;
< 		atomic_add(rqstp->rq_reserved, &xprt->xpt_reserved);
653,654d649
< 		rqstp->rq_reserved = serv->sv_max_mesg;
< 		atomic_add(rqstp->rq_reserved, &xprt->xpt_reserved);
750a746,747
> 		rqstp->rq_reserved = serv->sv_max_mesg;
> 		atomic_add(rqstp->rq_reserved, &xprt->xpt_reserved);
807c804,805
< 	if (test_bit(XPT_DEAD, &xprt->xpt_flags))
---
> 	if (test_bit(XPT_DEAD, &xprt->xpt_flags)
> 			|| test_bit(XPT_CLOSE, &xprt->xpt_flags))




diff -r linux-3.0.36/net/sunrpc/xprtrdma/transport.c linux-3.0.36-lenovo/net/sunrpc/xprtrdma/transport.c
202a203
> 		current->flags |= PF_FSTRANS;
215d215
< 
218a219
> 	current->flags &= ~PF_FSTRANS;




diff -r linux-3.0.36/net/sunrpc/xprtsock.c linux-3.0.36-lenovo/net/sunrpc/xprtsock.c
246d245
< 	void			(*old_error_report)(struct sock *);
729d727
< 	case -EPIPE:
732a731
> 	case -EPIPE:
771d769
< 	transport->old_error_report = sk->sk_error_report;
779d776
< 	sk->sk_error_report = transport->old_error_report;
1017a1015,1024
> /*
>  * Helper function to force a TCP close if the server is sending
>  * junk and/or it has put us in CLOSE_WAIT
>  */
> static void xs_tcp_force_close(struct rpc_xprt *xprt)
> {
> 	set_bit(XPRT_CONNECTION_CLOSE, &xprt->state);
> 	xprt_force_disconnect(xprt);
> }
> 
1044c1051
< 		xprt_force_disconnect(xprt);
---
> 		xs_tcp_force_close(xprt);
1125c1132
< 		xprt_force_disconnect(&transport->xprt);
---
> 		xs_tcp_force_close(&transport->xprt);
1445c1452
< static void xs_sock_mark_closed(struct rpc_xprt *xprt)
---
> static void xs_sock_reset_connection_flags(struct rpc_xprt *xprt)
1447a1455,1456
> 	clear_bit(XPRT_CONNECTION_ABORT, &xprt->state);
> 	clear_bit(XPRT_CONNECTION_CLOSE, &xprt->state);
1450a1460,1464
> }
> 
> static void xs_sock_mark_closed(struct rpc_xprt *xprt)
> {
> 	xs_sock_reset_connection_flags(xprt);
1505d1518
< 		xprt_force_disconnect(xprt);
1506a1520,1521
> 		clear_bit(XPRT_CONNECTED, &xprt->state);
> 		xs_tcp_force_close(xprt);
1530,1548d1544
< /**
<  * xs_error_report - callback mainly for catching socket errors
<  * @sk: socket
<  */
< static void xs_error_report(struct sock *sk)
< {
< 	struct rpc_xprt *xprt;
< 
< 	read_lock_bh(&sk->sk_callback_lock);
< 	if (!(xprt = xprt_from_sock(sk)))
< 		goto out;
< 	dprintk("RPC:       %s client %p...\n"
< 			"RPC:       error %d\n",
< 			__func__, xprt, sk->sk_err);
< 	xprt_wake_pending_tasks(xprt, -EAGAIN);
< out:
< 	read_unlock_bh(&sk->sk_callback_lock);
< }
< 
1848d1843
< 		sk->sk_error_report = xs_error_report;
1884a1880,1881
> 	current->flags |= PF_FSTRANS;
> 
1917a1915
> 	current->flags &= ~PF_FSTRANS;
1934d1931
< 		sk->sk_error_report = xs_error_report;
1959a1957,1958
> 	current->flags |= PF_FSTRANS;
> 
1977a1977
> 	current->flags &= ~PF_FSTRANS;
1999,2002c1999,2000
< 		xs_sock_mark_closed(&transport->xprt);
< 	else
< 		dprintk("RPC:       AF_UNSPEC connect return code %d\n",
< 				result);
---
> 		xs_sock_reset_connection_flags(&transport->xprt);
> 	dprintk("RPC:       AF_UNSPEC connect return code %d\n", result);
2047d2044
< 		sk->sk_error_report = xs_error_report;
2102a2100,2101
> 	current->flags |= PF_FSTRANS;
> 
2141,2142c2140
< 		set_bit(XPRT_CONNECTION_CLOSE, &xprt->state);
< 		xprt_force_disconnect(xprt);
---
> 		xs_tcp_force_close(xprt);
2151a2150
> 		current->flags &= ~PF_FSTRANS;
2163a2163
> 	current->flags &= ~PF_FSTRANS;




diff -r linux-3.0.36/net/wanrouter/wanmain.c linux-3.0.36-lenovo/net/wanrouter/wanmain.c
605,607c605,608
< 		if (dev->name == NULL) {
< 			err = -EINVAL;
< 		} else {
---
> #ifdef WANDEBUG
> 		printk(KERN_INFO "%s: registering interface %s...\n",
> 		       wanrouter_modname, dev->name);
> #endif
609,612c610,613
< 			#ifdef WANDEBUG
< 			printk(KERN_INFO "%s: registering interface %s...\n",
< 				wanrouter_modname, dev->name);
< 			#endif
---
> 		err = register_netdev(dev);
> 		if (!err) {
> 			struct net_device *slave = NULL;
> 			unsigned long smp_flags=0;
614,617c615
< 			err = register_netdev(dev);
< 			if (!err) {
< 				struct net_device *slave = NULL;
< 				unsigned long smp_flags=0;
---
> 			lock_adapter_irq(&wandev->lock, &smp_flags);
619,633c617,623
< 				lock_adapter_irq(&wandev->lock, &smp_flags);
< 
< 				if (wandev->dev == NULL) {
< 					wandev->dev = dev;
< 				} else {
< 					for (slave=wandev->dev;
< 					     DEV_TO_SLAVE(slave);
< 					     slave = DEV_TO_SLAVE(slave))
< 						DEV_TO_SLAVE(slave) = dev;
< 				}
< 				++wandev->ndev;
< 
< 				unlock_adapter_irq(&wandev->lock, &smp_flags);
< 				err = 0;	/* done !!! */
< 				goto out;
---
> 			if (wandev->dev == NULL) {
> 				wandev->dev = dev;
> 			} else {
> 				for (slave=wandev->dev;
> 				     DEV_TO_SLAVE(slave);
> 				     slave = DEV_TO_SLAVE(slave))
> 					DEV_TO_SLAVE(slave) = dev;
634a625,629
> 			++wandev->ndev;
> 
> 			unlock_adapter_irq(&wandev->lock, &smp_flags);
> 			err = 0;	/* done !!! */
> 			goto out;




diff -r linux-3.0.36/net/wireless/core.c linux-3.0.36-lenovo/net/wireless/core.c
490a491,498
> 	if (WARN_ON((wiphy->wowlan.flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE) &&
> 		    !(wiphy->wowlan.flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)))
> 		return -EINVAL;
> 
> 	if (WARN_ON(wiphy->ap_sme_capa &&
> 		    !(wiphy->flags & WIPHY_FLAG_HAVE_AP_SME)))
> 		return -EINVAL;
> 
547,548c555
< 			sband->channels[i].orig_mag =
< 				sband->channels[i].max_antenna_gain;
---
> 			sband->channels[i].orig_mag = INT_MAX;
961a969,973
> 		/*
> 		 * Ensure that all events have been processed and
> 		 * freed.
> 		 */
> 		cfg80211_process_wdev_events(wdev);




diff -r linux-3.0.36/net/wireless/core.h linux-3.0.36-lenovo/net/wireless/core.h
56a57,58
> 	u32 ap_beacons_nlpid;
> 
428a431
> void cfg80211_process_wdev_events(struct wireless_dev *wdev);




diff -r linux-3.0.36/net/wireless/Kconfig linux-3.0.36-lenovo/net/wireless/Kconfig
34c34
< 	depends on CFG80211
---
> 	depends on CFG80211 && (MT5931 || MT5931_MT6622 || MTK_COMBO)
161a162,172
> 
> config CFG80211_ALLOW_RECONNECT
> 	bool "Allow reconnect while already connected"
> 	depends on CFG80211
> 	default n
> 	help
> 	  cfg80211 stack doesn't allow to connect if you are already
> 	  connected. This option allows to make a connection in this case.
> 
> 	  Select this option ONLY for wlan drivers that are specifically
> 	  built for such purposes.




diff -r linux-3.0.36/net/wireless/mlme.c linux-3.0.36-lenovo/net/wireless/mlme.c
879a880,882
> 
> 	if (nlpid == wdev->ap_unexpected_nlpid)
> 		wdev->ap_unexpected_nlpid = 0;
1084a1088,1122
> 
> void cfg80211_gtk_rekey_notify(struct net_device *dev, const u8 *bssid,
> 			       const u8 *replay_ctr, gfp_t gfp)
> {
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct wiphy *wiphy = wdev->wiphy;
> 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
> 
> 	nl80211_gtk_rekey_notify(rdev, dev, bssid, replay_ctr, gfp);
> }
> EXPORT_SYMBOL(cfg80211_gtk_rekey_notify);
> 
> void cfg80211_pmksa_candidate_notify(struct net_device *dev, int index,
> 				     const u8 *bssid, bool preauth, gfp_t gfp)
> {
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct wiphy *wiphy = wdev->wiphy;
> 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
> 
> 	nl80211_pmksa_candidate_notify(rdev, dev, index, bssid, preauth, gfp);
> }
> EXPORT_SYMBOL(cfg80211_pmksa_candidate_notify);
> 
> bool cfg80211_rx_spurious_frame(struct net_device *dev,
> 				const u8 *addr, gfp_t gfp)
> {
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 
> 	if (WARN_ON(wdev->iftype != NL80211_IFTYPE_AP &&
> 		    wdev->iftype != NL80211_IFTYPE_P2P_GO))
> 		return false;
> 
> 	return nl80211_unexpected_frame(dev, addr, gfp);
> }
> EXPORT_SYMBOL(cfg80211_rx_spurious_frame);




diff -r linux-3.0.36/net/wireless/nl80211.c linux-3.0.36-lenovo/net/wireless/nl80211.c
177a178,192
> 	[NL80211_ATTR_REKEY_DATA] = { .type = NLA_NESTED },
> 	[NL80211_ATTR_SCAN_SUPP_RATES] = { .type = NLA_NESTED },
> 	[NL80211_ATTR_HIDDEN_SSID] = { .type = NLA_U32 },
> 	[NL80211_ATTR_IE_PROBE_RESP] = { .type = NLA_BINARY,
> 					 .len = IEEE80211_MAX_DATA_LEN },
> 	[NL80211_ATTR_IE_ASSOC_RESP] = { .type = NLA_BINARY,
> 					 .len = IEEE80211_MAX_DATA_LEN },
> 	[NL80211_ATTR_ROAM_SUPPORT] = { .type = NLA_FLAG },
> 	[NL80211_ATTR_SCHED_SCAN_MATCH] = { .type = NLA_NESTED },
> 	[NL80211_ATTR_TX_NO_CCK_RATE] = { .type = NLA_FLAG },
> 	[NL80211_ATTR_TDLS_ACTION] = { .type = NLA_U8 },
> 	[NL80211_ATTR_TDLS_DIALOG_TOKEN] = { .type = NLA_U8 },
> 	[NL80211_ATTR_TDLS_OPERATION] = { .type = NLA_U8 },
> 	[NL80211_ATTR_TDLS_SUPPORT] = { .type = NLA_FLAG },
> 	[NL80211_ATTR_TDLS_EXTERNAL_SETUP] = { .type = NLA_FLAG },
205a221,238
> 	[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE] = { .type = NLA_FLAG },
> 	[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST] = { .type = NLA_FLAG },
> 	[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE] = { .type = NLA_FLAG },
> 	[NL80211_WOWLAN_TRIG_RFKILL_RELEASE] = { .type = NLA_FLAG },
> };
> 
> static const struct nla_policy
> nl80211_match_policy[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1] = {
> 	[NL80211_ATTR_SCHED_SCAN_MATCH_SSID] = { .type = NLA_BINARY,
> 						 .len = IEEE80211_MAX_SSID_LEN },
> };
> 
> /* policy for GTK rekey offload attributes */
> static const struct nla_policy
> nl80211_rekey_policy[NUM_NL80211_REKEY_DATA] = {
> 	[NL80211_REKEY_DATA_KEK] = { .len = NL80211_KEK_LEN },
> 	[NL80211_REKEY_DATA_KCK] = { .len = NL80211_KCK_LEN },
> 	[NL80211_REKEY_DATA_REPLAY_CTR] = { .len = NL80211_REPLAY_CTR_LEN },
684a718,719
> 	NLA_PUT_U8(msg, NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
> 		   dev->wiphy.max_sched_scan_ssids);
686a722,725
> 	NLA_PUT_U16(msg, NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
> 		    dev->wiphy.max_sched_scan_ie_len);
> 	NLA_PUT_U8(msg, NL80211_ATTR_MAX_MATCH_SETS,
> 		   dev->wiphy.max_match_sets);
691a731,738
> 	if (dev->wiphy.flags & WIPHY_FLAG_AP_UAPSD)
> 		NLA_PUT_FLAG(msg, NL80211_ATTR_SUPPORT_AP_UAPSD);
> 	if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_FW_ROAM)
> 		NLA_PUT_FLAG(msg, NL80211_ATTR_ROAM_SUPPORT);
> 	if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS)
> 		NLA_PUT_FLAG(msg, NL80211_ATTR_TDLS_SUPPORT);
> 	if (dev->wiphy.flags & WIPHY_FLAG_TDLS_EXTERNAL_SETUP)
> 		NLA_PUT_FLAG(msg, NL80211_ATTR_TDLS_EXTERNAL_SETUP);
833a881,884
> 	if (dev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) {
> 		CMD(tdls_mgmt, TDLS_MGMT);
> 		CMD(tdls_oper, TDLS_OPER);
> 	}
835a887,891
> 	CMD(probe_client, PROBE_CLIENT);
> 	if (dev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS) {
> 		i++;
> 		NLA_PUT_U32(msg, i, NL80211_CMD_REGISTER_BEACONS);
> 	}
921a978,987
> 		if (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_SUPPORTS_GTK_REKEY)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED);
> 		if (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE);
> 		if (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST);
> 		if (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_4WAY_HANDSHAKE)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE);
> 		if (dev->wiphy.wowlan.flags & WIPHY_WOWLAN_RFKILL_RELEASE)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE);
943a1010,1013
> 	if (dev->wiphy.flags & WIPHY_FLAG_HAVE_AP_SME)
> 		NLA_PUT_U32(msg, NL80211_ATTR_DEVICE_AP_SME,
> 			    dev->wiphy.ap_sme_capa);
> 
2215a2286,2300
> #if defined(CONFIG_MT6620)
>     /*
>     **patch the cfg80211 for support AP mode need STA carry the assoc request ie. 
>     **Added by xbw, Rockchip Inc.
>     */
>     if (sinfo->assoc_req_ies) {
>         NLA_PUT(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,
>                 sinfo->assoc_req_ies);
>     }
> #else
> 	if (sinfo->filled & STATION_INFO_ASSOC_REQ_IES)
> 		NLA_PUT(msg, NL80211_ATTR_IE, sinfo->assoc_req_ies_len,
> 			sinfo->assoc_req_ies);
> #endif
> 
2242a2328
> 		memset(&sinfo, 0, sizeof(sinfo));
3456c3542
< 	int err, tmp, n_ssids = 0, n_channels, i;
---
> 	int err, tmp, n_ssids = 0, n_match_sets = 0, n_channels, i;
3459a3546
> 	struct nlattr *tb[NL80211_SCHED_SCAN_MATCH_ATTR_MAX + 1];
3495c3582,3591
< 	if (n_ssids > wiphy->max_scan_ssids)
---
> 	if (n_ssids > wiphy->max_sched_scan_ssids)
> 		return -EINVAL;
> 
> 	if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH])
> 		nla_for_each_nested(attr,
> 				    info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH],
> 				    tmp)
> 			n_match_sets++;
> 
> 	if (n_match_sets > wiphy->max_match_sets)
3503c3599
< 	if (ie_len > wiphy->max_scan_ie_len)
---
> 	if (ie_len > wiphy->max_sched_scan_ie_len)
3514a3611
> 			+ sizeof(*request->match_sets) * n_match_sets
3531a3629,3640
> 	if (n_match_sets) {
> 		if (request->ie)
> 			request->match_sets = (void *)(request->ie + ie_len);
> 		else if (request->ssids)
> 			request->match_sets =
> 				(void *)(request->ssids + n_ssids);
> 		else
> 			request->match_sets =
> 				(void *)(request->channels + n_channels);
> 	}
> 	request->n_match_sets = n_match_sets;
> 
3595a3705,3729
> 	i = 0;
> 	if (info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH]) {
> 		nla_for_each_nested(attr,
> 				    info->attrs[NL80211_ATTR_SCHED_SCAN_MATCH],
> 				    tmp) {
> 			struct nlattr *ssid;
> 
> 			nla_parse(tb, NL80211_SCHED_SCAN_MATCH_ATTR_MAX,
> 				  nla_data(attr), nla_len(attr),
> 				  nl80211_match_policy);
> 			ssid = tb[NL80211_ATTR_SCHED_SCAN_MATCH_SSID];
> 			if (ssid) {
> 				if (nla_len(ssid) > IEEE80211_MAX_SSID_LEN) {
> 					err = -EINVAL;
> 					goto out_free;
> 				}
> 				memcpy(request->match_sets[i].ssid.ssid,
> 				       nla_data(ssid), nla_len(ssid));
> 				request->match_sets[i].ssid.ssid_len =
> 					nla_len(ssid);
> 			}
> 			i++;
> 		}
> 	}
> 
4640a4775,4825
> static int nl80211_tdls_mgmt(struct sk_buff *skb, struct genl_info *info)
> {
> 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
> 	struct net_device *dev = info->user_ptr[1];
> 	u8 action_code, dialog_token;
> 	u16 status_code;
> 	u8 *peer;
> 
> 	if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||
> 	    !rdev->ops->tdls_mgmt)
> 		return -EOPNOTSUPP;
> 
> 	if (!info->attrs[NL80211_ATTR_TDLS_ACTION] ||
> 	    !info->attrs[NL80211_ATTR_STATUS_CODE] ||
> 	    !info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN] ||
> 	    !info->attrs[NL80211_ATTR_IE] ||
> 	    !info->attrs[NL80211_ATTR_MAC])
> 		return -EINVAL;
> 
> 	peer = nla_data(info->attrs[NL80211_ATTR_MAC]);
> 	action_code = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_ACTION]);
> 	status_code = nla_get_u16(info->attrs[NL80211_ATTR_STATUS_CODE]);
> 	dialog_token = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_DIALOG_TOKEN]);
> 
> 	return rdev->ops->tdls_mgmt(&rdev->wiphy, dev, peer, action_code,
> 				    dialog_token, status_code,
> 				    nla_data(info->attrs[NL80211_ATTR_IE]),
> 				    nla_len(info->attrs[NL80211_ATTR_IE]));
> }
> 
> static int nl80211_tdls_oper(struct sk_buff *skb, struct genl_info *info)
> {
> 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
> 	struct net_device *dev = info->user_ptr[1];
> 	enum nl80211_tdls_operation operation;
> 	u8 *peer;
> 
> 	if (!(rdev->wiphy.flags & WIPHY_FLAG_SUPPORTS_TDLS) ||
> 	    !rdev->ops->tdls_oper)
> 		return -EOPNOTSUPP;
> 
> 	if (!info->attrs[NL80211_ATTR_TDLS_OPERATION] ||
> 	    !info->attrs[NL80211_ATTR_MAC])
> 		return -EINVAL;
> 
> 	operation = nla_get_u8(info->attrs[NL80211_ATTR_TDLS_OPERATION]);
> 	peer = nla_data(info->attrs[NL80211_ATTR_MAC]);
> 
> 	return rdev->ops->tdls_oper(&rdev->wiphy, dev, peer, operation);
> }
> 
5170a5356,5363
> 		if (rdev->wowlan->gtk_rekey_failure)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE);
> 		if (rdev->wowlan->eap_identity_req)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST);
> 		if (rdev->wowlan->four_way_handshake)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE);
> 		if (rdev->wowlan->rfkill_release)
> 			NLA_PUT_FLAG(msg, NL80211_WOWLAN_TRIG_RFKILL_RELEASE);
5246a5440,5466
> 	if (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED])
> 		return -EINVAL;
> 
> 	if (tb[NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE]) {
> 		if (!(wowlan->flags & WIPHY_WOWLAN_GTK_REKEY_FAILURE))
> 			return -EINVAL;
> 		new_triggers.gtk_rekey_failure = true;
> 	}
> 
> 	if (tb[NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST]) {
> 		if (!(wowlan->flags & WIPHY_WOWLAN_EAP_IDENTITY_REQ))
> 			return -EINVAL;
> 		new_triggers.eap_identity_req = true;
> 	}
> 
> 	if (tb[NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE]) {
> 		if (!(wowlan->flags & WIPHY_WOWLAN_4WAY_HANDSHAKE))
> 			return -EINVAL;
> 		new_triggers.four_way_handshake = true;
> 	}
> 
> 	if (tb[NL80211_WOWLAN_TRIG_RFKILL_RELEASE]) {
> 		if (!(wowlan->flags & WIPHY_WOWLAN_RFKILL_RELEASE))
> 			return -EINVAL;
> 		new_triggers.rfkill_release = true;
> 	}
> 
5327a5548,5683
> static int nl80211_set_rekey_data(struct sk_buff *skb, struct genl_info *info)
> {
> 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
> 	struct net_device *dev = info->user_ptr[1];
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct nlattr *tb[NUM_NL80211_REKEY_DATA];
> 	struct cfg80211_gtk_rekey_data rekey_data;
> 	int err;
> 
> 	if (!info->attrs[NL80211_ATTR_REKEY_DATA])
> 		return -EINVAL;
> 
> 	err = nla_parse(tb, MAX_NL80211_REKEY_DATA,
> 			nla_data(info->attrs[NL80211_ATTR_REKEY_DATA]),
> 			nla_len(info->attrs[NL80211_ATTR_REKEY_DATA]),
> 			nl80211_rekey_policy);
> 	if (err)
> 		return err;
> 
> 	if (nla_len(tb[NL80211_REKEY_DATA_REPLAY_CTR]) != NL80211_REPLAY_CTR_LEN)
> 		return -ERANGE;
> 	if (nla_len(tb[NL80211_REKEY_DATA_KEK]) != NL80211_KEK_LEN)
> 		return -ERANGE;
> 	if (nla_len(tb[NL80211_REKEY_DATA_KCK]) != NL80211_KCK_LEN)
> 		return -ERANGE;
> 
> 	memcpy(rekey_data.kek, nla_data(tb[NL80211_REKEY_DATA_KEK]),
> 	       NL80211_KEK_LEN);
> 	memcpy(rekey_data.kck, nla_data(tb[NL80211_REKEY_DATA_KCK]),
> 	       NL80211_KCK_LEN);
> 	memcpy(rekey_data.replay_ctr,
> 	       nla_data(tb[NL80211_REKEY_DATA_REPLAY_CTR]),
> 	       NL80211_REPLAY_CTR_LEN);
> 
> 	wdev_lock(wdev);
> 	if (!wdev->current_bss) {
> 		err = -ENOTCONN;
> 		goto out;
> 	}
> 
> 	if (!rdev->ops->set_rekey_data) {
> 		err = -EOPNOTSUPP;
> 		goto out;
> 	}
> 
> 	err = rdev->ops->set_rekey_data(&rdev->wiphy, dev, &rekey_data);
>  out:
> 	wdev_unlock(wdev);
> 	return err;
> }
> 
> static int nl80211_register_unexpected_frame(struct sk_buff *skb,
> 					     struct genl_info *info)
> {
> 	struct net_device *dev = info->user_ptr[1];
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 
> 	if (wdev->iftype != NL80211_IFTYPE_AP &&
> 	    wdev->iftype != NL80211_IFTYPE_P2P_GO)
> 		return -EINVAL;
> 
> 	if (wdev->ap_unexpected_nlpid)
> 		return -EBUSY;
> 
> 	wdev->ap_unexpected_nlpid = info->snd_pid;
> 	return 0;
> }
> 
> static int nl80211_probe_client(struct sk_buff *skb,
> 				struct genl_info *info)
> {
> 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
> 	struct net_device *dev = info->user_ptr[1];
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct sk_buff *msg;
> 	void *hdr;
> 	const u8 *addr;
> 	u64 cookie;
> 	int err;
> 
> 	if (wdev->iftype != NL80211_IFTYPE_AP &&
> 	    wdev->iftype != NL80211_IFTYPE_P2P_GO)
> 		return -EOPNOTSUPP;
> 
> 	if (!info->attrs[NL80211_ATTR_MAC])
> 		return -EINVAL;
> 
> 	if (!rdev->ops->probe_client)
> 		return -EOPNOTSUPP;
> 
> 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
> 	if (!msg)
> 		return -ENOMEM;
> 
> 	hdr = nl80211hdr_put(msg, info->snd_pid, info->snd_seq, 0,
> 			     NL80211_CMD_PROBE_CLIENT);
> 
> 	if (IS_ERR(hdr)) {
> 		err = PTR_ERR(hdr);
> 		goto free_msg;
> 	}
> 
> 	addr = nla_data(info->attrs[NL80211_ATTR_MAC]);
> 
> 	err = rdev->ops->probe_client(&rdev->wiphy, dev, addr, &cookie);
> 	if (err)
> 		goto free_msg;
> 
> 	NLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);
> 
> 	genlmsg_end(msg, hdr);
> 
> 	return genlmsg_reply(msg, info);
> 
>  nla_put_failure:
> 	err = -ENOBUFS;
>  free_msg:
> 	nlmsg_free(msg);
> 	return err;
> }
> 
> static int nl80211_register_beacons(struct sk_buff *skb, struct genl_info *info)
> {
> 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
> 
> 	if (!(rdev->wiphy.flags & WIPHY_FLAG_REPORTS_OBSS))
> 		return -EOPNOTSUPP;
> 
> 	if (rdev->ap_beacons_nlpid)
> 		return -EBUSY;
> 
> 	rdev->ap_beacons_nlpid = info->snd_pid;
> 
> 	return 0;
> }
> 
5857a6214,6261
> 	{
> 		.cmd = NL80211_CMD_SET_REKEY_OFFLOAD,
> 		.doit = nl80211_set_rekey_data,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
> 	{
> 		.cmd = NL80211_CMD_TDLS_MGMT,
> 		.doit = nl80211_tdls_mgmt,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
> 	{
> 		.cmd = NL80211_CMD_TDLS_OPER,
> 		.doit = nl80211_tdls_oper,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_NETDEV_UP |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
> 	{
> 		.cmd = NL80211_CMD_UNEXPECTED_FRAME,
> 		.doit = nl80211_register_unexpected_frame,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_NETDEV |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
> 	{
> 		.cmd = NL80211_CMD_PROBE_CLIENT,
> 		.doit = nl80211_probe_client,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_NETDEV |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
> 	{
> 		.cmd = NL80211_CMD_REGISTER_BEACONS,
> 		.doit = nl80211_register_beacons,
> 		.policy = nl80211_policy,
> 		.flags = GENL_ADMIN_PERM,
> 		.internal_flags = NL80211_FLAG_NEED_WIPHY |
> 				  NL80211_FLAG_NEED_RTNL,
> 	},
6677a7082,7122
> bool nl80211_unexpected_frame(struct net_device *dev, const u8 *addr, gfp_t gfp)
> {
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
> 	struct sk_buff *msg;
> 	void *hdr;
> 	int err;
> 	u32 nlpid = ACCESS_ONCE(wdev->ap_unexpected_nlpid);
> 
> 	if (!nlpid)
> 		return false;
> 
> 	msg = nlmsg_new(100, gfp);
> 	if (!msg)
> 		return true;
> 
> 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_UNEXPECTED_FRAME);
> 	if (!hdr) {
> 		nlmsg_free(msg);
> 		return true;
> 	}
> 
> 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
> 	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);
> 	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
> 
> 	err = genlmsg_end(msg, hdr);
> 	if (err < 0) {
> 		nlmsg_free(msg);
> 		return true;
> 	}
> 
> 	genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlpid);
> 	return true;
> 
>  nla_put_failure:
> 	genlmsg_cancel(msg, hdr);
> 	nlmsg_free(msg);
> 	return true;
> }
> 
6801a7247,7337
> void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,
> 			      struct net_device *netdev, const u8 *bssid,
> 			      const u8 *replay_ctr, gfp_t gfp)
> {
> 	struct sk_buff *msg;
> 	struct nlattr *rekey_attr;
> 	void *hdr;
> 
> 	msg = nlmsg_new(NLMSG_GOODSIZE, gfp);
> 	if (!msg)
> 		return;
> 
> 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_SET_REKEY_OFFLOAD);
> 	if (!hdr) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
> 	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
> 	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, bssid);
> 
> 	rekey_attr = nla_nest_start(msg, NL80211_ATTR_REKEY_DATA);
> 	if (!rekey_attr)
> 		goto nla_put_failure;
> 
> 	NLA_PUT(msg, NL80211_REKEY_DATA_REPLAY_CTR,
> 		NL80211_REPLAY_CTR_LEN, replay_ctr);
> 
> 	nla_nest_end(msg, rekey_attr);
> 
> 	if (genlmsg_end(msg, hdr) < 0) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
> 				nl80211_mlme_mcgrp.id, gfp);
> 	return;
> 
>  nla_put_failure:
> 	genlmsg_cancel(msg, hdr);
> 	nlmsg_free(msg);
> }
> 
> void nl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,
> 				    struct net_device *netdev, int index,
> 				    const u8 *bssid, bool preauth, gfp_t gfp)
> {
> 	struct sk_buff *msg;
> 	struct nlattr *attr;
> 	void *hdr;
> 
> 	msg = nlmsg_new(NLMSG_GOODSIZE, gfp);
> 	if (!msg)
> 		return;
> 
> 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PMKSA_CANDIDATE);
> 	if (!hdr) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
> 	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
> 
> 	attr = nla_nest_start(msg, NL80211_ATTR_PMKSA_CANDIDATE);
> 	if (!attr)
> 		goto nla_put_failure;
> 
> 	NLA_PUT_U32(msg, NL80211_PMKSA_CANDIDATE_INDEX, index);
> 	NLA_PUT(msg, NL80211_PMKSA_CANDIDATE_BSSID, ETH_ALEN, bssid);
> 	if (preauth)
> 		NLA_PUT_FLAG(msg, NL80211_PMKSA_CANDIDATE_PREAUTH);
> 
> 	nla_nest_end(msg, attr);
> 
> 	if (genlmsg_end(msg, hdr) < 0) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
> 				nl80211_mlme_mcgrp.id, gfp);
> 	return;
> 
>  nla_put_failure:
> 	genlmsg_cancel(msg, hdr);
> 	nlmsg_free(msg);
> }
> 
6846a7383,7462
> void cfg80211_probe_status(struct net_device *dev, const u8 *addr,
> 			   u64 cookie, bool acked, gfp_t gfp)
> {
> 	struct wireless_dev *wdev = dev->ieee80211_ptr;
> 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
> 	struct sk_buff *msg;
> 	void *hdr;
> 	int err;
> 
> 	msg = nlmsg_new(NLMSG_GOODSIZE, gfp);
> 	if (!msg)
> 		return;
> 
> 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_PROBE_CLIENT);
> 	if (!hdr) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
> 	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, dev->ifindex);
> 	NLA_PUT(msg, NL80211_ATTR_MAC, ETH_ALEN, addr);
> 	NLA_PUT_U64(msg, NL80211_ATTR_COOKIE, cookie);
> 	if (acked)
> 		NLA_PUT_FLAG(msg, NL80211_ATTR_ACK);
> 
> 	err = genlmsg_end(msg, hdr);
> 	if (err < 0) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
> 				nl80211_mlme_mcgrp.id, gfp);
> 	return;
> 
>  nla_put_failure:
> 	genlmsg_cancel(msg, hdr);
> 	nlmsg_free(msg);
> }
> EXPORT_SYMBOL(cfg80211_probe_status);
> 
> void cfg80211_report_obss_beacon(struct wiphy *wiphy,
> 				 const u8 *frame, size_t len,
> 				 int freq, gfp_t gfp)
> {
> 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wiphy);
> 	struct sk_buff *msg;
> 	void *hdr;
> 	u32 nlpid = ACCESS_ONCE(rdev->ap_beacons_nlpid);
> 
> 	if (!nlpid)
> 		return;
> 
> 	msg = nlmsg_new(len + 100, gfp);
> 	if (!msg)
> 		return;
> 
> 	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_FRAME);
> 	if (!hdr) {
> 		nlmsg_free(msg);
> 		return;
> 	}
> 
> 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
> 	if (freq)
> 		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, freq);
> 	NLA_PUT(msg, NL80211_ATTR_FRAME, len, frame);
> 
> 	genlmsg_end(msg, hdr);
> 
> 	genlmsg_unicast(wiphy_net(&rdev->wiphy), msg, nlpid);
> 	return;
> 
>  nla_put_failure:
> 	genlmsg_cancel(msg, hdr);
> 	nlmsg_free(msg);
> }
> EXPORT_SYMBOL(cfg80211_report_obss_beacon);
> 
6860c7476
< 	list_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list)
---
> 	list_for_each_entry_rcu(rdev, &cfg80211_rdev_list, list) {
6862a7479,7481
> 		if (rdev->ap_beacons_nlpid == notify->pid)
> 			rdev->ap_beacons_nlpid = 0;
> 	}




diff -r linux-3.0.36/net/wireless/nl80211.h linux-3.0.36-lenovo/net/wireless/nl80211.h
111a112,122
> void nl80211_gtk_rekey_notify(struct cfg80211_registered_device *rdev,
> 			      struct net_device *netdev, const u8 *bssid,
> 			      const u8 *replay_ctr, gfp_t gfp);
> 
> void nl80211_pmksa_candidate_notify(struct cfg80211_registered_device *rdev,
> 				    struct net_device *netdev, int index,
> 				    const u8 *bssid, bool preauth, gfp_t gfp);
> 
> bool nl80211_unexpected_frame(struct net_device *dev,
> 			      const u8 *addr, gfp_t gfp);
> 




diff -r linux-3.0.36/net/wireless/reg.c linux-3.0.36-lenovo/net/wireless/reg.c
128,130c128,129
< 		/* IEEE 802.11b/g, channels 12..13. No HT40
< 		 * channel fits here. */
< 		REG_RULE(2467-10, 2472+10, 20, 6, 20,
---
> 		/* IEEE 802.11b/g, channels 12..13. */
> 		REG_RULE(2467-10, 2472+10, 40, 6, 20,
333a333,335
> 	bool set_reg = false;
> 
> 	mutex_lock(&cfg80211_mutex);
349,351c351
< 				mutex_lock(&cfg80211_mutex);
< 				set_regdom(regdom);
< 				mutex_unlock(&cfg80211_mutex);
---
> 				set_reg = true;
358a359,363
> 
> 	if (set_reg)
> 		set_regdom(regdom);
> 
> 	mutex_unlock(&cfg80211_mutex);
1361c1366
< 		cancel_delayed_work_sync(&reg_timeout);
---
> 		cancel_delayed_work(&reg_timeout);
1783a1789
> 	char world_alpha2[2];
1833a1840,1841
> 	world_alpha2[0] = cfg80211_regdomain->alpha2[0];
> 	world_alpha2[1] = cfg80211_regdomain->alpha2[1];
1838c1846
< 	regulatory_hint_core(cfg80211_regdomain->alpha2);
---
> 	regulatory_hint_core(world_alpha2);




diff -r linux-3.0.36/net/wireless/scan.c linux-3.0.36-lenovo/net/wireless/scan.c
20c20
< #define IEEE80211_SCAN_RESULT_EXPIRE	(15 * HZ)
---
> #define IEEE80211_SCAN_RESULT_EXPIRE	(3 * HZ)




diff -r linux-3.0.36/net/wireless/sme.c linux-3.0.36-lenovo/net/wireless/sme.c
661a662
> #ifndef CONFIG_CFG80211_ALLOW_RECONNECT
663a665
> #endif
760a763
> #ifndef CONFIG_CFG80211_ALLOW_RECONNECT
764a768,770
> #else
> 	if (wdev->connect_keys) {
> #endif




diff -r linux-3.0.36/net/wireless/util.c linux-3.0.36-lenovo/net/wireless/util.c
301c301
< 	/* 7.1.3.5a.2 */
---
> 	/* 802.11-2012, 8.2.4.7.3 */
302a303
> 	default:
309,312d309
< 	case (MESH_FLAGS_AE_A4 | MESH_FLAGS_AE_A5_A6):
< 		return 24;
< 	default:
< 		return 6;
361a359,360
> 			if (meshdr->flags & MESH_FLAGS_AE_A4)
> 				return -1;
385a385,386
> 			if (meshdr->flags & MESH_FLAGS_AE_A5_A6)
> 				return -1;
722c723
< static void cfg80211_process_wdev_events(struct wireless_dev *wdev)
---
> void cfg80211_process_wdev_events(struct wireless_dev *wdev)
810c811
< 	if (ntype != otype) {
---
> 	if (ntype != otype && netif_running(dev)) {
976a978,980
> 
> 	if (total == 1)
> 		return 0;




diff -r linux-3.0.36/net/xfrm/xfrm_input.c linux-3.0.36-lenovo/net/xfrm/xfrm_input.c
215c215
< 		if (async && x->repl->check(x, skb, seq)) {
---
> 		if (async && x->repl->recheck(x, skb, seq)) {




diff -r linux-3.0.36/net/xfrm/xfrm_policy.c linux-3.0.36-lenovo/net/xfrm/xfrm_policy.c
1352,1353d1351
< 	memset(&xdst->u.rt6.rt6i_table, 0, sizeof(*xdst) - sizeof(struct dst_entry));
< 	xfrm_policy_put_afinfo(afinfo);
1355c1353,1355
< 	if (likely(xdst))
---
> 	if (likely(xdst)) {
> 		memset(&xdst->u.rt6.rt6i_table, 0,
> 			sizeof(*xdst) - sizeof(struct dst_entry));
1357c1357
< 	else
---
> 	} else
1359a1360,1361
> 	xfrm_policy_put_afinfo(afinfo);
> 
1762c1764
< 		ret = ERR_PTR(-EINVAL);
---
> 		return ERR_PTR(-EINVAL);




diff -r linux-3.0.36/net/xfrm/xfrm_replay.c linux-3.0.36-lenovo/net/xfrm/xfrm_replay.c
439a440,451
> static int xfrm_replay_recheck_esn(struct xfrm_state *x,
> 				   struct sk_buff *skb, __be32 net_seq)
> {
> 	if (unlikely(XFRM_SKB_CB(skb)->seq.input.hi !=
> 		     htonl(xfrm_replay_seqhi(x, net_seq)))) {
> 			x->stats.replay_window++;
> 			return -EINVAL;
> 	}
> 
> 	return xfrm_replay_check_esn(x, skb, net_seq);
> }
> 
510a523
> 	.recheck	= xfrm_replay_check,
517a531
> 	.recheck	= xfrm_replay_check_bmp,
524a539
> 	.recheck	= xfrm_replay_recheck_esn,




diff -r linux-3.0.36/net/xfrm/xfrm_user.c linux-3.0.36-lenovo/net/xfrm/xfrm_user.c
125a126
> 	struct xfrm_replay_state_esn *rs;
127,128c128,140
< 	if ((p->flags & XFRM_STATE_ESN) && !rt)
< 		return -EINVAL;
---
> 	if (p->flags & XFRM_STATE_ESN) {
> 		if (!rt)
> 			return -EINVAL;
> 
> 		rs = nla_data(rt);
> 
> 		if (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)
> 			return -EINVAL;
> 
> 		if (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&
> 		    nla_len(rt) != sizeof(*rs))
> 			return -EINVAL;
> 	}
372a385
> 	int ulen;
377a391
> 	ulen = xfrm_replay_state_esn_len(up);
379,380c393
< 	if (xfrm_replay_state_esn_len(replay_esn) !=
< 			xfrm_replay_state_esn_len(up))
---
> 	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
390a404
> 	int klen, ulen;
395a410,411
> 	klen = xfrm_replay_state_esn_len(up);
> 	ulen = nla_len(rta) >= klen ? klen : sizeof(*up);
397c413
< 	p = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
---
> 	p = kzalloc(klen, GFP_KERNEL);
401c417
< 	pp = kmemdup(up, xfrm_replay_state_esn_len(up), GFP_KERNEL);
---
> 	pp = kzalloc(klen, GFP_KERNEL);
406a423,425
> 	memcpy(p, up, ulen);
> 	memcpy(pp, up, ulen);
> 
445c464,465
< static void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs)
---
> static void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,
> 				  int update_esn)
448c468
< 	struct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];
---
> 	struct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;
558c578
< 	xfrm_update_ae_params(x, attrs);
---
> 	xfrm_update_ae_params(x, attrs, 0);
691a712
> 	memset(p, 0, sizeof(*p));
745c766
< 	strcpy(algo->alg_name, auth->alg_name);
---
> 	strncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));
864a886
> 	int err;
875c897,898
< 	if (dump_one_state(x, 0, &info)) {
---
> 	err = dump_one_state(x, 0, &info);
> 	if (err) {
877c900
< 		return NULL;
---
> 		return ERR_PTR(err);
1299a1323
> 	memset(p, 0, sizeof(*p));
1403a1428
> 		memset(up, 0, sizeof(*up));
1531a1557
> 	int err;
1542c1568,1569
< 	if (dump_one_policy(xp, dir, 0, &info) < 0) {
---
> 	err = dump_one_policy(xp, dir, 0, &info);
> 	if (err) {
1544c1571
< 		return NULL;
---
> 		return ERR_PTR(err);
1797c1824
< 	xfrm_update_ae_params(x, attrs);
---
> 	xfrm_update_ae_params(x, attrs, 1);
2302c2329,2330
< 		return netlink_dump_start(net->xfrm.nlsk, skb, nlh, link->dump, link->done);
---
> 		return netlink_dump_start(net->xfrm.nlsk, skb, nlh,
> 					  link->dump, link->done, 0);
Only in linux-3.0.36-lenovo: rktools
Only in linux-3.0.36-lenovo/samples: uhid
Only in linux-3.0.36-lenovo/scripts: bmptologo.c




diff -r linux-3.0.36/scripts/gcc-version.sh linux-3.0.36-lenovo/scripts/gcc-version.sh
25,26c25,26
< MAJOR=$(echo __GNUC__ | $compiler -E -xc - | tail -n 1)
< MINOR=$(echo __GNUC_MINOR__ | $compiler -E -xc - | tail -n 1)
---
> MAJOR=$(echo __GNUC__ | $compiler -E -x c - | tail -n 1)
> MINOR=$(echo __GNUC_MINOR__ | $compiler -E -x c - | tail -n 1)
28c28
< 	PATCHLEVEL=$(echo __GNUC_PATCHLEVEL__ | $compiler -E -xc - | tail -n 1)
---
> 	PATCHLEVEL=$(echo __GNUC_PATCHLEVEL__ | $compiler -E -x c - | tail -n 1)




diff -r linux-3.0.36/scripts/gcc-x86_32-has-stack-protector.sh linux-3.0.36-lenovo/scripts/gcc-x86_32-has-stack-protector.sh
3c3
< echo "int foo(void) { char X[200]; return 3; }" | $* -S -xc -c -O0 -fstack-protector - -o - 2> /dev/null | grep -q "%gs"
---
> echo "int foo(void) { char X[200]; return 3; }" | $* -S -x c -c -O0 -fstack-protector - -o - 2> /dev/null | grep -q "%gs"




diff -r linux-3.0.36/scripts/gcc-x86_64-has-stack-protector.sh linux-3.0.36-lenovo/scripts/gcc-x86_64-has-stack-protector.sh
3c3
< echo "int foo(void) { char X[200]; return 3; }" | $* -S -xc -c -O0 -mcmodel=kernel -fstack-protector - -o - 2> /dev/null | grep -q "%gs"
---
> echo "int foo(void) { char X[200]; return 3; }" | $* -S -x c -c -O0 -mcmodel=kernel -fstack-protector - -o - 2> /dev/null | grep -q "%gs"




diff -r linux-3.0.36/scripts/.gitignore linux-3.0.36-lenovo/scripts/.gitignore
5a6
> bmptologo




diff -r linux-3.0.36/scripts/Kbuild.include linux-3.0.36-lenovo/scripts/Kbuild.include
97c97
< 	$(CC) $(KBUILD_CFLAGS) $(1) -c -xassembler /dev/null -o "$$TMP",$(1),$(2))
---
> 	$(CC) $(KBUILD_CFLAGS) $(1) -c -x assembler /dev/null -o "$$TMP",$(1),$(2))
103c103
< 	/bin/echo -e "$(1)" | $(CC) $(KBUILD_AFLAGS) -c -xassembler -o "$$TMP" -,$(2),$(3))
---
> 	/bin/echo -e "$(1)" | $(CC) $(KBUILD_AFLAGS) -c -x assembler -o "$$TMP" -,$(2),$(3))
109c109
< 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -xc /dev/null -o "$$TMP",$(1),$(2))
---
> 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -x c /dev/null -o "$$TMP",$(1),$(2))
114c114
< 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -xc /dev/null -o "$$TMP",y,n)
---
> 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) $(1) -c -x c /dev/null -o "$$TMP",y,n)
124c124
< 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -W$(strip $(1)) -c -xc /dev/null -o "$$TMP",-Wno-$(strip $(1)))
---
> 	$(CC) $(KBUILD_CPPFLAGS) $(KBUILD_CFLAGS) -W$(strip $(1)) -c -x c /dev/null -o "$$TMP",-Wno-$(strip $(1)))
142c142
< 	$(CC) $(1) -nostdlib -xc /dev/null -o "$$TMP",$(1),$(2))
---
> 	$(CC) $(1) -nostdlib -x c /dev/null -o "$$TMP",$(1),$(2))
208c208
< make-cmd = $(subst \#,\\\#,$(subst $$,$$$$,$(call escsq,$(cmd_$(1)))))
---
> make-cmd = $(subst \\,\\\\,$(subst \#,\\\#,$(subst $$,$$$$,$(call escsq,$(cmd_$(1))))))




diff -r linux-3.0.36/scripts/kconfig/check.sh linux-3.0.36-lenovo/scripts/kconfig/check.sh
3c3
< $* -xc -o /dev/null - > /dev/null 2>&1 << EOF
---
> $* -x c -o /dev/null - > /dev/null 2>&1 << EOF




diff -r linux-3.0.36/scripts/kconfig/lxdialog/check-lxdialog.sh linux-3.0.36-lenovo/scripts/kconfig/lxdialog/check-lxdialog.sh
41c41
<         $cc -xc - -o $tmp 2>/dev/null <<'EOF'
---
>         $cc -x c - -o $tmp 2>/dev/null <<'EOF'




diff -r linux-3.0.36/scripts/Makefile linux-3.0.36-lenovo/scripts/Makefile
12a13
> hostprogs-y        += bmptologo




diff -r linux-3.0.36/scripts/Makefile.build linux-3.0.36-lenovo/scripts/Makefile.build
465a466,474
> 
> 
> # .uu -> .o
> # ---------------------------------------------------------------------------
> quiet_cmd_uudecode_o_uu = DECODE  $@
>       cmd_uudecode_o_uu = uudecode -o $@ $<
> 
> $(obj)/%.o: $(src)/%.uu FORCE
> 	$(call if_changed,uudecode_o_uu)




diff -r linux-3.0.36/scripts/pnmtologo.c linux-3.0.36-lenovo/scripts/pnmtologo.c
30d29
< 
69a69,86
> unsigned char data_name[] = {
> 	0x6C, 0x6F, 0x67,
> 	0x6F, 0x5F, 0x52,
> 	0x4B, 0x6C, 0x6F,
> 	0x67, 0x6F, 0x5F,
> 	0x64, 0x61, 0x74,
> 	0x61
> };
> 
> unsigned char clut_name[] = {
> 	0x70, 0x70, 0x6c,
> 	0x6C, 0x6F, 0x67,
> 	0x6F, 0x5F, 0x52,
> 	0x4B, 0x6C, 0x6F,
> 	0x67, 0x6F, 0x5F,
> 	0x63, 0x6C, 0x75,
> 	0x74
> };
82d98
< 
121,129c137,145
<     FILE *fp;
<     unsigned int i, j;
<     int magic;
<     unsigned int maxval;
< 
<     /* open image file */
<     fp = fopen(filename, "r");
<     if (!fp)
< 	die("Cannot open file %s: %s\n", filename, strerror(errno));
---
> 	FILE *fp;
> 	unsigned int i, j;
> 	int magic;
> 	unsigned int maxval;
> 
> 	/* open image file */
> 	fp = fopen(filename, "r");
> 	if (!fp)
> 		die("Cannot open file %s: %s\n", filename, strerror(errno));
153,154c169,170
<     logo_width = get_number(fp);
<     logo_height = get_number(fp);
---
> 	logo_width = get_number(fp);
> 	logo_height = get_number(fp);
156,164c172,181
<     /* allocate image data */
<     logo_data = (struct color **)malloc(logo_height*sizeof(struct color *));
<     if (!logo_data)
< 	die("%s\n", strerror(errno));
<     for (i = 0; i < logo_height; i++) {
< 	logo_data[i] = malloc(logo_width*sizeof(struct color));
< 	if (!logo_data[i])
< 	    die("%s\n", strerror(errno));
<     }
---
> 
> 	/* allocate image data */
> 	logo_data = (struct color **)malloc(logo_height * sizeof(struct color *));
> 	if (!logo_data)
> 		die("%s\n", strerror(errno));
> 	for (i = 0; i < logo_height; i++) {
> 		logo_data[i] = (struct color *)malloc(logo_width * sizeof(struct color));
> 		if (!logo_data[i])
> 		die("%s\n", strerror(errno));
> 	}
221,262d237
< static void write_header(void)
< {
<     /* open logo file */
<     if (outputname) {
< 	out = fopen(outputname, "w");
< 	if (!out)
< 	    die("Cannot create file %s: %s\n", outputname, strerror(errno));
<     } else {
< 	out = stdout;
<     }
< 
<     fputs("/*\n", out);
<     fputs(" *  DO NOT EDIT THIS FILE!\n", out);
<     fputs(" *\n", out);
<     fprintf(out, " *  It was automatically generated from %s\n", filename);
<     fputs(" *\n", out);
<     fprintf(out, " *  Linux logo %s\n", logoname);
<     fputs(" */\n\n", out);
<     fputs("#include <linux/linux_logo.h>\n\n", out);
<     fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
< 	    logoname);
< }
< 
< static void write_footer(void)
< {
<     fputs("\n};\n\n", out);
<     fprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);
<     fprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);
<     fprintf(out, "\t.width\t\t= %d,\n", logo_width);
<     fprintf(out, "\t.height\t\t= %d,\n", logo_height);
<     if (logo_type == LINUX_LOGO_CLUT224) {
< 	fprintf(out, "\t.clutsize\t= %d,\n", logo_clutsize);
< 	fprintf(out, "\t.clut\t\t= %s_clut,\n", logoname);
<     }
<     fprintf(out, "\t.data\t\t= %s_data\n", logoname);
<     fputs("};\n\n", out);
< 
<     /* close logo file */
<     if (outputname)
< 	fclose(out);
< }
< 
275a251,299
> static void write_header(void)
> {
> 	/* open logo file */
> 	if (outputname) {
> 		out = fopen(outputname, "w");
> 		if (!out)
> 			die("Cannot create file %s: %s\n", outputname, strerror(errno));
> 	} else {
> 		out = stdout;
> 	}
> 
> 	fputs("/*\n", out);
> 	fputs(" *  DO NOT EDIT THIS FILE!\n", out);
> 	fputs(" *\n", out);
> 	fprintf(out, " *  It was automatically generated from %s\n", filename);
> 	fputs(" *\n", out);
> 	fprintf(out, " *  Linux logo %s\n", logoname);
> 	fputs(" */\n\n", out);
> 	fputs("#include <linux/linux_logo.h>\n\n", out);
> 	fprintf(out, "static unsigned char %s_data[] __initdata = {\n",
> 		logoname);
> }
> 
> static void write_footer(void)
> {
> 	fputs("\n};\n\n", out);
> 	fprintf(out, "const struct linux_logo %s __initconst = {\n", logoname);
> 	fprintf(out, "\t.type\t\t= %s,\n", logo_types[logo_type]);
> 
> 	if (logo_type == LINUX_LOGO_CLUT224) {
> 		fprintf(out, "\t.clut\t\t= &(%s_clut[%ld]),\n", logoname, sizeof(clut_name));
> 		fprintf(out, "\t.data\t\t= &(%s_data[%ld])\n", logoname, sizeof(data_name) + 4);
> 	} else {
> 		fprintf(out, "\t.width\t\t= %d,\n", logo_width);
> 		fprintf(out, "\t.height\t\t= %d,\n", logo_height);
> 		if (logo_type == LINUX_LOGO_CLUT224) {
> 			fprintf(out, "\t.clutsize\t= %d,\n", logo_clutsize);
> 			fprintf(out, "\t.clut\t\t= %s_clut,\n", logoname);
> 		}
> 		fprintf(out, "\t.data\t\t= %s_data\n", logoname);
> 	}
> 
> 	fputs("};\n\n", out);
> 
> 	/* close logo file */
> 	if (outputname)
> 		fclose(out);
> }
> 
299a324
> 
346c371
<     unsigned int i, j, k;
---
> 	unsigned int i, j, k;
348,360c373,401
<     /* validate image */
<     for (i = 0; i < logo_height; i++)
< 	for (j = 0; j < logo_width; j++) {
< 	    for (k = 0; k < logo_clutsize; k++)
< 		if (is_equal(logo_data[i][j], logo_clut[k]))
< 		    break;
< 	    if (k == logo_clutsize) {
< 		if (logo_clutsize == MAX_LINUX_LOGO_COLORS)
< 		    die("Image has more than %d colors\n"
< 			"Use ppmquant(1) to reduce the number of colors\n",
< 			MAX_LINUX_LOGO_COLORS);
< 		logo_clut[logo_clutsize++] = logo_data[i][j];
< 	    }
---
> 	logo_clutsize = 0;
> 
> 	/* validate image */
> 	for (i = 0; i < logo_height; i++)
> 		for (j = 0; j < logo_width; j++) {
> 			for (k = 0; k < logo_clutsize; k++)
> 				if (is_equal(logo_data[i][j], logo_clut[k]))
> 					break;
> 			if (k == logo_clutsize) {
> 				if (logo_clutsize == MAX_LINUX_LOGO_COLORS)
> 					die("Image has more than %d colors\n"
> 						"Use ppmquant(1) to reduce the number of colors\n",
> 						MAX_LINUX_LOGO_COLORS);
> 					logo_clut[logo_clutsize++] = logo_data[i][j];
> 			}
> 		}
> 
> 	write_hex_cnt = 0;
> 
> 	/* write file header */
> 	write_header();
> 
> 	write_hex((unsigned char)(logo_width >> 8));
> 	write_hex((unsigned char)logo_width);
> 	write_hex((unsigned char)(logo_height >> 8));
> 	write_hex((unsigned char)logo_height);
> 
> 	for (i = 0; i < sizeof(data_name); i++){
> 		write_hex(data_name[i]);
361a403,406
> 	write_hex((unsigned char)(logo_width >> 8));
> 	write_hex((unsigned char)logo_width);
> 	write_hex((unsigned char)(logo_height >> 8));
> 	write_hex((unsigned char)logo_height);
363,364c408,415
<     /* write file header */
<     write_header();
---
> 	/* write logo data */
> 	for (i = 0; i < logo_height; i++)
> 		for (j = 0; j < logo_width; j++) {
> 	 		for (k = 0; k < logo_clutsize; k++)
> 				if (is_equal(logo_data[i][j], logo_clut[k]))
> 					break;
> 			write_hex(k+32);
> 		}
366,372c417,426
<     /* write logo data */
<     for (i = 0; i < logo_height; i++)
< 	for (j = 0; j < logo_width; j++) {
< 	    for (k = 0; k < logo_clutsize; k++)
< 		if (is_equal(logo_data[i][j], logo_clut[k]))
< 		    break;
< 	    write_hex(k+32);
---
> 	fputs("\n};\n\n", out);
> 
> 	/* write logo clut */
> 	fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
> 		logoname);
> 
> 	write_hex_cnt = 0;
> 
> 	for (i = 0; i < sizeof(clut_name); i++){
> 		write_hex(clut_name[i]);
374c428
<     fputs("\n};\n\n", out);
---
> 	write_hex(logo_clutsize);
376,384c430,434
<     /* write logo clut */
<     fprintf(out, "static unsigned char %s_clut[] __initdata = {\n",
< 	    logoname);
<     write_hex_cnt = 0;
<     for (i = 0; i < logo_clutsize; i++) {
< 	write_hex(logo_clut[i].red);
< 	write_hex(logo_clut[i].green);
< 	write_hex(logo_clut[i].blue);
<     }
---
> 	for (i = 0; i < logo_clutsize; i++) {
> 		write_hex(logo_clut[i].red);
> 		write_hex(logo_clut[i].green);
> 		write_hex(logo_clut[i].blue);
> 	}
386,387c436,442
<     /* write logo structure and file footer */
<     write_footer();
---
> 	for (i = logo_clutsize; i < (MAX_LINUX_LOGO_COLORS * 3); i++)
> 	{
> 		write_hex(32);
> 	}
> 
> 	/* write logo structure and file footer */
> 	write_footer();




diff -r linux-3.0.36/security/commoncap.c linux-3.0.36-lenovo/security/commoncap.c
32a33,36
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> #include <linux/android_aid.h>
> #endif
> 
86a91,97
> #ifdef CONFIG_ANDROID_PARANOID_NETWORK
> 	if (cap == CAP_NET_RAW && in_egroup_p(AID_NET_RAW))
> 		return 0;
> 	if (cap == CAP_NET_ADMIN && in_egroup_p(AID_NET_ADMIN))
> 		return 0;
> #endif
> 




diff -r linux-3.0.36/security/selinux/netnode.c linux-3.0.36-lenovo/security/selinux/netnode.c
193c193,194
< 			rcu_dereference(sel_netnode_hash[idx].list.prev),
---
> 			rcu_dereference_protected(sel_netnode_hash[idx].list.prev,
> 						  lockdep_is_held(&sel_netnode_lock)),




diff -r linux-3.0.36/sound/arm/pxa2xx-ac97-lib.c linux-3.0.36-lenovo/sound/arm/pxa2xx-ac97-lib.c
148a149,150
> 	unsigned int timeout;
> 
158,159c160,163
< 	GCR = GCR_COLD_RST;
< 	udelay(50);
---
> 	GCR = GCR_COLD_RST | GCR_WARM_RST;
> 	timeout = 100;     /* wait for the codec-ready bit to be set */
> 	while (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)) && timeout--)
> 		mdelay(1);




diff -r linux-3.0.36/sound/core/control.c linux-3.0.36-lenovo/sound/core/control.c
87a88
> 	snd_card_unref(card);
94a96,97
> 	if (card)
> 		snd_card_unref(card);
1362a1366,1367
> 			if (ctl->card->shutdown)
> 				return -ENODEV;




diff -r linux-3.0.36/sound/core/hwdep.c linux-3.0.36-lenovo/sound/core/hwdep.c
102c102,103
< 	if (!try_module_get(hw->card->module))
---
> 	if (!try_module_get(hw->card->module)) {
> 		snd_card_unref(hw->card);
103a105
> 	}
130a133,136
> 		if (hw->card->shutdown) {
> 			err = -ENODEV;
> 			break;
> 		}
149a156
> 	snd_card_unref(hw->card);
453a461,462
> 	mutex_lock(&hwdep->open_mutex);
> 	wake_up(&hwdep->open_wait);
459a469
> 	mutex_unlock(&hwdep->open_mutex);




diff -r linux-3.0.36/sound/core/init.c linux-3.0.36-lenovo/sound/core/init.c
213a214
> 	atomic_set(&card->refcount, 0);
446a448,464
> /**
>  * snd_card_unref - release the reference counter
>  * @card: the card instance
>  *
>  * Decrements the reference counter.  When it reaches to zero, wake up
>  * the sleeper and call the destructor if needed.
>  */
> void snd_card_unref(struct snd_card *card)
> {
> 	if (atomic_dec_and_test(&card->refcount)) {
> 		wake_up(&card->shutdown_sleep);
> 		if (card->free_on_last_close)
> 			snd_card_do_free(card);
> 	}
> }
> EXPORT_SYMBOL(snd_card_unref);
> 
449,452c467
< 	int free_now = 0;
< 	int ret = snd_card_disconnect(card);
< 	if (ret)
< 		return ret;
---
> 	int ret;
454,459c469,474
< 	spin_lock(&card->files_lock);
< 	if (list_empty(&card->files_list))
< 		free_now = 1;
< 	else
< 		card->free_on_last_close = 1;
< 	spin_unlock(&card->files_lock);
---
> 	atomic_inc(&card->refcount);
> 	ret = snd_card_disconnect(card);
> 	if (ret) {
> 		atomic_dec(&card->refcount);
> 		return ret;
> 	}
461c476,477
< 	if (free_now)
---
> 	card->free_on_last_close = 1;
> 	if (atomic_dec_and_test(&card->refcount))
475c491
< 	wait_event(card->shutdown_sleep, list_empty(&card->files_list));
---
> 	wait_event(card->shutdown_sleep, !atomic_read(&card->refcount));
855a872
> 	atomic_inc(&card->refcount);
878d894
< 	int last_close = 0;
893,894d908
< 	if (list_empty(&card->files_list))
< 		last_close = 1;
896,900d909
< 	if (last_close) {
< 		wake_up(&card->shutdown_sleep);
< 		if (card->free_on_last_close)
< 			snd_card_do_free(card);
< 	}
905a915
> 	snd_card_unref(card);




diff -r linux-3.0.36/sound/core/oss/mixer_oss.c linux-3.0.36-lenovo/sound/core/oss/mixer_oss.c
54c54,55
< 	if (card->mixer_oss == NULL)
---
> 	if (card->mixer_oss == NULL) {
> 		snd_card_unref(card);
55a57
> 	}
57c59,60
< 	if (err < 0)
---
> 	if (err < 0) {
> 		snd_card_unref(card);
58a62
> 	}
61a66
> 		snd_card_unref(card);
69a75
> 		snd_card_unref(card);
71a78
> 	snd_card_unref(card);




diff -r linux-3.0.36/sound/core/oss/pcm_oss.c linux-3.0.36-lenovo/sound/core/oss/pcm_oss.c
2443a2444,2447
> 		if (pcm->card->shutdown) {
> 			err = -ENODEV;
> 			break;
> 		}
2452a2457
> 	snd_card_unref(pcm->card);
2459a2465,2466
> 	if (pcm)
> 		snd_card_unref(pcm->card);




diff -r linux-3.0.36/sound/core/pcm.c linux-3.0.36-lenovo/sound/core/pcm.c
1047a1048,1049
> 	mutex_lock(&pcm->open_mutex);
> 	wake_up(&pcm->open_wait);
1050,1051c1052,1054
< 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
< 			if (substream->runtime)
---
> 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next) {
> 			snd_pcm_stream_lock_irq(substream);
> 			if (substream->runtime) {
1052a1056,1060
> 				wake_up(&substream->runtime->sleep);
> 				wake_up(&substream->runtime->tsleep);
> 			}
> 			snd_pcm_stream_unlock_irq(substream);
> 		}
1067a1076
> 	mutex_unlock(&pcm->open_mutex);




diff -r linux-3.0.36/sound/core/pcm_native.c linux-3.0.36-lenovo/sound/core/pcm_native.c
370a371,378
> static void snd_pcm_set_state(struct snd_pcm_substream *substream, int state)
> {
> 	snd_pcm_stream_lock_irq(substream);
> 	if (substream->runtime->status->state != SNDRV_PCM_STATE_DISCONNECTED)
> 		substream->runtime->status->state = state;
> 	snd_pcm_stream_unlock_irq(substream);
> }
> 
454c462
< 	runtime->status->state = SNDRV_PCM_STATE_SETUP;
---
> 	snd_pcm_set_state(substream, SNDRV_PCM_STATE_SETUP);
466c474
< 	runtime->status->state = SNDRV_PCM_STATE_OPEN;
---
> 	snd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);
514c522
< 	runtime->status->state = SNDRV_PCM_STATE_OPEN;
---
> 	snd_pcm_set_state(substream, SNDRV_PCM_STATE_OPEN);
1042a1051,1061
> /*
>  * set volume.
>  * add by qiuen
>  */
> static int snd_pcm_vol(struct snd_pcm_substream *substream, int push)
> {
> 	substream->number = push;
> 
> 	return substream->ops->trigger(substream, SNDRV_PCM_TRIGGER_VOLUME);
> }
> 
1322c1341
< 	runtime->status->state = SNDRV_PCM_STATE_PREPARED;
---
> 	snd_pcm_set_state(substream, SNDRV_PCM_STATE_PREPARED);
1501a1521,1524
> 		if (card->shutdown) {
> 			result = -ENODEV;
> 			break;
> 		}
1621a1645
> 	snd_card_unref(substream1->pcm->card);
2099c2123,2126
< 	return snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);
---
> 	err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_PLAYBACK);
> 	if (pcm)
> 		snd_card_unref(pcm->card);
> 	return err;
2110c2137,2140
< 	return snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_CAPTURE);
---
> 	err = snd_pcm_open(file, pcm, SNDRV_PCM_STREAM_CAPTURE);
> 	if (pcm)
> 		snd_card_unref(pcm->card);
> 	return err;
2147a2178,2181
> 		if (pcm->card->shutdown) {
> 			err = -ENODEV;
> 			break;
> 		}
2561a2596,2600
> 	/*add by qiuen for volume*/	
> 	case SNDRV_PCM_IOCTL_VOL:
> 		snd_pcm_vol(substream, (int)(unsigned long)arg);
> 		return 0;
> 	/**********end***********/
2573a2613,2616
> #ifdef	CONFIG_FB_MIRRORING
> int (*audio_data_to_mirroring)(void* data,int size,int channel) = NULL;
> EXPORT_SYMBOL(audio_data_to_mirroring);
> #endif
2595a2639,2645
> 		#ifdef	CONFIG_FB_MIRRORING
> 		
> 		if(audio_data_to_mirroring!=NULL)
> 		 	audio_data_to_mirroring(xferi.buf, xferi.frames*4,2);
> 		
> 		#endif
> 




diff -r linux-3.0.36/sound/core/rawmidi.c linux-3.0.36-lenovo/sound/core/rawmidi.c
397c397,398
< 	if (!try_module_get(rmidi->card->module))
---
> 	if (!try_module_get(rmidi->card->module)) {
> 		snd_card_unref(rmidi->card);
398a400
> 	}
439a442,445
> 		if (rmidi->card->shutdown) {
> 			err = -ENODEV;
> 			break;
> 		}
457a464
> 	snd_card_unref(rmidi->card);
464a472
> 	snd_card_unref(rmidi->card);
1008a1017,1018
> 			if (rfile->rmidi->card->shutdown)
> 				return -ENODEV;
1251a1262,1263
> 			if (rfile->rmidi->card->shutdown)
> 				return -ENODEV;
1626a1639
> 	int dir;
1628a1642,1643
> 	mutex_lock(&rmidi->open_mutex);
> 	wake_up(&rmidi->open_wait);
1629a1645,1652
> 	for (dir = 0; dir < 2; dir++) {
> 		struct snd_rawmidi_substream *s;
> 		list_for_each_entry(s, &rmidi->streams[dir].substreams, list) {
> 			if (s->runtime)
> 				wake_up(&s->runtime->sleep);
> 		}
> 	}
> 
1643a1667
> 	mutex_unlock(&rmidi->open_mutex);




diff -r linux-3.0.36/sound/core/sound.c linux-3.0.36-lenovo/sound/core/sound.c
101a102,105
>  *
>  * This function increments the reference counter of the card instance
>  * if an associated instance with the given minor number and type is found.
>  * The caller must call snd_card_unref() appropriately later.
112c116
< 	if (mreg && mreg->type == type)
---
> 	if (mreg && mreg->type == type) {
114c118,120
< 	else
---
> 		if (private_data && mreg->card_ptr)
> 			atomic_inc(&mreg->card_ptr->refcount);
> 	} else
277a284
> 	preg->card_ptr = card;




diff -r linux-3.0.36/sound/core/sound_oss.c linux-3.0.36-lenovo/sound/core/sound_oss.c
41a42,44
> /* NOTE: This function increments the refcount of the associated card like
>  * snd_lookup_minor_data(); the caller must call snd_card_unref() appropriately
>  */
51c54
< 	if (mreg && mreg->type == type)
---
> 	if (mreg && mreg->type == type) {
53c56,58
< 	else
---
> 		if (private_data && mreg->card_ptr)
> 			atomic_inc(&mreg->card_ptr->refcount);
> 	} else
124a130
> 	preg->card_ptr = card;




diff -r linux-3.0.36/sound/drivers/aloop.c linux-3.0.36-lenovo/sound/drivers/aloop.c
121a122
> 	spinlock_t timer_lock;
171a173
> 	spin_lock(&dpcm->timer_lock);
183a186
> 	spin_unlock(&dpcm->timer_lock);
187a191
> 	spin_lock(&dpcm->timer_lock);
189a194
> 	spin_unlock(&dpcm->timer_lock);
660a666
> 	spin_lock_init(&dpcm->timer_lock);




diff -r linux-3.0.36/sound/drivers/mpu401/mpu401_uart.c linux-3.0.36-lenovo/sound/drivers/mpu401/mpu401_uart.c
556a557
> 	mpu->irq = -1;




diff -r linux-3.0.36/sound/pci/ac97/ac97_codec.c linux-3.0.36-lenovo/sound/pci/ac97/ac97_codec.c
1273a1274,1275
> 	if (!kctl)
> 		return -ENOMEM;




diff -r linux-3.0.36/sound/pci/emu10k1/emu10k1_main.c linux-3.0.36-lenovo/sound/pci/emu10k1/emu10k1_main.c
1417a1418,1426
> 	/* Tested by Maxim Kachur <mcdebugger@duganet.ru> 17th Oct 2012. */
> 	/* This is MAEM8986, 0202 is MAEM8980 */
> 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x40071102,
> 	 .driver = "Audigy2", .name = "E-mu 1010 PCIe [MAEM8986]",
> 	 .id = "EMU1010",
> 	 .emu10k2_chip = 1,
> 	 .ca0108_chip = 1,
> 	 .spk71 = 1,
> 	 .emu_model = EMU_MODEL_EMU1010B}, /* EMU 1010 PCIe */




diff -r linux-3.0.36/sound/pci/hda/hda_proc.c linux-3.0.36-lenovo/sound/pci/hda/hda_proc.c
409c409
< 		snd_iprintf(buffer, " Copyright");
---
> 		snd_iprintf(buffer, " Non-Copyright");




diff -r linux-3.0.36/sound/pci/hda/patch_analog.c linux-3.0.36-lenovo/sound/pci/hda/patch_analog.c
467a468
> 		codec->spdif_status_reset = 1;




diff -r linux-3.0.36/sound/pci/hda/patch_cirrus.c linux-3.0.36-lenovo/sound/pci/hda/patch_cirrus.c
994c994
< 	{0x11, AC_VERB_SET_COEF_INDEX, IDX_DAC_CFG},
---
> 	{0x11, AC_VERB_SET_COEF_INDEX, IDX_BEEP_CFG},




diff -r linux-3.0.36/sound/pci/hda/patch_realtek.c linux-3.0.36-lenovo/sound/pci/hda/patch_realtek.c
5969a5970
> 	SND_PCI_QUIRK(0x1043, 0x103c, "ASUS", 1),
20134a20136,20140
> 	{ .id = 0x10ec0280, .name = "ALC280", .patch = patch_alc269 },
> 	{ .id = 0x10ec0282, .name = "ALC282", .patch = patch_alc269 },
> 	{ .id = 0x10ec0283, .name = "ALC283", .patch = patch_alc269 },
> 	{ .id = 0x10ec0290, .name = "ALC290", .patch = patch_alc269 },
> 	{ .id = 0x10ec0292, .name = "ALC292", .patch = patch_alc269 },




diff -r linux-3.0.36/sound/pci/ice1712/prodigy_hifi.c linux-3.0.36-lenovo/sound/pci/ice1712/prodigy_hifi.c
299a300
> static const DECLARE_TLV_DB_LINEAR(ak4396_db_scale, TLV_DB_GAIN_MUTE, 0);
310c311
< 	.tlv = { .p = db_scale_wm_dac },
---
> 	.tlv = { .p = ak4396_db_scale },




diff -r linux-3.0.36/sound/pcmcia/pdaudiocf/pdaudiocf.c linux-3.0.36-lenovo/sound/pcmcia/pdaudiocf/pdaudiocf.c
226c226
< 	ret = pcmcia_request_exclusive_irq(link, pdacf_interrupt);
---
> 	ret = pcmcia_request_irq(link, pdacf_interrupt);




diff -r linux-3.0.36/sound/pcmcia/vx/vxpocket.c linux-3.0.36-lenovo/sound/pcmcia/vx/vxpocket.c
232c232
< 	ret = pcmcia_request_exclusive_irq(link, snd_vx_irq_handler);
---
> 	ret = pcmcia_request_irq(link, snd_vx_irq_handler);
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic3262_codec_ops.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic3262_codec_ops.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic326x_tiload.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic326x_tiload.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic3xxx_cfw.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic3xxx_cfw_ops.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: aic3xxx_cfw_ops.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: cs42l52.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: cs42l52.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: es8323.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: es8323.h




diff -r linux-3.0.36/sound/soc/codecs/Kconfig linux-3.0.36-lenovo/sound/soc/codecs/Kconfig
28a29
> 	select SND_SOC_CS42L52 if I2C
33a35
> 	select SND_SOC_ES8323 if SND_SOC_I2C_AND_SPI
51a54
> 	select SND_SOC_TLV320AIC3111 if I2C
75a79,89
> 	select SND_SOC_RT5621 if I2C
> 	select SND_SOC_RT5631 if I2C
> 	select SND_SOC_RT5631_PHONE if I2C
> 	select SND_SOC_RT5625 if I2C
> 	select SND_SOC_RT5640 if I2C
> 	select SND_SOC_RT3261 if I2C
> 	select SND_SOC_RT3224 if I2C
> 	select SND_SOC_RT3224_MID if I2C
> 	select SND_SOC_RT5623 if I2C
> 	select SND_SOC_RK610 if I2C
> 	select SND_SOC_RK616 if I2C
160a175,177
> config SND_SOC_CS42L52
> 	tristate
> 
193a211,212
> config SND_SOC_ES8323
> 	tristate
237a257,262
> config SND_SOC_TLV320AIC3111
> 	tristate
> 
> config SND_SOC_TLV320AIC326X
> 	tristate
> 
307a333,365
> config SND_SOC_RT5621
> 	tristate
> 
> config SND_SOC_RT5623
> 	tristate
> 
> config SND_SOC_RT5631
> 	tristate
> 	
> config SND_SOC_RT5631_PHONE
> 	tristate
> 	
> config SND_SOC_RT5625
> 	tristate
> 
> config SND_SOC_RT5640
> 	select SND_HWDEP
> 	tristate
> 
> config SND_SOC_RT3224_MID
> 	tristate
> 
> config SND_SOC_REALTEK_COMBINE
> 	tristate
> 
> config SND_SOC_RT3224
> 	select SND_HWDEP
> 	tristate
> 
> config SND_SOC_RT3261
> 	select SND_HWDEP
> 	tristate
> 
373a432,443
> config SND_SOC_RK1000
> 	tristate
> #	depends on RK1000_CONTROL
> 
> config SND_SOC_RK610
> 	tristate
> 	depends on MFD_RK610
> 
> config SND_SOC_RK616
> 	tristate
> 	depends on MFD_RK616
> 
388a459,462
> 
> config SND_SOC_RK2928
> 	tristate
> 	depends on ARCH_RK2928




diff -r linux-3.0.36/sound/soc/codecs/Makefile linux-3.0.36-lenovo/sound/soc/codecs/Makefile
20a21
> snd-soc-es8323-objs := es8323.o
35a37
> snd-soc-tlv320aic3111-objs := tlv320aic3111.o
36a39
> snd-soc-tlv320aic326x-objs := tlv320aic326x.o aic326x_tiload.o aic3xxx_cfw_ops.o aic3262_codec_ops.o
59a63,68
> snd-soc-rt5621-objs := rt5621.o
> snd-soc-rt5623-objs := rt5623.o
> snd-soc-rt5631-objs := rt5631.o
> snd-soc-rt5631-phone-objs := rt5631_phone.o
> snd-soc-rt5625-objs := rt5625.o
> snd-soc-cs42l52-objs := cs42l52.o
82a92
> snd-soc-rk1000-objs := rk1000_codec.o
83a94,102
> snd-soc-rk610-objs := rk610_codec.o
> snd-soc-rt5640-objs := rt5640.o rt5640-dsp.o #rt5640_ioctl.o rt56xx_ioctl.o
> snd-soc-rk616-objs := rk616_codec.o
> 
> snd-soc-rt3261-objs := rt3261.o rt3261-dsp.o #rt3261_ioctl.o rt_codec_ioctl.o
> snd-soc-rt3224-objs := rt3261.o #rt3261_ioctl.o rt_codec_ioctl.o
> snd-soc-rt3224-mid-objs := rt3261-mid.o #rt3261_ioctl.o rt_codec_ioctl.o
> #snd-soc-realtek-combine-objs := rt3261-mid.o rt5640.o rt5640-dsp.o #rt5640_ioctl.o rt56xx_ioctl.o #rt3261_ioctl.o rt_codec_ioctl.o
> snd-soc-rk2928-objs := rk2928_codec.o
91c110,114
< 
---
> obj-$(CONFIG_SND_SOC_RT5640)    += snd-soc-rt5640.o
> obj-$(CONFIG_SND_SOC_RT3261)    += snd-soc-rt3261.o
> obj-$(CONFIG_SND_SOC_RT3224)    += snd-soc-rt3224.o
> obj-$(CONFIG_SND_SOC_RT3224_MID)    += snd-soc-rt3224-mid.o
> #obj-$(CONFIG_SND_SOC_REALTEK_COMBINE) += snd-soc-realtek-combine.o
112a136
> obj-$(CONFIG_SND_SOC_ES8323)	+= snd-soc-es8323.o
127a152
> obj-$(CONFIG_SND_SOC_TLV320AIC3111)	+= snd-soc-tlv320aic3111.o
128a154
> obj-$(CONFIG_SND_SOC_TLV320AIC326X)	+= snd-soc-tlv320aic326x.o
151a178,183
> obj-$(CONFIG_SND_SOC_RT5621)	+= snd-soc-rt5621.o
> obj-$(CONFIG_SND_SOC_RT5623)	+= snd-soc-rt5623.o
> obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
> obj-$(CONFIG_SND_SOC_RT5631_PHONE)	+= snd-soc-rt5631-phone.o
> obj-$(CONFIG_SND_SOC_RT5625)	+= snd-soc-rt5625.o
> obj-$(CONFIG_SND_SOC_CS42L52)	+= snd-soc-cs42l52.o
174a207,210
> obj-$(CONFIG_SND_SOC_RK1000)	+= snd-soc-rk1000.o
> obj-$(CONFIG_SND_SOC_RK610)	+= snd-soc-rk610.o
> obj-$(CONFIG_SND_SOC_RK616)	+= snd-soc-rk616.o
> obj-$(CONFIG_SND_SOC_RK2928)	+= snd-soc-rk2928.o
Only in linux-3.0.36-lenovo/sound/soc/codecs: pickle.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk1000_codec.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk1000_codec.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk2928_codec.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk2928_codec.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk610_codec.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk610_codec.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk616_codec.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rk616_codec.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261-dsp.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261-dsp.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261_ioctl.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261_ioctl.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt3261-mid.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5621.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5621.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5623.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5623.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5625.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5625.c.enc
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5625.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5631.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5631.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5631_phone.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5631_phone.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640-dsp.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640-dsp.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640_ioctl.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt5640_ioctl.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt56xx_ioctl.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt56xx_ioctl.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt_codec_ioctl.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: rt_codec_ioctl.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: tlv320aic3111.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: tlv320aic3111.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: tlv320aic3262_default_fw.h
Only in linux-3.0.36-lenovo/sound/soc/codecs: tlv320aic326x.c
Only in linux-3.0.36-lenovo/sound/soc/codecs: tlv320aic326x.h




diff -r linux-3.0.36/sound/soc/codecs/tlv320aic3x.c linux-3.0.36-lenovo/sound/soc/codecs/tlv320aic3x.c
952,954c952
< 	data = snd_soc_read(codec, AIC3X_PLL_PROGA_REG);
< 	snd_soc_write(codec, AIC3X_PLL_PROGA_REG,
< 		      data | (pll_p << PLLP_SHIFT));
---
> 	snd_soc_update_bits(codec, AIC3X_PLL_PROGA_REG, PLLP_MASK, pll_p);




diff -r linux-3.0.36/sound/soc/codecs/tlv320aic3x.h linux-3.0.36-lenovo/sound/soc/codecs/tlv320aic3x.h
168a169
> #define PLLP_MASK		7




diff -r linux-3.0.36/sound/soc/codecs/wm2000.c linux-3.0.36-lenovo/sound/soc/codecs/wm2000.c
227,228d226
< 		ret &= ~WM2000_SPEECH_CLARITY;
< 	else
229a228,229
> 	else
> 		ret &= ~WM2000_SPEECH_CLARITY;




diff -r linux-3.0.36/sound/soc/codecs/wm8900.c linux-3.0.36-lenovo/sound/soc/codecs/wm8900.c
26d25
< #include <linux/spi/spi.h>
32a32
> #include <sound/soc-dapm.h>
34a35,37
> #include <mach/gpio.h>
> #include <mach/irqs.h>
> #include <mach/rk29_iomap.h>
37a41,47
> 
> #if 0
> #define	WM8900_DBG(x...)	printk(KERN_INFO x)
> #else
> #define	WM8900_DBG(x...)
> #endif
> 
116,117c126,127
< #define WM8900_REG_CLOCKING2_ADC_CLKDIV 0xe0
< #define WM8900_REG_CLOCKING2_DAC_CLKDIV 0x1c
---
> #define WM8900_REG_CLOCKING2_ADC_CLKDIV 0x1c
> #define WM8900_REG_CLOCKING2_DAC_CLKDIV 0xe0
138a149,172
> #define SPK_CON 		RK29_PIN6_PB6
> 
> #define WM8900_NO_POWEROFF /* Do not close codec except suspend or poweroff */
> 
> #define WM8900_IS_SHUTDOWN	0
> #define WM8900_IS_STARTUP	1
> 
> #define WM8900_WORK_NULL	0
> #define WM8900_WORK_POWERDOWN_PLAYBACK	1
> #define WM8900_WORK_POWERDOWN_CAPTURE	2
> #define WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE	3
> #define WM8900_WORK_HW_SET 4
> 
> static void wm8900_work(struct work_struct *work);
> 
> static struct workqueue_struct *wm8900_workq;
> static DECLARE_DELAYED_WORK(delayed_work, wm8900_work);
> static int wm8900_current_status = WM8900_IS_SHUTDOWN, wm8900_work_type = WM8900_WORK_NULL;
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> static struct snd_soc_codec_driver soc_codec_dev_wm8900;
> #endif
> static struct snd_soc_codec *wm8900_codec;
> static bool isSPKon = true;
140a175
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
141a177,180
> #endif
> 	struct snd_soc_codec codec;
> 
> 	u16 reg_cache[WM8900_MAXREG];
182a222
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
183a224,226
> #else
> static int wm8900_volatile_register(unsigned int reg)
> #endif
194a238,239
> 	WM8900_DBG("Enter:%s, %d, codec=%p\n", __FUNCTION__, __LINE__,codec);
> 
201,202c246
< static int wm8900_hp_event(struct snd_soc_dapm_widget *w,
< 			   struct snd_kcontrol *kcontrol, int event)
---
> void codec_set_spk(bool on)
204,259c248,256
< 	struct snd_soc_codec *codec = w->codec;
< 	u16 hpctl1 = snd_soc_read(codec, WM8900_REG_HPCTL1);
< 
< 	switch (event) {
< 	case SND_SOC_DAPM_PRE_PMU:
< 		/* Clamp headphone outputs */
< 		hpctl1 = WM8900_REG_HPCTL1_HP_CLAMP_IP |
< 			WM8900_REG_HPCTL1_HP_CLAMP_OP;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 		break;
< 
< 	case SND_SOC_DAPM_POST_PMU:
< 		/* Enable the input stage */
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_IP;
< 		hpctl1 |= WM8900_REG_HPCTL1_HP_SHORT |
< 			WM8900_REG_HPCTL1_HP_SHORT2 |
< 			WM8900_REG_HPCTL1_HP_IPSTAGE_ENA;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 
< 		msleep(400);
< 
< 		/* Enable the output stage */
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_CLAMP_OP;
< 		hpctl1 |= WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 
< 		/* Remove the shorts */
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT2;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_SHORT;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 		break;
< 
< 	case SND_SOC_DAPM_PRE_PMD:
< 		/* Short the output */
< 		hpctl1 |= WM8900_REG_HPCTL1_HP_SHORT;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 
< 		/* Disable the output stage */
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_OPSTAGE_ENA;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 
< 		/* Clamp the outputs and power down input */
< 		hpctl1 |= WM8900_REG_HPCTL1_HP_CLAMP_IP |
< 			WM8900_REG_HPCTL1_HP_CLAMP_OP;
< 		hpctl1 &= ~WM8900_REG_HPCTL1_HP_IPSTAGE_ENA;
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, hpctl1);
< 		break;
< 
< 	case SND_SOC_DAPM_POST_PMD:
< 		/* Disable everything */
< 		snd_soc_write(codec, WM8900_REG_HPCTL1, 0);
< 		break;
< 
< 	default:
< 		BUG();
---
> 	isSPKon = on;
> 	if (on) {
> #ifdef SPK_CON
> 		gpio_set_value(SPK_CON, GPIO_HIGH);
> #endif
> 	} else {
> #ifdef SPK_CON
> 		gpio_set_value(SPK_CON, GPIO_LOW);
> #endif
261,262d257
< 
< 	return 0;
265,296c260
< static const DECLARE_TLV_DB_SCALE(out_pga_tlv, -5700, 100, 0);
< 
< static const DECLARE_TLV_DB_SCALE(out_mix_tlv, -1500, 300, 0);
< 
< static const DECLARE_TLV_DB_SCALE(in_boost_tlv, -1200, 600, 0);
< 
< static const DECLARE_TLV_DB_SCALE(in_pga_tlv, -1200, 100, 0);
< 
< static const DECLARE_TLV_DB_SCALE(dac_boost_tlv, 0, 600, 0);
< 
< static const DECLARE_TLV_DB_SCALE(dac_tlv, -7200, 75, 1);
< 
< static const DECLARE_TLV_DB_SCALE(adc_svol_tlv, -3600, 300, 0);
< 
< static const DECLARE_TLV_DB_SCALE(adc_tlv, -7200, 75, 1);
< 
< static const char *mic_bias_level_txt[] = { "0.9*AVDD", "0.65*AVDD" };
< 
< static const struct soc_enum mic_bias_level =
< SOC_ENUM_SINGLE(WM8900_REG_INCTL, 8, 2, mic_bias_level_txt);
< 
< static const char *dac_mute_rate_txt[] = { "Fast", "Slow" };
< 
< static const struct soc_enum dac_mute_rate =
< SOC_ENUM_SINGLE(WM8900_REG_DACCTRL, 7, 2, dac_mute_rate_txt);
< 
< static const char *dac_deemphasis_txt[] = {
< 	"Disabled", "32kHz", "44.1kHz", "48kHz"
< };
< 
< static const struct soc_enum dac_deemphasis =
< SOC_ENUM_SINGLE(WM8900_REG_DACCTRL, 4, 4, dac_deemphasis_txt);
---
> EXPORT_SYMBOL_GPL(codec_set_spk);
298,426c262,267
< static const char *adc_hpf_cut_txt[] = {
< 	"Hi-fi mode", "Voice mode 1", "Voice mode 2", "Voice mode 3"
< };
< 
< static const struct soc_enum adc_hpf_cut =
< SOC_ENUM_SINGLE(WM8900_REG_ADCCTRL, 5, 4, adc_hpf_cut_txt);
< 
< static const char *lr_txt[] = {
< 	"Left", "Right"
< };
< 
< static const struct soc_enum aifl_src =
< SOC_ENUM_SINGLE(WM8900_REG_AUDIO1, 15, 2, lr_txt);
< 
< static const struct soc_enum aifr_src =
< SOC_ENUM_SINGLE(WM8900_REG_AUDIO1, 14, 2, lr_txt);
< 
< static const struct soc_enum dacl_src =
< SOC_ENUM_SINGLE(WM8900_REG_AUDIO2, 15, 2, lr_txt);
< 
< static const struct soc_enum dacr_src =
< SOC_ENUM_SINGLE(WM8900_REG_AUDIO2, 14, 2, lr_txt);
< 
< static const char *sidetone_txt[] = {
< 	"Disabled", "Left ADC", "Right ADC"
< };
< 
< static const struct soc_enum dacl_sidetone =
< SOC_ENUM_SINGLE(WM8900_REG_SIDETONE, 2, 3, sidetone_txt);
< 
< static const struct soc_enum dacr_sidetone =
< SOC_ENUM_SINGLE(WM8900_REG_SIDETONE, 0, 3, sidetone_txt);
< 
< static const struct snd_kcontrol_new wm8900_snd_controls[] = {
< SOC_ENUM("Mic Bias Level", mic_bias_level),
< 
< SOC_SINGLE_TLV("Left Input PGA Volume", WM8900_REG_LINVOL, 0, 31, 0,
< 	       in_pga_tlv),
< SOC_SINGLE("Left Input PGA Switch", WM8900_REG_LINVOL, 6, 1, 1),
< SOC_SINGLE("Left Input PGA ZC Switch", WM8900_REG_LINVOL, 7, 1, 0),
< 
< SOC_SINGLE_TLV("Right Input PGA Volume", WM8900_REG_RINVOL, 0, 31, 0,
< 	       in_pga_tlv),
< SOC_SINGLE("Right Input PGA Switch", WM8900_REG_RINVOL, 6, 1, 1),
< SOC_SINGLE("Right Input PGA ZC Switch", WM8900_REG_RINVOL, 7, 1, 0),
< 
< SOC_SINGLE("DAC Soft Mute Switch", WM8900_REG_DACCTRL, 6, 1, 1),
< SOC_ENUM("DAC Mute Rate", dac_mute_rate),
< SOC_SINGLE("DAC Mono Switch", WM8900_REG_DACCTRL, 9, 1, 0),
< SOC_ENUM("DAC Deemphasis", dac_deemphasis),
< SOC_SINGLE("DAC Sigma-Delta Modulator Clock Switch", WM8900_REG_DACCTRL,
< 	   12, 1, 0),
< 
< SOC_SINGLE("ADC HPF Switch", WM8900_REG_ADCCTRL, 8, 1, 0),
< SOC_ENUM("ADC HPF Cut-Off", adc_hpf_cut),
< SOC_DOUBLE("ADC Invert Switch", WM8900_REG_ADCCTRL, 1, 0, 1, 0),
< SOC_SINGLE_TLV("Left ADC Sidetone Volume", WM8900_REG_SIDETONE, 9, 12, 0,
< 	       adc_svol_tlv),
< SOC_SINGLE_TLV("Right ADC Sidetone Volume", WM8900_REG_SIDETONE, 5, 12, 0,
< 	       adc_svol_tlv),
< SOC_ENUM("Left Digital Audio Source", aifl_src),
< SOC_ENUM("Right Digital Audio Source", aifr_src),
< 
< SOC_SINGLE_TLV("DAC Input Boost Volume", WM8900_REG_AUDIO2, 10, 4, 0,
< 	       dac_boost_tlv),
< SOC_ENUM("Left DAC Source", dacl_src),
< SOC_ENUM("Right DAC Source", dacr_src),
< SOC_ENUM("Left DAC Sidetone", dacl_sidetone),
< SOC_ENUM("Right DAC Sidetone", dacr_sidetone),
< SOC_DOUBLE("DAC Invert Switch", WM8900_REG_DACCTRL, 1, 0, 1, 0),
< 
< SOC_DOUBLE_R_TLV("Digital Playback Volume",
< 		 WM8900_REG_LDAC_DV, WM8900_REG_RDAC_DV,
< 		 1, 96, 0, dac_tlv),
< SOC_DOUBLE_R_TLV("Digital Capture Volume",
< 		 WM8900_REG_LADC_DV, WM8900_REG_RADC_DV, 1, 119, 0, adc_tlv),
< 
< SOC_SINGLE_TLV("LINPUT3 Bypass Volume", WM8900_REG_LOUTMIXCTL1, 4, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("RINPUT3 Bypass Volume", WM8900_REG_ROUTMIXCTL1, 4, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("Left AUX Bypass Volume", WM8900_REG_AUXOUT_CTL, 4, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("Right AUX Bypass Volume", WM8900_REG_AUXOUT_CTL, 0, 7, 0,
< 	       out_mix_tlv),
< 
< SOC_SINGLE_TLV("LeftIn to RightOut Mixer Volume", WM8900_REG_BYPASS1, 0, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("LeftIn to LeftOut Mixer Volume", WM8900_REG_BYPASS1, 4, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("RightIn to LeftOut Mixer Volume", WM8900_REG_BYPASS2, 0, 7, 0,
< 	       out_mix_tlv),
< SOC_SINGLE_TLV("RightIn to RightOut Mixer Volume", WM8900_REG_BYPASS2, 4, 7, 0,
< 	       out_mix_tlv),
< 
< SOC_SINGLE_TLV("IN2L Boost Volume", WM8900_REG_INBOOSTMIX1, 0, 3, 0,
< 	       in_boost_tlv),
< SOC_SINGLE_TLV("IN3L Boost Volume", WM8900_REG_INBOOSTMIX1, 4, 3, 0,
< 	       in_boost_tlv),
< SOC_SINGLE_TLV("IN2R Boost Volume", WM8900_REG_INBOOSTMIX2, 0, 3, 0,
< 	       in_boost_tlv),
< SOC_SINGLE_TLV("IN3R Boost Volume", WM8900_REG_INBOOSTMIX2, 4, 3, 0,
< 	       in_boost_tlv),
< SOC_SINGLE_TLV("Left AUX Boost Volume", WM8900_REG_AUXBOOST, 4, 3, 0,
< 	       in_boost_tlv),
< SOC_SINGLE_TLV("Right AUX Boost Volume", WM8900_REG_AUXBOOST, 0, 3, 0,
< 	       in_boost_tlv),
< 
< SOC_DOUBLE_R_TLV("LINEOUT1 Volume", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
< 	       0, 63, 0, out_pga_tlv),
< SOC_DOUBLE_R("LINEOUT1 Switch", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
< 	     6, 1, 1),
< SOC_DOUBLE_R("LINEOUT1 ZC Switch", WM8900_REG_LOUT1CTL, WM8900_REG_ROUT1CTL,
< 	     7, 1, 0),
< 
< SOC_DOUBLE_R_TLV("LINEOUT2 Volume",
< 		 WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL,
< 		 0, 63, 0, out_pga_tlv),
< SOC_DOUBLE_R("LINEOUT2 Switch",
< 	     WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL, 6, 1, 1),
< SOC_DOUBLE_R("LINEOUT2 ZC Switch",
< 	     WM8900_REG_LOUT2CTL, WM8900_REG_ROUT2CTL, 7, 1, 0),
< SOC_SINGLE("LINEOUT2 LP -12dB", WM8900_REG_LOUTMIXCTL1,
< 	   0, 1, 1),
< 
< };
< 
< static const struct snd_kcontrol_new wm8900_dapm_loutput2_control =
< SOC_DAPM_SINGLE("LINEOUT2L Switch", WM8900_REG_POWER3, 6, 1, 0);
---
> static void wm8900_powerdown(void)
> {
> 	printk("Power down wm8900\n");
> #ifndef WM8900_NO_POWEROFF
> 	gpio_set_value(RK29_PIN1_PD6, GPIO_LOW);
> #endif
428,429c269
< static const struct snd_kcontrol_new wm8900_dapm_routput2_control =
< SOC_DAPM_SINGLE("LINEOUT2R Switch", WM8900_REG_POWER3, 5, 1, 0);
---
> 	snd_soc_write(wm8900_codec, WM8900_REG_POWER1, 0x210D);
431,437c271,279
< static const struct snd_kcontrol_new wm8900_loutmix_controls[] = {
< SOC_DAPM_SINGLE("LINPUT3 Bypass Switch", WM8900_REG_LOUTMIXCTL1, 7, 1, 0),
< SOC_DAPM_SINGLE("AUX Bypass Switch", WM8900_REG_AUXOUT_CTL, 7, 1, 0),
< SOC_DAPM_SINGLE("Left Input Mixer Switch", WM8900_REG_BYPASS1, 7, 1, 0),
< SOC_DAPM_SINGLE("Right Input Mixer Switch", WM8900_REG_BYPASS2, 3, 1, 0),
< SOC_DAPM_SINGLE("DACL Switch", WM8900_REG_LOUTMIXCTL1, 8, 1, 0),
< };
---
> 	if (wm8900_current_status != WM8900_IS_SHUTDOWN) {
> #ifdef SPK_CON
> 		gpio_set_value(SPK_CON, GPIO_LOW);
> #endif
> 		msleep(20);
> 		snd_soc_write(wm8900_codec, WM8900_REG_RESET, 0);
> 		wm8900_current_status = WM8900_IS_SHUTDOWN;
> 	}
> }
439,445c281,283
< static const struct snd_kcontrol_new wm8900_routmix_controls[] = {
< SOC_DAPM_SINGLE("RINPUT3 Bypass Switch", WM8900_REG_ROUTMIXCTL1, 7, 1, 0),
< SOC_DAPM_SINGLE("AUX Bypass Switch", WM8900_REG_AUXOUT_CTL, 3, 1, 0),
< SOC_DAPM_SINGLE("Left Input Mixer Switch", WM8900_REG_BYPASS1, 3, 1, 0),
< SOC_DAPM_SINGLE("Right Input Mixer Switch", WM8900_REG_BYPASS2, 7, 1, 0),
< SOC_DAPM_SINGLE("DACR Switch", WM8900_REG_ROUTMIXCTL1, 8, 1, 0),
< };
---
> static void wm8900_set_hw(struct snd_soc_codec *codec)
> {
> 	u16 reg;
447,452c285,286
< static const struct snd_kcontrol_new wm8900_linmix_controls[] = {
< SOC_DAPM_SINGLE("LINPUT2 Switch", WM8900_REG_INBOOSTMIX1, 2, 1, 1),
< SOC_DAPM_SINGLE("LINPUT3 Switch", WM8900_REG_INBOOSTMIX1, 6, 1, 1),
< SOC_DAPM_SINGLE("AUX Switch", WM8900_REG_AUXBOOST, 6, 1, 1),
< SOC_DAPM_SINGLE("Input PGA Switch", WM8900_REG_ADCPATH, 6, 1, 0),
< };
---
> 	if (wm8900_current_status & WM8900_IS_STARTUP)
> 		return;
454,459c288,321
< static const struct snd_kcontrol_new wm8900_rinmix_controls[] = {
< SOC_DAPM_SINGLE("RINPUT2 Switch", WM8900_REG_INBOOSTMIX2, 2, 1, 1),
< SOC_DAPM_SINGLE("RINPUT3 Switch", WM8900_REG_INBOOSTMIX2, 6, 1, 1),
< SOC_DAPM_SINGLE("AUX Switch", WM8900_REG_AUXBOOST, 2, 1, 1),
< SOC_DAPM_SINGLE("Input PGA Switch", WM8900_REG_ADCPATH, 2, 1, 0),
< };
---
> 	printk("Power up wm8900\n");
> //CLK , PATH, VOL,POW.
> 	
> 	snd_soc_write(codec, WM8900_REG_HPCTL1, 0x30);
> 	snd_soc_write(codec, WM8900_REG_POWER1, 0x0100);
> 	snd_soc_write(codec, WM8900_REG_POWER3, 0x60);
> 	snd_soc_write(codec, WM8900_REG_POWER1, 0x0101);
> 	msleep(400);
> 	snd_soc_write(codec, WM8900_REG_POWER1, 0x0109);
> 	snd_soc_write(codec, WM8900_REG_ADDCTL, 0x02);
> 	snd_soc_write(codec, WM8900_REG_POWER1, 0x09);
> 	snd_soc_write(codec, WM8900_REG_POWER3, 0xEF);
> 	snd_soc_write(codec, WM8900_REG_DACCTRL, WM8900_REG_DACCTRL_MUTE);
> 	snd_soc_write(codec, WM8900_REG_LOUTMIXCTL1, 0x150);
> 	snd_soc_write(codec, WM8900_REG_ROUTMIXCTL1, 0x150);
> 
> 	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xB0);
> 	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xF0);
> 	snd_soc_write(codec, WM8900_REG_HPCTL1, 0xC0);
> 
> 	//for recorder
> 	snd_soc_write(codec, WM8900_REG_POWER1, 0x210D);
> 	snd_soc_write(codec, WM8900_REG_POWER2, 0xC1AF);
> 
> 	snd_soc_write(codec, WM8900_REG_LADC_DV, 0x01C0);
> 	snd_soc_write(codec, WM8900_REG_RADC_DV, 0x01C0);
> 
> 	snd_soc_write(codec, WM8900_REG_INCTL, 0x0040);
> 
> 	snd_soc_write(codec, WM8900_REG_LINVOL, 0x011A);
> 	snd_soc_write(codec, WM8900_REG_RINVOL, 0x011A);
> 	snd_soc_write(codec, WM8900_REG_INBOOSTMIX1, 0x0042);
> 	snd_soc_write(codec, WM8900_REG_INBOOSTMIX2, 0x0042);
> 	snd_soc_write(codec, WM8900_REG_ADCPATH, 0x0055);
461,465c323
< static const struct snd_kcontrol_new wm8900_linpga_controls[] = {
< SOC_DAPM_SINGLE("LINPUT1 Switch", WM8900_REG_INCTL, 6, 1, 0),
< SOC_DAPM_SINGLE("LINPUT2 Switch", WM8900_REG_INCTL, 5, 1, 0),
< SOC_DAPM_SINGLE("LINPUT3 Switch", WM8900_REG_INCTL, 4, 1, 0),
< };
---
> 	reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
467,471c325,326
< static const struct snd_kcontrol_new wm8900_rinpga_controls[] = {
< SOC_DAPM_SINGLE("RINPUT1 Switch", WM8900_REG_INCTL, 2, 1, 0),
< SOC_DAPM_SINGLE("RINPUT2 Switch", WM8900_REG_INCTL, 1, 1, 0),
< SOC_DAPM_SINGLE("RINPUT3 Switch", WM8900_REG_INCTL, 0, 1, 0),
< };
---
> 	reg &= ~WM8900_REG_DACCTRL_MUTE;
> 	snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
473c328,329
< static const char *wm9700_lp_mux[] = { "Disabled", "Enabled" };
---
> 	snd_soc_write(codec, WM8900_REG_LOUT1CTL, 0x130);
> 	snd_soc_write(codec, WM8900_REG_ROUT1CTL, 0x130);
475,476c331
< static const struct soc_enum wm8900_lineout2_lp_mux =
< SOC_ENUM_SINGLE(WM8900_REG_LOUTMIXCTL1, 1, 2, wm9700_lp_mux);
---
> 	/* Turn up vol slowly, for HP out pop noise */
478,479c333,339
< static const struct snd_kcontrol_new wm8900_lineout2_lp =
< SOC_DAPM_ENUM("Route", wm8900_lineout2_lp_mux);
---
> 	for (reg = 0; reg <= 0x33; reg += 0x10) {
> 			snd_soc_write(codec, WM8900_REG_LOUT2CTL, 0x100 + reg);
> 			snd_soc_write(codec, WM8900_REG_ROUT2CTL, 0x100 + reg);
> 			msleep(5);
> 	}
> 	snd_soc_write(codec, WM8900_REG_LOUT2CTL, 0x133);
> 	snd_soc_write(codec, WM8900_REG_ROUT2CTL, 0x133);
481,543c341
< static const struct snd_soc_dapm_widget wm8900_dapm_widgets[] = {
< 
< /* Externally visible pins */
< SND_SOC_DAPM_OUTPUT("LINEOUT1L"),
< SND_SOC_DAPM_OUTPUT("LINEOUT1R"),
< SND_SOC_DAPM_OUTPUT("LINEOUT2L"),
< SND_SOC_DAPM_OUTPUT("LINEOUT2R"),
< SND_SOC_DAPM_OUTPUT("HP_L"),
< SND_SOC_DAPM_OUTPUT("HP_R"),
< 
< SND_SOC_DAPM_INPUT("RINPUT1"),
< SND_SOC_DAPM_INPUT("LINPUT1"),
< SND_SOC_DAPM_INPUT("RINPUT2"),
< SND_SOC_DAPM_INPUT("LINPUT2"),
< SND_SOC_DAPM_INPUT("RINPUT3"),
< SND_SOC_DAPM_INPUT("LINPUT3"),
< SND_SOC_DAPM_INPUT("AUX"),
< 
< SND_SOC_DAPM_VMID("VMID"),
< 
< /* Input */
< SND_SOC_DAPM_MIXER("Left Input PGA", WM8900_REG_POWER2, 3, 0,
< 		   wm8900_linpga_controls,
< 		   ARRAY_SIZE(wm8900_linpga_controls)),
< SND_SOC_DAPM_MIXER("Right Input PGA", WM8900_REG_POWER2, 2, 0,
< 		   wm8900_rinpga_controls,
< 		   ARRAY_SIZE(wm8900_rinpga_controls)),
< 
< SND_SOC_DAPM_MIXER("Left Input Mixer", WM8900_REG_POWER2, 5, 0,
< 		   wm8900_linmix_controls,
< 		   ARRAY_SIZE(wm8900_linmix_controls)),
< SND_SOC_DAPM_MIXER("Right Input Mixer", WM8900_REG_POWER2, 4, 0,
< 		   wm8900_rinmix_controls,
< 		   ARRAY_SIZE(wm8900_rinmix_controls)),
< 
< SND_SOC_DAPM_MICBIAS("Mic Bias", WM8900_REG_POWER1, 4, 0),
< 
< SND_SOC_DAPM_ADC("ADCL", "Left HiFi Capture", WM8900_REG_POWER2, 1, 0),
< SND_SOC_DAPM_ADC("ADCR", "Right HiFi Capture", WM8900_REG_POWER2, 0, 0),
< 
< /* Output */
< SND_SOC_DAPM_DAC("DACL", "Left HiFi Playback", WM8900_REG_POWER3, 1, 0),
< SND_SOC_DAPM_DAC("DACR", "Right HiFi Playback", WM8900_REG_POWER3, 0, 0),
< 
< SND_SOC_DAPM_PGA_E("Headphone Amplifier", WM8900_REG_POWER3, 7, 0, NULL, 0,
< 		   wm8900_hp_event,
< 		   SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
< 		   SND_SOC_DAPM_PRE_PMD | SND_SOC_DAPM_POST_PMD),
< 
< SND_SOC_DAPM_PGA("LINEOUT1L PGA", WM8900_REG_POWER2, 8, 0, NULL, 0),
< SND_SOC_DAPM_PGA("LINEOUT1R PGA", WM8900_REG_POWER2, 7, 0, NULL, 0),
< 
< SND_SOC_DAPM_MUX("LINEOUT2 LP", SND_SOC_NOPM, 0, 0, &wm8900_lineout2_lp),
< SND_SOC_DAPM_PGA("LINEOUT2L PGA", WM8900_REG_POWER3, 6, 0, NULL, 0),
< SND_SOC_DAPM_PGA("LINEOUT2R PGA", WM8900_REG_POWER3, 5, 0, NULL, 0),
< 
< SND_SOC_DAPM_MIXER("Left Output Mixer", WM8900_REG_POWER3, 3, 0,
< 		   wm8900_loutmix_controls,
< 		   ARRAY_SIZE(wm8900_loutmix_controls)),
< SND_SOC_DAPM_MIXER("Right Output Mixer", WM8900_REG_POWER3, 2, 0,
< 		   wm8900_routmix_controls,
< 		   ARRAY_SIZE(wm8900_routmix_controls)),
< };
---
> 	msleep(20);
545,608c343,353
< /* Target, Path, Source */
< static const struct snd_soc_dapm_route audio_map[] = {
< /* Inputs */
< {"Left Input PGA", "LINPUT1 Switch", "LINPUT1"},
< {"Left Input PGA", "LINPUT2 Switch", "LINPUT2"},
< {"Left Input PGA", "LINPUT3 Switch", "LINPUT3"},
< 
< {"Right Input PGA", "RINPUT1 Switch", "RINPUT1"},
< {"Right Input PGA", "RINPUT2 Switch", "RINPUT2"},
< {"Right Input PGA", "RINPUT3 Switch", "RINPUT3"},
< 
< {"Left Input Mixer", "LINPUT2 Switch", "LINPUT2"},
< {"Left Input Mixer", "LINPUT3 Switch", "LINPUT3"},
< {"Left Input Mixer", "AUX Switch", "AUX"},
< {"Left Input Mixer", "Input PGA Switch", "Left Input PGA"},
< 
< {"Right Input Mixer", "RINPUT2 Switch", "RINPUT2"},
< {"Right Input Mixer", "RINPUT3 Switch", "RINPUT3"},
< {"Right Input Mixer", "AUX Switch", "AUX"},
< {"Right Input Mixer", "Input PGA Switch", "Right Input PGA"},
< 
< {"ADCL", NULL, "Left Input Mixer"},
< {"ADCR", NULL, "Right Input Mixer"},
< 
< /* Outputs */
< {"LINEOUT1L", NULL, "LINEOUT1L PGA"},
< {"LINEOUT1L PGA", NULL, "Left Output Mixer"},
< {"LINEOUT1R", NULL, "LINEOUT1R PGA"},
< {"LINEOUT1R PGA", NULL, "Right Output Mixer"},
< 
< {"LINEOUT2L PGA", NULL, "Left Output Mixer"},
< {"LINEOUT2 LP", "Disabled", "LINEOUT2L PGA"},
< {"LINEOUT2 LP", "Enabled", "Left Output Mixer"},
< {"LINEOUT2L", NULL, "LINEOUT2 LP"},
< 
< {"LINEOUT2R PGA", NULL, "Right Output Mixer"},
< {"LINEOUT2 LP", "Disabled", "LINEOUT2R PGA"},
< {"LINEOUT2 LP", "Enabled", "Right Output Mixer"},
< {"LINEOUT2R", NULL, "LINEOUT2 LP"},
< 
< {"Left Output Mixer", "LINPUT3 Bypass Switch", "LINPUT3"},
< {"Left Output Mixer", "AUX Bypass Switch", "AUX"},
< {"Left Output Mixer", "Left Input Mixer Switch", "Left Input Mixer"},
< {"Left Output Mixer", "Right Input Mixer Switch", "Right Input Mixer"},
< {"Left Output Mixer", "DACL Switch", "DACL"},
< 
< {"Right Output Mixer", "RINPUT3 Bypass Switch", "RINPUT3"},
< {"Right Output Mixer", "AUX Bypass Switch", "AUX"},
< {"Right Output Mixer", "Left Input Mixer Switch", "Left Input Mixer"},
< {"Right Output Mixer", "Right Input Mixer Switch", "Right Input Mixer"},
< {"Right Output Mixer", "DACR Switch", "DACR"},
< 
< /* Note that the headphone output stage needs to be connected
<  * externally to LINEOUT2 via DC blocking capacitors.  Other
<  * configurations are not supported.
<  *
<  * Note also that left and right headphone paths are treated as a
<  * mono path.
<  */
< {"Headphone Amplifier", NULL, "LINEOUT2 LP"},
< {"Headphone Amplifier", NULL, "LINEOUT2 LP"},
< {"HP_L", NULL, "Headphone Amplifier"},
< {"HP_R", NULL, "Headphone Amplifier"},
< };
---
> #ifdef SPK_CON
> 	if (isSPKon) {
> 		gpio_set_value(SPK_CON, GPIO_HIGH);
> 	}
> #endif
> #ifndef WM8900_NO_POWEROFF
> 	msleep(350);
> 	gpio_set_value(RK29_PIN1_PD6, GPIO_HIGH);
> #endif
> 	wm8900_current_status |= WM8900_IS_STARTUP;
> }
610c355
< static int wm8900_add_widgets(struct snd_soc_codec *codec)
---
> static void wm8900_work(struct work_struct *work)
612c357
< 	struct snd_soc_dapm_context *dapm = &codec->dapm;
---
>         WM8900_DBG("Enter::wm8900_work : wm8900_work_type = %d\n", wm8900_work_type);
614,616c359,373
< 	snd_soc_dapm_new_controls(dapm, wm8900_dapm_widgets,
< 				  ARRAY_SIZE(wm8900_dapm_widgets));
< 	snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
---
>         switch (wm8900_work_type) {
>         case WM8900_WORK_POWERDOWN_PLAYBACK :
>                 break;
>         case WM8900_WORK_POWERDOWN_CAPTURE:
>                 snd_soc_write(wm8900_codec, WM8900_REG_POWER1, 0x210D);
>                 break;
>         case WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE:
>                 wm8900_powerdown();
>                 break;
>         case WM8900_WORK_HW_SET:
>                 wm8900_set_hw(wm8900_codec);
>                 break;
>         default:
>                 break;
>         }
618c375
< 	return 0;
---
>         wm8900_work_type = WM8900_WORK_NULL;
625a383
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
626a385,388
> #else
> 	struct snd_soc_device *socdev = rtd->socdev;
> 	struct snd_soc_codec *codec = socdev->card->codec;
> #endif
628a391,392
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
649,659d412
< 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
< 		reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
< 
< 		if (params_rate(params) <= 24000)
< 			reg |= WM8900_REG_DACCTRL_DAC_SB_FILT;
< 		else
< 			reg &= ~WM8900_REG_DACCTRL_DAC_SB_FILT;
< 
< 		snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
< 	}
< 
683c436
< 	BUG_ON(!Fout);
---
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
684a438,439
> 	BUG_ON(!Fout);
>         
746a502,503
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
813a571,573
> 
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
822a583,584
> 	WM8900_DBG("Enter:%s, %d, div_id=%d, div=%d \n", __FUNCTION__, __LINE__, div_id, div);
> 
872a635,636
> 	WM8900_DBG("Enter:%s, %d, fmt=0x%08X \n", __FUNCTION__, __LINE__, fmt);
> 
982,983c746
< 	struct snd_soc_codec *codec = codec_dai->codec;
< 	u16 reg;
---
> 	WM8900_DBG("Enter:%s, %d , mute = %d \n", __FUNCTION__, __LINE__, mute);
985c748,749
< 	reg = snd_soc_read(codec, WM8900_REG_DACCTRL);
---
> 	return 0;
> }
987,990c751,763
< 	if (mute)
< 		reg |= WM8900_REG_DACCTRL_MUTE;
< 	else
< 		reg &= ~WM8900_REG_DACCTRL_MUTE;
---
> static int wm8900_startup(struct snd_pcm_substream *substream,
> 			  struct snd_soc_dai *dai)
> {
> 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	struct snd_soc_codec *codec = rtd->codec;
> 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
> #else
> 	struct snd_soc_device *socdev = rtd->socdev;
> 	struct snd_soc_codec *codec = socdev->card->codec;
> 	struct snd_soc_dai_link *machine = rtd->dai;
> 	struct snd_soc_dai *codec_dai = machine->codec_dai;
> #endif
992c765,786
< 	snd_soc_write(codec, WM8900_REG_DACCTRL, reg);
---
> 	WM8900_DBG("Enter::%s----%d substream->stream:%s \n",__FUNCTION__,__LINE__,
> 		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");
> 
> 	cancel_delayed_work_sync(&delayed_work);
> 	wm8900_work_type = WM8900_WORK_NULL;
> 
> 	wm8900_set_hw(codec);
> 
> 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE ||
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	     codec_dai->capture_active) {
> #else
> 	     codec_dai->capture.active) {
> #endif
> 		snd_soc_write(codec, WM8900_REG_POWER1, 0x211D);
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	} else if (!codec_dai->capture_active) {
> #else
> 	} else if (!codec_dai->capture.active) {
> #endif
> 		snd_soc_write(codec, WM8900_REG_POWER1, 0x210D);
> 	}
997,999c791,878
< #define WM8900_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_11025 |\
< 		      SNDRV_PCM_RATE_16000 | SNDRV_PCM_RATE_22050 |\
< 		      SNDRV_PCM_RATE_44100 | SNDRV_PCM_RATE_48000)
---
> static void wm8900_shutdown(struct snd_pcm_substream *substream,
> 			    struct snd_soc_dai *dai)
> {
> 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
> #else
> 	struct snd_soc_dai_link *machine = rtd->dai;
> 	struct snd_soc_dai *codec_dai = machine->codec_dai;
> #endif
> 
> 	WM8900_DBG("Enter::%s----%d substream->stream:%s \n",__FUNCTION__,__LINE__,
> 		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");
> 
> 	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE &&
> 	    wm8900_work_type == WM8900_WORK_NULL) {
> 		cancel_delayed_work_sync(&delayed_work);
> 		wm8900_work_type = WM8900_WORK_POWERDOWN_CAPTURE;
> 		queue_delayed_work(wm8900_workq, &delayed_work,
> 			msecs_to_jiffies(3000));
> 	}
> #ifdef WM8900_NO_POWEROFF
> 	return; /* Let codec not going to power off for pop noise */
> #endif
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	if (!codec_dai->capture_active && !codec_dai->playback_active) {
> #else
> 	if (!codec_dai->capture.active && !codec_dai->playback.active) {
> #endif
> 
> 		cancel_delayed_work_sync(&delayed_work);
> 		wm8900_work_type = WM8900_WORK_NULL;
> 
> 		/* If codec is already shutdown, return */
> 		if (wm8900_current_status == WM8900_IS_SHUTDOWN)
> 			return;
> 
> 		WM8900_DBG("Is going to power down wm8900\n");
> 
> 		wm8900_work_type = WM8900_WORK_POWERDOWN_PLAYBACK_CAPTURE;
> 
> 		/* If codec is useless, queue work to close it */
> 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
> 			queue_delayed_work(wm8900_workq, &delayed_work,
> 				msecs_to_jiffies(1000));
> 		} else {
> 			queue_delayed_work(wm8900_workq, &delayed_work,
> 				msecs_to_jiffies(3000));
> 		}
> 	}
> }
> 
> static int wm8900_trigger(struct snd_pcm_substream *substream,
> 			  int status,
> 			  struct snd_soc_dai *dai)
> {	
> 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
> #else
> 	struct snd_soc_dai_link *machine = rtd->dai;
> 	struct snd_soc_dai *codec_dai = machine->codec_dai;
> #endif
> 
> 	WM8900_DBG("Enter::%s----%d status = %d substream->stream:%s \n",__FUNCTION__, __LINE__, status,
> 		   substream->stream == SNDRV_PCM_STREAM_PLAYBACK ? "PLAYBACK":"CAPTURE");	
> 
> 	if(status == 1 || status == 0){
> 		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK){
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 			codec_dai->playback_active = status;
> #else
> 			codec_dai->playback.active = status;
> #endif
> 		}else{
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 			codec_dai->capture_active = status;
> #else
> 			codec_dai->capture.active = status;
> #endif
> 		}
> 	}
> 
> 	return 0;
> }
> 
> #define WM8900_RATES SNDRV_PCM_RATE_44100
1010a890,892
> 	.startup	= wm8900_startup,
> 	.shutdown	= wm8900_shutdown,
> 	.trigger	= wm8900_trigger,
1012a895
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1014c897,900
< 	.name = "wm8900-hifi",
---
> #else
> struct snd_soc_dai wm8900_dai = {
> #endif
> 	.name = "WM8900 HiFi",
1030a917
> EXPORT_SYMBOL_GPL(wm8900_dai);
1036a924,933
> 	WM8900_DBG("Enter:%s, %d, level=0x%08X \n", __FUNCTION__, __LINE__, level);
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	codec->dapm.bias_level = level;
> #else
> 	codec->bias_level = level;
> #endif
> 	return 0;
> #if 0
> 
1053c950
< 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF) {
---
> 		if (codec->bias_level == SND_SOC_BIAS_OFF) {
1121c1018,1019
< 	codec->dapm.bias_level = level;
---
> 
> 	codec->bias_level = level;
1122a1021
> #endif
1124a1024
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1125a1026,1028
> #else
> static int wm8900_suspend(struct platform_device *pdev, pm_message_t state)
> #endif
1126a1030,1033
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
> 	struct snd_soc_codec *codec = socdev->card->codec;
> #endif
1131a1039,1047
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
> 	cancel_delayed_work_sync(&delayed_work);
> 	wm8900_work_type = WM8900_WORK_NULL;
> 
> #ifdef WM8900_NO_POWEROFF
> 	wm8900_powerdown();
> #endif
> 
1134a1051
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1135a1053,1055
> #else
> 		dev_err(&pdev->dev, "Failed to stop FLL\n");
> #endif
1146a1067
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1147a1069,1071
> #else
> static int wm8900_resume(struct platform_device *pdev)
> #endif
1148a1073,1076
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
> 	struct snd_soc_codec *codec = socdev->card->codec;
> #endif
1150,1154d1077
< 	u16 *cache;
< 	int i, ret;
< 
< 	cache = kmemdup(codec->reg_cache, sizeof(wm8900_reg_defaults),
< 			GFP_KERNEL);
1156d1078
< 	wm8900_reset(codec);
1160a1083
> 		int ret;
1168a1092
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1169a1094,1096
> #else
> 			dev_err(&pdev->dev, "Failed to restart FLL\n");
> #endif
1174,1179c1101,1109
< 	if (cache) {
< 		for (i = 0; i < WM8900_MAXREG; i++)
< 			snd_soc_write(codec, i, cache[i]);
< 		kfree(cache);
< 	} else
< 		dev_err(codec->dev, "Unable to allocate register cache\n");
---
> #ifdef WM8900_NO_POWEROFF
> 	if (wm8900_current_status == WM8900_IS_SHUTDOWN) {
> 
> 		cancel_delayed_work_sync(&delayed_work);
> 		wm8900_work_type = WM8900_WORK_HW_SET;
> 		queue_delayed_work(wm8900_workq, &delayed_work,
> 		                   msecs_to_jiffies(1000));
> 	}
> #endif
1184c1114,1116
< static int wm8900_probe(struct snd_soc_codec *codec)
---
> #if 0
> static __devinit int wm8900_i2c_probe(struct i2c_client *i2c,
> 				      const struct i2c_device_id *id)
1186,1187c1118,1121
< 	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
< 	int ret = 0, reg;
---
> 	struct wm8900_priv *wm8900;
> 	struct snd_soc_codec *codec;
> 	unsigned int reg;
> 	int ret;
1189c1123,1155
< 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8900->control_type);
---
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
>         
> 	wm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);
> 	if (wm8900 == NULL)
> 		return -ENOMEM;
> 
> 	codec = &wm8900->codec;
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	snd_soc_codec_set_drvdata(codec, wm8900);
> 	codec->reg_cache = &wm8900->reg_cache[0];
> 	codec->reg_cache_size = WM8900_MAXREG;
> #endif
> 
> 	mutex_init(&codec->mutex);
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	INIT_LIST_HEAD(&codec->dapm_widgets);
> 	INIT_LIST_HEAD(&codec->dapm_paths);
> #endif
> 
> 	codec->name = "WM8900";
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	codec->owner = THIS_MODULE;
> 	codec->dai = &wm8900_dai;
> #endif
> 	codec->num_dai = 1;
> 	codec->control_data = i2c;
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	codec->set_bias_level = wm8900_set_bias_level;
> 	codec->volatile_register = wm8900_volatile_register;
> #endif
> 	codec->dev = &i2c->dev;
> 
> 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, SND_SOC_I2C);
1191,1192c1157,1158
< 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
< 		return ret;
---
> 		dev_err(&i2c->dev, "Failed to set cache I/O: %d\n", ret);
> 		goto err;
1197,1198c1163,1165
< 		dev_err(codec->dev, "Device is not a WM8900 - ID %x\n", reg);
< 		return -ENODEV;
---
> 		dev_err(&i2c->dev, "Device is not a WM8900 - ID %x\n", reg);
> 		ret = -ENODEV;
> 		goto err;
1206,1255c1173,1175
< 	/* Latch the volume update bits */
< 	snd_soc_write(codec, WM8900_REG_LINVOL,
< 		      snd_soc_read(codec, WM8900_REG_LINVOL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_RINVOL,
< 		      snd_soc_read(codec, WM8900_REG_RINVOL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_LOUT1CTL,
< 		      snd_soc_read(codec, WM8900_REG_LOUT1CTL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_ROUT1CTL,
< 		      snd_soc_read(codec, WM8900_REG_ROUT1CTL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_LOUT2CTL,
< 		      snd_soc_read(codec, WM8900_REG_LOUT2CTL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_ROUT2CTL,
< 		      snd_soc_read(codec, WM8900_REG_ROUT2CTL) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_LDAC_DV,
< 		      snd_soc_read(codec, WM8900_REG_LDAC_DV) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_RDAC_DV,
< 		      snd_soc_read(codec, WM8900_REG_RDAC_DV) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_LADC_DV,
< 		      snd_soc_read(codec, WM8900_REG_LADC_DV) | 0x100);
< 	snd_soc_write(codec, WM8900_REG_RADC_DV,
< 		      snd_soc_read(codec, WM8900_REG_RADC_DV) | 0x100);
< 
< 	/* Set the DAC and mixer output bias */
< 	snd_soc_write(codec, WM8900_REG_OUTBIASCTL, 0x81);
< 
< 	snd_soc_add_controls(codec, wm8900_snd_controls,
< 				ARRAY_SIZE(wm8900_snd_controls));
< 	wm8900_add_widgets(codec);
< 
< 	return 0;
< }
< 
< /* power down chip */
< static int wm8900_remove(struct snd_soc_codec *codec)
< {
< 	wm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);
< 	return 0;
< }
< 
< static struct snd_soc_codec_driver soc_codec_dev_wm8900 = {
< 	.probe =	wm8900_probe,
< 	.remove =	wm8900_remove,
< 	.suspend =	wm8900_suspend,
< 	.resume =	wm8900_resume,
< 	.set_bias_level = wm8900_set_bias_level,
< 	.volatile_register = wm8900_volatile_register,
< 	.reg_cache_size = ARRAY_SIZE(wm8900_reg_defaults),
< 	.reg_word_size = sizeof(u16),
< 	.reg_cache_default = wm8900_reg_defaults,
< };
---
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	wm8900_dai.dev = &i2c->dev;
> #endif
1257,1261c1177
< #if defined(CONFIG_SPI_MASTER)
< static int __devinit wm8900_spi_probe(struct spi_device *spi)
< {
< 	struct wm8900_priv *wm8900;
< 	int ret;
---
> 	wm8900_codec = codec;
1263,1265c1179,1188
< 	wm8900 = kzalloc(sizeof(struct wm8900_priv), GFP_KERNEL);
< 	if (wm8900 == NULL)
< 		return -ENOMEM;
---
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 	ret = snd_soc_register_codec(&i2c->dev,
> 			&soc_codec_dev_wm8900, &wm8900_dai, 1);
> #else
> 	ret = snd_soc_register_codec(codec);
> #endif
> 	if (ret != 0) {
> 		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
> 		goto err;
> 	}
1267,1268c1190,1196
< 	wm8900->control_type = SND_SOC_SPI;
< 	spi_set_drvdata(spi, wm8900);
---
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	ret = snd_soc_register_dai(&wm8900_dai);
> 	if (ret != 0) {
> 		dev_err(&i2c->dev, "Failed to register DAI: %d\n", ret);
> 		goto err_codec;
> 	}
> #endif
1270,1273d1197
< 	ret = snd_soc_register_codec(&spi->dev,
< 			&soc_codec_dev_wm8900, &wm8900_dai, 1);
< 	if (ret < 0)
< 		kfree(wm8900);
1275d1198
< }
1277,1281c1200,1207
< static int __devexit wm8900_spi_remove(struct spi_device *spi)
< {
< 	snd_soc_unregister_codec(&spi->dev);
< 	kfree(spi_get_drvdata(spi));
< 	return 0;
---
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> err_codec:
> 	snd_soc_unregister_codec(codec);
> #endif
> err:
> 	kfree(wm8900);
> 	wm8900_codec = NULL;
> 	return ret;
1283,1294c1209
< 
< static struct spi_driver wm8900_spi_driver = {
< 	.driver = {
< 		.name	= "wm8900-codec",
< 		.owner	= THIS_MODULE,
< 	},
< 	.probe		= wm8900_spi_probe,
< 	.remove		= __devexit_p(wm8900_spi_remove),
< };
< #endif /* CONFIG_SPI_MASTER */
< 
< #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
---
> #else
1300a1216,1217
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
1310c1227,1228
< 	if (ret < 0)
---
> 	if (ret < 0) {
> 		dev_err(&i2c->dev, "Failed to register codec: %d\n", ret);
1311a1230
> 	}
1313a1233
> #endif
1316a1237,1239
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
1318a1242,1252
> #else
> 	snd_soc_unregister_dai(&wm8900_dai);
> 	snd_soc_unregister_codec(wm8900_codec);
> 
> 	wm8900_set_bias_level(wm8900_codec, SND_SOC_BIAS_OFF);
> 
> 	wm8900_dai.dev = NULL;
> 	kfree(snd_soc_codec_get_drvdata(wm8900_codec));
> 	wm8900_codec = NULL;
> #endif
> 
1321a1256,1261
> void wm8900_i2c_shutdown(struct i2c_client *client)
> {
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
> 	wm8900_powerdown();
> }
> 
1330c1270
< 		.name = "wm8900-codec",
---
> 		.name = "WM8900",
1333,1334c1273,1275
< 	.probe =    wm8900_i2c_probe,
< 	.remove =   __devexit_p(wm8900_i2c_remove),
---
> 	.probe = wm8900_i2c_probe,
> 	.remove = __devexit_p(wm8900_i2c_remove),
> 	.shutdown = wm8900_i2c_shutdown,
1337d1277
< #endif
1339c1279,1280
< static int __init wm8900_modinit(void)
---
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> static int wm8900_probe(struct snd_soc_codec *codec)
1341,1343c1282,1286
< 	int ret = 0;
< #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
< 	ret = i2c_add_driver(&wm8900_i2c_driver);
---
> 	struct wm8900_priv *wm8900 = snd_soc_codec_get_drvdata(codec);
> 	int ret;
> 	wm8900_codec = codec;
> 
> 	ret = snd_soc_codec_set_cache_io(codec, 8, 16, wm8900->control_type);
1345,1346c1288,1289
< 		printk(KERN_ERR "Failed to register wm8900 I2C driver: %d\n",
< 		       ret);
---
> 		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
> 		return ret;
1347a1291,1296
> #else
> static int wm8900_probe(struct platform_device *pdev)
> {
> 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
> 	struct snd_soc_codec *codec;
> 	int ret = 0;
1349,1353c1298,1311
< #if defined(CONFIG_SPI_MASTER)
< 	ret = spi_register_driver(&wm8900_spi_driver);
< 	if (ret != 0) {
< 		printk(KERN_ERR "Failed to register wm8900 SPI driver: %d\n",
< 		       ret);
---
> 
> #ifndef WM8900_NO_POWEROFF
> 	gpio_set_value(RK29_PIN1_PD6, GPIO_LOW);
> #endif
> 
> 	WM8900_DBG("Enter:%s, %d \n", __FUNCTION__, __LINE__);
>         
> 	if (!wm8900_codec) {
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> 		dev_err(codec->dev, "I2C client not yet instantiated\n");
> #else
> 		dev_err(&pdev->dev, "I2C client not yet instantiated\n");
> #endif
> 		return -ENODEV;
1354a1313,1343
> 
> #if defined(SPK_CON)
> 	gpio_request(SPK_CON,NULL);
> 	gpio_direction_output(SPK_CON, GPIO_LOW);
> #endif
> 
> 	codec = wm8900_codec;
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> 	socdev->card->codec = codec;
> 
> 	/* Register pcms */
> 	ret = snd_soc_new_pcms(socdev, SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1);
> 	if (ret < 0) {
> 		dev_err(codec->dev, "Failed to register new PCMs\n");
> 		dev_err(&pdev->dev, "Failed to register new PCMs\n");
> 		goto pcm_err;
> 	}
> #endif
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 38))
> 	wm8900_workq = create_freezable_workqueue("wm8900");
> #else
> 	wm8900_workq = create_freezeable_workqueue("wm8900");
> #endif
> 	if (wm8900_workq == NULL) {
> 		kfree(codec);
> 		return -ENOMEM;
> 	}
> 
> #ifdef WM8900_NO_POWEROFF
> 	wm8900_set_hw(codec);
1355a1345,1349
> 
> 	return ret;
> 
> #if (LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 37))
> pcm_err:
1356a1351,1397
> #endif
> }
> 
> /* power down chip */
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> static int wm8900_remove(struct snd_soc_codec *codec)
> {
> 	wm8900_set_bias_level(codec, SND_SOC_BIAS_OFF);
> 	return 0;
> }
> #else
> static int wm8900_remove(struct platform_device *pdev)
> {
> 	struct snd_soc_device *socdev = platform_get_drvdata(pdev);
> 
> 	snd_soc_free_pcms(socdev);
> 	snd_soc_dapm_free(socdev);
> 
> 	return 0;
> }
> #endif
> 
> #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
> static struct snd_soc_codec_driver soc_codec_dev_wm8900 = {
> 	.probe =	wm8900_probe,
> 	.remove =	wm8900_remove,
> 	.suspend =	wm8900_suspend,
> 	.resume =	wm8900_resume,
> 	.set_bias_level = wm8900_set_bias_level,
> 	.volatile_register = wm8900_volatile_register,
> 	.reg_cache_size = ARRAY_SIZE(wm8900_reg_defaults),
> 	.reg_word_size = sizeof(u16),
> 	.reg_cache_default = wm8900_reg_defaults,
> };
> #else
> struct snd_soc_codec_device soc_codec_dev_wm8900 = {
> 	.probe = 	wm8900_probe,
> 	.remove = 	wm8900_remove,
> 	.suspend = 	wm8900_suspend,
> 	.resume =	wm8900_resume,
> };
> EXPORT_SYMBOL_GPL(soc_codec_dev_wm8900);
> #endif
> 
> static int __init wm8900_modinit(void)
> {
> 	return i2c_add_driver(&wm8900_i2c_driver);
1362d1402
< #if defined(CONFIG_I2C) || defined(CONFIG_I2C_MODULE)
1364,1367d1403
< #endif
< #if defined(CONFIG_SPI_MASTER)
< 	spi_unregister_driver(&wm8900_spi_driver);
< #endif




diff -r linux-3.0.36/sound/soc/codecs/wm8962.c linux-3.0.36-lenovo/sound/soc/codecs/wm8962.c
2892a2893,2895
> 
> 		if (codec->dapm.bias_level == SND_SOC_BIAS_OFF)
> 			msleep(100);




diff -r linux-3.0.36/sound/soc/codecs/wm8978.c linux-3.0.36-lenovo/sound/soc/codecs/wm8978.c
753c753
< 		if (!wm8978->f_pllout) {
---
> 		if (!wm8978->f_opclk) {




diff -r linux-3.0.36/sound/soc/codecs/wm8988.c linux-3.0.36-lenovo/sound/soc/codecs/wm8988.c
27a28
> #include <sound/soc-dapm.h>
29a31,33
> #include <mach/iomux.h>
> #include <mach/gpio.h>
> 
31a36,44
> #include <linux/proc_fs.h>
> #include <linux/gpio.h>
> 
> #if 0
> #define DBG(x...) printk(KERN_INFO x)
> #else
> #define DBG(x...) do { } while (0)
> #endif
> 
55a69,70
> 	int is_startup;		// gModify.Add
> 	int is_biason;
192a208,209
> 	DBG("Enter::%s----%d, adctl2 = %x\n",__FUNCTION__,__LINE__,adctl2);
> 	
293,294c310,312
< 	SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8988_PWR2, 7, 0),
< 	SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8988_PWR2, 8, 0),
---
> 	/* gModify.Cmmt Implement when suspend/startup */
> 	/*SND_SOC_DAPM_DAC("Right DAC", "Right Playback", WM8988_PWR2, 7, 0),*/
> 	/*SND_SOC_DAPM_DAC("Left DAC", "Left Playback", WM8988_PWR2, 8, 0),*/
480c498
< 	8000, 11025, 12000, 16000, 22050, 2400, 32000, 41100, 48000,
---
> 	8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000,
497a516,517
>     DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
> 		
577a598,599
> 	DBG("Enter::%s----%d  iface=%x\n",__FUNCTION__,__LINE__,iface);
> 
587a610,620
> 	if (!wm8988->is_startup) {
> 		wm8988->is_startup = 1;
> 		snd_soc_write(codec, WM8988_PWR1, 0xfc);
> 		gpio_direction_output(RK29_PIN6_PB5, GPIO_LOW);
> 		mdelay(100);		// Discharge C310
> 		snd_soc_write(codec, WM8988_PWR2, 0x1e0);
> 		gpio_direction_output(RK29_PIN6_PB5, GPIO_HIGH);
> 	}
> 
> 	DBG("Enter::%s----%d  wm8988->sysclk=%d\n",__FUNCTION__,__LINE__,wm8988->sysclk); 
> 
641a675,676
> 	DBG("Enter::%s----%d  iface=%x srate =%x rate=%d\n",__FUNCTION__,__LINE__,iface,srate,params_rate(params));
> 
655a691,692
> 	DBG("Enter::%s----%d--mute=%d\n",__FUNCTION__,__LINE__,mute);
> 
665a703
> 	struct wm8988_priv *wm8988 = snd_soc_codec_get_drvdata(codec);
667a706,707
> 	DBG("Enter::%s----%d level =%d\n",__FUNCTION__,__LINE__,level);
> 
669a710
> 		wm8988->is_biason = 1;
672a714,718
> 		if (wm8988->is_startup && wm8988->is_biason) {
> 			snd_soc_write(codec, WM8988_PWR2, 0x0);
> 			wm8988->is_startup = 0;
> 			wm8988->is_biason = 0;
> 		}
712c758
< 	.name = "wm8988-hifi",
---
> 	.name = "WM8988 HiFi",
732a779,780
> 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
> 
742a791,792
> 	DBG("Enter::%s----%d\n",__FUNCTION__,__LINE__);
> 
750a801,803
> 	
> 	//snd_soc_write(codec, WM8988_PWR1, 0xfc);
> 	//snd_soc_write(codec, WM8988_PWR2, 0x1e0);
756a810,824
> static struct snd_soc_codec *wm8988_codec;
> 
> static int entry_read(char *page, char **start, off_t off,
> 		int count, int *eof, void *data)
> {
> 	int len;
> 
> 	snd_soc_write(wm8988_codec, WM8988_PWR1, 0x0000);
> 	snd_soc_write(wm8988_codec, WM8988_PWR2, 0x0000);
> 
> 	len = sprintf(page, "wm8988 suspend...\n");
> 
> 	return len ;
> }
> 
763a832,838
> 	if (codec == NULL) {
> 		dev_err(codec->dev, "Codec device not registered\n");
> 		return -ENODEV;
> 	}
> 
> 	wm8988_codec = codec;
> 
775a851,858
> #if 0
> 		/*disable speaker */
> 		gpio_request(RK2818_PIN_PF7, "WM8988");	
> 		rk2818_mux_api_set(GPIOE_SPI1_FLASH_SEL_NAME, IOMUXA_GPIO1_A3B7);
> 		gpio_direction_output(RK2818_PIN_PF7,GPIO_HIGH);
> 		
> #endif
> 
786c869,902
< 	snd_soc_write(codec, WM8988_RINVOL, reg | 0x0100);
---
> 	snd_soc_write(codec, WM8988_RINVOL, reg | 0x0100); 
> 	
> 	snd_soc_write(codec, WM8988_LOUTM1, 0x120); 
> 	snd_soc_write(codec, WM8988_ROUTM2, 0x120);  
> 	snd_soc_write(codec, WM8988_LOUTM2, 0x0070);
> 	snd_soc_write(codec, WM8988_ROUTM1, 0x0070);
> //tcl miaozh modify	
> //	snd_soc_write(codec, WM8988_LOUT1V, 0x017f); 
> //	snd_soc_write(codec, WM8988_ROUT1V, 0x017f);
> 	snd_soc_write(codec, WM8988_LOUT1V, 0x017a); 
> 	snd_soc_write(codec, WM8988_ROUT1V, 0x017a);
> 	
> 	snd_soc_write(codec, WM8988_LDAC, 0xfa/*0xff*/);  // Change max by zhansb@110415
> 	snd_soc_write(codec, WM8988_RDAC, 0x1fa/*0x1ff*/);//vol set 
> 
> 	//TCL lgw add 20110412
> 	snd_soc_write(codec, WM8988_LINVOL,  0x0117);
> 	snd_soc_write(codec, WM8988_RINVOL,  0x0117);
> 
> 	snd_soc_write(codec, WM8988_ADCTL2, 0x0184);
> 
> 	snd_soc_write(codec, WM8988_LADC, 0x01ec);
> 	snd_soc_write(codec, WM8988_RADC, 0x01ec);
> 	
> 	snd_soc_write(codec, WM8988_ADCIN,  0x0140);
> 	snd_soc_write(codec, WM8988_LADCIN, 0x00f0);//0x00e0
> 	snd_soc_write(codec, WM8988_RADCIN, 0x0);//0x00e0
> 	//lgw end
> 	
> 	snd_soc_write(codec, WM8988_SRATE,0x100);  ///SET MCLK/8
> 	//snd_soc_write(codec, WM8988_PWR1, 0x1cc);  ///(0x80|0x40|0x20|0x08|0x04|0x10|0x02));
> 	//TCL lgw modify 20110412
> 	//snd_soc_write(codec, WM8988_PWR1, 0xfc);
>  	//snd_soc_write(codec, WM8988_PWR2, 0x1e0);  //power r l out1
794a911
> 	create_proc_read_entry("wm8988_suspend", 0644, NULL, entry_read, NULL);
845c962
< 		.name	= "wm8988-codec",
---
> 		.name	= "WM8988",
889c1006
< 		.name = "wm8988-codec",
---
> 		.name = "WM8988",




diff -r linux-3.0.36/sound/soc/codecs/wm8994.c linux-3.0.36-lenovo/sound/soc/codecs/wm8994.c
31a32,33
> #include <mach/gpio.h>
> #include <mach/iomux.h>
40a43,69
> #define WM8994_PROC
> #ifdef WM8994_PROC
> #include <linux/proc_fs.h>
> #include <linux/seq_file.h>
> #include <linux/vmalloc.h>
> char debug_write_read = 0;
> #endif
> 
> #if 1
> #define DBG(x...) printk(KERN_INFO x)
> #else
> #define DBG(x...) do { } while (0)
> #endif
> 
> #if 0
> #define DBG_CLK(x...) printk(KERN_INFO x)
> #else
> #define DBG_CLK(x...) do { } while (0)
> #endif
> 
> #if 0
> #define DBG_INFO(x...) dev_info(x)
> #else
> #define DBG_INFO(x...) do { } while (0)
> #endif
> 
> 
43a73,74
> static struct snd_soc_codec *wm8994_codec;
> 
119a151,152
> //	if(reg == 0x3 || reg == 0x208)
> //		debug_write_read = 1;
122c155,158
< 
---
> #ifdef WM8994_PROC		
> 	if(debug_write_read != 0)		
> 		printk("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,value);
> #endif
127a164,168
> 		else
> #ifdef WM8994_PROC		
> 	if(debug_write_read != 0)				
> 			DBG("snd_soc_cache_write:0x%04x = 0x%04x\n",reg,value);
> #endif	
128a170,171
> //	if(reg == 0x3 || reg == 0x208)
> //		debug_write_read = 0;
140c183
< 
---
> 		
144a188,192
> 		{	
> #ifdef WM8994_PROC			
> 		if(debug_write_read != 0)			
> 			DBG("snd_soc_cache_read:0x%04x = 0x%04x\n",reg,val);
> #endif	
145a194
> 		}	
149a199,205
> 	val = wm8994_reg_read(codec->control_data, reg);
> #ifdef WM8994_PROC			
> 	if(debug_write_read != 0)			
> 		printk("%s:0x%04x = 0x%04x\n",__FUNCTION__,reg,val);	
> #endif
> 	return val;
> }
151c207,222
< 	return wm8994_reg_read(codec->control_data, reg);
---
> int wm8994_set_status(void)
> {
> 	struct wm8994_priv *wm8994 = NULL;
> //	DBG("%s::%d\n",__FUNCTION__,__LINE__);
> 
> 	if(wm8994_codec == NULL )
> 		return -1;
> 	
> 	wm8994 = snd_soc_codec_get_drvdata(wm8994_codec);
> 
> 	if(wm8994 == NULL)
> 		return -1;
> 	
> 	return snd_soc_test_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
> 			WM8994_MICB2_ENA ,
> 			WM8994_MICB2_ENA);
152a224
> EXPORT_SYMBOL_GPL(wm8994_set_status);
194c266
< 		dev_dbg(codec->dev, "Dividing AIF%d clock to %dHz\n",
---
> 		DBG_INFO(codec->dev, "Dividing AIF%d clock to %dHz\n",
199,200c271,272
< 		dev_warn(codec->dev, "AIF%dCLK is %dHz, should be >=3MHz for optimal performance\n",
< 			 aif + 1, rate);
---
> 		dev_dbg(codec->dev, "AIF%dCLK is %dHz, should be >=3MHz for optimal performance\n",
> 			 aif + 1, rate);//dev_warn
234c306
< 
---
> 	
629c701
< 	   8, 1, 0),
---
> 	   8, 1, 0),	   
675c747,748
< 
---
> //	DBG("%s::%d\n",__FUNCTION__,__LINE__);
> 	
755a829
> //	DBG("%s::%d\n",__FUNCTION__,__LINE__);
769a844,850
> 			//add
> 			snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,
> 				0x30a0,
> 				0x30a0);
> 			snd_soc_update_bits(codec, WM8994_CLOCKING_1,
> 					    WM8994_SYSCLK_SRC,
> 					    WM8994_SYSCLK_SRC);			
785c866,872
< 
---
> 	DBG("%s::%d event = %d active = %d\n",__FUNCTION__,__LINE__,event,codec->active);
> 	
> 	if(codec->active)
> 	{
> 		DBG("%s::%d codec is %s\n",__FUNCTION__,__LINE__,codec->active?"active":"inactive");
> 		return 0;
> 	}
791a879
> 			wm8994->aif1clk_enable = 1;
796a885
> 			//wm8994->aif2clk_enable = 1;
803a893,947
> static int wm8994_PA_event(struct snd_soc_dapm_widget *w,
> 			  struct snd_kcontrol *control, int event)
> {
> 	struct snd_soc_codec *codec = w->codec;
> 	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
> 	struct wm8994_pdata *pdata = wm8994->pdata;
> //	DBG("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
> 
> 	switch (event) {
> 	case SND_SOC_DAPM_POST_PMU:
> 		DBG("wm8994_PA_event PA enable\n");
> 		gpio_set_value(pdata->PA_control_pin,GPIO_HIGH);	
> 		break;
> 
> 	case SND_SOC_DAPM_PRE_PMD:
> 		DBG("wm8994_PA_event PA disable\n");
> 		gpio_set_value(pdata->PA_control_pin,GPIO_LOW);
> 		break;
> 
> 	default:
> 	//	BUG();
> 		break;
> 	}
> 
> 	return 0;
> }
> 
> int lineout_event(struct snd_soc_dapm_widget *w,
> 			  struct snd_kcontrol *control, int event)
> {
> //	struct snd_soc_codec *codec = w->codec;
> //	struct wm8994_priv *wm8994 = snd_soc_codec_get_drvdata(codec);
> //	struct wm8994_pdata *pdata = wm8994->pdata;
> 	
> //	printk("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
> 	switch (event) {
> 	case SND_SOC_DAPM_POST_PMU:
> 		printk("wm8994 is incall status\n");
> 		snd_soc_incall_status(1,1);
> 		break;
> 
> 	case SND_SOC_DAPM_PRE_PMD:
> 		printk("wm8994 exit incall status\n");
> 		snd_soc_incall_status(1,0);
> 		break;
> 
> 	default:
> 		BUG();
> 		break;
> 	}
> #endif
> 	return 0;
> }
> 
1258c1402
< 
---
>      
1269c1413
< SND_SOC_DAPM_AIF_OUT("AIF3ADCDAT", "AIF3 Capture", 0, SND_SOC_NOPM, 0, 0),
---
> SND_SOC_DAPM_AIF_IN("AIF3ADCDAT", "AIF3 Capture", 0, SND_SOC_NOPM, 0, 0),
1291c1435
< 		   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),
---
> 		   right_speaker_mixer, ARRAY_SIZE(right_speaker_mixer)),		   
1459,1466c1603,1612
< 	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC1L" },
< 	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC1R" },
< 	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC2L" },
< 	{ "AIF3ADCDAT", "AIF1ADCDAT", "AIF1ADC2R" },
< 	{ "AIF3ADCDAT", "AIF2ADCDAT", "AIF2ADCL" },
< 	{ "AIF3ADCDAT", "AIF2ADCDAT", "AIF2ADCR" },
< 	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACL" },
< 	{ "AIF3ADCDAT", "AIF2DACDAT", "AIF2DACR" },
---
> 	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC1L" },
> 	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC1R" },
> 	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC2L" },
> 	{ "AIF3ADC Mux", "AIF1ADCDAT", "AIF1ADC2R" },
> 	{ "AIF3ADC Mux", "AIF2ADCDAT", "AIF2ADCL" },
> 	{ "AIF3ADC Mux", "AIF2ADCDAT", "AIF2ADCR" },
> 	{ "AIF3ADC Mux", "AIF2DACDAT", "AIF2DACL" },
> 	{ "AIF3ADC Mux", "AIF2DACDAT", "AIF2DACR" },
> 	
> 	{ "AIF3ADCDAT", NULL, "AIF3ADC Mux" },
1485a1632,1639
> 	
> //	{ "IN1L PGA", NULL , "MICBIAS2" },
> 	{ "IN1R PGA", NULL , "MICBIAS1" },
> //	{ "MICBIAS2", NULL , "IN1LP"},//headset
> //	{ "MICBIAS2", NULL , "IN1LN"},
> 	{ "MICBIAS1", NULL , "IN1RP"},//mainMIC
> 	{ "MICBIAS1", NULL , "IN1RN"},
> 	
1536a1691,1718
> static const struct snd_soc_dapm_route wm8994_PA_intercon[] = {
> 
> 	{ "PA Driver", NULL,"SPKL Driver"},
> //	{ "PA Driver", NULL,"SPKR Driver"},	
> 	
> 	{ "SPKOUTLP", NULL, "PA Driver" },
> 	{ "SPKOUTLN", NULL, "PA Driver" },
> //	{ "SPKOUTRP", NULL, "PA Driver" },
> //	{ "SPKOUTRN", NULL, "PA Driver" },	
> };
> 
> static const struct snd_soc_dapm_widget wm8994_PA_dapm_widgets[] = {
> SND_SOC_DAPM_SPK("PA Driver", wm8994_PA_event),
> };
> /*
> static const struct snd_soc_dapm_route wm8994_lineout_status_intercon[] = {
> 	{ "LINEOUT1N STATUS", NULL,"LINEOUT1N Driver"},
> 	{ "LINEOUT1P STATUS", NULL,"LINEOUT1P Driver"},	
> 
> 	{ "LINEOUT1N", NULL, "LINEOUT1N STATUS" },
> 	{ "LINEOUT1P", NULL, "LINEOUT1P STATUS" },
> };
> 
> static const struct snd_soc_dapm_widget wm8994_lineout_status_dapm_widgets[] = {
> SND_SOC_DAPM_LINE("LINEOUT1N Driver", lineout_event),
> SND_SOC_DAPM_LINE("LINEOUT1P Driver", lineout_event),	
> };
> */
1555c1737
< 	pr_debug("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
---
> 	DBG_CLK("FLL input=%dHz, output=%dHz\n", freq_in, freq_out);
1566c1748
< 	pr_debug("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);
---
> 	DBG_CLK("CLK_REF_DIV=%d, Fref=%dHz\n", fll->clk_ref_div, freq_in);
1576c1758
< 	pr_debug("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);
---
> 	DBG_CLK("OUTDIV=%d, Fvco=%dHz\n", fll->outdiv, freq_out);
1593c1775
< 	pr_debug("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);
---
> 	DBG_CLK("FLL_FRATIO=%d, Fref=%dHz\n", fll->fll_fratio, freq_in);
1600c1782
< 	pr_debug("Nmod=%d\n", Nmod);
---
> 	DBG_CLK("Nmod=%d\n", Nmod);
1615c1797
< 	pr_debug("N=%x K=%x\n", fll->n, fll->k);
---
> 	DBG_CLK("N=%x K=%x\n", fll->n, fll->k);
1643a1826
> 		printk("%s:__ id = %d\n",__FUNCTION__,id);
1650a1834,1835
> 		{
> 			printk("%s:__ src = %d && freq_out = %d\n",__FUNCTION__,src,freq_out);	
1651a1837
> 		}	
1659a1846
> 		printk("%s:__ src = %d\n",__FUNCTION__,src);
1766c1953
< 		dev_dbg(dai->dev, "AIF%d using MCLK1 at %uHz\n",
---
> 		DBG_INFO(dai->dev, "AIF%d using MCLK1 at %uHz\n",
1774c1961
< 		dev_dbg(dai->dev, "AIF%d using MCLK2 at %uHz\n",
---
> 		DBG_INFO(dai->dev, "AIF%d using MCLK2 at %uHz\n",
1780c1967
< 		dev_dbg(dai->dev, "AIF%d using FLL1\n", dai->id);
---
> 		DBG_INFO(dai->dev, "AIF%d using FLL1\n", dai->id);
1785c1972
< 		dev_dbg(dai->dev, "AIF%d using FLL2\n", dai->id);
---
> 		DBG_INFO(dai->dev, "AIF%d using FLL2\n", dai->id);
1820a2008
> //	DBG("Enter %s::%s---%d\n",__FILE__,__FUNCTION__,__LINE__);
1832a2021
> 		printk("standby wm8994\n");
2076a2266
> 	int rate = params_rate(params);
2089a2280,2283
> 	
> 	//snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_1,
> 		//	WM8994_MICB2_ENA ,
> 		//	WM8994_MICB2_ENA);
2103a2298,2301
> 		//add		
> 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
> 				WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK,
> 				0);		
2116a2315,2331
> 		//add
> 		rate = 8000;
> 	//	wm8994_set_bias_level(codec,SND_SOC_BIAS_PREPARE);
> 	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_2,
> 	//			WM8994_IN2R_ENA | WM8994_IN2L_ENA | WM8994_MIXINR_ENA | WM8994_MIXINL_ENA,
> 	//			WM8994_IN2R_ENA| WM8994_IN2L_ENA| WM8994_MIXINR_ENA | WM8994_MIXINL_ENA);	
> 	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_3,
> 	//			0x30a0,
> 	//			0x30a0);
> 	//	snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_4,
> 	//			0x3303,
> 	//			0x3303);
> 		snd_soc_update_bits(codec, WM8994_POWER_MANAGEMENT_5,
> 				WM8994_AIF2DACL_ENA_MASK | WM8994_AIF2DACR_ENA_MASK,
> 				1 << WM8994_AIF2DACL_ENA_SHIFT| 1<<WM8994_AIF2DACR_ENA_SHIFT);
> 		
> 
2130c2345
< 	bclk_rate = params_rate(params) * 2;
---
> 	bclk_rate = rate * 4;
2153c2368
< 		if (srs[i].rate == params_rate(params))
---
> 		if (srs[i].rate == rate)
2159,2160c2374,2375
< 	dev_dbg(dai->dev, "Sample rate is %dHz\n", srs[i].rate);
< 	dev_dbg(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
---
> 	DBG_INFO(dai->dev, "Sample rate is %dHz\n", srs[i].rate);
> 	DBG_INFO(dai->dev, "AIF%dCLK is %dHz, target BCLK %dHz\n",
2174c2389
< 	best_val = abs((fs_ratios[0] * params_rate(params))
---
> 	best_val = abs((fs_ratios[0] * rate)
2177c2392
< 		cur_val = abs((fs_ratios[i] * params_rate(params))
---
> 		cur_val = abs((fs_ratios[i] * rate)
2184c2399
< 	dev_dbg(dai->dev, "Selected AIF%dCLK/fs = %d\n",
---
> 	DBG_INFO(dai->dev, "Selected AIF%dCLK/fs = %d\n",
2201c2416
< 	dev_dbg(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
---
> 	DBG_INFO(dai->dev, "Using BCLK_DIV %d for actual BCLK %dHz\n",
2205,2206c2420,2421
< 	lrclk = bclk_rate / params_rate(params);
< 	dev_dbg(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
---
> 	lrclk = bclk_rate / rate;
> 	DBG_INFO(dai->dev, "Using LRCLK rate %d for actual LRCLK %dHz\n",
2220c2435
< 			wm8994->dac_rates[0] = params_rate(params);
---
> 			wm8994->dac_rates[0] = rate;
2225c2440
< 			wm8994->dac_rates[1] = params_rate(params);
---
> 			wm8994->dac_rates[1] = rate;
2426c2641,2649
< 
---
> 	
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
> 	DBG("on wm8994.c wm8994_suspend\n");
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		DBG("incalling  cannot suspend\n");
> 		return 0;
> 	}
> #endif
2456a2680,2688
> 	
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND	
> 	printk("on wm8994.c wm8994_resume\n");
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		DBG("incalling cannot resume\n");
> 		return 0;
> 	}
> #endif
2644c2876
< 
---
> 	
2711a2944,2978
> int wm8994_headset_mic_detect(bool headset_status)
> {
> 	struct wm8994_priv *wm8994 = NULL;
> 	int jack_type = 0;
> 	printk("%s::%d\n",__FUNCTION__,__LINE__);
> 	
> 	if(wm8994_codec == NULL)
> 		return -1;
> 	wm8994 = snd_soc_codec_get_drvdata(wm8994_codec);
> 	if(wm8994 == NULL)
> 		return -1;
> 	if(headset_status)
> 	{
> 		while(wm8994_codec->dapm.bias_level == SND_SOC_BIAS_OFF)
> 		{
> 			printk("----------wm8994 unnot standby-----------------\n");
> 			msleep(300);
> 		}
> 		
> 		snd_soc_update_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
> 			WM8994_MICB2_ENA ,
> 			WM8994_MICB2_ENA);		
> 		
> 		msleep(400);
> 	}
> 	else
> 	{// headset is out,disable MIC2 Bias
> 		printk("headset is out,disable Mic2 Bias\n");
> 		snd_soc_update_bits(wm8994_codec, WM8994_POWER_MANAGEMENT_1,
> 			WM8994_MICB2_ENA,
> 			0);		
> 	}
> 	return jack_type;
> }
> EXPORT_SYMBOL(wm8994_headset_mic_detect);
2851a3119,3156
> #ifdef CONFIG_HDMI
> #include <linux/hdmi.h>
> void codec_set_spk(bool on)
> {
>         struct snd_soc_codec *codec = wm8994_codec;
> 
>         DBG("%s: %d\n", __func__, on);
> 
>         if(!codec)
>                 return;
> 
>         if(on){
>                 DBG("snd_soc_dapm_enable_pin\n");
>                 snd_soc_dapm_enable_pin(&codec->dapm, "Ext Left Spk");
>                 snd_soc_dapm_enable_pin(&codec->dapm, "Ext Right Spk");
>                 snd_soc_dapm_enable_pin(&codec->dapm, "Headset Stereophone");
>         }
>         else{
> 
>                 DBG("snd_soc_dapm_disable_pin\n");
>                 snd_soc_dapm_disable_pin(&codec->dapm, "Ext Left Spk");
>                 snd_soc_dapm_disable_pin(&codec->dapm, "Ext Right Spk");
>                 snd_soc_dapm_disable_pin(&codec->dapm, "Headset Stereophone");
>         }
> 
>         snd_soc_dapm_sync(&codec->dapm);
> 
>         return;
> }
> static struct hdmi_codec_driver hdmi_codec_driver = {
>     .hdmi_get_spk = NULL,
>     .hdmi_set_spk = codec_set_spk,
> };
> #endif 
> 
> #ifdef WM8994_PROC	
> static int wm8994_proc_init(void);
> #endif
2856a3162
> 	struct wm8994_pdata *pdata;
2858a3165,3168
> 	
> #ifdef WM8994_PROC	
> 	wm8994_proc_init();
> #endif
2868a3179
> 	pdata = wm8994->pdata;
2870c3181,3182
< 
---
> 	wm8994_codec = codec;
> 	
3062c3374
< 
---
> 	
3113c3425
< 	wm_hubs_add_analogue_routes(codec, 0, 0);
---
> 	wm_hubs_add_analogue_routes(codec, 1, 0);
3121a3434
> 			printk("wm8994->revision = %d\n",wm8994->revision);
3146a3460,3474
> 	
> 	if(pdata ->PA_control_pin)
> 	{
> 		DBG_INFO(codec->dev,"Add the PA control route\n");
> 		snd_soc_dapm_new_controls(dapm, wm8994_PA_dapm_widgets,
> 				  ARRAY_SIZE(wm8994_PA_dapm_widgets));	
> 		snd_soc_dapm_add_routes(dapm, wm8994_PA_intercon, 
> 				ARRAY_SIZE(wm8994_PA_intercon));
> 		if(pdata->PA_iomux_name != NULL)
> 			rk29_mux_api_set(pdata->PA_iomux_name, pdata->PA_iomux_mode);
> 		gpio_request(pdata->PA_control_pin, "wm8994_PA_ctrl");				
> 		gpio_direction_output(pdata->PA_control_pin,GPIO_LOW);
> 	}
> 	else
> 		dev_info(codec->dev, "have not pa control\n");	
3147a3476,3488
> 	//lineout off
> //	snd_soc_dapm_new_controls(dapm, wm8994_lineout_status_dapm_widgets,
> //				 ARRAY_SIZE(wm8994_lineout_status_dapm_widgets));	
> //	snd_soc_dapm_add_routes(dapm, wm8994_lineout_status_intercon, 
> //				ARRAY_SIZE(wm8994_lineout_status_intercon));
> 	#ifdef CONFIG_HDMI
> 		hdmi_codec_driver.name = "wm8994";
> 		ret = hdmi_codec_register(&hdmi_codec_driver);
> 		if (ret != 0) {
> 			printk("Failed to register HDMI_codec: %d\n", ret);
>     }
> 	#endif
> 	
3165c3506,3507
< 
---
> 	struct wm8994_pdata *pdata = wm8994->pdata;
> 	
3192a3535,3536
> 	if (gpio_is_valid(pdata->PA_control_pin))
> 		gpio_free(pdata->PA_control_pin);
3254a3599,3949
> 
> //=====================================================================
> //Proc
> #ifdef WM8994_PROC
> void mainMIC_to_BB_to_earpiece(void)
> {
> 	DBG("%s::%d\n",__FUNCTION__,__LINE__);
> 
> //	wm8994_write(wm8994_codec,0x0000,0x0000);
> //	wm8994_write(wm8994_codec,0x0001,0x0023);
> //	wm8994_write(wm8994_codec,0x0200,0x0000);
> //	wm8994_write(wm8994_codec,0x0222,0x0000);
> //	wm8994_write(wm8994_codec,0x0223,0x0400);
> //	wm8994_write(wm8994_codec,0x0220,0x0005);
> //	wm8994_write(wm8994_codec,0x0208,0x000a);
> //	wm8994_write(wm8994_codec,0x0210,0x0073);
> //	wm8994_write(wm8994_codec,0x0200,0x0011);
> 
> 	wm8994_write(wm8994_codec,0x0034,0x0004);
> 	wm8994_write(wm8994_codec,0x002b,0x0007);
> 	wm8994_write(wm8994_codec,0x002e,0x0081);
> 	
> //	wm8994_write(wm8994_codec,0x0601,0x0001);
> //	wm8994_write(wm8994_codec,0x0610,0x01c0);
> //	wm8994_write(wm8994_codec,0x0611,0x01c0);
> 	wm8994_write(wm8994_codec,0x0033,0x0018);
> //	wm8994_write(wm8994_codec,0x0031,0x0000);
> //	wm8994_write(wm8994_codec,0x004c,0x9f25);
> //	wm8994_write(wm8994_codec,0x0001,0x0833);
> 	
> //	wm8994_write(wm8994_codec,0x0020,0x0179);
> //	wm8994_write(wm8994_codec,0x0021,0x0179);
> }
> void BT_BB(void)
> {//
> 	DBG("%s::%d\n",__FUNCTION__,__LINE__);
> #if 0
> //	wm8994_reg_write(wm8994_codec->control_data,0x0,  0x0);
> 	msleep(50);
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x01,  0x0023);
> 	wm8994_reg_write(wm8994_codec->control_data,0x200, 0x0000);
> 	msleep(50);
> //CLK
> 	//AIF2CLK use FLL2
>     //BT CLK = 8000
>     //8KHz, BCLK=8KHz*64=512KHz, Fout=2.048MHz
>     
> 	wm8994_reg_write(wm8994_codec->control_data,0x241, 0x2b00);
> 	wm8994_reg_write(wm8994_codec->control_data,0x242, 0xfb5b);
> 	wm8994_reg_write(wm8994_codec->control_data,0x243, 0x00e0);
> 	wm8994_reg_write(wm8994_codec->control_data,0x240, 0x0005);    //FLL2_ENA = 1  \u8fd9\u8fb9\u5f97\u5230\u7684FLL CLK\u5e94\u8be5=2.048M
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x204, 0x0018);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=0
> 	wm8994_reg_write(wm8994_codec->control_data,0x208, 0x000F);    // DSP_FS1CLK_ENA = 1 DSP_FS2CLK_ENA = 1 DSP_FSINTCLK_ENA =1 SYSCLK_SRC=AIF1CLK
> 	wm8994_reg_write(wm8994_codec->control_data,0x211, 0x0003);    // AIF2_SR[3:0]=0 8k   AIF2CLK_RATE [3:0]=3 256\u5206\u9891    Fout = 8000 * 256 = 2.048MHz
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x312, 0x3000);    // AIF2 Master/Slave(312H): 7000  AIF2_TRI=0, AIF2_MSTR=1, AIF2_CLK_FRC=0, AIF2_LRCLK_FRC=0
> 	msleep(30);
> 	wm8994_reg_write(wm8994_codec->control_data,0x312, 0x7000);
> 	wm8994_reg_write(wm8994_codec->control_data,0x313, 0x0020);    // AIF2 BCLK DIV--------AIF1CLK/2
> 	wm8994_reg_write(wm8994_codec->control_data,0x314, 0x0080);    // AIF2 ADCLRCK DIV-----BCLK/128
> 	wm8994_reg_write(wm8994_codec->control_data,0x315, 0x0080);
> 	wm8994_reg_write(wm8994_codec->control_data,0x310, 0x0118);    // DSP/PCM; 16bits; ADC L channel = R channel;MODE A
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x204, 0x0019);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=1
> 	
> //GPIO
> 	wm8994_reg_write(wm8994_codec->control_data,0x702, 0x2100);//BCLK2
> 	wm8994_reg_write(wm8994_codec->control_data,0x703, 0x2100);//DACLRCLK2
> 	wm8994_reg_write(wm8994_codec->control_data,0x704, 0xA100);//DACDAT2
> 	wm8994_reg_write(wm8994_codec->control_data,0x707, 0xA100);//DACDAT3
> 	wm8994_reg_write(wm8994_codec->control_data,0x708, 0x2100);//ADCDAT3
> 	wm8994_reg_write(wm8994_codec->control_data,0x709, 0x2100);//LRCLK3
> 	wm8994_reg_write(wm8994_codec->control_data,0x70A, 0x2100);//BCLK3
> 	wm8994_reg_write(wm8994_codec->control_data,0x06,  0x000A);
> //1010  bit_0 AIF1DACDAT=DACDAT1 bit_1 AIF2DACDAT=GPIO8/DACDAT3 bit_2 GPIO7/ADCDAT2=AIF2ADCDAT2 bit_3 GPIO9/ADCDAT3=AIF2ADCDAT2
> //path
> 	
>     //listen   IN2RP/IN2LP to MIXIN to ADC to DAC2 to AIF2
> 	wm8994_reg_write(wm8994_codec->control_data,0x28,   0x00C0);   //IN2LP_TO_IN2L IN2LN_TO_IN2L
> 	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0100);   //IN2L_TO_MIXINL   BB
> 	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0100);   //IN2R_TO_MIXINR
> 	wm8994_reg_write(wm8994_codec->control_data,0x604,  0x0010);   //ADC1_TO_DAC2L
> 	wm8994_reg_write(wm8994_codec->control_data,0x605,  0x0010);   //ADC1_TO_DAC2R
> //	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0130);//IN1L_TO_MIXINL   MIC
> //	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0130);//IN1R_TO_MIXINR
>     //say   AIF2DACL to DACL to MIXOUTL to LINEOUT
>     //\u6309\u952e\u97f3 AIF1ADCR to DACR to MIXOUTR to SPKMIXR
> 	wm8994_reg_write(wm8994_codec->control_data,0x601,  0x0004);   //AIF2DACL_TO_DAC1L
> 	wm8994_reg_write(wm8994_codec->control_data,0x602,  0x0001);   //AIF1DAC1R_TO_DAC1R
> 	wm8994_reg_write(wm8994_codec->control_data,0x2D,   0x0001);   //DAC1L_TO_MIXOUTL
> 	wm8994_reg_write(wm8994_codec->control_data,0x2E,   0x0001);   //DAC1R_TO_MIXOUTR
> 	wm8994_reg_write(wm8994_codec->control_data,0x34,   0x0001);   //MIXOUTL_TO_LINEOUT1P
> 	wm8994_reg_write(wm8994_codec->control_data,0x36,   0x0004);   //MIXOUTR_TO_SPKMIXR
> 	wm8994_reg_write(wm8994_codec->control_data,0x24,   0x0009);   //SPKMIXR_TO_SPKOUTL   SPKMIXR_TO_SPKOUTR
> 	
> //volume
> 	wm8994_reg_write(wm8994_codec->control_data,0x19,   0x011F);   // IN2L volume
> 	wm8994_reg_write(wm8994_codec->control_data,0x20,   0x017F);   // MIXOUTL volume
> 	wm8994_reg_write(wm8994_codec->control_data,0x0500, 0x017F);   // AIF2 ADC Left Volume
> 	wm8994_reg_write(wm8994_codec->control_data,0x0501, 0x0100);   // AIF2 ADC Right Volume mute
> 	wm8994_reg_write(wm8994_codec->control_data,0x1E,   0x0006);   //LINEOUT2N_MUTE=UN-MUTE  LINEOUT2P_MUTE=UN-MUTE
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x22,   0x0000);
> 	wm8994_reg_write(wm8994_codec->control_data,0x23,   0x0100);
> 	wm8994_reg_write(wm8994_codec->control_data,0x610, 0x01C0);//DAC1L
> 	wm8994_reg_write(wm8994_codec->control_data,0x611, 0x01C0);//DAC1R
> 	wm8994_reg_write(wm8994_codec->control_data,0x612, 0x01C0);//DAC2L
> 	wm8994_reg_write(wm8994_codec->control_data,0x613, 0x01C0);//DAC2R
> 
> 	wm8994_reg_write(wm8994_codec->control_data,0x603, 0x000C);//ADC1_DAC2_VOL[3:0] 1100 0DB
> 	wm8994_reg_write(wm8994_codec->control_data,0x620, 0x0000);
> 	wm8994_reg_write(wm8994_codec->control_data,0x420, 0x0000);
> //other
> 	wm8994_reg_write(wm8994_codec->control_data,0x4C,   0x9F25);
> 	wm8994_reg_write(wm8994_codec->control_data,0x60,   0x00EE);
> 	msleep(5);
> //power
> 	wm8994_reg_write(wm8994_codec->control_data,0x01,   0x3033);
> 	wm8994_reg_write(wm8994_codec->control_data,0x02,   0x63A0);
> 	wm8994_reg_write(wm8994_codec->control_data,0x03,   0x33F0);
> 	wm8994_reg_write(wm8994_codec->control_data,0x04,   0x3303);
> 	wm8994_reg_write(wm8994_codec->control_data,0x05,   0x3303);
> #endif	
> //	wm8994_write(wm8994_codec,0x0,  0x0);
> //	msleep(50);
> 
> //	wm8994_write(wm8994_codec,0x01,  0x0023);
> //	wm8994_write(wm8994_codec,0x200, 0x0000);
> //	msleep(50);
> //CLK
> 	//AIF2CLK use FLL2
>     //BT CLK = 8000
>     //8KHz, BCLK=8KHz*64=512KHz, Fout=2.048MHz
>     
> //	wm8994_write(wm8994_codec,0x241, 0x2b00);
> //	wm8994_write(wm8994_codec,0x242, 0xfb5b);
> //	wm8994_write(wm8994_codec,0x243, 0x00e0);
> //	wm8994_write(wm8994_codec,0x240, 0x0005);    //FLL2_ENA = 1  \u8fd9\u8fb9\u5f97\u5230\u7684FLL CLK\u5e94\u8be5=2.048M
> 
> //	wm8994_write(wm8994_codec,0x204, 0x0018);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=0
> //	wm8994_write(wm8994_codec,0x208, 0x000F);    // DSP_FS1CLK_ENA = 1 DSP_FS2CLK_ENA = 1 DSP_FSINTCLK_ENA =1 SYSCLK_SRC=AIF1CLK
> //	wm8994_write(wm8994_codec,0x211, 0x0003);    // AIF2_SR[3:0]=0 8k   AIF2CLK_RATE [3:0]=3 256\u5206\u9891    Fout = 8000 * 256 = 2.048MHz
> 
> //	wm8994_write(wm8994_codec,0x312, 0x3000);    // AIF2 Master/Slave(312H): 7000  AIF2_TRI=0, AIF2_MSTR=1, AIF2_CLK_FRC=0, AIF2_LRCLK_FRC=0
> //	msleep(30);
> //	wm8994_write(wm8994_codec,0x312, 0x7000);
> //	wm8994_write(wm8994_codec,0x313, 0x0020);    // AIF2 BCLK DIV--------AIF1CLK/2
> //	wm8994_write(wm8994_codec,0x314, 0x0080);    // AIF2 ADCLRCK DIV-----BCLK/128
> //	wm8994_write(wm8994_codec,0x315, 0x0080);
> //	wm8994_write(wm8994_codec,0x310, 0x0118);    // DSP/PCM; 16bits; ADC L channel = R channel;MODE A
> 
> //	wm8994_write(wm8994_codec,0x204, 0x0019);    // AIF2CLK_SRC=10 use FLL2 AIF2CLK_ENA=1
> 	
> //GPIO
> //	wm8994_write(wm8994_codec,0x702, 0x2100);//BCLK2
> //	wm8994_write(wm8994_codec,0x703, 0x2100);//DACLRCLK2
> //	wm8994_write(wm8994_codec,0x704, 0xA100);//DACDAT2
> //	wm8994_write(wm8994_codec,0x707, 0xA100);//DACDAT3
> //	wm8994_write(wm8994_codec,0x708, 0x2100);//ADCDAT3
> //	wm8994_write(wm8994_codec,0x709, 0x2100);//LRCLK3
> //	wm8994_write(wm8994_codec,0x70A, 0x2100);//BCLK3
> //	wm8994_write(wm8994_codec,0x06,  0x000A);
> //1010  bit_0 AIF1DACDAT=DACDAT1 bit_1 AIF2DACDAT=GPIO8/DACDAT3 bit_2 GPIO7/ADCDAT2=AIF2ADCDAT2 bit_3 GPIO9/ADCDAT3=AIF2ADCDAT2
> //path
> 	
>     //listen   IN2RP/IN2LP to MIXIN to ADC to DAC2 to AIF2
> 	wm8994_write(wm8994_codec,0x28,   0x00C0);   //IN2LP_TO_IN2L IN2LN_TO_IN2L
> 	wm8994_write(wm8994_codec,0x29,   0x0100);   //IN2L_TO_MIXINL   BB
> 	wm8994_write(wm8994_codec,0x2A,   0x0100);   //IN2R_TO_MIXINR
> 	wm8994_write(wm8994_codec,0x604,  0x0010);   //ADC1_TO_DAC2L
> 	wm8994_write(wm8994_codec,0x605,  0x0010);   //ADC1_TO_DAC2R
> //	wm8994_reg_write(wm8994_codec->control_data,0x29,   0x0130);//IN1L_TO_MIXINL   MIC
> //	wm8994_reg_write(wm8994_codec->control_data,0x2A,   0x0130);//IN1R_TO_MIXINR
>     //say   AIF2DACL to DACL to MIXOUTL to LINEOUT
>     //\u6309\u952e\u97f3 AIF1ADCR to DACR to MIXOUTR to SPKMIXR
> 	wm8994_write(wm8994_codec,0x601,  0x0004);   //AIF2DACL_TO_DAC1L
> //	wm8994_write(wm8994_codec,0x602,  0x0001);   //AIF1DAC1R_TO_DAC1R
> 	wm8994_write(wm8994_codec,0x2D,   0x0001);   //DAC1L_TO_MIXOUTL
> //	wm8994_write(wm8994_codec,0x2E,   0x0001);   //DAC1R_TO_MIXOUTR
> 	wm8994_write(wm8994_codec,0x34,   0x0001);   //MIXOUTL_TO_LINEOUT1P
> //	wm8994_write(wm8994_codec,0x36,   0x0004);   //MIXOUTR_TO_SPKMIXR
> 	wm8994_write(wm8994_codec,0x24,   0x0009);   //SPKMIXR_TO_SPKOUTL   SPKMIXR_TO_SPKOUTR
> 	/*
> //volume
> 	wm8994_write(wm8994_codec,0x19,   0x011F);   // IN2L volume
> 	wm8994_write(wm8994_codec,0x20,   0x017F);   // MIXOUTL volume
> 	wm8994_write(wm8994_codec,0x0500, 0x017F);   // AIF2 ADC Left Volume
> 	wm8994_write(wm8994_codec,0x0501, 0x0100);   // AIF2 ADC Right Volume mute
> 	wm8994_write(wm8994_codec,0x1E,   0x0006);   //LINEOUT2N_MUTE=UN-MUTE  LINEOUT2P_MUTE=UN-MUTE
> 
> 	wm8994_write(wm8994_codec,0x22,   0x0000);
> 	wm8994_write(wm8994_codec,0x23,   0x0100);
> 	wm8994_write(wm8994_codec,0x610, 0x01C0);//DAC1L
> 	wm8994_write(wm8994_codec,0x611, 0x01C0);//DAC1R
> 	wm8994_write(wm8994_codec,0x612, 0x01C0);//DAC2L
> 	wm8994_write(wm8994_codec,0x613, 0x01C0);//DAC2R
> 
> 	wm8994_write(wm8994_codec,0x603, 0x000C);//ADC1_DAC2_VOL[3:0] 1100 0DB
> 	wm8994_write(wm8994_codec,0x620, 0x0000);
> 	wm8994_write(wm8994_codec,0x420, 0x0000);*/
> //other
> //	wm8994_write(wm8994_codec,0x4C,   0x9F25);
> //	wm8994_write(wm8994_codec,0x60,   0x00EE);
> //	msleep(5);
> //power
> //	wm8994_write(wm8994_codec,0x01,   0x0003);
> //	wm8994_write(wm8994_codec,0x02,   0x63A0);
> //	wm8994_write(wm8994_codec,0x03,   0x30a0);
> //	wm8994_write(wm8994_codec,0x04,   0x3303);
> //	wm8994_write(wm8994_codec,0x05,   0x3003);
> 
> }
> 
> static ssize_t wm8994_proc_write(struct file *file, const char __user *buffer,
> 			   unsigned long len, void *data)
> {
> 	char *cookie_pot; 
> 	char *p;
> 	int reg;
> 	int value;
> 	
> 	cookie_pot = (char *)vmalloc( len );
> 	if (!cookie_pot) 
> 	{
> 		return -ENOMEM;
> 	} 
> 	else 
> 	{
> 		if (copy_from_user( cookie_pot, buffer, len )) 
> 			return -EFAULT;
> 	}
> 
> 	switch(cookie_pot[0])
> 	{
> 	case 'd':
> 	case 'D':
> 		debug_write_read ++;
> 		debug_write_read %= 2;
> 		if(debug_write_read != 0)
> 			printk("Debug read and write reg on\n");
> 		else	
> 			printk("Debug read and write reg off\n");	
> 		break;	
> 	case 'r':
> 	case 'R':
> 		printk("Read reg debug\n");		
> 		if(cookie_pot[1] ==':')
> 		{
> 			debug_write_read = 1;
> 			strsep(&cookie_pot,":");
> 			while((p=strsep(&cookie_pot,",")))
> 			{
> 				reg = simple_strtol(p,NULL,16);
> 				value = wm8994_reg_read(wm8994_codec->control_data,reg);
> 				printk("wm8994_read:0x%04x = 0x%04x\n",reg,value);
> 			}
> 			debug_write_read = 0;
> 			printk("\n");
> 		}
> 		else
> 		{
> 			printk("Error Read reg debug.\n");
> 			printk("For example: echo 'r:22,23,24,25'>wm8994_ts\n");
> 		}
> 		break;
> 	case 'w':
> 	case 'W':
> 		printk("Write reg debug\n");		
> 		if(cookie_pot[1] ==':')
> 		{
> 			debug_write_read = 1;
> 			strsep(&cookie_pot,":");
> 			while((p=strsep(&cookie_pot,"=")))
> 			{
> 				reg = simple_strtol(p,NULL,16);
> 				p=strsep(&cookie_pot,",");
> 				value = simple_strtol(p,NULL,16);
> 				wm8994_reg_write(wm8994_codec->control_data,reg,value);
> 				printk("wm8994_write:0x%04x = 0x%04x\n",reg,value);
> 			}
> 			debug_write_read = 0;
> 			printk("\n");
> 		}
> 		else
> 		{
> 			printk("Error Write reg debug.\n");
> 			printk("For example: w:22=0,23=0,24=0,25=0\n");
> 		}
> 		break;
> 	case 'p'://enable pa
> 	//	gpio_request(RK29_PIN6_PD3, NULL);			 	
> 	//	gpio_direction_output(RK29_PIN6_PD3,GPIO_HIGH); 			
> 	//	gpio_free(RK29_PIN6_PD3);
> 		break;
> 
> 	case 'a':
> 		printk("Dump reg \n");		
> 
> 		for(reg = 0; reg < 0x621; reg++)
> 		{
> 			value = wm8994_reg_read(wm8994_codec->control_data,reg);
> 			printk("wm8994_read:0x%04x = 0x%04x\n",reg,value);
> 		}
> 
> 		break;		
> 	case 'b':
> 		BT_BB();
> 		break;
> 	case 'c':
> 		mainMIC_to_BB_to_earpiece();
> 		break;
> 	default:
> 		printk("Help for wm8994_ts .\n-->The Cmd list: \n");
> 		printk("-->'d&&D' Open or Off the debug\n");
> 		printk("-->'r&&R' Read reg debug,Example: echo 'r:22,23,24,25'>wm8994_ts\n");
> 		printk("-->'w&&W' Write reg debug,Example: echo 'w:22=0,23=0,24=0,25=0'>wm8994_ts\n");
> 		break;
> 	}
> 
> 	return len;
> }
> static const struct file_operations wm8994_proc_fops = {
> 	.owner		= THIS_MODULE,
> 	//.open		= snd_mem_proc_open,
> 	//.read		= seq_read,
> //#ifdef CONFIG_PCI
> //	.write		= wm8994_proc_write,
> //#endif
> 	//.llseek	= seq_lseek,
> 	//.release	= single_release,
> };
> 
> static int wm8994_proc_init(void)
> {
> 	struct proc_dir_entry *wm8994_proc_entry;
> 	wm8994_proc_entry = create_proc_entry("driver/wm8994_ts", 0777, NULL);
> 	if(wm8994_proc_entry != NULL)
> 	{
> 		wm8994_proc_entry->write_proc = wm8994_proc_write;
> 		return -1;
> 	}
> 	else
> 	{
> 		printk("create proc error !\n");
> 	}
> 	return 0;
> }
> 
> #endif




diff -r linux-3.0.36/sound/soc/codecs/wm8994.h linux-3.0.36-lenovo/sound/soc/codecs/wm8994.h
142a143,144
> 
> 	unsigned int lineout_status:1;
143a146,148
> 
> int lineout_event(struct snd_soc_dapm_widget *w,
> 			  struct snd_kcontrol *control, int event);




diff -r linux-3.0.36/sound/soc/codecs/wm9712.c linux-3.0.36-lenovo/sound/soc/codecs/wm9712.c
147c147
< SOC_SINGLE("Capture ADC Switch", AC97_REC_GAIN, 15, 1, 1),
---
> SOC_SINGLE("Capture Switch", AC97_REC_GAIN, 15, 1, 1),
273c273
< SOC_DAPM_ENUM("Route", wm9712_enum[7]);
---
> SOC_DAPM_ENUM("Mic Source Select", wm9712_enum[7]);
292c292,294
< SND_SOC_DAPM_MUX("Mic Select Source", SND_SOC_NOPM, 0, 0,
---
> SND_SOC_DAPM_MUX("Left Mic Select Source", SND_SOC_NOPM, 0, 0,
> 	&wm9712_mic_src_controls),
> SND_SOC_DAPM_MUX("Right Mic Select Source", SND_SOC_NOPM, 0, 0,
319a322
> SND_SOC_DAPM_PGA("Differential Mic", SND_SOC_NOPM, 0, 0, NULL, 0),
378a382,393
> 
> 	/* microphones */
> 	{"Differential Mic", NULL, "MIC1"},
> 	{"Differential Mic", NULL, "MIC2"},
> 	{"Left Mic Select Source", "Mic 1", "MIC1"},
> 	{"Left Mic Select Source", "Mic 2", "MIC2"},
> 	{"Left Mic Select Source", "Stereo", "MIC1"},
> 	{"Left Mic Select Source", "Differential", "Differential Mic"},
> 	{"Right Mic Select Source", "Mic 1", "MIC1"},
> 	{"Right Mic Select Source", "Mic 2", "MIC2"},
> 	{"Right Mic Select Source", "Stereo", "MIC2"},
> 	{"Right Mic Select Source", "Differential", "Differential Mic"},




diff -r linux-3.0.36/sound/soc/codecs/wm_hubs.c linux-3.0.36-lenovo/sound/soc/codecs/wm_hubs.c
28a29
> #include "wm8994.h"
79c80
< 		msleep(1);
---
> 		msleep(100);
82c83
< 	} while (reg & op && count < 400);
---
> 	} while (reg & op && count < 4);
214a216,223
> //for mic mute		
> SOC_SINGLE_TLV("Main Mic Capture Volume", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
> 		  inpga_tlv),
> SOC_SINGLE("Main Mic Capture Switch", WM8993_RIGHT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),		
> SOC_SINGLE("Headset Mic Capture Switch", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 7, 1, 1),		
> SOC_SINGLE_TLV("Headset Mic Capture Volume", WM8993_LEFT_LINE_INPUT_1_2_VOLUME, 0, 31, 0,
>        inpga_tlv),		
> //end	
298c307,309
< SOC_SINGLE_TLV("Earpiece Volume", WM8993_HPOUT2_VOLUME, 4, 1, 1, earpiece_tlv),
---
> SOC_SINGLE_TLV("HPOUT2 Volume", WM8993_HPOUT2_VOLUME, 4, 1, 1, earpiece_tlv),
> SOC_DOUBLE_R_TLV("Earpiece Volume", WM8993_LEFT_OPGA_VOLUME, 
> 		WM8993_RIGHT_OPGA_VOLUME, 0, 63, 0, outpga_tlv),
408a420,432
> 		snd_soc_update_bits(codec, WM8993_LEFT_OUTPUT_VOLUME,
> 					WM8993_HPOUT1_VU ,
> 					0 | 0);
> 		snd_soc_update_bits(codec, WM8993_RIGHT_OUTPUT_VOLUME,
> 					WM8993_HPOUT1_VU ,
> 					0 | 0);
> 		snd_soc_update_bits(codec, WM8993_LEFT_OUTPUT_VOLUME,
> 					WM8993_HPOUT1_VU ,
> 					WM8993_HPOUT1_VU );
> 		snd_soc_update_bits(codec, WM8993_RIGHT_OUTPUT_VOLUME,
> 					WM8993_HPOUT1_VU ,
> 					WM8993_HPOUT1_VU );
> 					
656,659c680,690
< SND_SOC_DAPM_PGA("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
< 		 NULL, 0),
< SND_SOC_DAPM_PGA("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
< 		 NULL, 0),
---
> //SND_SOC_DAPM_PGA("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
> //		 NULL, 0),
> //SND_SOC_DAPM_PGA("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
> //		 NULL, 0),
> SND_SOC_DAPM_PGA_E("LINEOUT1N Driver", WM8993_POWER_MANAGEMENT_3, 13, 0,
> 		 NULL, 0,
> 		 lineout_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
> SND_SOC_DAPM_PGA_E("LINEOUT1P Driver", WM8993_POWER_MANAGEMENT_3, 12, 0,
> 		 NULL, 0,
> 		 lineout_event, SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
> 		 




diff -r linux-3.0.36/sound/soc/Kconfig linux-3.0.36-lenovo/sound/soc/Kconfig
60c60
< 
---
> source "sound/soc/rk29/Kconfig"




diff -r linux-3.0.36/sound/soc/Makefile linux-3.0.36-lenovo/sound/soc/Makefile
22a23
> obj-$(CONFIG_SND_SOC)	+= rk29/
Only in linux-3.0.36-lenovo/sound/soc: rk29




diff -r linux-3.0.36/sound/soc/soc-cache.c linux-3.0.36-lenovo/sound/soc/soc-cache.c
167a168
> 	xfer[0].scl_rate = 100 * 1000;




diff -r linux-3.0.36/sound/soc/soc-core.c linux-3.0.36-lenovo/sound/soc/soc-core.c
1034a1035,1049
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
> int snd_soc_incall_status(int read_or_write, int status)
> {
> 	static int now_status = 0;
> 	if(read_or_write == 1)
> 	{//write
> 		now_status = status;
> 	}
> 
> 	return now_status;
> }
> EXPORT_SYMBOL_GPL(snd_soc_incall_status);
> #endif
> 
> 
1042c1057,1064
< 
---
> 	
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		printk("card is incall cannot into suspend\n");
> 		return 0;
> 	}
> #endif	
1191a1214
> 
1262c1285,1292
< 
---
> 	
> #ifdef CONFIG_PHONE_INCALL_IS_SUSPEND
> 	if(snd_soc_incall_status(0,0))
> 	{
> 		printk("card is incall cannot into suspend\n");
> 		return 0;
> 	}
> #endif
1291c1321
< 
---
> #define CODEC_NAME_CMP
1300c1330,1337
< 
---
> #ifdef CODEC_NAME_CMP
> 	char *p_codec_name;
> 	char *p_dai_codec_name;
> 	char tmp_codec_name[50];
> 	char tmp_dai_codec_name[50];
> 	p_codec_name = tmp_codec_name;
> 	p_dai_codec_name = tmp_dai_codec_name;
> #endif	
1327c1364,1374
< 		if (!strcmp(codec->name, dai_link->codec_name)) {
---
> #ifdef CODEC_NAME_CMP
> 		strcpy(p_codec_name,codec->name);
>         if(codec->name && dai_link->codec_name)
>             strcpy(dai_link->codec_name,codec->name);
> 		strcpy(p_dai_codec_name,dai_link->codec_name);		
> #endif		
> 		if (!strcmp(codec->name, dai_link->codec_name) 
> #ifdef CODEC_NAME_CMP			
> 		||	!strcmp(strsep(&p_codec_name,"."), strsep(&p_dai_codec_name,"."))
> #endif
> 			) {
3132c3179
< 	struct soc_mixer_control *mc =
---
> 	/*struct soc_mixer_control *mc =
3158a3206,3230
> 
> 	return 0;*/		//sxj modify, this function have bug
> 
> 	struct soc_mixer_control *mc =
>          (struct soc_mixer_control *)kcontrol->private_value;
> 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
> 	unsigned int mask = (1<<mc->shift)-1;
> 	int min = mc->min;
> 	int ret;
> 	unsigned int val, valr, oval, ovalr;
> 
> 	val = ((ucontrol->value.integer.value[0]+min) & 0xff);
> 	val &= mask;
> 	valr = ((ucontrol->value.integer.value[1]+min) & 0xff);
> 	valr &= mask;
> 
> 	ret = 0;
> 	ret = snd_soc_update_bits_locked(codec, mc->reg, mask, val);
> 	if(ret < 0)
> 		return ret;
> 
> 	ret = snd_soc_update_bits_locked(codec, mc->rreg, mask, valr);
> 
> 	if(ret < 0)
> 		return ret;




diff -r linux-3.0.36/sound/soc/soc-dapm.c linux-3.0.36-lenovo/sound/soc/soc-dapm.c
2637c2637
< 	list_for_each_entry(codec, &card->codec_dev_list, list) {
---
> 	list_for_each_entry(codec, &card->codec_dev_list, card_list) {




diff -r linux-3.0.36/sound/usb/card.c linux-3.0.36-lenovo/sound/usb/card.c
338c338
< 	mutex_init(&chip->shutdown_mutex);
---
> 	init_rwsem(&chip->shutdown_rwsem);
557,558c557
< 	mutex_lock(&register_mutex);
< 	mutex_lock(&chip->shutdown_mutex);
---
> 	down_write(&chip->shutdown_rwsem);
559a559,561
> 	up_write(&chip->shutdown_rwsem);
> 
> 	mutex_lock(&register_mutex);
576d577
< 		mutex_unlock(&chip->shutdown_mutex);
580d580
< 		mutex_unlock(&chip->shutdown_mutex);
611a612
> 	down_read(&chip->shutdown_rwsem);
613a615
> 	up_read(&chip->shutdown_rwsem);
619a622
> 	down_read(&chip->shutdown_rwsem);
621a625
> 	up_read(&chip->shutdown_rwsem);




diff -r linux-3.0.36/sound/usb/card.h linux-3.0.36-lenovo/sound/usb/card.h
88a89
> 	unsigned int speed;		/* USB_SPEED_XXX */




diff -r linux-3.0.36/sound/usb/clock.c linux-3.0.36-lenovo/sound/usb/clock.c
114c114,115
< 	if (!uac2_control_is_readable(cs_desc->bmControls, UAC2_CS_CONTROL_CLOCK_VALID))
---
> 	if (!uac2_control_is_readable(cs_desc->bmControls,
> 				      UAC2_CS_CONTROL_CLOCK_VALID - 1))




diff -r linux-3.0.36/sound/usb/midi.c linux-3.0.36-lenovo/sound/usb/midi.c
117a118
> 	struct rw_semaphore disc_rwsem;
127c128,129
< 	unsigned int opened;
---
> 	bool autopm_reference;
> 	unsigned int opened[2];
128a131
> 	unsigned char input_running;
1018c1021,1022
< static void substream_open(struct snd_rawmidi_substream *substream, int open)
---
> static int substream_open(struct snd_rawmidi_substream *substream, int dir,
> 			  int open)
1021a1026,1032
> 	int err;
> 
> 	down_read(&umidi->disc_rwsem);
> 	if (umidi->disconnected) {
> 		up_read(&umidi->disc_rwsem);
> 		return open ? -ENODEV : 0;
> 	}
1025,1028c1036,1047
< 		if (umidi->opened++ == 0 && umidi->roland_load_ctl) {
< 			ctl = umidi->roland_load_ctl;
< 			ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
< 			snd_ctl_notify(umidi->card,
---
> 		if (!umidi->opened[0] && !umidi->opened[1]) {
> 			err = usb_autopm_get_interface(umidi->iface);
> 			umidi->autopm_reference = err >= 0;
> 			if (err < 0 && err != -EACCES) {
> 				mutex_unlock(&umidi->mutex);
> 				up_read(&umidi->disc_rwsem);
> 				return -EIO;
> 			}
> 			if (umidi->roland_load_ctl) {
> 				ctl = umidi->roland_load_ctl;
> 				ctl->vd[0].access |= SNDRV_CTL_ELEM_ACCESS_INACTIVE;
> 				snd_ctl_notify(umidi->card,
1030c1049,1050
< 			update_roland_altsetting(umidi);
---
> 				update_roland_altsetting(umidi);
> 			}
1031a1052,1054
> 		umidi->opened[dir]++;
> 		if (umidi->opened[1])
> 			snd_usbmidi_input_start(&umidi->list);
1033,1036c1056,1063
< 		if (--umidi->opened == 0 && umidi->roland_load_ctl) {
< 			ctl = umidi->roland_load_ctl;
< 			ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
< 			snd_ctl_notify(umidi->card,
---
> 		umidi->opened[dir]--;
> 		if (!umidi->opened[1])
> 			snd_usbmidi_input_stop(&umidi->list);
> 		if (!umidi->opened[0] && !umidi->opened[1]) {
> 			if (umidi->roland_load_ctl) {
> 				ctl = umidi->roland_load_ctl;
> 				ctl->vd[0].access &= ~SNDRV_CTL_ELEM_ACCESS_INACTIVE;
> 				snd_ctl_notify(umidi->card,
1037a1065,1067
> 			}
> 			if (umidi->autopm_reference)
> 				usb_autopm_put_interface(umidi->iface);
1040a1071,1072
> 	up_read(&umidi->disc_rwsem);
> 	return 0;
1048d1079
< 	int err;
1061,1063c1092
< 	err = usb_autopm_get_interface(umidi->iface);
< 	if (err < 0)
< 		return -EIO;
---
> 
1066,1067c1095
< 	substream_open(substream, 1);
< 	return 0;
---
> 	return substream_open(substream, 0, 1);
1072,1076c1100
< 	struct snd_usb_midi* umidi = substream->rmidi->private_data;
< 
< 	substream_open(substream, 0);
< 	usb_autopm_put_interface(umidi->iface);
< 	return 0;
---
> 	return substream_open(substream, 0, 0);
1129,1130c1153
< 	substream_open(substream, 1);
< 	return 0;
---
> 	return substream_open(substream, 1, 1);
1135,1136c1158
< 	substream_open(substream, 0);
< 	return 0;
---
> 	return substream_open(substream, 1, 0);
1384a1407
> 	down_write(&umidi->disc_rwsem);
1387a1411,1412
> 	up_write(&umidi->disc_rwsem);
> 
2041a2067,2068
> 	if (!umidi->input_running)
> 		return;
2047a2075
> 	umidi->input_running = 0;
2071a2100,2101
> 	if (umidi->input_running || !umidi->opened[1])
> 		return;
2073a2104
> 	umidi->input_running = 1;
2098a2130
> 	init_rwsem(&umidi->disc_rwsem);
2200,2202d2231
< 
< 	for (i = 0; i < MIDI_MAX_ENDPOINTS; ++i)
< 		snd_usbmidi_input_start_ep(umidi->endpoints[i].in);




diff -r linux-3.0.36/sound/usb/mixer.c linux-3.0.36-lenovo/sound/usb/mixer.c
290c290
< 	int err;
---
> 	int idx = 0, err;
294a295
> 	down_read(&chip->shutdown_rwsem);
295a297,299
> 		if (chip->shutdown)
> 			break;
> 		idx = snd_usb_ctrl_intf(chip) | (cval->id << 8);
298,299c302
< 				    validx, snd_usb_ctrl_intf(chip) | (cval->id << 8),
< 				    buf, val_len, 100) >= val_len) {
---
> 				    validx, idx, buf, val_len, 100) >= val_len) {
301,302c304,305
< 			snd_usb_autosuspend(cval->mixer->chip);
< 			return 0;
---
> 			err = 0;
> 			goto out;
305d307
< 	snd_usb_autosuspend(cval->mixer->chip);
307,308c309,315
< 		    request, validx, snd_usb_ctrl_intf(chip) | (cval->id << 8), cval->val_type);
< 	return -EINVAL;
---
> 		    request, validx, idx, cval->val_type);
> 	err = -EINVAL;
> 
>  out:
> 	up_read(&chip->shutdown_rwsem);
> 	snd_usb_autosuspend(cval->mixer->chip);
> 	return err;
316c323
< 	int ret, size;
---
> 	int idx = 0, ret, size;
333c340,345
< 	ret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,
---
> 	down_read(&chip->shutdown_rwsem);
> 	if (chip->shutdown)
> 		ret = -ENODEV;
> 	else {
> 		idx = snd_usb_ctrl_intf(chip) | (cval->id << 8);
> 		ret = snd_usb_ctl_msg(chip->dev, usb_rcvctrlpipe(chip->dev, 0), bRequest,
335,336c347,349
< 			      validx, snd_usb_ctrl_intf(chip) | (cval->id << 8),
< 			      buf, size, 1000);
---
> 			      validx, idx, buf, size, 1000);
> 	}
> 	up_read(&chip->shutdown_rwsem);
342c355
< 			   request, validx, snd_usb_ctrl_intf(chip) | (cval->id << 8), cval->val_type);
---
> 			   request, validx, idx, cval->val_type);
420c433
< 	int val_len, err, timeout = 10;
---
> 	int idx = 0, val_len, err, timeout = 10;
443c456,460
< 	while (timeout-- > 0)
---
> 	down_read(&chip->shutdown_rwsem);
> 	while (timeout-- > 0) {
> 		if (chip->shutdown)
> 			break;
> 		idx = snd_usb_ctrl_intf(chip) | (cval->id << 8);
447,450c464,466
< 				    validx, snd_usb_ctrl_intf(chip) | (cval->id << 8),
< 				    buf, val_len, 100) >= 0) {
< 			snd_usb_autosuspend(chip);
< 			return 0;
---
> 				    validx, idx, buf, val_len, 100) >= 0) {
> 			err = 0;
> 			goto out;
452c468
< 	snd_usb_autosuspend(chip);
---
> 	}
454,455c470,476
< 		    request, validx, snd_usb_ctrl_intf(chip) | (cval->id << 8), cval->val_type, buf[0], buf[1]);
< 	return -EINVAL;
---
> 		    request, validx, idx, cval->val_type, buf[0], buf[1]);
> 	err = -EINVAL;
> 
>  out:
> 	up_read(&chip->shutdown_rwsem);
> 	snd_usb_autosuspend(chip);
> 	return err;
1219a1241,1246
> 		if (hdr->bLength < 7 + csize) {
> 			snd_printk(KERN_ERR "usbaudio: unit %u: "
> 				   "invalid UAC_FEATURE_UNIT descriptor\n",
> 				   unitid);
> 			return -EINVAL;
> 		}
1225,1229c1252,1257
< 	}
< 
< 	if (hdr->bLength < 7 || !csize || hdr->bLength < 7 + csize) {
< 		snd_printk(KERN_ERR "usbaudio: unit %u: invalid UAC_FEATURE_UNIT descriptor\n", unitid);
< 		return -EINVAL;
---
> 		if (hdr->bLength < 6 + csize) {
> 			snd_printk(KERN_ERR "usbaudio: unit %u: "
> 				   "invalid UAC_FEATURE_UNIT descriptor\n",
> 				   unitid);
> 			return -EINVAL;
> 		}
1248a1277,1283
> 	case USB_ID(0x1130, 0xf211):
> 		snd_printk(KERN_INFO
> 			   "usbmixer: volume control quirk for Tenx TP6911 Audio Headset\n");
> 		/* disable non-functional volume control */
> 		channels = 0;
> 		break;
> 




diff -r linux-3.0.36/sound/usb/mixer_quirks.c linux-3.0.36-lenovo/sound/usb/mixer_quirks.c
188a189,193
> 	down_read(&mixer->chip->shutdown_rwsem);
> 	if (mixer->chip->shutdown) {
> 		err = -ENODEV;
> 		goto out;
> 	}
204a210,211
>  out:
> 	up_read(&mixer->chip->shutdown_rwsem);
298c305,309
< 		err = snd_usb_ctl_msg(mixer->chip->dev,
---
> 		down_read(&mixer->chip->shutdown_rwsem);
> 		if (mixer->chip->shutdown)
> 			err = 0;
> 		else
> 			err = snd_usb_ctl_msg(mixer->chip->dev,
302a314
> 		up_read(&mixer->chip->shutdown_rwsem);
332c344,348
< 	err = snd_usb_ctl_msg(mixer->chip->dev,
---
> 	down_read(&mixer->chip->shutdown_rwsem);
> 	if (mixer->chip->shutdown)
> 		err = -ENODEV;
> 	else
> 		err = snd_usb_ctl_msg(mixer->chip->dev,
335a352
> 	up_read(&mixer->chip->shutdown_rwsem);
373a391
> 	int ret;
375c393,397
< 	int ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest,
---
> 	down_read(&mixer->chip->shutdown_rwsem);
> 	if (mixer->chip->shutdown)
> 		ret = -ENODEV;
> 	else
> 		ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), bRequest,
378a401
> 	up_read(&mixer->chip->shutdown_rwsem);
398a422
> 	int ret;
400c424,428
< 	int ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), bRequest,
---
> 	down_read(&mixer->chip->shutdown_rwsem);
> 	if (mixer->chip->shutdown)
> 		ret = -ENODEV;
> 	else
> 		ret = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), bRequest,
403a432
> 	up_read(&mixer->chip->shutdown_rwsem);




diff -r linux-3.0.36/sound/usb/pcm.c linux-3.0.36-lenovo/sound/usb/pcm.c
45a46,47
> 	if (subs->stream->chip->shutdown)
> 		return SNDRV_PCM_POS_XRUN;
349a352,357
> 
> 	down_read(&subs->stream->chip->shutdown_rwsem);
> 	if (subs->stream->chip->shutdown) {
> 		ret = -ENODEV;
> 		goto unlock;
> 	}
351c359
< 		return ret;
---
> 		goto unlock;
360c368
< 			return ret;
---
> 			goto unlock;
365d372
< 		mutex_lock(&subs->stream->chip->shutdown_mutex);
373d379
< 		mutex_unlock(&subs->stream->chip->shutdown_mutex);
375a382,383
> unlock:
> 	up_read(&subs->stream->chip->shutdown_rwsem);
391c399
< 	mutex_lock(&subs->stream->chip->shutdown_mutex);
---
> 	down_read(&subs->stream->chip->shutdown_rwsem);
393c401
< 	mutex_unlock(&subs->stream->chip->shutdown_mutex);
---
> 	up_read(&subs->stream->chip->shutdown_rwsem);
405a414
> 	int ret = 0;
411a421,425
> 	down_read(&subs->stream->chip->shutdown_rwsem);
> 	if (subs->stream->chip->shutdown) {
> 		ret = -ENODEV;
> 		goto unlock;
> 	}
422c436,439
< 	return snd_usb_substream_prepare(subs, runtime);
---
> 	ret = snd_usb_substream_prepare(subs, runtime);
>  unlock:
> 	up_read(&subs->stream->chip->shutdown_rwsem);
> 	return ret;
475c492
< 	if (snd_usb_get_speed(subs->dev) != USB_SPEED_FULL) {
---
> 	if (subs->speed != USB_SPEED_FULL) {
751c768
< 	if (snd_usb_get_speed(subs->dev) == USB_SPEED_FULL)
---
> 	if (subs->speed == USB_SPEED_FULL)




diff -r linux-3.0.36/sound/usb/proc.c linux-3.0.36-lenovo/sound/usb/proc.c
110c110
< 		if (snd_usb_get_speed(subs->dev) != USB_SPEED_FULL)
---
> 		if (subs->speed != USB_SPEED_FULL)
131c131
< 			    snd_usb_get_speed(subs->dev) == USB_SPEED_FULL
---
> 			    subs->speed == USB_SPEED_FULL




diff -r linux-3.0.36/sound/usb/quirks-table.h linux-3.0.36-lenovo/sound/usb/quirks-table.h
2583a2584,2636
> /* Microsoft XboxLive Headset/Xbox Communicator */
> {
> 	USB_DEVICE(0x045e, 0x0283),
> 	.bInterfaceClass = USB_CLASS_PER_INTERFACE,
> 	.driver_info = (unsigned long) &(const struct snd_usb_audio_quirk) {
> 		.vendor_name = "Microsoft",
> 		.product_name = "XboxLive Headset/Xbox Communicator",
> 		.ifnum = QUIRK_ANY_INTERFACE,
> 		.type = QUIRK_COMPOSITE,
> 		.data = &(const struct snd_usb_audio_quirk[]) {
> 			{
> 				/* playback */
> 				.ifnum = 0,
> 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
> 				.data = &(const struct audioformat) {
> 					.formats = SNDRV_PCM_FMTBIT_S16_LE,
> 					.channels = 1,
> 					.iface = 0,
> 					.altsetting = 0,
> 					.altset_idx = 0,
> 					.attributes = 0,
> 					.endpoint = 0x04,
> 					.ep_attr = 0x05,
> 					.rates = SNDRV_PCM_RATE_CONTINUOUS,
> 					.rate_min = 22050,
> 					.rate_max = 22050
> 				}
> 			},
> 			{
> 				/* capture */
> 				.ifnum = 1,
> 				.type = QUIRK_AUDIO_FIXED_ENDPOINT,
> 				.data = &(const struct audioformat) {
> 					.formats = SNDRV_PCM_FMTBIT_S16_LE,
> 					.channels = 1,
> 					.iface = 1,
> 					.altsetting = 0,
> 					.altset_idx = 0,
> 					.attributes = 0,
> 					.endpoint = 0x85,
> 					.ep_attr = 0x05,
> 					.rates = SNDRV_PCM_RATE_CONTINUOUS,
> 					.rate_min = 16000,
> 					.rate_max = 16000
> 				}
> 			},
> 			{
> 				.ifnum = -1
> 			}
> 		}
> 	}
> },
> 




diff -r linux-3.0.36/sound/usb/urb.c linux-3.0.36-lenovo/sound/usb/urb.c
150,151c150,153
< 	deactivate_urbs(subs, force, 1);
< 	wait_clear_urbs(subs);
---
> 	if (!subs->stream->chip->shutdown) {
> 		deactivate_urbs(subs, force, 1);
> 		wait_clear_urbs(subs);
> 	}
873c875,876
< 	if (snd_usb_get_speed(subs->dev) >= USB_SPEED_HIGH)
---
> 	subs->speed = snd_usb_get_speed(subs->dev);
> 	if (subs->speed >= USB_SPEED_HIGH)




diff -r linux-3.0.36/sound/usb/usbaudio.h linux-3.0.36-lenovo/sound/usb/usbaudio.h
39c39
< 	struct mutex shutdown_mutex;
---
> 	struct rw_semaphore shutdown_rwsem;
Only in linux-3.0.36/tools/perf: .gitignore




diff -r linux-3.0.36/tools/perf/Makefile linux-3.0.36-lenovo/tools/perf/Makefile
57c57
< 		IS_X86_64 := $(shell echo __x86_64__ | ${CC} -E -xc - | tail -n 1)
---
> 		IS_X86_64 := $(shell echo __x86_64__ | ${CC} -E -x c - | tail -n 1)




diff -r linux-3.0.36/usr/gen_init_cpio.c linux-3.0.36-lenovo/usr/gen_init_cpio.c
306c306
< 	int i;
---
> 	unsigned int i;
384,400c384,403
<        char expanded[PATH_MAX + 1];
<        char env_var[PATH_MAX + 1];
<        char *start;
<        char *end;
< 
<        for (start = NULL; (start = strstr(new_location, "${")); ) {
<                end = strchr(start, '}');
<                if (start < end) {
<                        *env_var = *expanded = '\0';
<                        strncat(env_var, start + 2, end - start - 2);
<                        strncat(expanded, new_location, start - new_location);
<                        strncat(expanded, getenv(env_var), PATH_MAX);
<                        strncat(expanded, end + 1, PATH_MAX);
<                        strncpy(new_location, expanded, PATH_MAX);
<                } else
<                        break;
<        }
---
> 	char expanded[PATH_MAX + 1];
> 	char env_var[PATH_MAX + 1];
> 	char *start;
> 	char *end;
> 
> 	for (start = NULL; (start = strstr(new_location, "${")); ) {
> 		end = strchr(start, '}');
> 		if (start < end) {
> 			*env_var = *expanded = '\0';
> 			strncat(env_var, start + 2, end - start - 2);
> 			strncat(expanded, new_location, start - new_location);
> 			strncat(expanded, getenv(env_var),
> 				PATH_MAX - strlen(expanded));
> 			strncat(expanded, end + 1,
> 				PATH_MAX - strlen(expanded));
> 			strncpy(new_location, expanded, PATH_MAX);
> 			new_location[PATH_MAX] = 0;
> 		} else
> 			break;
> 	}
402c405
<        return new_location;
---
> 	return new_location;
Only in linux-3.0.36/usr: .gitignore
